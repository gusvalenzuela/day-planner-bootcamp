/******/ ;(function (modules) {
	// webpackBootstrap
	/******/ // The module cache
	/******/ var installedModules = {} // The require function
	/******/
	/******/ /******/ function __webpack_require__(moduleId) {
		/******/
		/******/ // Check if module is in cache
		/******/ if (installedModules[moduleId]) {
			/******/ return installedModules[moduleId].exports
			/******/
		} // Create a new module (and put it into the cache)
		/******/ /******/ var module = (installedModules[moduleId] = {
			/******/ i: moduleId,
			/******/ l: false,
			/******/ exports: {},
			/******/
		}) // Execute the module function
		/******/
		/******/ /******/ modules[moduleId].call(
			module.exports,
			module,
			module.exports,
			__webpack_require__,
		) // Flag the module as loaded
		/******/
		/******/ /******/ module.l = true // Return the exports of the module
		/******/
		/******/ /******/ return module.exports
		/******/
	} // expose the modules object (__webpack_modules__)
	/******/
	/******/
	/******/ /******/ __webpack_require__.m = modules // expose the module cache
	/******/
	/******/ /******/ __webpack_require__.c = installedModules // define getter function for harmony exports
	/******/
	/******/ /******/ __webpack_require__.d = function (exports, name, getter) {
		/******/ if (!__webpack_require__.o(exports, name)) {
			/******/ Object.defineProperty(exports, name, {
				enumerable: true,
				get: getter,
			})
			/******/
		}
		/******/
	} // define __esModule on exports
	/******/
	/******/ /******/ __webpack_require__.r = function (exports) {
		/******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
			/******/ Object.defineProperty(exports, Symbol.toStringTag, {
				value: "Module",
			})
			/******/
		}
		/******/ Object.defineProperty(exports, "__esModule", { value: true })
		/******/
	} // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
	/******/
	/******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function (
		value,
		mode,
	) {
		/******/ if (mode & 1) value = __webpack_require__(value)
		/******/ if (mode & 8) return value
		/******/ if (
			mode & 4 &&
			typeof value === "object" &&
			value &&
			value.__esModule
		)
			return value
		/******/ var ns = Object.create(null)
		/******/ __webpack_require__.r(ns)
		/******/ Object.defineProperty(ns, "default", {
			enumerable: true,
			value: value,
		})
		/******/ if (mode & 2 && typeof value != "string")
			for (var key in value)
				__webpack_require__.d(
					ns,
					key,
					function (key) {
						return value[key]
					}.bind(null, key),
				)
		/******/ return ns
		/******/
	} // getDefaultExport function for compatibility with non-harmony modules
	/******/
	/******/ /******/ __webpack_require__.n = function (module) {
		/******/ var getter =
			module && module.__esModule
				? /******/ function getDefault() {
						return module["default"]
				  }
				: /******/ function getModuleExports() {
						return module
				  }
		/******/ __webpack_require__.d(getter, "a", getter)
		/******/ return getter
		/******/
	} // Object.prototype.hasOwnProperty.call
	/******/
	/******/ /******/ __webpack_require__.o = function (object, property) {
		return Object.prototype.hasOwnProperty.call(object, property)
	} // __webpack_public_path__
	/******/
	/******/ /******/ __webpack_require__.p = "/" // Load entry module and return exports
	/******/
	/******/
	/******/ /******/ return __webpack_require__(
		(__webpack_require__.s = "./src/_js/index.js"),
	)
	/******/
})(
	/************************************************************************/
	/******/ {
		/***/ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/index.js?!./src/_css/style.css":
			/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader??ref--5-1!./src/_css/style.css ***!
  \******************************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				var escape = __webpack_require__(
					/*! ../../node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/url/escape.js */ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/url/escape.js",
				)
				exports = module.exports = __webpack_require__(
					/*! ../../node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js",
				)(false)
				// imports

				// module
				exports.push([
					module.i,
					'/* @import "./global/reset.css"; */\n\nhtml {\n\tmin-height: 100%;\n\tposition: relative;\n}\n\nbody {\n\tmargin-bottom: 60px;\n}\n\n* {\n\tfont-family:\n\t\t-apple-system,\n\t\tBlinkMacSystemFont,\n\t\t"Segoe UI",\n\t\tRoboto,\n\t\tOxygen,\n\t\tUbuntu,\n\t\tCantarell,\n\t\t"Open Sans",\n\t\t"Helvetica Neue",\n\t\tsans-serif;\n}\n\n:root {\n\t--orange: #ff783a;\n\t--backgroundcolor: #f7f7f7 !important;\n\t--black: #070707 !important;\n\t--black-faded-1: #070707c7 !important;\n\t--white: #f4f4f4 !important;\n\t--white-faded-1: #f4f4f4e0 !important;\n\t--gray: #a7a7a7 !important;\n\t--link-blue: #007bff !important;\n\t--color-past: #797979 !important;\n\t--color-current: #b7b7b7 !important;\n\t--color-future: #59c044 !important;\n}\n\nheader {\n\tbackground: url(' +
						escape(
							__webpack_require__(
								/*! ./images/workdayplanner1.jpg */ "./src/_css/images/workdayplanner1.jpg",
							),
						) +
						");\n\tbackground-position: 0% 0%;\n\tbackground-size: cover;\n\tmin-height: 369px;\n}\n\nheader > .container {\n\tbackground: var(--white-faded-1);\n\tcolor: var(--black);\n}\n\nheader h1,\nheader p {\n\tmargin-bottom: 1rem;\n}\n\nblockquote {\n\tmargin-bottom: 0.5rem;\n\tpadding-top: 1rem;\n\ttext-align: center;\n}\n\nform#signup,\nform#login {\n\tmargin: auto;\n}\n\nform#demo-login {\n\tfont-size: 12px;\n\tmargin: auto;\n\tmargin-top: 3rem;\n}\n\n#blockquoteBody {\n\ttext-align: justify;\n}\n\n#profile-header-row {\n\tline-height: 32px;\n\tpadding: 6rem 1rem;\n}\n\n.login-container,\n.signup-container {\n\tmargin-top: 2.65rem;\n}\n\n.text-date {\n\tcolor: var(--orange);\n\tfont-size: 1.7rem;\n\tfont-weight: 700;\n\tword-wrap: break-word;\n}\n\n.bg-past {\n\tbackground: var(--color-past);\n\tcolor: var(--white-faded-1);\n}\n\n.bg-current {\n\tbackground: var(--color-current);\n}\n\n.bg-future {\n\tbackground: var(--color-future);\n}\n\n.bg-gray {\n\tbackground: #dbdbdb;\n}\n\n.footer {\n\n\t/* Vertically center the text there */\n\tbackground-color: var(--backgroundcolor);\n\tborder-top: 1px solid #000;\n\tbottom: 0;\n\theight: 30px;\n\tleft: 0;\n\n\t/* Set the fixed height of the footer here */\n\tline-height: 150px;\n\tposition: absolute;\n\tright: 0;\n\twidth: 100%;\n}\n\n.link-button {\n\tbackground: none;\n\tborder: none;\n\tcolor: var(--link-blue);\n\tcursor: pointer;\n\ttext-decoration: none;\n}\n\n.link-button:focus {\n\toutline: none;\n}\n\n.disable-click {\n\tpointer-events: none;\n}\n\n.timeSlotRow {\n\theight: 70px;\n}\n\n.time-display {\n\tborder-top: 1px solid #888;\n\tpadding-top: 0.5rem;\n}\n\n.note-slots {\n\tborder: none;\n\theight: 50px;\n\theight: 100%;\n\tpadding-left: 0.25rem;\n\tresize: none;\n}\n\n.fa-save {\n\tfont-size: 18px;\n}\n\n.chevrons:hover {\n\tbackground: #292b2c34;\n\n\t/* opacity: .2; */\n}\n\n/* The Modal (background) */\n\n.modal {\n\n\t/* Enable scroll if needed */\n\tbackground-color: var(--black);\n\n\t/* Fallback color */\n\tbackground-color: var(--black-faded-1);\n\tdisplay: none;\n\n\t/* Full width */\n\theight: 100%;\n\n\t/* Location of the box */\n\tleft: 0;\n\n\t/* Full height */\n\toverflow: auto;\n\n\t/* Sit on top */\n\tpadding-top: 100px;\n\n\t/* Hidden by default */\n\tposition: fixed;\n\ttop: 0;\n\twidth: 100%;\n\n\t/* Stay in place */\n\tz-index: 1;\n\n\t/* Black w/ opacity */\n}\n\n/* Modal Content */\n\n.settings-modal-content {\n\tbackground-color: var(--backgroundcolor);\n\tborder: 1px solid #888;\n\tmargin: auto;\n\tpadding: 20px;\n\ttext-align: center;\n\twidth: 68%;\n}\n\n@media screen and (max-width: 576px) {\n\n\t.modal-content {\n\t\tfont-size: small;\n\t\tpadding: 20px;\n\t\twidth: 100%;\n\t}\n}\n\n/* The Close Button */\n\n.close {\n\tcolor: var(--gray);\n\tfloat: right;\n\tfont-size: 8px;\n\tfont-weight: 600;\n}\n\n.modal-save-button {\n\tbackground: #0084ffda;\n\tmargin-top: 0.25em;\n\n\t/* float: right; */\n\tpadding: 0.5em 1em;\n}\n",
					"",
				])

				// exports

				/***/
			},

		/***/ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js":
			/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js ***!
  \***************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports) {
				/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
				// css base code, injected by the css-loader
				module.exports = function (useSourceMap) {
					var list = []

					// return the list of modules as css string
					list.toString = function toString() {
						return this.map(function (item) {
							var content = cssWithMappingToString(item, useSourceMap)
							if (item[2]) {
								return "@media " + item[2] + "{" + content + "}"
							} else {
								return content
							}
						}).join("")
					}

					// import a list of modules into the list
					list.i = function (modules, mediaQuery) {
						if (typeof modules === "string") modules = [[null, modules, ""]]
						var alreadyImportedModules = {}
						for (var i = 0; i < this.length; i++) {
							var id = this[i][0]
							if (typeof id === "number") alreadyImportedModules[id] = true
						}
						for (i = 0; i < modules.length; i++) {
							var item = modules[i]
							// skip already imported module
							// this implementation is not 100% perfect for weird media query combinations
							//  when a module is imported multiple times with different media queries.
							//  I hope this will never occur (Hey this way we have smaller bundles)
							if (
								typeof item[0] !== "number" ||
								!alreadyImportedModules[item[0]]
							) {
								if (mediaQuery && !item[2]) {
									item[2] = mediaQuery
								} else if (mediaQuery) {
									item[2] = "(" + item[2] + ") and (" + mediaQuery + ")"
								}
								list.push(item)
							}
						}
					}
					return list
				}

				function cssWithMappingToString(item, useSourceMap) {
					var content = item[1] || ""
					var cssMapping = item[3]
					if (!cssMapping) {
						return content
					}

					if (useSourceMap && typeof btoa === "function") {
						var sourceMapping = toComment(cssMapping)
						var sourceURLs = cssMapping.sources.map(function (source) {
							return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */"
						})

						return [content]
							.concat(sourceURLs)
							.concat([sourceMapping])
							.join("\n")
					}

					return [content].join("\n")
				}

				// Adapted from convert-source-map (MIT)
				function toComment(sourceMap) {
					// eslint-disable-next-line no-undef
					var base64 = btoa(
						unescape(encodeURIComponent(JSON.stringify(sourceMap))),
					)
					var data =
						"sourceMappingURL=data:application/json;charset=utf-8;base64," +
						base64

					return "/*# " + data + " */"
				}

				/***/
			},

		/***/ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/url/escape.js":
			/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/url/escape.js ***!
  \*****************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports) {
				module.exports = function escape(url) {
					if (typeof url !== "string") {
						return url
					}
					// If url is already wrapped in quotes, remove them
					if (/^['"].*['"]$/.test(url)) {
						url = url.slice(1, -1)
					}
					// Should url be wrapped?
					// See https://drafts.csswg.org/css-values-3/#urls
					if (/["'() \t\n]/.test(url)) {
						return '"' + url.replace(/"/g, '\\"').replace(/\n/g, "\\n") + '"'
					}

					return url
				}

				/***/
			},

		/***/ "./node_modules/.pnpm/jquery@3.5.1/node_modules/jquery/dist/jquery.js":
			/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/jquery@3.5.1/node_modules/jquery/dist/jquery.js ***!
  \****************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__
				/*!
				 * jQuery JavaScript Library v3.5.1
				 * https://jquery.com/
				 *
				 * Includes Sizzle.js
				 * https://sizzlejs.com/
				 *
				 * Copyright JS Foundation and other contributors
				 * Released under the MIT license
				 * https://jquery.org/license
				 *
				 * Date: 2020-05-04T22:49Z
				 */
				;(function (global, factory) {
					"use strict"

					if (true && typeof module.exports === "object") {
						// For CommonJS and CommonJS-like environments where a proper `window`
						// is present, execute the factory and get jQuery.
						// For environments that do not have a `window` with a `document`
						// (such as Node.js), expose a factory as module.exports.
						// This accentuates the need for the creation of a real `window`.
						// e.g. var jQuery = require("jquery")(window);
						// See ticket #14549 for more info.
						module.exports = global.document
							? factory(global, true)
							: function (w) {
									if (!w.document) {
										throw new Error("jQuery requires a window with a document")
									}
									return factory(w)
							  }
					} else {
						factory(global)
					}

					// Pass this if window is not defined yet
				})(typeof window !== "undefined" ? window : this, function (
					window,
					noGlobal,
				) {
					// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
					// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
					// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
					// enough that all such attempts are guarded in a try block.
					"use strict"

					var arr = []

					var getProto = Object.getPrototypeOf

					var slice = arr.slice

					var flat = arr.flat
						? function (array) {
								return arr.flat.call(array)
						  }
						: function (array) {
								return arr.concat.apply([], array)
						  }

					var push = arr.push

					var indexOf = arr.indexOf

					var class2type = {}

					var toString = class2type.toString

					var hasOwn = class2type.hasOwnProperty

					var fnToString = hasOwn.toString

					var ObjectFunctionString = fnToString.call(Object)

					var support = {}

					var isFunction = function isFunction(obj) {
						// Support: Chrome <=57, Firefox <=52
						// In some browsers, typeof returns "function" for HTML <object> elements
						// (i.e., `typeof document.createElement( "object" ) === "function"`).
						// We don't want to classify *any* DOM node as a function.
						return typeof obj === "function" && typeof obj.nodeType !== "number"
					}

					var isWindow = function isWindow(obj) {
						return obj != null && obj === obj.window
					}

					var document = window.document

					var preservedScriptAttributes = {
						type: true,
						src: true,
						nonce: true,
						noModule: true,
					}

					function DOMEval(code, node, doc) {
						doc = doc || document

						var i,
							val,
							script = doc.createElement("script")

						script.text = code
						if (node) {
							for (i in preservedScriptAttributes) {
								// Support: Firefox 64+, Edge 18+
								// Some browsers don't support the "nonce" property on scripts.
								// On the other hand, just using `getAttribute` is not enough as
								// the `nonce` attribute is reset to an empty string whenever it
								// becomes browsing-context connected.
								// See https://github.com/whatwg/html/issues/2369
								// See https://html.spec.whatwg.org/#nonce-attributes
								// The `node.getAttribute` check was added for the sake of
								// `jQuery.globalEval` so that it can fake a nonce-containing node
								// via an object.
								val = node[i] || (node.getAttribute && node.getAttribute(i))
								if (val) {
									script.setAttribute(i, val)
								}
							}
						}
						doc.head.appendChild(script).parentNode.removeChild(script)
					}

					function toType(obj) {
						if (obj == null) {
							return obj + ""
						}

						// Support: Android <=2.3 only (functionish RegExp)
						return typeof obj === "object" || typeof obj === "function"
							? class2type[toString.call(obj)] || "object"
							: typeof obj
					}
					/* global Symbol */
					// Defining this global in .eslintrc.json would create a danger of using the global
					// unguarded in another place, it seems safer to define global only for this module

					var version = "3.5.1",
						// Define a local copy of jQuery
						jQuery = function (selector, context) {
							// The jQuery object is actually just the init constructor 'enhanced'
							// Need init if jQuery is called (just allow error to be thrown if not included)
							return new jQuery.fn.init(selector, context)
						}

					jQuery.fn = jQuery.prototype = {
						// The current version of jQuery being used
						jquery: version,

						constructor: jQuery,

						// The default length of a jQuery object is 0
						length: 0,

						toArray: function () {
							return slice.call(this)
						},

						// Get the Nth element in the matched element set OR
						// Get the whole matched element set as a clean array
						get: function (num) {
							// Return all the elements in a clean array
							if (num == null) {
								return slice.call(this)
							}

							// Return just the one element from the set
							return num < 0 ? this[num + this.length] : this[num]
						},

						// Take an array of elements and push it onto the stack
						// (returning the new matched element set)
						pushStack: function (elems) {
							// Build a new jQuery matched element set
							var ret = jQuery.merge(this.constructor(), elems)

							// Add the old object onto the stack (as a reference)
							ret.prevObject = this

							// Return the newly-formed element set
							return ret
						},

						// Execute a callback for every element in the matched set.
						each: function (callback) {
							return jQuery.each(this, callback)
						},

						map: function (callback) {
							return this.pushStack(
								jQuery.map(this, function (elem, i) {
									return callback.call(elem, i, elem)
								}),
							)
						},

						slice: function () {
							return this.pushStack(slice.apply(this, arguments))
						},

						first: function () {
							return this.eq(0)
						},

						last: function () {
							return this.eq(-1)
						},

						even: function () {
							return this.pushStack(
								jQuery.grep(this, function (_elem, i) {
									return (i + 1) % 2
								}),
							)
						},

						odd: function () {
							return this.pushStack(
								jQuery.grep(this, function (_elem, i) {
									return i % 2
								}),
							)
						},

						eq: function (i) {
							var len = this.length,
								j = +i + (i < 0 ? len : 0)
							return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
						},

						end: function () {
							return this.prevObject || this.constructor()
						},

						// For internal use only.
						// Behaves like an Array's method, not like a jQuery method.
						push: push,
						sort: arr.sort,
						splice: arr.splice,
					}

					jQuery.extend = jQuery.fn.extend = function () {
						var options,
							name,
							src,
							copy,
							copyIsArray,
							clone,
							target = arguments[0] || {},
							i = 1,
							length = arguments.length,
							deep = false

						// Handle a deep copy situation
						if (typeof target === "boolean") {
							deep = target

							// Skip the boolean and the target
							target = arguments[i] || {}
							i++
						}

						// Handle case when target is a string or something (possible in deep copy)
						if (typeof target !== "object" && !isFunction(target)) {
							target = {}
						}

						// Extend jQuery itself if only one argument is passed
						if (i === length) {
							target = this
							i--
						}

						for (; i < length; i++) {
							// Only deal with non-null/undefined values
							if ((options = arguments[i]) != null) {
								// Extend the base object
								for (name in options) {
									copy = options[name]

									// Prevent Object.prototype pollution
									// Prevent never-ending loop
									if (name === "__proto__" || target === copy) {
										continue
									}

									// Recurse if we're merging plain objects or arrays
									if (
										deep &&
										copy &&
										(jQuery.isPlainObject(copy) ||
											(copyIsArray = Array.isArray(copy)))
									) {
										src = target[name]

										// Ensure proper type for the source value
										if (copyIsArray && !Array.isArray(src)) {
											clone = []
										} else if (!copyIsArray && !jQuery.isPlainObject(src)) {
											clone = {}
										} else {
											clone = src
										}
										copyIsArray = false

										// Never move original objects, clone them
										target[name] = jQuery.extend(deep, clone, copy)

										// Don't bring in undefined values
									} else if (copy !== undefined) {
										target[name] = copy
									}
								}
							}
						}

						// Return the modified object
						return target
					}

					jQuery.extend({
						// Unique for each copy of jQuery on the page
						expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

						// Assume jQuery is ready without the ready module
						isReady: true,

						error: function (msg) {
							throw new Error(msg)
						},

						noop: function () {},

						isPlainObject: function (obj) {
							var proto, Ctor

							// Detect obvious negatives
							// Use toString instead of jQuery.type to catch host objects
							if (!obj || toString.call(obj) !== "[object Object]") {
								return false
							}

							proto = getProto(obj)

							// Objects with no prototype (e.g., `Object.create( null )`) are plain
							if (!proto) {
								return true
							}

							// Objects with prototype are plain iff they were constructed by a global Object function
							Ctor = hasOwn.call(proto, "constructor") && proto.constructor
							return (
								typeof Ctor === "function" &&
								fnToString.call(Ctor) === ObjectFunctionString
							)
						},

						isEmptyObject: function (obj) {
							var name

							for (name in obj) {
								return false
							}
							return true
						},

						// Evaluates a script in a provided context; falls back to the global one
						// if not specified.
						globalEval: function (code, options, doc) {
							DOMEval(code, { nonce: options && options.nonce }, doc)
						},

						each: function (obj, callback) {
							var length,
								i = 0

							if (isArrayLike(obj)) {
								length = obj.length
								for (; i < length; i++) {
									if (callback.call(obj[i], i, obj[i]) === false) {
										break
									}
								}
							} else {
								for (i in obj) {
									if (callback.call(obj[i], i, obj[i]) === false) {
										break
									}
								}
							}

							return obj
						},

						// results is for internal usage only
						makeArray: function (arr, results) {
							var ret = results || []

							if (arr != null) {
								if (isArrayLike(Object(arr))) {
									jQuery.merge(ret, typeof arr === "string" ? [arr] : arr)
								} else {
									push.call(ret, arr)
								}
							}

							return ret
						},

						inArray: function (elem, arr, i) {
							return arr == null ? -1 : indexOf.call(arr, elem, i)
						},

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						merge: function (first, second) {
							var len = +second.length,
								j = 0,
								i = first.length

							for (; j < len; j++) {
								first[i++] = second[j]
							}

							first.length = i

							return first
						},

						grep: function (elems, callback, invert) {
							var callbackInverse,
								matches = [],
								i = 0,
								length = elems.length,
								callbackExpect = !invert

							// Go through the array, only saving the items
							// that pass the validator function
							for (; i < length; i++) {
								callbackInverse = !callback(elems[i], i)
								if (callbackInverse !== callbackExpect) {
									matches.push(elems[i])
								}
							}

							return matches
						},

						// arg is for internal usage only
						map: function (elems, callback, arg) {
							var length,
								value,
								i = 0,
								ret = []

							// Go through the array, translating each of the items to their new values
							if (isArrayLike(elems)) {
								length = elems.length
								for (; i < length; i++) {
									value = callback(elems[i], i, arg)

									if (value != null) {
										ret.push(value)
									}
								}

								// Go through every key on the object,
							} else {
								for (i in elems) {
									value = callback(elems[i], i, arg)

									if (value != null) {
										ret.push(value)
									}
								}
							}

							// Flatten any nested arrays
							return flat(ret)
						},

						// A global GUID counter for objects
						guid: 1,

						// jQuery.support is not used in Core but other projects attach their
						// properties to it so it needs to exist.
						support: support,
					})

					if (typeof Symbol === "function") {
						jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]
					}

					// Populate the class2type map
					jQuery.each(
						"Boolean Number String Function Array Date RegExp Object Error Symbol".split(
							" ",
						),
						function (_i, name) {
							class2type["[object " + name + "]"] = name.toLowerCase()
						},
					)

					function isArrayLike(obj) {
						// Support: real iOS 8.2 only (not reproducible in simulator)
						// `in` check used to prevent JIT error (gh-2145)
						// hasOwn isn't used here due to false negatives
						// regarding Nodelist length in IE
						var length = !!obj && "length" in obj && obj.length,
							type = toType(obj)

						if (isFunction(obj) || isWindow(obj)) {
							return false
						}

						return (
							type === "array" ||
							length === 0 ||
							(typeof length === "number" && length > 0 && length - 1 in obj)
						)
					}
					var Sizzle =
						/*!
						 * Sizzle CSS Selector Engine v2.3.5
						 * https://sizzlejs.com/
						 *
						 * Copyright JS Foundation and other contributors
						 * Released under the MIT license
						 * https://js.foundation/
						 *
						 * Date: 2020-03-14
						 */
						(function (window) {
							var i,
								support,
								Expr,
								getText,
								isXML,
								tokenize,
								compile,
								select,
								outermostContext,
								sortInput,
								hasDuplicate,
								// Local document vars
								setDocument,
								document,
								docElem,
								documentIsHTML,
								rbuggyQSA,
								rbuggyMatches,
								matches,
								contains,
								// Instance-specific data
								expando = "sizzle" + 1 * new Date(),
								preferredDoc = window.document,
								dirruns = 0,
								done = 0,
								classCache = createCache(),
								tokenCache = createCache(),
								compilerCache = createCache(),
								nonnativeSelectorCache = createCache(),
								sortOrder = function (a, b) {
									if (a === b) {
										hasDuplicate = true
									}
									return 0
								},
								// Instance methods
								hasOwn = {}.hasOwnProperty,
								arr = [],
								pop = arr.pop,
								pushNative = arr.push,
								push = arr.push,
								slice = arr.slice,
								// Use a stripped-down indexOf as it's faster than native
								// https://jsperf.com/thor-indexof-vs-for/5
								indexOf = function (list, elem) {
									var i = 0,
										len = list.length
									for (; i < len; i++) {
										if (list[i] === elem) {
											return i
										}
									}
									return -1
								},
								booleans =
									"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
									"ismap|loop|multiple|open|readonly|required|scoped",
								// Regular expressions

								// http://www.w3.org/TR/css3-selectors/#whitespace
								whitespace = "[\\x20\\t\\r\\n\\f]",
								// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
								identifier =
									"(?:\\\\[\\da-fA-F]{1,6}" +
									whitespace +
									"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
								// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
								attributes =
									"\\[" +
									whitespace +
									"*(" +
									identifier +
									")(?:" +
									whitespace +
									// Operator (capture 2)
									"*([*^$|!~]?=)" +
									whitespace +
									// "Attribute values must be CSS identifiers [capture 5]
									// or strings [capture 3 or capture 4]"
									"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
									identifier +
									"))|)" +
									whitespace +
									"*\\]",
								pseudos =
									":(" +
									identifier +
									")(?:\\((" +
									// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
									// 1. quoted (capture 3; capture 4 or capture 5)
									"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
									// 2. simple (capture 6)
									"((?:\\\\.|[^\\\\()[\\]]|" +
									attributes +
									")*)|" +
									// 3. anything else (capture 2)
									".*" +
									")\\)|)",
								// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
								rwhitespace = new RegExp(whitespace + "+", "g"),
								rtrim = new RegExp(
									"^" +
										whitespace +
										"+|((?:^|[^\\\\])(?:\\\\.)*)" +
										whitespace +
										"+$",
									"g",
								),
								rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
								rcombinators = new RegExp(
									"^" +
										whitespace +
										"*([>+~]|" +
										whitespace +
										")" +
										whitespace +
										"*",
								),
								rdescend = new RegExp(whitespace + "|>"),
								rpseudo = new RegExp(pseudos),
								ridentifier = new RegExp("^" + identifier + "$"),
								matchExpr = {
									ID: new RegExp("^#(" + identifier + ")"),
									CLASS: new RegExp("^\\.(" + identifier + ")"),
									TAG: new RegExp("^(" + identifier + "|[*])"),
									ATTR: new RegExp("^" + attributes),
									PSEUDO: new RegExp("^" + pseudos),
									CHILD: new RegExp(
										"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
											whitespace +
											"*(even|odd|(([+-]|)(\\d*)n|)" +
											whitespace +
											"*(?:([+-]|)" +
											whitespace +
											"*(\\d+)|))" +
											whitespace +
											"*\\)|)",
										"i",
									),
									bool: new RegExp("^(?:" + booleans + ")$", "i"),

									// For use in libraries implementing .is()
									// We use this for POS matching in `select`
									needsContext: new RegExp(
										"^" +
											whitespace +
											"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
											whitespace +
											"*((?:-\\d)?\\d*)" +
											whitespace +
											"*\\)|)(?=[^-]|$)",
										"i",
									),
								},
								rhtml = /HTML$/i,
								rinputs = /^(?:input|select|textarea|button)$/i,
								rheader = /^h\d$/i,
								rnative = /^[^{]+\{\s*\[native \w/,
								// Easily-parseable/retrievable ID or TAG or CLASS selectors
								rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
								rsibling = /[+~]/,
								// CSS escapes
								// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
								runescape = new RegExp(
									"\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])",
									"g",
								),
								funescape = function (escape, nonHex) {
									var high = "0x" + escape.slice(1) - 0x10000

									return nonHex
										? // Strip the backslash prefix from a non-hex escape sequence
										  nonHex
										: // Replace a hexadecimal escape sequence with the encoded Unicode code point
										// Support: IE <=11+
										// For values outside the Basic Multilingual Plane (BMP), manually construct a
										// surrogate pair
										high < 0
										? String.fromCharCode(high + 0x10000)
										: String.fromCharCode(
												(high >> 10) | 0xd800,
												(high & 0x3ff) | 0xdc00,
										  )
								},
								// CSS string/identifier serialization
								// https://drafts.csswg.org/cssom/#common-serializing-idioms
								rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
								fcssescape = function (ch, asCodePoint) {
									if (asCodePoint) {
										// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
										if (ch === "\0") {
											return "\uFFFD"
										}

										// Control characters and (dependent upon position) numbers get escaped as code points
										return (
											ch.slice(0, -1) +
											"\\" +
											ch.charCodeAt(ch.length - 1).toString(16) +
											" "
										)
									}

									// Other potentially-special ASCII characters get backslash-escaped
									return "\\" + ch
								},
								// Used for iframes
								// See setDocument()
								// Removing the function wrapper causes a "Permission Denied"
								// error in IE
								unloadHandler = function () {
									setDocument()
								},
								inDisabledFieldset = addCombinator(
									function (elem) {
										return (
											elem.disabled === true &&
											elem.nodeName.toLowerCase() === "fieldset"
										)
									},
									{ dir: "parentNode", next: "legend" },
								)

							// Optimize for push.apply( _, NodeList )
							try {
								push.apply(
									(arr = slice.call(preferredDoc.childNodes)),
									preferredDoc.childNodes,
								)

								// Support: Android<4.0
								// Detect silently failing push.apply
								// eslint-disable-next-line no-unused-expressions
								arr[preferredDoc.childNodes.length].nodeType
							} catch (e) {
								push = {
									apply: arr.length
										? // Leverage slice if possible
										  function (target, els) {
												pushNative.apply(target, slice.call(els))
										  }
										: // Support: IE<9
										  // Otherwise append directly
										  function (target, els) {
												var j = target.length,
													i = 0

												// Can't trust NodeList.length
												while ((target[j++] = els[i++])) {}
												target.length = j - 1
										  },
								}
							}

							function Sizzle(selector, context, results, seed) {
								var m,
									i,
									elem,
									nid,
									match,
									groups,
									newSelector,
									newContext = context && context.ownerDocument,
									// nodeType defaults to 9, since context defaults to document
									nodeType = context ? context.nodeType : 9

								results = results || []

								// Return early from calls with invalid selector or context
								if (
									typeof selector !== "string" ||
									!selector ||
									(nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
								) {
									return results
								}

								// Try to shortcut find operations (as opposed to filters) in HTML documents
								if (!seed) {
									setDocument(context)
									context = context || document

									if (documentIsHTML) {
										// If the selector is sufficiently simple, try using a "get*By*" DOM method
										// (excepting DocumentFragment context, where the methods don't exist)
										if (
											nodeType !== 11 &&
											(match = rquickExpr.exec(selector))
										) {
											// ID selector
											if ((m = match[1])) {
												// Document context
												if (nodeType === 9) {
													if ((elem = context.getElementById(m))) {
														// Support: IE, Opera, Webkit
														// TODO: identify versions
														// getElementById can match elements by name instead of ID
														if (elem.id === m) {
															results.push(elem)
															return results
														}
													} else {
														return results
													}

													// Element context
												} else {
													// Support: IE, Opera, Webkit
													// TODO: identify versions
													// getElementById can match elements by name instead of ID
													if (
														newContext &&
														(elem = newContext.getElementById(m)) &&
														contains(context, elem) &&
														elem.id === m
													) {
														results.push(elem)
														return results
													}
												}

												// Type selector
											} else if (match[2]) {
												push.apply(
													results,
													context.getElementsByTagName(selector),
												)
												return results

												// Class selector
											} else if (
												(m = match[3]) &&
												support.getElementsByClassName &&
												context.getElementsByClassName
											) {
												push.apply(results, context.getElementsByClassName(m))
												return results
											}
										}

										// Take advantage of querySelectorAll
										if (
											support.qsa &&
											!nonnativeSelectorCache[selector + " "] &&
											(!rbuggyQSA || !rbuggyQSA.test(selector)) &&
											// Support: IE 8 only
											// Exclude object elements
											(nodeType !== 1 ||
												context.nodeName.toLowerCase() !== "object")
										) {
											newSelector = selector
											newContext = context

											// qSA considers elements outside a scoping root when evaluating child or
											// descendant combinators, which is not what we want.
											// In such cases, we work around the behavior by prefixing every selector in the
											// list with an ID selector referencing the scope context.
											// The technique has to be used as well when a leading combinator is used
											// as such selectors are not recognized by querySelectorAll.
											// Thanks to Andrew Dupont for this technique.
											if (
												nodeType === 1 &&
												(rdescend.test(selector) || rcombinators.test(selector))
											) {
												// Expand context for sibling selectors
												newContext =
													(rsibling.test(selector) &&
														testContext(context.parentNode)) ||
													context

												// We can use :scope instead of the ID hack if the browser
												// supports it & if we're not changing the context.
												if (newContext !== context || !support.scope) {
													// Capture the context ID, setting it first if necessary
													if ((nid = context.getAttribute("id"))) {
														nid = nid.replace(rcssescape, fcssescape)
													} else {
														context.setAttribute("id", (nid = expando))
													}
												}

												// Prefix every selector in the list
												groups = tokenize(selector)
												i = groups.length
												while (i--) {
													groups[i] =
														(nid ? "#" + nid : ":scope") +
														" " +
														toSelector(groups[i])
												}
												newSelector = groups.join(",")
											}

											try {
												push.apply(
													results,
													newContext.querySelectorAll(newSelector),
												)
												return results
											} catch (qsaError) {
												nonnativeSelectorCache(selector, true)
											} finally {
												if (nid === expando) {
													context.removeAttribute("id")
												}
											}
										}
									}
								}

								// All others
								return select(
									selector.replace(rtrim, "$1"),
									context,
									results,
									seed,
								)
							}

							/**
							 * Create key-value caches of limited size
							 * @returns {function(string, object)} Returns the Object data after storing it on itself with
							 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
							 *	deleting the oldest entry
							 */
							function createCache() {
								var keys = []

								function cache(key, value) {
									// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
									if (keys.push(key + " ") > Expr.cacheLength) {
										// Only keep the most recent entries
										delete cache[keys.shift()]
									}
									return (cache[key + " "] = value)
								}
								return cache
							}

							/**
							 * Mark a function for special use by Sizzle
							 * @param {Function} fn The function to mark
							 */
							function markFunction(fn) {
								fn[expando] = true
								return fn
							}

							/**
							 * Support testing using an element
							 * @param {Function} fn Passed the created element and returns a boolean result
							 */
							function assert(fn) {
								var el = document.createElement("fieldset")

								try {
									return !!fn(el)
								} catch (e) {
									return false
								} finally {
									// Remove from its parent by default
									if (el.parentNode) {
										el.parentNode.removeChild(el)
									}

									// release memory in IE
									el = null
								}
							}

							/**
							 * Adds the same handler for all of the specified attrs
							 * @param {String} attrs Pipe-separated list of attributes
							 * @param {Function} handler The method that will be applied
							 */
							function addHandle(attrs, handler) {
								var arr = attrs.split("|"),
									i = arr.length

								while (i--) {
									Expr.attrHandle[arr[i]] = handler
								}
							}

							/**
							 * Checks document order of two siblings
							 * @param {Element} a
							 * @param {Element} b
							 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
							 */
							function siblingCheck(a, b) {
								var cur = b && a,
									diff =
										cur &&
										a.nodeType === 1 &&
										b.nodeType === 1 &&
										a.sourceIndex - b.sourceIndex

								// Use IE sourceIndex if available on both nodes
								if (diff) {
									return diff
								}

								// Check if b follows a
								if (cur) {
									while ((cur = cur.nextSibling)) {
										if (cur === b) {
											return -1
										}
									}
								}

								return a ? 1 : -1
							}

							/**
							 * Returns a function to use in pseudos for input types
							 * @param {String} type
							 */
							function createInputPseudo(type) {
								return function (elem) {
									var name = elem.nodeName.toLowerCase()
									return name === "input" && elem.type === type
								}
							}

							/**
							 * Returns a function to use in pseudos for buttons
							 * @param {String} type
							 */
							function createButtonPseudo(type) {
								return function (elem) {
									var name = elem.nodeName.toLowerCase()
									return (
										(name === "input" || name === "button") &&
										elem.type === type
									)
								}
							}

							/**
							 * Returns a function to use in pseudos for :enabled/:disabled
							 * @param {Boolean} disabled true for :disabled; false for :enabled
							 */
							function createDisabledPseudo(disabled) {
								// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
								return function (elem) {
									// Only certain elements can match :enabled or :disabled
									// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
									// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
									if ("form" in elem) {
										// Check for inherited disabledness on relevant non-disabled elements:
										// * listed form-associated elements in a disabled fieldset
										//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
										//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
										// * option elements in a disabled optgroup
										//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
										// All such elements have a "form" property.
										if (elem.parentNode && elem.disabled === false) {
											// Option elements defer to a parent optgroup if present
											if ("label" in elem) {
												if ("label" in elem.parentNode) {
													return elem.parentNode.disabled === disabled
												} else {
													return elem.disabled === disabled
												}
											}

											// Support: IE 6 - 11
											// Use the isDisabled shortcut property to check for disabled fieldset ancestors
											return (
												elem.isDisabled === disabled ||
												// Where there is no isDisabled, check manually
												/* jshint -W018 */
												(elem.isDisabled !== !disabled &&
													inDisabledFieldset(elem) === disabled)
											)
										}

										return elem.disabled === disabled

										// Try to winnow out elements that can't be disabled before trusting the disabled property.
										// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
										// even exist on them, let alone have a boolean value.
									} else if ("label" in elem) {
										return elem.disabled === disabled
									}

									// Remaining elements are neither :enabled nor :disabled
									return false
								}
							}

							/**
							 * Returns a function to use in pseudos for positionals
							 * @param {Function} fn
							 */
							function createPositionalPseudo(fn) {
								return markFunction(function (argument) {
									argument = +argument
									return markFunction(function (seed, matches) {
										var j,
											matchIndexes = fn([], seed.length, argument),
											i = matchIndexes.length

										// Match elements found at the specified indexes
										while (i--) {
											if (seed[(j = matchIndexes[i])]) {
												seed[j] = !(matches[j] = seed[j])
											}
										}
									})
								})
							}

							/**
							 * Checks a node for validity as a Sizzle context
							 * @param {Element|Object=} context
							 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
							 */
							function testContext(context) {
								return (
									context &&
									typeof context.getElementsByTagName !== "undefined" &&
									context
								)
							}

							// Expose support vars for convenience
							support = Sizzle.support = {}

							/**
							 * Detects XML nodes
							 * @param {Element|Object} elem An element or a document
							 * @returns {Boolean} True iff elem is a non-HTML XML node
							 */
							isXML = Sizzle.isXML = function (elem) {
								var namespace = elem.namespaceURI,
									docElem = (elem.ownerDocument || elem).documentElement

								// Support: IE <=8
								// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
								// https://bugs.jquery.com/ticket/4833
								return !rhtml.test(
									namespace || (docElem && docElem.nodeName) || "HTML",
								)
							}

							/**
							 * Sets document-related variables once based on the current document
							 * @param {Element|Object} [doc] An element or document object to use to set the document
							 * @returns {Object} Returns the current document
							 */
							setDocument = Sizzle.setDocument = function (node) {
								var hasCompare,
									subWindow,
									doc = node ? node.ownerDocument || node : preferredDoc

								// Return early if doc is invalid or already selected
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if (
									doc == document ||
									doc.nodeType !== 9 ||
									!doc.documentElement
								) {
									return document
								}

								// Update global variables
								document = doc
								docElem = document.documentElement
								documentIsHTML = !isXML(document)

								// Support: IE 9 - 11+, Edge 12 - 18+
								// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if (
									preferredDoc != document &&
									(subWindow = document.defaultView) &&
									subWindow.top !== subWindow
								) {
									// Support: IE 11, Edge
									if (subWindow.addEventListener) {
										subWindow.addEventListener("unload", unloadHandler, false)

										// Support: IE 9 - 10 only
									} else if (subWindow.attachEvent) {
										subWindow.attachEvent("onunload", unloadHandler)
									}
								}

								// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
								// Safari 4 - 5 only, Opera <=11.6 - 12.x only
								// IE/Edge & older browsers don't support the :scope pseudo-class.
								// Support: Safari 6.0 only
								// Safari 6.0 supports :scope but it's an alias of :root there.
								support.scope = assert(function (el) {
									docElem
										.appendChild(el)
										.appendChild(document.createElement("div"))
									return (
										typeof el.querySelectorAll !== "undefined" &&
										!el.querySelectorAll(":scope fieldset div").length
									)
								})

								/* Attributes
	---------------------------------------------------------------------- */

								// Support: IE<8
								// Verify that getAttribute really returns attributes and not properties
								// (excepting IE8 booleans)
								support.attributes = assert(function (el) {
									el.className = "i"
									return !el.getAttribute("className")
								})

								/* getElement(s)By*
	---------------------------------------------------------------------- */

								// Check if getElementsByTagName("*") returns only elements
								support.getElementsByTagName = assert(function (el) {
									el.appendChild(document.createComment(""))
									return !el.getElementsByTagName("*").length
								})

								// Support: IE<9
								support.getElementsByClassName = rnative.test(
									document.getElementsByClassName,
								)

								// Support: IE<10
								// Check if getElementById returns elements by name
								// The broken getElementById methods don't pick up programmatically-set names,
								// so use a roundabout getElementsByName test
								support.getById = assert(function (el) {
									docElem.appendChild(el).id = expando
									return (
										!document.getElementsByName ||
										!document.getElementsByName(expando).length
									)
								})

								// ID filter and find
								if (support.getById) {
									Expr.filter["ID"] = function (id) {
										var attrId = id.replace(runescape, funescape)
										return function (elem) {
											return elem.getAttribute("id") === attrId
										}
									}
									Expr.find["ID"] = function (id, context) {
										if (
											typeof context.getElementById !== "undefined" &&
											documentIsHTML
										) {
											var elem = context.getElementById(id)
											return elem ? [elem] : []
										}
									}
								} else {
									Expr.filter["ID"] = function (id) {
										var attrId = id.replace(runescape, funescape)
										return function (elem) {
											var node =
												typeof elem.getAttributeNode !== "undefined" &&
												elem.getAttributeNode("id")
											return node && node.value === attrId
										}
									}

									// Support: IE 6 - 7 only
									// getElementById is not reliable as a find shortcut
									Expr.find["ID"] = function (id, context) {
										if (
											typeof context.getElementById !== "undefined" &&
											documentIsHTML
										) {
											var node,
												i,
												elems,
												elem = context.getElementById(id)

											if (elem) {
												// Verify the id attribute
												node = elem.getAttributeNode("id")
												if (node && node.value === id) {
													return [elem]
												}

												// Fall back on getElementsByName
												elems = context.getElementsByName(id)
												i = 0
												while ((elem = elems[i++])) {
													node = elem.getAttributeNode("id")
													if (node && node.value === id) {
														return [elem]
													}
												}
											}

											return []
										}
									}
								}

								// Tag
								Expr.find["TAG"] = support.getElementsByTagName
									? function (tag, context) {
											if (typeof context.getElementsByTagName !== "undefined") {
												return context.getElementsByTagName(tag)

												// DocumentFragment nodes don't have gEBTN
											} else if (support.qsa) {
												return context.querySelectorAll(tag)
											}
									  }
									: function (tag, context) {
											var elem,
												tmp = [],
												i = 0,
												// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
												results = context.getElementsByTagName(tag)

											// Filter out possible comments
											if (tag === "*") {
												while ((elem = results[i++])) {
													if (elem.nodeType === 1) {
														tmp.push(elem)
													}
												}

												return tmp
											}
											return results
									  }

								// Class
								Expr.find["CLASS"] =
									support.getElementsByClassName &&
									function (className, context) {
										if (
											typeof context.getElementsByClassName !== "undefined" &&
											documentIsHTML
										) {
											return context.getElementsByClassName(className)
										}
									}

								/* QSA/matchesSelector
	---------------------------------------------------------------------- */

								// QSA and matchesSelector support

								// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
								rbuggyMatches = []

								// qSa(:focus) reports false when true (Chrome 21)
								// We allow this because of a bug in IE8/9 that throws an error
								// whenever `document.activeElement` is accessed on an iframe
								// So, we allow :focus to pass through QSA all the time to avoid the IE error
								// See https://bugs.jquery.com/ticket/13378
								rbuggyQSA = []

								if ((support.qsa = rnative.test(document.querySelectorAll))) {
									// Build QSA regex
									// Regex strategy adopted from Diego Perini
									assert(function (el) {
										var input

										// Select is set to empty string on purpose
										// This is to test IE's treatment of not explicitly
										// setting a boolean content attribute,
										// since its presence should be enough
										// https://bugs.jquery.com/ticket/12359
										docElem.appendChild(el).innerHTML =
											"<a id='" +
											expando +
											"'></a>" +
											"<select id='" +
											expando +
											"-\r\\' msallowcapture=''>" +
											"<option selected=''></option></select>"

										// Support: IE8, Opera 11-12.16
										// Nothing should be selected when empty strings follow ^= or $= or *=
										// The test attribute must be unknown in Opera but "safe" for WinRT
										// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
										if (el.querySelectorAll("[msallowcapture^='']").length) {
											rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")")
										}

										// Support: IE8
										// Boolean attributes and "value" are not treated correctly
										if (!el.querySelectorAll("[selected]").length) {
											rbuggyQSA.push(
												"\\[" + whitespace + "*(?:value|" + booleans + ")",
											)
										}

										// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
										if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
											rbuggyQSA.push("~=")
										}

										// Support: IE 11+, Edge 15 - 18+
										// IE 11/Edge don't find elements on a `[name='']` query in some cases.
										// Adding a temporary attribute to the document before the selection works
										// around the issue.
										// Interestingly, IE 10 & older don't seem to have the issue.
										input = document.createElement("input")
										input.setAttribute("name", "")
										el.appendChild(input)
										if (!el.querySelectorAll("[name='']").length) {
											rbuggyQSA.push(
												"\\[" +
													whitespace +
													"*name" +
													whitespace +
													"*=" +
													whitespace +
													"*(?:''|\"\")",
											)
										}

										// Webkit/Opera - :checked should return selected option elements
										// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
										// IE8 throws error here and will not see later tests
										if (!el.querySelectorAll(":checked").length) {
											rbuggyQSA.push(":checked")
										}

										// Support: Safari 8+, iOS 8+
										// https://bugs.webkit.org/show_bug.cgi?id=136851
										// In-page `selector#id sibling-combinator selector` fails
										if (!el.querySelectorAll("a#" + expando + "+*").length) {
											rbuggyQSA.push(".#.+[+~]")
										}

										// Support: Firefox <=3.6 - 5 only
										// Old Firefox doesn't throw on a badly-escaped identifier.
										el.querySelectorAll("\\\f")
										rbuggyQSA.push("[\\r\\n\\f]")
									})

									assert(function (el) {
										el.innerHTML =
											"<a href='' disabled='disabled'></a>" +
											"<select disabled='disabled'><option/></select>"

										// Support: Windows 8 Native Apps
										// The type and name attributes are restricted during .innerHTML assignment
										var input = document.createElement("input")
										input.setAttribute("type", "hidden")
										el.appendChild(input).setAttribute("name", "D")

										// Support: IE8
										// Enforce case-sensitivity of name attribute
										if (el.querySelectorAll("[name=d]").length) {
											rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=")
										}

										// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
										// IE8 throws error here and will not see later tests
										if (el.querySelectorAll(":enabled").length !== 2) {
											rbuggyQSA.push(":enabled", ":disabled")
										}

										// Support: IE9-11+
										// IE's :disabled selector does not pick up the children of disabled fieldsets
										docElem.appendChild(el).disabled = true
										if (el.querySelectorAll(":disabled").length !== 2) {
											rbuggyQSA.push(":enabled", ":disabled")
										}

										// Support: Opera 10 - 11 only
										// Opera 10-11 does not throw on post-comma invalid pseudos
										el.querySelectorAll("*,:x")
										rbuggyQSA.push(",.*:")
									})
								}

								if (
									(support.matchesSelector = rnative.test(
										(matches =
											docElem.matches ||
											docElem.webkitMatchesSelector ||
											docElem.mozMatchesSelector ||
											docElem.oMatchesSelector ||
											docElem.msMatchesSelector),
									))
								) {
									assert(function (el) {
										// Check to see if it's possible to do matchesSelector
										// on a disconnected node (IE 9)
										support.disconnectedMatch = matches.call(el, "*")

										// This should fail with an exception
										// Gecko does not error, returns false instead
										matches.call(el, "[s!='']:x")
										rbuggyMatches.push("!=", pseudos)
									})
								}

								rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"))
								rbuggyMatches =
									rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"))

								/* Contains
	---------------------------------------------------------------------- */
								hasCompare = rnative.test(docElem.compareDocumentPosition)

								// Element contains another
								// Purposefully self-exclusive
								// As in, an element does not contain itself
								contains =
									hasCompare || rnative.test(docElem.contains)
										? function (a, b) {
												var adown = a.nodeType === 9 ? a.documentElement : a,
													bup = b && b.parentNode
												return (
													a === bup ||
													!!(
														bup &&
														bup.nodeType === 1 &&
														(adown.contains
															? adown.contains(bup)
															: a.compareDocumentPosition &&
															  a.compareDocumentPosition(bup) & 16)
													)
												)
										  }
										: function (a, b) {
												if (b) {
													while ((b = b.parentNode)) {
														if (b === a) {
															return true
														}
													}
												}
												return false
										  }

								/* Sorting
	---------------------------------------------------------------------- */

								// Document order sorting
								sortOrder = hasCompare
									? function (a, b) {
											// Flag for duplicate removal
											if (a === b) {
												hasDuplicate = true
												return 0
											}

											// Sort on method existence if only one input has compareDocumentPosition
											var compare =
												!a.compareDocumentPosition - !b.compareDocumentPosition
											if (compare) {
												return compare
											}

											// Calculate position if both inputs belong to the same document
											// Support: IE 11+, Edge 17 - 18+
											// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
											// two documents; shallow comparisons work.
											// eslint-disable-next-line eqeqeq
											compare =
												(a.ownerDocument || a) == (b.ownerDocument || b)
													? a.compareDocumentPosition(b)
													: // Otherwise we know they are disconnected
													  1

											// Disconnected nodes
											if (
												compare & 1 ||
												(!support.sortDetached &&
													b.compareDocumentPosition(a) === compare)
											) {
												// Choose the first element that is related to our preferred document
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (
													a == document ||
													(a.ownerDocument == preferredDoc &&
														contains(preferredDoc, a))
												) {
													return -1
												}

												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (
													b == document ||
													(b.ownerDocument == preferredDoc &&
														contains(preferredDoc, b))
												) {
													return 1
												}

												// Maintain original order
												return sortInput
													? indexOf(sortInput, a) - indexOf(sortInput, b)
													: 0
											}

											return compare & 4 ? -1 : 1
									  }
									: function (a, b) {
											// Exit early if the nodes are identical
											if (a === b) {
												hasDuplicate = true
												return 0
											}

											var cur,
												i = 0,
												aup = a.parentNode,
												bup = b.parentNode,
												ap = [a],
												bp = [b]

											// Parentless nodes are either documents or disconnected
											if (!aup || !bup) {
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												/* eslint-disable eqeqeq */
												return a == document
													? -1
													: b == document
													? 1
													: /* eslint-enable eqeqeq */
													aup
													? -1
													: bup
													? 1
													: sortInput
													? indexOf(sortInput, a) - indexOf(sortInput, b)
													: 0

												// If the nodes are siblings, we can do a quick check
											} else if (aup === bup) {
												return siblingCheck(a, b)
											}

											// Otherwise we need full lists of their ancestors for comparison
											cur = a
											while ((cur = cur.parentNode)) {
												ap.unshift(cur)
											}
											cur = b
											while ((cur = cur.parentNode)) {
												bp.unshift(cur)
											}

											// Walk down the tree looking for a discrepancy
											while (ap[i] === bp[i]) {
												i++
											}

											return i
												? // Do a sibling check if the nodes have a common ancestor
												  siblingCheck(ap[i], bp[i])
												: // Otherwise nodes in our document sort first
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												/* eslint-disable eqeqeq */
												ap[i] == preferredDoc
												? -1
												: bp[i] == preferredDoc
												? 1
												: /* eslint-enable eqeqeq */
												  0
									  }

								return document
							}

							Sizzle.matches = function (expr, elements) {
								return Sizzle(expr, null, null, elements)
							}

							Sizzle.matchesSelector = function (elem, expr) {
								setDocument(elem)

								if (
									support.matchesSelector &&
									documentIsHTML &&
									!nonnativeSelectorCache[expr + " "] &&
									(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
									(!rbuggyQSA || !rbuggyQSA.test(expr))
								) {
									try {
										var ret = matches.call(elem, expr)

										// IE 9's matchesSelector returns false on disconnected nodes
										if (
											ret ||
											support.disconnectedMatch ||
											// As well, disconnected nodes are said to be in a document
											// fragment in IE 9
											(elem.document && elem.document.nodeType !== 11)
										) {
											return ret
										}
									} catch (e) {
										nonnativeSelectorCache(expr, true)
									}
								}

								return Sizzle(expr, document, null, [elem]).length > 0
							}

							Sizzle.contains = function (context, elem) {
								// Set document vars if needed
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if ((context.ownerDocument || context) != document) {
									setDocument(context)
								}
								return contains(context, elem)
							}

							Sizzle.attr = function (elem, name) {
								// Set document vars if needed
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if ((elem.ownerDocument || elem) != document) {
									setDocument(elem)
								}

								var fn = Expr.attrHandle[name.toLowerCase()],
									// Don't get fooled by Object.prototype properties (jQuery #13807)
									val =
										fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
											? fn(elem, name, !documentIsHTML)
											: undefined

								return val !== undefined
									? val
									: support.attributes || !documentIsHTML
									? elem.getAttribute(name)
									: (val = elem.getAttributeNode(name)) && val.specified
									? val.value
									: null
							}

							Sizzle.escape = function (sel) {
								return (sel + "").replace(rcssescape, fcssescape)
							}

							Sizzle.error = function (msg) {
								throw new Error("Syntax error, unrecognized expression: " + msg)
							}

							/**
							 * Document sorting and removing duplicates
							 * @param {ArrayLike} results
							 */
							Sizzle.uniqueSort = function (results) {
								var elem,
									duplicates = [],
									j = 0,
									i = 0

								// Unless we *know* we can detect duplicates, assume their presence
								hasDuplicate = !support.detectDuplicates
								sortInput = !support.sortStable && results.slice(0)
								results.sort(sortOrder)

								if (hasDuplicate) {
									while ((elem = results[i++])) {
										if (elem === results[i]) {
											j = duplicates.push(i)
										}
									}
									while (j--) {
										results.splice(duplicates[j], 1)
									}
								}

								// Clear input after sorting to release objects
								// See https://github.com/jquery/sizzle/pull/225
								sortInput = null

								return results
							}

							/**
							 * Utility function for retrieving the text value of an array of DOM nodes
							 * @param {Array|Element} elem
							 */
							getText = Sizzle.getText = function (elem) {
								var node,
									ret = "",
									i = 0,
									nodeType = elem.nodeType

								if (!nodeType) {
									// If no nodeType, this is expected to be an array
									while ((node = elem[i++])) {
										// Do not traverse comment nodes
										ret += getText(node)
									}
								} else if (
									nodeType === 1 ||
									nodeType === 9 ||
									nodeType === 11
								) {
									// Use textContent for elements
									// innerText usage removed for consistency of new lines (jQuery #11153)
									if (typeof elem.textContent === "string") {
										return elem.textContent
									} else {
										// Traverse its children
										for (
											elem = elem.firstChild;
											elem;
											elem = elem.nextSibling
										) {
											ret += getText(elem)
										}
									}
								} else if (nodeType === 3 || nodeType === 4) {
									return elem.nodeValue
								}

								// Do not include comment or processing instruction nodes

								return ret
							}

							Expr = Sizzle.selectors = {
								// Can be adjusted by the user
								cacheLength: 50,

								createPseudo: markFunction,

								match: matchExpr,

								attrHandle: {},

								find: {},

								relative: {
									">": { dir: "parentNode", first: true },
									" ": { dir: "parentNode" },
									"+": { dir: "previousSibling", first: true },
									"~": { dir: "previousSibling" },
								},

								preFilter: {
									ATTR: function (match) {
										match[1] = match[1].replace(runescape, funescape)

										// Move the given value to match[3] whether quoted or unquoted
										match[3] = (match[3] || match[4] || match[5] || "").replace(
											runescape,
											funescape,
										)

										if (match[2] === "~=") {
											match[3] = " " + match[3] + " "
										}

										return match.slice(0, 4)
									},

									CHILD: function (match) {
										/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
										match[1] = match[1].toLowerCase()

										if (match[1].slice(0, 3) === "nth") {
											// nth-* requires argument
											if (!match[3]) {
												Sizzle.error(match[0])
											}

											// numeric x and y parameters for Expr.filter.CHILD
											// remember that false/true cast respectively to 0/1
											match[4] = +(match[4]
												? match[5] + (match[6] || 1)
												: 2 * (match[3] === "even" || match[3] === "odd"))
											match[5] = +(match[7] + match[8] || match[3] === "odd")

											// other types prohibit arguments
										} else if (match[3]) {
											Sizzle.error(match[0])
										}

										return match
									},

									PSEUDO: function (match) {
										var excess,
											unquoted = !match[6] && match[2]

										if (matchExpr["CHILD"].test(match[0])) {
											return null
										}

										// Accept quoted arguments as-is
										if (match[3]) {
											match[2] = match[4] || match[5] || ""

											// Strip excess characters from unquoted arguments
										} else if (
											unquoted &&
											rpseudo.test(unquoted) &&
											// Get excess from tokenize (recursively)
											(excess = tokenize(unquoted, true)) &&
											// advance to the next closing parenthesis
											(excess =
												unquoted.indexOf(")", unquoted.length - excess) -
												unquoted.length)
										) {
											// excess is a negative index
											match[0] = match[0].slice(0, excess)
											match[2] = unquoted.slice(0, excess)
										}

										// Return only captures needed by the pseudo filter method (type and argument)
										return match.slice(0, 3)
									},
								},

								filter: {
									TAG: function (nodeNameSelector) {
										var nodeName = nodeNameSelector
											.replace(runescape, funescape)
											.toLowerCase()
										return nodeNameSelector === "*"
											? function () {
													return true
											  }
											: function (elem) {
													return (
														elem.nodeName &&
														elem.nodeName.toLowerCase() === nodeName
													)
											  }
									},

									CLASS: function (className) {
										var pattern = classCache[className + " "]

										return (
											pattern ||
											((pattern = new RegExp(
												"(^|" +
													whitespace +
													")" +
													className +
													"(" +
													whitespace +
													"|$)",
											)) &&
												classCache(className, function (elem) {
													return pattern.test(
														(typeof elem.className === "string" &&
															elem.className) ||
															(typeof elem.getAttribute !== "undefined" &&
																elem.getAttribute("class")) ||
															"",
													)
												}))
										)
									},

									ATTR: function (name, operator, check) {
										return function (elem) {
											var result = Sizzle.attr(elem, name)

											if (result == null) {
												return operator === "!="
											}
											if (!operator) {
												return true
											}

											result += ""

											/* eslint-disable max-len */

											return operator === "="
												? result === check
												: operator === "!="
												? result !== check
												: operator === "^="
												? check && result.indexOf(check) === 0
												: operator === "*="
												? check && result.indexOf(check) > -1
												: operator === "$="
												? check && result.slice(-check.length) === check
												: operator === "~="
												? (
														" " +
														result.replace(rwhitespace, " ") +
														" "
												  ).indexOf(check) > -1
												: operator === "|="
												? result === check ||
												  result.slice(0, check.length + 1) === check + "-"
												: false
											/* eslint-enable max-len */
										}
									},

									CHILD: function (type, what, _argument, first, last) {
										var simple = type.slice(0, 3) !== "nth",
											forward = type.slice(-4) !== "last",
											ofType = what === "of-type"

										return first === 1 && last === 0
											? // Shortcut for :nth-*(n)
											  function (elem) {
													return !!elem.parentNode
											  }
											: function (elem, _context, xml) {
													var cache,
														uniqueCache,
														outerCache,
														node,
														nodeIndex,
														start,
														dir =
															simple !== forward
																? "nextSibling"
																: "previousSibling",
														parent = elem.parentNode,
														name = ofType && elem.nodeName.toLowerCase(),
														useCache = !xml && !ofType,
														diff = false

													if (parent) {
														// :(first|last|only)-(child|of-type)
														if (simple) {
															while (dir) {
																node = elem
																while ((node = node[dir])) {
																	if (
																		ofType
																			? node.nodeName.toLowerCase() === name
																			: node.nodeType === 1
																	) {
																		return false
																	}
																}

																// Reverse direction for :only-* (if we haven't yet done so)
																start = dir =
																	type === "only" && !start && "nextSibling"
															}
															return true
														}

														start = [
															forward ? parent.firstChild : parent.lastChild,
														]

														// non-xml :nth-child(...) stores cache data on `parent`
														if (forward && useCache) {
															// Seek `elem` from a previously-cached index

															// ...in a gzip-friendly way
															node = parent
															outerCache = node[expando] || (node[expando] = {})

															// Support: IE <9 only
															// Defend against cloned attroperties (jQuery gh-1709)
															uniqueCache =
																outerCache[node.uniqueID] ||
																(outerCache[node.uniqueID] = {})

															cache = uniqueCache[type] || []
															nodeIndex = cache[0] === dirruns && cache[1]
															diff = nodeIndex && cache[2]
															node = nodeIndex && parent.childNodes[nodeIndex]

															while (
																(node =
																	(++nodeIndex && node && node[dir]) ||
																	// Fallback to seeking `elem` from the start
																	(diff = nodeIndex = 0) ||
																	start.pop())
															) {
																// When found, cache indexes on `parent` and break
																if (
																	node.nodeType === 1 &&
																	++diff &&
																	node === elem
																) {
																	uniqueCache[type] = [dirruns, nodeIndex, diff]
																	break
																}
															}
														} else {
															// Use previously-cached element index if available
															if (useCache) {
																// ...in a gzip-friendly way
																node = elem
																outerCache =
																	node[expando] || (node[expando] = {})

																// Support: IE <9 only
																// Defend against cloned attroperties (jQuery gh-1709)
																uniqueCache =
																	outerCache[node.uniqueID] ||
																	(outerCache[node.uniqueID] = {})

																cache = uniqueCache[type] || []
																nodeIndex = cache[0] === dirruns && cache[1]
																diff = nodeIndex
															}

															// xml :nth-child(...)
															// or :nth-last-child(...) or :nth(-last)?-of-type(...)
															if (diff === false) {
																// Use the same loop as above to seek `elem` from the start
																while (
																	(node =
																		(++nodeIndex && node && node[dir]) ||
																		(diff = nodeIndex = 0) ||
																		start.pop())
																) {
																	if (
																		(ofType
																			? node.nodeName.toLowerCase() === name
																			: node.nodeType === 1) &&
																		++diff
																	) {
																		// Cache the index of each encountered element
																		if (useCache) {
																			outerCache =
																				node[expando] || (node[expando] = {})

																			// Support: IE <9 only
																			// Defend against cloned attroperties (jQuery gh-1709)
																			uniqueCache =
																				outerCache[node.uniqueID] ||
																				(outerCache[node.uniqueID] = {})

																			uniqueCache[type] = [dirruns, diff]
																		}

																		if (node === elem) {
																			break
																		}
																	}
																}
															}
														}

														// Incorporate the offset, then check against cycle size
														diff -= last
														return (
															diff === first ||
															(diff % first === 0 && diff / first >= 0)
														)
													}
											  }
									},

									PSEUDO: function (pseudo, argument) {
										// pseudo-class names are case-insensitive
										// http://www.w3.org/TR/selectors/#pseudo-classes
										// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
										// Remember that setFilters inherits from pseudos
										var args,
											fn =
												Expr.pseudos[pseudo] ||
												Expr.setFilters[pseudo.toLowerCase()] ||
												Sizzle.error("unsupported pseudo: " + pseudo)

										// The user may use createPseudo to indicate that
										// arguments are needed to create the filter function
										// just as Sizzle does
										if (fn[expando]) {
											return fn(argument)
										}

										// But maintain support for old signatures
										if (fn.length > 1) {
											args = [pseudo, pseudo, "", argument]
											return Expr.setFilters.hasOwnProperty(
												pseudo.toLowerCase(),
											)
												? markFunction(function (seed, matches) {
														var idx,
															matched = fn(seed, argument),
															i = matched.length
														while (i--) {
															idx = indexOf(seed, matched[i])
															seed[idx] = !(matches[idx] = matched[i])
														}
												  })
												: function (elem) {
														return fn(elem, 0, args)
												  }
										}

										return fn
									},
								},

								pseudos: {
									// Potentially complex pseudos
									not: markFunction(function (selector) {
										// Trim the selector passed to compile
										// to avoid treating leading and trailing
										// spaces as combinators
										var input = [],
											results = [],
											matcher = compile(selector.replace(rtrim, "$1"))

										return matcher[expando]
											? markFunction(function (seed, matches, _context, xml) {
													var elem,
														unmatched = matcher(seed, null, xml, []),
														i = seed.length

													// Match elements unmatched by `matcher`
													while (i--) {
														if ((elem = unmatched[i])) {
															seed[i] = !(matches[i] = elem)
														}
													}
											  })
											: function (elem, _context, xml) {
													input[0] = elem
													matcher(input, null, xml, results)

													// Don't keep the element (issue #299)
													input[0] = null
													return !results.pop()
											  }
									}),

									has: markFunction(function (selector) {
										return function (elem) {
											return Sizzle(selector, elem).length > 0
										}
									}),

									contains: markFunction(function (text) {
										text = text.replace(runescape, funescape)
										return function (elem) {
											return (
												(elem.textContent || getText(elem)).indexOf(text) > -1
											)
										}
									}),

									// "Whether an element is represented by a :lang() selector
									// is based solely on the element's language value
									// being equal to the identifier C,
									// or beginning with the identifier C immediately followed by "-".
									// The matching of C against the element's language value is performed case-insensitively.
									// The identifier C does not have to be a valid language name."
									// http://www.w3.org/TR/selectors/#lang-pseudo
									lang: markFunction(function (lang) {
										// lang value must be a valid identifier
										if (!ridentifier.test(lang || "")) {
											Sizzle.error("unsupported lang: " + lang)
										}
										lang = lang.replace(runescape, funescape).toLowerCase()
										return function (elem) {
											var elemLang
											do {
												if (
													(elemLang = documentIsHTML
														? elem.lang
														: elem.getAttribute("xml:lang") ||
														  elem.getAttribute("lang"))
												) {
													elemLang = elemLang.toLowerCase()
													return (
														elemLang === lang ||
														elemLang.indexOf(lang + "-") === 0
													)
												}
											} while ((elem = elem.parentNode) && elem.nodeType === 1)
											return false
										}
									}),

									// Miscellaneous
									target: function (elem) {
										var hash = window.location && window.location.hash
										return hash && hash.slice(1) === elem.id
									},

									root: function (elem) {
										return elem === docElem
									},

									focus: function (elem) {
										return (
											elem === document.activeElement &&
											(!document.hasFocus || document.hasFocus()) &&
											!!(elem.type || elem.href || ~elem.tabIndex)
										)
									},

									// Boolean properties
									enabled: createDisabledPseudo(false),
									disabled: createDisabledPseudo(true),

									checked: function (elem) {
										// In CSS3, :checked should return both checked and selected elements
										// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
										var nodeName = elem.nodeName.toLowerCase()
										return (
											(nodeName === "input" && !!elem.checked) ||
											(nodeName === "option" && !!elem.selected)
										)
									},

									selected: function (elem) {
										// Accessing this property makes selected-by-default
										// options in Safari work properly
										if (elem.parentNode) {
											// eslint-disable-next-line no-unused-expressions
											elem.parentNode.selectedIndex
										}

										return elem.selected === true
									},

									// Contents
									empty: function (elem) {
										// http://www.w3.org/TR/selectors/#empty-pseudo
										// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
										//   but not by others (comment: 8; processing instruction: 7; etc.)
										// nodeType < 6 works because attributes (2) do not appear as children
										for (
											elem = elem.firstChild;
											elem;
											elem = elem.nextSibling
										) {
											if (elem.nodeType < 6) {
												return false
											}
										}
										return true
									},

									parent: function (elem) {
										return !Expr.pseudos["empty"](elem)
									},

									// Element/input types
									header: function (elem) {
										return rheader.test(elem.nodeName)
									},

									input: function (elem) {
										return rinputs.test(elem.nodeName)
									},

									button: function (elem) {
										var name = elem.nodeName.toLowerCase()
										return (
											(name === "input" && elem.type === "button") ||
											name === "button"
										)
									},

									text: function (elem) {
										var attr
										return (
											elem.nodeName.toLowerCase() === "input" &&
											elem.type === "text" &&
											// Support: IE<8
											// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
											((attr = elem.getAttribute("type")) == null ||
												attr.toLowerCase() === "text")
										)
									},

									// Position-in-collection
									first: createPositionalPseudo(function () {
										return [0]
									}),

									last: createPositionalPseudo(function (
										_matchIndexes,
										length,
									) {
										return [length - 1]
									}),

									eq: createPositionalPseudo(function (
										_matchIndexes,
										length,
										argument,
									) {
										return [argument < 0 ? argument + length : argument]
									}),

									even: createPositionalPseudo(function (matchIndexes, length) {
										var i = 0
										for (; i < length; i += 2) {
											matchIndexes.push(i)
										}
										return matchIndexes
									}),

									odd: createPositionalPseudo(function (matchIndexes, length) {
										var i = 1
										for (; i < length; i += 2) {
											matchIndexes.push(i)
										}
										return matchIndexes
									}),

									lt: createPositionalPseudo(function (
										matchIndexes,
										length,
										argument,
									) {
										var i =
											argument < 0
												? argument + length
												: argument > length
												? length
												: argument
										for (; --i >= 0; ) {
											matchIndexes.push(i)
										}
										return matchIndexes
									}),

									gt: createPositionalPseudo(function (
										matchIndexes,
										length,
										argument,
									) {
										var i = argument < 0 ? argument + length : argument
										for (; ++i < length; ) {
											matchIndexes.push(i)
										}
										return matchIndexes
									}),
								},
							}

							Expr.pseudos["nth"] = Expr.pseudos["eq"]

							// Add button/input type pseudos
							for (i in {
								radio: true,
								checkbox: true,
								file: true,
								password: true,
								image: true,
							}) {
								Expr.pseudos[i] = createInputPseudo(i)
							}
							for (i in { submit: true, reset: true }) {
								Expr.pseudos[i] = createButtonPseudo(i)
							}

							// Easy API for creating new setFilters
							function setFilters() {}
							setFilters.prototype = Expr.filters = Expr.pseudos
							Expr.setFilters = new setFilters()

							tokenize = Sizzle.tokenize = function (selector, parseOnly) {
								var matched,
									match,
									tokens,
									type,
									soFar,
									groups,
									preFilters,
									cached = tokenCache[selector + " "]

								if (cached) {
									return parseOnly ? 0 : cached.slice(0)
								}

								soFar = selector
								groups = []
								preFilters = Expr.preFilter

								while (soFar) {
									// Comma and first run
									if (!matched || (match = rcomma.exec(soFar))) {
										if (match) {
											// Don't consume trailing commas as valid
											soFar = soFar.slice(match[0].length) || soFar
										}
										groups.push((tokens = []))
									}

									matched = false

									// Combinators
									if ((match = rcombinators.exec(soFar))) {
										matched = match.shift()
										tokens.push({
											value: matched,

											// Cast descendant combinators to space
											type: match[0].replace(rtrim, " "),
										})
										soFar = soFar.slice(matched.length)
									}

									// Filters
									for (type in Expr.filter) {
										if (
											(match = matchExpr[type].exec(soFar)) &&
											(!preFilters[type] || (match = preFilters[type](match)))
										) {
											matched = match.shift()
											tokens.push({
												value: matched,
												type: type,
												matches: match,
											})
											soFar = soFar.slice(matched.length)
										}
									}

									if (!matched) {
										break
									}
								}

								// Return the length of the invalid excess
								// if we're just parsing
								// Otherwise, throw an error or return tokens
								return parseOnly
									? soFar.length
									: soFar
									? Sizzle.error(selector)
									: // Cache the tokens
									  tokenCache(selector, groups).slice(0)
							}

							function toSelector(tokens) {
								var i = 0,
									len = tokens.length,
									selector = ""
								for (; i < len; i++) {
									selector += tokens[i].value
								}
								return selector
							}

							function addCombinator(matcher, combinator, base) {
								var dir = combinator.dir,
									skip = combinator.next,
									key = skip || dir,
									checkNonElements = base && key === "parentNode",
									doneName = done++

								return combinator.first
									? // Check against closest ancestor/preceding element
									  function (elem, context, xml) {
											while ((elem = elem[dir])) {
												if (elem.nodeType === 1 || checkNonElements) {
													return matcher(elem, context, xml)
												}
											}
											return false
									  }
									: // Check against all ancestor/preceding elements
									  function (elem, context, xml) {
											var oldCache,
												uniqueCache,
												outerCache,
												newCache = [dirruns, doneName]

											// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
											if (xml) {
												while ((elem = elem[dir])) {
													if (elem.nodeType === 1 || checkNonElements) {
														if (matcher(elem, context, xml)) {
															return true
														}
													}
												}
											} else {
												while ((elem = elem[dir])) {
													if (elem.nodeType === 1 || checkNonElements) {
														outerCache = elem[expando] || (elem[expando] = {})

														// Support: IE <9 only
														// Defend against cloned attroperties (jQuery gh-1709)
														uniqueCache =
															outerCache[elem.uniqueID] ||
															(outerCache[elem.uniqueID] = {})

														if (skip && skip === elem.nodeName.toLowerCase()) {
															elem = elem[dir] || elem
														} else if (
															(oldCache = uniqueCache[key]) &&
															oldCache[0] === dirruns &&
															oldCache[1] === doneName
														) {
															// Assign to newCache so results back-propagate to previous elements
															return (newCache[2] = oldCache[2])
														} else {
															// Reuse newcache so results back-propagate to previous elements
															uniqueCache[key] = newCache

															// A match means we're done; a fail means we have to keep checking
															if ((newCache[2] = matcher(elem, context, xml))) {
																return true
															}
														}
													}
												}
											}
											return false
									  }
							}

							function elementMatcher(matchers) {
								return matchers.length > 1
									? function (elem, context, xml) {
											var i = matchers.length
											while (i--) {
												if (!matchers[i](elem, context, xml)) {
													return false
												}
											}
											return true
									  }
									: matchers[0]
							}

							function multipleContexts(selector, contexts, results) {
								var i = 0,
									len = contexts.length
								for (; i < len; i++) {
									Sizzle(selector, contexts[i], results)
								}
								return results
							}

							function condense(unmatched, map, filter, context, xml) {
								var elem,
									newUnmatched = [],
									i = 0,
									len = unmatched.length,
									mapped = map != null

								for (; i < len; i++) {
									if ((elem = unmatched[i])) {
										if (!filter || filter(elem, context, xml)) {
											newUnmatched.push(elem)
											if (mapped) {
												map.push(i)
											}
										}
									}
								}

								return newUnmatched
							}

							function setMatcher(
								preFilter,
								selector,
								matcher,
								postFilter,
								postFinder,
								postSelector,
							) {
								if (postFilter && !postFilter[expando]) {
									postFilter = setMatcher(postFilter)
								}
								if (postFinder && !postFinder[expando]) {
									postFinder = setMatcher(postFinder, postSelector)
								}
								return markFunction(function (seed, results, context, xml) {
									var temp,
										i,
										elem,
										preMap = [],
										postMap = [],
										preexisting = results.length,
										// Get initial elements from seed or context
										elems =
											seed ||
											multipleContexts(
												selector || "*",
												context.nodeType ? [context] : context,
												[],
											),
										// Prefilter to get matcher input, preserving a map for seed-results synchronization
										matcherIn =
											preFilter && (seed || !selector)
												? condense(elems, preMap, preFilter, context, xml)
												: elems,
										matcherOut = matcher
											? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
											  postFinder ||
											  (seed ? preFilter : preexisting || postFilter)
												? // ...intermediate processing is necessary
												  []
												: // ...otherwise use results directly
												  results
											: matcherIn

									// Find primary matches
									if (matcher) {
										matcher(matcherIn, matcherOut, context, xml)
									}

									// Apply postFilter
									if (postFilter) {
										temp = condense(matcherOut, postMap)
										postFilter(temp, [], context, xml)

										// Un-match failing elements by moving them back to matcherIn
										i = temp.length
										while (i--) {
											if ((elem = temp[i])) {
												matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)
											}
										}
									}

									if (seed) {
										if (postFinder || preFilter) {
											if (postFinder) {
												// Get the final matcherOut by condensing this intermediate into postFinder contexts
												temp = []
												i = matcherOut.length
												while (i--) {
													if ((elem = matcherOut[i])) {
														// Restore matcherIn since elem is not yet a final match
														temp.push((matcherIn[i] = elem))
													}
												}
												postFinder(null, (matcherOut = []), temp, xml)
											}

											// Move matched elements from seed to results to keep them synchronized
											i = matcherOut.length
											while (i--) {
												if (
													(elem = matcherOut[i]) &&
													(temp = postFinder
														? indexOf(seed, elem)
														: preMap[i]) > -1
												) {
													seed[temp] = !(results[temp] = elem)
												}
											}
										}

										// Add elements to results, through postFinder if defined
									} else {
										matcherOut = condense(
											matcherOut === results
												? matcherOut.splice(preexisting, matcherOut.length)
												: matcherOut,
										)
										if (postFinder) {
											postFinder(null, results, matcherOut, xml)
										} else {
											push.apply(results, matcherOut)
										}
									}
								})
							}

							function matcherFromTokens(tokens) {
								var checkContext,
									matcher,
									j,
									len = tokens.length,
									leadingRelative = Expr.relative[tokens[0].type],
									implicitRelative = leadingRelative || Expr.relative[" "],
									i = leadingRelative ? 1 : 0,
									// The foundational matcher ensures that elements are reachable from top-level context(s)
									matchContext = addCombinator(
										function (elem) {
											return elem === checkContext
										},
										implicitRelative,
										true,
									),
									matchAnyContext = addCombinator(
										function (elem) {
											return indexOf(checkContext, elem) > -1
										},
										implicitRelative,
										true,
									),
									matchers = [
										function (elem, context, xml) {
											var ret =
												(!leadingRelative &&
													(xml || context !== outermostContext)) ||
												((checkContext = context).nodeType
													? matchContext(elem, context, xml)
													: matchAnyContext(elem, context, xml))

											// Avoid hanging onto element (issue #299)
											checkContext = null
											return ret
										},
									]

								for (; i < len; i++) {
									if ((matcher = Expr.relative[tokens[i].type])) {
										matchers = [
											addCombinator(elementMatcher(matchers), matcher),
										]
									} else {
										matcher = Expr.filter[tokens[i].type].apply(
											null,
											tokens[i].matches,
										)

										// Return special upon seeing a positional matcher
										if (matcher[expando]) {
											// Find the next relative operator (if any) for proper handling
											j = ++i
											for (; j < len; j++) {
												if (Expr.relative[tokens[j].type]) {
													break
												}
											}
											return setMatcher(
												i > 1 && elementMatcher(matchers),
												i > 1 &&
													toSelector(
														// If the preceding token was a descendant combinator, insert an implicit any-element `*`
														tokens
															.slice(0, i - 1)
															.concat({
																value: tokens[i - 2].type === " " ? "*" : "",
															}),
													).replace(rtrim, "$1"),
												matcher,
												i < j && matcherFromTokens(tokens.slice(i, j)),
												j < len &&
													matcherFromTokens((tokens = tokens.slice(j))),
												j < len && toSelector(tokens),
											)
										}
										matchers.push(matcher)
									}
								}

								return elementMatcher(matchers)
							}

							function matcherFromGroupMatchers(elementMatchers, setMatchers) {
								var bySet = setMatchers.length > 0,
									byElement = elementMatchers.length > 0,
									superMatcher = function (
										seed,
										context,
										xml,
										results,
										outermost,
									) {
										var elem,
											j,
											matcher,
											matchedCount = 0,
											i = "0",
											unmatched = seed && [],
											setMatched = [],
											contextBackup = outermostContext,
											// We must always have either seed elements or outermost context
											elems =
												seed || (byElement && Expr.find["TAG"]("*", outermost)),
											// Use integer dirruns iff this is the outermost matcher
											dirrunsUnique = (dirruns +=
												contextBackup == null ? 1 : Math.random() || 0.1),
											len = elems.length

										if (outermost) {
											// Support: IE 11+, Edge 17 - 18+
											// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
											// two documents; shallow comparisons work.
											// eslint-disable-next-line eqeqeq
											outermostContext =
												context == document || context || outermost
										}

										// Add elements passing elementMatchers directly to results
										// Support: IE<9, Safari
										// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
										for (; i !== len && (elem = elems[i]) != null; i++) {
											if (byElement && elem) {
												j = 0

												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (!context && elem.ownerDocument != document) {
													setDocument(elem)
													xml = !documentIsHTML
												}
												while ((matcher = elementMatchers[j++])) {
													if (matcher(elem, context || document, xml)) {
														results.push(elem)
														break
													}
												}
												if (outermost) {
													dirruns = dirrunsUnique
												}
											}

											// Track unmatched elements for set filters
											if (bySet) {
												// They will have gone through all possible matchers
												if ((elem = !matcher && elem)) {
													matchedCount--
												}

												// Lengthen the array for every element, matched or not
												if (seed) {
													unmatched.push(elem)
												}
											}
										}

										// `i` is now the count of elements visited above, and adding it to `matchedCount`
										// makes the latter nonnegative.
										matchedCount += i

										// Apply set filters to unmatched elements
										// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
										// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
										// no element matchers and no seed.
										// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
										// case, which will result in a "00" `matchedCount` that differs from `i` but is also
										// numerically zero.
										if (bySet && i !== matchedCount) {
											j = 0
											while ((matcher = setMatchers[j++])) {
												matcher(unmatched, setMatched, context, xml)
											}

											if (seed) {
												// Reintegrate element matches to eliminate the need for sorting
												if (matchedCount > 0) {
													while (i--) {
														if (!(unmatched[i] || setMatched[i])) {
															setMatched[i] = pop.call(results)
														}
													}
												}

												// Discard index placeholder values to get only actual matches
												setMatched = condense(setMatched)
											}

											// Add matches to results
											push.apply(results, setMatched)

											// Seedless set matches succeeding multiple successful matchers stipulate sorting
											if (
												outermost &&
												!seed &&
												setMatched.length > 0 &&
												matchedCount + setMatchers.length > 1
											) {
												Sizzle.uniqueSort(results)
											}
										}

										// Override manipulation of globals by nested matchers
										if (outermost) {
											dirruns = dirrunsUnique
											outermostContext = contextBackup
										}

										return unmatched
									}

								return bySet ? markFunction(superMatcher) : superMatcher
							}

							compile = Sizzle.compile = function (
								selector,
								match /* Internal Use Only */,
							) {
								var i,
									setMatchers = [],
									elementMatchers = [],
									cached = compilerCache[selector + " "]

								if (!cached) {
									// Generate a function of recursive functions that can be used to check each element
									if (!match) {
										match = tokenize(selector)
									}
									i = match.length
									while (i--) {
										cached = matcherFromTokens(match[i])
										if (cached[expando]) {
											setMatchers.push(cached)
										} else {
											elementMatchers.push(cached)
										}
									}

									// Cache the compiled function
									cached = compilerCache(
										selector,
										matcherFromGroupMatchers(elementMatchers, setMatchers),
									)

									// Save selector and tokenization
									cached.selector = selector
								}
								return cached
							}

							/**
							 * A low-level selection function that works with Sizzle's compiled
							 *  selector functions
							 * @param {String|Function} selector A selector or a pre-compiled
							 *  selector function built with Sizzle.compile
							 * @param {Element} context
							 * @param {Array} [results]
							 * @param {Array} [seed] A set of elements to match against
							 */
							select = Sizzle.select = function (
								selector,
								context,
								results,
								seed,
							) {
								var i,
									tokens,
									token,
									type,
									find,
									compiled = typeof selector === "function" && selector,
									match =
										!seed &&
										tokenize((selector = compiled.selector || selector))

								results = results || []

								// Try to minimize operations if there is only one selector in the list and no seed
								// (the latter of which guarantees us context)
								if (match.length === 1) {
									// Reduce context if the leading compound selector is an ID
									tokens = match[0] = match[0].slice(0)
									if (
										tokens.length > 2 &&
										(token = tokens[0]).type === "ID" &&
										context.nodeType === 9 &&
										documentIsHTML &&
										Expr.relative[tokens[1].type]
									) {
										context = (Expr.find["ID"](
											token.matches[0].replace(runescape, funescape),
											context,
										) || [])[0]
										if (!context) {
											return results

											// Precompiled matchers will still verify ancestry, so step up a level
										} else if (compiled) {
											context = context.parentNode
										}

										selector = selector.slice(tokens.shift().value.length)
									}

									// Fetch a seed set for right-to-left matching
									i = matchExpr["needsContext"].test(selector)
										? 0
										: tokens.length
									while (i--) {
										token = tokens[i]

										// Abort if we hit a combinator
										if (Expr.relative[(type = token.type)]) {
											break
										}
										if ((find = Expr.find[type])) {
											// Search, expanding context for leading sibling combinators
											if (
												(seed = find(
													token.matches[0].replace(runescape, funescape),
													(rsibling.test(tokens[0].type) &&
														testContext(context.parentNode)) ||
														context,
												))
											) {
												// If seed is empty or no tokens remain, we can return early
												tokens.splice(i, 1)
												selector = seed.length && toSelector(tokens)
												if (!selector) {
													push.apply(results, seed)
													return results
												}

												break
											}
										}
									}
								}

								// Compile and execute a filtering function if one is not provided
								// Provide `match` to avoid retokenization if we modified the selector above
								;(compiled || compile(selector, match))(
									seed,
									context,
									!documentIsHTML,
									results,
									!context ||
										(rsibling.test(selector) &&
											testContext(context.parentNode)) ||
										context,
								)
								return results
							}

							// One-time assignments

							// Sort stability
							support.sortStable =
								expando.split("").sort(sortOrder).join("") === expando

							// Support: Chrome 14-35+
							// Always assume duplicates if they aren't passed to the comparison function
							support.detectDuplicates = !!hasDuplicate

							// Initialize against the default document
							setDocument()

							// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
							// Detached nodes confoundingly follow *each other*
							support.sortDetached = assert(function (el) {
								// Should return 1, but returns 4 (following)
								return (
									el.compareDocumentPosition(
										document.createElement("fieldset"),
									) & 1
								)
							})

							// Support: IE<8
							// Prevent attribute/property "interpolation"
							// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
							if (
								!assert(function (el) {
									el.innerHTML = "<a href='#'></a>"
									return el.firstChild.getAttribute("href") === "#"
								})
							) {
								addHandle("type|href|height|width", function (
									elem,
									name,
									isXML,
								) {
									if (!isXML) {
										return elem.getAttribute(
											name,
											name.toLowerCase() === "type" ? 1 : 2,
										)
									}
								})
							}

							// Support: IE<9
							// Use defaultValue in place of getAttribute("value")
							if (
								!support.attributes ||
								!assert(function (el) {
									el.innerHTML = "<input/>"
									el.firstChild.setAttribute("value", "")
									return el.firstChild.getAttribute("value") === ""
								})
							) {
								addHandle("value", function (elem, _name, isXML) {
									if (!isXML && elem.nodeName.toLowerCase() === "input") {
										return elem.defaultValue
									}
								})
							}

							// Support: IE<9
							// Use getAttributeNode to fetch booleans when getAttribute lies
							if (
								!assert(function (el) {
									return el.getAttribute("disabled") == null
								})
							) {
								addHandle(booleans, function (elem, name, isXML) {
									var val
									if (!isXML) {
										return elem[name] === true
											? name.toLowerCase()
											: (val = elem.getAttributeNode(name)) && val.specified
											? val.value
											: null
									}
								})
							}

							return Sizzle
						})(window)

					jQuery.find = Sizzle
					jQuery.expr = Sizzle.selectors

					// Deprecated
					jQuery.expr[":"] = jQuery.expr.pseudos
					jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort
					jQuery.text = Sizzle.getText
					jQuery.isXMLDoc = Sizzle.isXML
					jQuery.contains = Sizzle.contains
					jQuery.escapeSelector = Sizzle.escape

					var dir = function (elem, dir, until) {
						var matched = [],
							truncate = until !== undefined

						while ((elem = elem[dir]) && elem.nodeType !== 9) {
							if (elem.nodeType === 1) {
								if (truncate && jQuery(elem).is(until)) {
									break
								}
								matched.push(elem)
							}
						}
						return matched
					}

					var siblings = function (n, elem) {
						var matched = []

						for (; n; n = n.nextSibling) {
							if (n.nodeType === 1 && n !== elem) {
								matched.push(n)
							}
						}

						return matched
					}

					var rneedsContext = jQuery.expr.match.needsContext

					function nodeName(elem, name) {
						return (
							elem.nodeName &&
							elem.nodeName.toLowerCase() === name.toLowerCase()
						)
					}
					var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i

					// Implement the identical functionality for filter and not
					function winnow(elements, qualifier, not) {
						if (isFunction(qualifier)) {
							return jQuery.grep(elements, function (elem, i) {
								return !!qualifier.call(elem, i, elem) !== not
							})
						}

						// Single element
						if (qualifier.nodeType) {
							return jQuery.grep(elements, function (elem) {
								return (elem === qualifier) !== not
							})
						}

						// Arraylike of elements (jQuery, arguments, Array)
						if (typeof qualifier !== "string") {
							return jQuery.grep(elements, function (elem) {
								return indexOf.call(qualifier, elem) > -1 !== not
							})
						}

						// Filtered directly for both simple and complex selectors
						return jQuery.filter(qualifier, elements, not)
					}

					jQuery.filter = function (expr, elems, not) {
						var elem = elems[0]

						if (not) {
							expr = ":not(" + expr + ")"
						}

						if (elems.length === 1 && elem.nodeType === 1) {
							return jQuery.find.matchesSelector(elem, expr) ? [elem] : []
						}

						return jQuery.find.matches(
							expr,
							jQuery.grep(elems, function (elem) {
								return elem.nodeType === 1
							}),
						)
					}

					jQuery.fn.extend({
						find: function (selector) {
							var i,
								ret,
								len = this.length,
								self = this

							if (typeof selector !== "string") {
								return this.pushStack(
									jQuery(selector).filter(function () {
										for (i = 0; i < len; i++) {
											if (jQuery.contains(self[i], this)) {
												return true
											}
										}
									}),
								)
							}

							ret = this.pushStack([])

							for (i = 0; i < len; i++) {
								jQuery.find(selector, self[i], ret)
							}

							return len > 1 ? jQuery.uniqueSort(ret) : ret
						},
						filter: function (selector) {
							return this.pushStack(winnow(this, selector || [], false))
						},
						not: function (selector) {
							return this.pushStack(winnow(this, selector || [], true))
						},
						is: function (selector) {
							return !!winnow(
								this,

								// If this is a positional/relative selector, check membership in the returned set
								// so $("p:first").is("p:last") won't return true for a doc with two "p".
								typeof selector === "string" && rneedsContext.test(selector)
									? jQuery(selector)
									: selector || [],
								false,
							).length
						},
					})

					// Initialize a jQuery object

					// A central reference to the root jQuery(document)
					var rootjQuery,
						// A simple way to check for HTML strings
						// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
						// Strict HTML recognition (#11290: must start with <)
						// Shortcut simple #id case for speed
						rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
						init = (jQuery.fn.init = function (selector, context, root) {
							var match, elem

							// HANDLE: $(""), $(null), $(undefined), $(false)
							if (!selector) {
								return this
							}

							// Method init() accepts an alternate rootjQuery
							// so migrate can support jQuery.sub (gh-2101)
							root = root || rootjQuery

							// Handle HTML strings
							if (typeof selector === "string") {
								if (
									selector[0] === "<" &&
									selector[selector.length - 1] === ">" &&
									selector.length >= 3
								) {
									// Assume that strings that start and end with <> are HTML and skip the regex check
									match = [null, selector, null]
								} else {
									match = rquickExpr.exec(selector)
								}

								// Match html or make sure no context is specified for #id
								if (match && (match[1] || !context)) {
									// HANDLE: $(html) -> $(array)
									if (match[1]) {
										context = context instanceof jQuery ? context[0] : context

										// Option to run scripts is true for back-compat
										// Intentionally let the error be thrown if parseHTML is not present
										jQuery.merge(
											this,
											jQuery.parseHTML(
												match[1],
												context && context.nodeType
													? context.ownerDocument || context
													: document,
												true,
											),
										)

										// HANDLE: $(html, props)
										if (
											rsingleTag.test(match[1]) &&
											jQuery.isPlainObject(context)
										) {
											for (match in context) {
												// Properties of context are called as methods if possible
												if (isFunction(this[match])) {
													this[match](context[match])

													// ...and otherwise set as attributes
												} else {
													this.attr(match, context[match])
												}
											}
										}

										return this

										// HANDLE: $(#id)
									} else {
										elem = document.getElementById(match[2])

										if (elem) {
											// Inject the element directly into the jQuery object
											this[0] = elem
											this.length = 1
										}
										return this
									}

									// HANDLE: $(expr, $(...))
								} else if (!context || context.jquery) {
									return (context || root).find(selector)

									// HANDLE: $(expr, context)
									// (which is just equivalent to: $(context).find(expr)
								} else {
									return this.constructor(context).find(selector)
								}

								// HANDLE: $(DOMElement)
							} else if (selector.nodeType) {
								this[0] = selector
								this.length = 1
								return this

								// HANDLE: $(function)
								// Shortcut for document ready
							} else if (isFunction(selector)) {
								return root.ready !== undefined
									? root.ready(selector)
									: // Execute immediately if ready is not present
									  selector(jQuery)
							}

							return jQuery.makeArray(selector, this)
						})

					// Give the init function the jQuery prototype for later instantiation
					init.prototype = jQuery.fn

					// Initialize central reference
					rootjQuery = jQuery(document)

					var rparentsprev = /^(?:parents|prev(?:Until|All))/,
						// Methods guaranteed to produce a unique set when starting from a unique set
						guaranteedUnique = {
							children: true,
							contents: true,
							next: true,
							prev: true,
						}

					jQuery.fn.extend({
						has: function (target) {
							var targets = jQuery(target, this),
								l = targets.length

							return this.filter(function () {
								var i = 0
								for (; i < l; i++) {
									if (jQuery.contains(this, targets[i])) {
										return true
									}
								}
							})
						},

						closest: function (selectors, context) {
							var cur,
								i = 0,
								l = this.length,
								matched = [],
								targets = typeof selectors !== "string" && jQuery(selectors)

							// Positional selectors never match, since there's no _selection_ context
							if (!rneedsContext.test(selectors)) {
								for (; i < l; i++) {
									for (
										cur = this[i];
										cur && cur !== context;
										cur = cur.parentNode
									) {
										// Always skip document fragments
										if (
											cur.nodeType < 11 &&
											(targets
												? targets.index(cur) > -1
												: // Don't pass non-elements to Sizzle
												  cur.nodeType === 1 &&
												  jQuery.find.matchesSelector(cur, selectors))
										) {
											matched.push(cur)
											break
										}
									}
								}
							}

							return this.pushStack(
								matched.length > 1 ? jQuery.uniqueSort(matched) : matched,
							)
						},

						// Determine the position of an element within the set
						index: function (elem) {
							// No argument, return index in parent
							if (!elem) {
								return this[0] && this[0].parentNode
									? this.first().prevAll().length
									: -1
							}

							// Index in selector
							if (typeof elem === "string") {
								return indexOf.call(jQuery(elem), this[0])
							}

							// Locate the position of the desired element
							return indexOf.call(
								this,

								// If it receives a jQuery object, the first element is used
								elem.jquery ? elem[0] : elem,
							)
						},

						add: function (selector, context) {
							return this.pushStack(
								jQuery.uniqueSort(
									jQuery.merge(this.get(), jQuery(selector, context)),
								),
							)
						},

						addBack: function (selector) {
							return this.add(
								selector == null
									? this.prevObject
									: this.prevObject.filter(selector),
							)
						},
					})

					function sibling(cur, dir) {
						while ((cur = cur[dir]) && cur.nodeType !== 1) {}
						return cur
					}

					jQuery.each(
						{
							parent: function (elem) {
								var parent = elem.parentNode
								return parent && parent.nodeType !== 11 ? parent : null
							},
							parents: function (elem) {
								return dir(elem, "parentNode")
							},
							parentsUntil: function (elem, _i, until) {
								return dir(elem, "parentNode", until)
							},
							next: function (elem) {
								return sibling(elem, "nextSibling")
							},
							prev: function (elem) {
								return sibling(elem, "previousSibling")
							},
							nextAll: function (elem) {
								return dir(elem, "nextSibling")
							},
							prevAll: function (elem) {
								return dir(elem, "previousSibling")
							},
							nextUntil: function (elem, _i, until) {
								return dir(elem, "nextSibling", until)
							},
							prevUntil: function (elem, _i, until) {
								return dir(elem, "previousSibling", until)
							},
							siblings: function (elem) {
								return siblings((elem.parentNode || {}).firstChild, elem)
							},
							children: function (elem) {
								return siblings(elem.firstChild)
							},
							contents: function (elem) {
								if (
									elem.contentDocument != null &&
									// Support: IE 11+
									// <object> elements with no `data` attribute has an object
									// `contentDocument` with a `null` prototype.
									getProto(elem.contentDocument)
								) {
									return elem.contentDocument
								}

								// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
								// Treat the template element as a regular one in browsers that
								// don't support it.
								if (nodeName(elem, "template")) {
									elem = elem.content || elem
								}

								return jQuery.merge([], elem.childNodes)
							},
						},
						function (name, fn) {
							jQuery.fn[name] = function (until, selector) {
								var matched = jQuery.map(this, fn, until)

								if (name.slice(-5) !== "Until") {
									selector = until
								}

								if (selector && typeof selector === "string") {
									matched = jQuery.filter(selector, matched)
								}

								if (this.length > 1) {
									// Remove duplicates
									if (!guaranteedUnique[name]) {
										jQuery.uniqueSort(matched)
									}

									// Reverse order for parents* and prev-derivatives
									if (rparentsprev.test(name)) {
										matched.reverse()
									}
								}

								return this.pushStack(matched)
							}
						},
					)
					var rnothtmlwhite = /[^\x20\t\r\n\f]+/g

					// Convert String-formatted options into Object-formatted ones
					function createOptions(options) {
						var object = {}
						jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
							object[flag] = true
						})
						return object
					}

					/*
					 * Create a callback list using the following parameters:
					 *
					 *	options: an optional list of space-separated options that will change how
					 *			the callback list behaves or a more traditional option object
					 *
					 * By default a callback list will act like an event callback list and can be
					 * "fired" multiple times.
					 *
					 * Possible options:
					 *
					 *	once:			will ensure the callback list can only be fired once (like a Deferred)
					 *
					 *	memory:			will keep track of previous values and will call any callback added
					 *					after the list has been fired right away with the latest "memorized"
					 *					values (like a Deferred)
					 *
					 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
					 *
					 *	stopOnFalse:	interrupt callings when a callback returns false
					 *
					 */
					jQuery.Callbacks = function (options) {
						// Convert options from String-formatted to Object-formatted if needed
						// (we check in cache first)
						options =
							typeof options === "string"
								? createOptions(options)
								: jQuery.extend({}, options)

						var // Flag to know if list is currently firing
							firing,
							// Last fire value for non-forgettable lists
							memory,
							// Flag to know if list was already fired
							fired,
							// Flag to prevent firing
							locked,
							// Actual callback list
							list = [],
							// Queue of execution data for repeatable lists
							queue = [],
							// Index of currently firing callback (modified by add/remove as needed)
							firingIndex = -1,
							// Fire callbacks
							fire = function () {
								// Enforce single-firing
								locked = locked || options.once

								// Execute callbacks for all pending executions,
								// respecting firingIndex overrides and runtime changes
								fired = firing = true
								for (; queue.length; firingIndex = -1) {
									memory = queue.shift()
									while (++firingIndex < list.length) {
										// Run callback and check for early termination
										if (
											list[firingIndex].apply(memory[0], memory[1]) === false &&
											options.stopOnFalse
										) {
											// Jump to end and forget the data so .add doesn't re-fire
											firingIndex = list.length
											memory = false
										}
									}
								}

								// Forget the data if we're done with it
								if (!options.memory) {
									memory = false
								}

								firing = false

								// Clean up if we're done firing for good
								if (locked) {
									// Keep an empty list if we have data for future add calls
									if (memory) {
										list = []

										// Otherwise, this object is spent
									} else {
										list = ""
									}
								}
							},
							// Actual Callbacks object
							self = {
								// Add a callback or a collection of callbacks to the list
								add: function () {
									if (list) {
										// If we have memory from a past run, we should fire after adding
										if (memory && !firing) {
											firingIndex = list.length - 1
											queue.push(memory)
										}

										;(function add(args) {
											jQuery.each(args, function (_, arg) {
												if (isFunction(arg)) {
													if (!options.unique || !self.has(arg)) {
														list.push(arg)
													}
												} else if (
													arg &&
													arg.length &&
													toType(arg) !== "string"
												) {
													// Inspect recursively
													add(arg)
												}
											})
										})(arguments)

										if (memory && !firing) {
											fire()
										}
									}
									return this
								},

								// Remove a callback from the list
								remove: function () {
									jQuery.each(arguments, function (_, arg) {
										var index
										while ((index = jQuery.inArray(arg, list, index)) > -1) {
											list.splice(index, 1)

											// Handle firing indexes
											if (index <= firingIndex) {
												firingIndex--
											}
										}
									})
									return this
								},

								// Check if a given callback is in the list.
								// If no argument is given, return whether or not list has callbacks attached.
								has: function (fn) {
									return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
								},

								// Remove all callbacks from the list
								empty: function () {
									if (list) {
										list = []
									}
									return this
								},

								// Disable .fire and .add
								// Abort any current/pending executions
								// Clear all callbacks and values
								disable: function () {
									locked = queue = []
									list = memory = ""
									return this
								},
								disabled: function () {
									return !list
								},

								// Disable .fire
								// Also disable .add unless we have memory (since it would have no effect)
								// Abort any pending executions
								lock: function () {
									locked = queue = []
									if (!memory && !firing) {
										list = memory = ""
									}
									return this
								},
								locked: function () {
									return !!locked
								},

								// Call all callbacks with the given context and arguments
								fireWith: function (context, args) {
									if (!locked) {
										args = args || []
										args = [context, args.slice ? args.slice() : args]
										queue.push(args)
										if (!firing) {
											fire()
										}
									}
									return this
								},

								// Call all the callbacks with the given arguments
								fire: function () {
									self.fireWith(this, arguments)
									return this
								},

								// To know if the callbacks have already been called at least once
								fired: function () {
									return !!fired
								},
							}

						return self
					}

					function Identity(v) {
						return v
					}
					function Thrower(ex) {
						throw ex
					}

					function adoptValue(value, resolve, reject, noValue) {
						var method

						try {
							// Check for promise aspect first to privilege synchronous behavior
							if (value && isFunction((method = value.promise))) {
								method.call(value).done(resolve).fail(reject)

								// Other thenables
							} else if (value && isFunction((method = value.then))) {
								method.call(value, resolve, reject)

								// Other non-thenables
							} else {
								// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
								// * false: [ value ].slice( 0 ) => resolve( value )
								// * true: [ value ].slice( 1 ) => resolve()
								resolve.apply(undefined, [value].slice(noValue))
							}

							// For Promises/A+, convert exceptions into rejections
							// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
							// Deferred#then to conditionally suppress rejection.
						} catch (value) {
							// Support: Android 4.0 only
							// Strict mode functions invoked without .call/.apply get global-object context
							reject.apply(undefined, [value])
						}
					}

					jQuery.extend({
						Deferred: function (func) {
							var tuples = [
									// action, add listener, callbacks,
									// ... .then handlers, argument index, [final state]
									[
										"notify",
										"progress",
										jQuery.Callbacks("memory"),
										jQuery.Callbacks("memory"),
										2,
									],
									[
										"resolve",
										"done",
										jQuery.Callbacks("once memory"),
										jQuery.Callbacks("once memory"),
										0,
										"resolved",
									],
									[
										"reject",
										"fail",
										jQuery.Callbacks("once memory"),
										jQuery.Callbacks("once memory"),
										1,
										"rejected",
									],
								],
								state = "pending",
								promise = {
									state: function () {
										return state
									},
									always: function () {
										deferred.done(arguments).fail(arguments)
										return this
									},
									catch: function (fn) {
										return promise.then(null, fn)
									},

									// Keep pipe for back-compat
									pipe: function (/* fnDone, fnFail, fnProgress */) {
										var fns = arguments

										return jQuery
											.Deferred(function (newDefer) {
												jQuery.each(tuples, function (_i, tuple) {
													// Map tuples (progress, done, fail) to arguments (done, fail, progress)
													var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]

													// deferred.progress(function() { bind to newDefer or newDefer.notify })
													// deferred.done(function() { bind to newDefer or newDefer.resolve })
													// deferred.fail(function() { bind to newDefer or newDefer.reject })
													deferred[tuple[1]](function () {
														var returned = fn && fn.apply(this, arguments)
														if (returned && isFunction(returned.promise)) {
															returned
																.promise()
																.progress(newDefer.notify)
																.done(newDefer.resolve)
																.fail(newDefer.reject)
														} else {
															newDefer[tuple[0] + "With"](
																this,
																fn ? [returned] : arguments,
															)
														}
													})
												})
												fns = null
											})
											.promise()
									},
									then: function (onFulfilled, onRejected, onProgress) {
										var maxDepth = 0
										function resolve(depth, deferred, handler, special) {
											return function () {
												var that = this,
													args = arguments,
													mightThrow = function () {
														var returned, then

														// Support: Promises/A+ section 2.3.3.3.3
														// https://promisesaplus.com/#point-59
														// Ignore double-resolution attempts
														if (depth < maxDepth) {
															return
														}

														returned = handler.apply(that, args)

														// Support: Promises/A+ section 2.3.1
														// https://promisesaplus.com/#point-48
														if (returned === deferred.promise()) {
															throw new TypeError("Thenable self-resolution")
														}

														// Support: Promises/A+ sections 2.3.3.1, 3.5
														// https://promisesaplus.com/#point-54
														// https://promisesaplus.com/#point-75
														// Retrieve `then` only once
														then =
															returned &&
															// Support: Promises/A+ section 2.3.4
															// https://promisesaplus.com/#point-64
															// Only check objects and functions for thenability
															(typeof returned === "object" ||
																typeof returned === "function") &&
															returned.then

														// Handle a returned thenable
														if (isFunction(then)) {
															// Special processors (notify) just wait for resolution
															if (special) {
																then.call(
																	returned,
																	resolve(
																		maxDepth,
																		deferred,
																		Identity,
																		special,
																	),
																	resolve(maxDepth, deferred, Thrower, special),
																)

																// Normal processors (resolve) also hook into progress
															} else {
																// ...and disregard older resolution values
																maxDepth++

																then.call(
																	returned,
																	resolve(
																		maxDepth,
																		deferred,
																		Identity,
																		special,
																	),
																	resolve(maxDepth, deferred, Thrower, special),
																	resolve(
																		maxDepth,
																		deferred,
																		Identity,
																		deferred.notifyWith,
																	),
																)
															}

															// Handle all other returned values
														} else {
															// Only substitute handlers pass on context
															// and multiple values (non-spec behavior)
															if (handler !== Identity) {
																that = undefined
																args = [returned]
															}

															// Process the value(s)
															// Default process is resolve
															;(special || deferred.resolveWith)(that, args)
														}
													},
													// Only normal processors (resolve) catch and reject exceptions
													process = special
														? mightThrow
														: function () {
																try {
																	mightThrow()
																} catch (e) {
																	if (jQuery.Deferred.exceptionHook) {
																		jQuery.Deferred.exceptionHook(
																			e,
																			process.stackTrace,
																		)
																	}

																	// Support: Promises/A+ section 2.3.3.3.4.1
																	// https://promisesaplus.com/#point-61
																	// Ignore post-resolution exceptions
																	if (depth + 1 >= maxDepth) {
																		// Only substitute handlers pass on context
																		// and multiple values (non-spec behavior)
																		if (handler !== Thrower) {
																			that = undefined
																			args = [e]
																		}

																		deferred.rejectWith(that, args)
																	}
																}
														  }

												// Support: Promises/A+ section 2.3.3.3.1
												// https://promisesaplus.com/#point-57
												// Re-resolve promises immediately to dodge false rejection from
												// subsequent errors
												if (depth) {
													process()
												} else {
													// Call an optional hook to record the stack, in case of exception
													// since it's otherwise lost when execution goes async
													if (jQuery.Deferred.getStackHook) {
														process.stackTrace = jQuery.Deferred.getStackHook()
													}
													window.setTimeout(process)
												}
											}
										}

										return jQuery
											.Deferred(function (newDefer) {
												// progress_handlers.add( ... )
												tuples[0][3].add(
													resolve(
														0,
														newDefer,
														isFunction(onProgress) ? onProgress : Identity,
														newDefer.notifyWith,
													),
												)

												// fulfilled_handlers.add( ... )
												tuples[1][3].add(
													resolve(
														0,
														newDefer,
														isFunction(onFulfilled) ? onFulfilled : Identity,
													),
												)

												// rejected_handlers.add( ... )
												tuples[2][3].add(
													resolve(
														0,
														newDefer,
														isFunction(onRejected) ? onRejected : Thrower,
													),
												)
											})
											.promise()
									},

									// Get a promise for this deferred
									// If obj is provided, the promise aspect is added to the object
									promise: function (obj) {
										return obj != null ? jQuery.extend(obj, promise) : promise
									},
								},
								deferred = {}

							// Add list-specific methods
							jQuery.each(tuples, function (i, tuple) {
								var list = tuple[2],
									stateString = tuple[5]

								// promise.progress = list.add
								// promise.done = list.add
								// promise.fail = list.add
								promise[tuple[1]] = list.add

								// Handle state
								if (stateString) {
									list.add(
										function () {
											// state = "resolved" (i.e., fulfilled)
											// state = "rejected"
											state = stateString
										},

										// rejected_callbacks.disable
										// fulfilled_callbacks.disable
										tuples[3 - i][2].disable,

										// rejected_handlers.disable
										// fulfilled_handlers.disable
										tuples[3 - i][3].disable,

										// progress_callbacks.lock
										tuples[0][2].lock,

										// progress_handlers.lock
										tuples[0][3].lock,
									)
								}

								// progress_handlers.fire
								// fulfilled_handlers.fire
								// rejected_handlers.fire
								list.add(tuple[3].fire)

								// deferred.notify = function() { deferred.notifyWith(...) }
								// deferred.resolve = function() { deferred.resolveWith(...) }
								// deferred.reject = function() { deferred.rejectWith(...) }
								deferred[tuple[0]] = function () {
									deferred[tuple[0] + "With"](
										this === deferred ? undefined : this,
										arguments,
									)
									return this
								}

								// deferred.notifyWith = list.fireWith
								// deferred.resolveWith = list.fireWith
								// deferred.rejectWith = list.fireWith
								deferred[tuple[0] + "With"] = list.fireWith
							})

							// Make the deferred a promise
							promise.promise(deferred)

							// Call given func if any
							if (func) {
								func.call(deferred, deferred)
							}

							// All done!
							return deferred
						},

						// Deferred helper
						when: function (singleValue) {
							var // count of uncompleted subordinates
								remaining = arguments.length,
								// count of unprocessed arguments
								i = remaining,
								// subordinate fulfillment data
								resolveContexts = Array(i),
								resolveValues = slice.call(arguments),
								// the master Deferred
								master = jQuery.Deferred(),
								// subordinate callback factory
								updateFunc = function (i) {
									return function (value) {
										resolveContexts[i] = this
										resolveValues[i] =
											arguments.length > 1 ? slice.call(arguments) : value
										if (!--remaining) {
											master.resolveWith(resolveContexts, resolveValues)
										}
									}
								}

							// Single- and empty arguments are adopted like Promise.resolve
							if (remaining <= 1) {
								adoptValue(
									singleValue,
									master.done(updateFunc(i)).resolve,
									master.reject,
									!remaining,
								)

								// Use .then() to unwrap secondary thenables (cf. gh-3000)
								if (
									master.state() === "pending" ||
									isFunction(resolveValues[i] && resolveValues[i].then)
								) {
									return master.then()
								}
							}

							// Multiple arguments are aggregated like Promise.all array elements
							while (i--) {
								adoptValue(resolveValues[i], updateFunc(i), master.reject)
							}

							return master.promise()
						},
					})

					// These usually indicate a programmer mistake during development,
					// warn about them ASAP rather than swallowing them by default.
					var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/

					jQuery.Deferred.exceptionHook = function (error, stack) {
						// Support: IE 8 - 9 only
						// Console exists when dev tools are open, which can happen at any time
						if (
							window.console &&
							window.console.warn &&
							error &&
							rerrorNames.test(error.name)
						) {
							window.console.warn(
								"jQuery.Deferred exception: " + error.message,
								error.stack,
								stack,
							)
						}
					}

					jQuery.readyException = function (error) {
						window.setTimeout(function () {
							throw error
						})
					}

					// The deferred used on DOM ready
					var readyList = jQuery.Deferred()

					jQuery.fn.ready = function (fn) {
						readyList
							.then(fn)

							// Wrap jQuery.readyException in a function so that the lookup
							// happens at the time of error handling instead of callback
							// registration.
							.catch(function (error) {
								jQuery.readyException(error)
							})

						return this
					}

					jQuery.extend({
						// Is the DOM ready to be used? Set to true once it occurs.
						isReady: false,

						// A counter to track how many items to wait for before
						// the ready event fires. See #6781
						readyWait: 1,

						// Handle when the DOM is ready
						ready: function (wait) {
							// Abort if there are pending holds or we're already ready
							if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
								return
							}

							// Remember that the DOM is ready
							jQuery.isReady = true

							// If a normal DOM Ready event fired, decrement, and wait if need be
							if (wait !== true && --jQuery.readyWait > 0) {
								return
							}

							// If there are functions bound, to execute
							readyList.resolveWith(document, [jQuery])
						},
					})

					jQuery.ready.then = readyList.then

					// The ready event handler and self cleanup method
					function completed() {
						document.removeEventListener("DOMContentLoaded", completed)
						window.removeEventListener("load", completed)
						jQuery.ready()
					}

					// Catch cases where $(document).ready() is called
					// after the browser event has already occurred.
					// Support: IE <=9 - 10 only
					// Older IE sometimes signals "interactive" too soon
					if (
						document.readyState === "complete" ||
						(document.readyState !== "loading" &&
							!document.documentElement.doScroll)
					) {
						// Handle it asynchronously to allow scripts the opportunity to delay ready
						window.setTimeout(jQuery.ready)
					} else {
						// Use the handy event callback
						document.addEventListener("DOMContentLoaded", completed)

						// A fallback to window.onload, that will always work
						window.addEventListener("load", completed)
					}

					// Multifunctional method to get and set values of a collection
					// The value/s can optionally be executed if it's a function
					var access = function (
						elems,
						fn,
						key,
						value,
						chainable,
						emptyGet,
						raw,
					) {
						var i = 0,
							len = elems.length,
							bulk = key == null

						// Sets many values
						if (toType(key) === "object") {
							chainable = true
							for (i in key) {
								access(elems, fn, i, key[i], true, emptyGet, raw)
							}

							// Sets one value
						} else if (value !== undefined) {
							chainable = true

							if (!isFunction(value)) {
								raw = true
							}

							if (bulk) {
								// Bulk operations run against the entire set
								if (raw) {
									fn.call(elems, value)
									fn = null

									// ...except when executing function values
								} else {
									bulk = fn
									fn = function (elem, _key, value) {
										return bulk.call(jQuery(elem), value)
									}
								}
							}

							if (fn) {
								for (; i < len; i++) {
									fn(
										elems[i],
										key,
										raw ? value : value.call(elems[i], i, fn(elems[i], key)),
									)
								}
							}
						}

						if (chainable) {
							return elems
						}

						// Gets
						if (bulk) {
							return fn.call(elems)
						}

						return len ? fn(elems[0], key) : emptyGet
					}

					// Matches dashed string for camelizing
					var rmsPrefix = /^-ms-/,
						rdashAlpha = /-([a-z])/g

					// Used by camelCase as callback to replace()
					function fcamelCase(_all, letter) {
						return letter.toUpperCase()
					}

					// Convert dashed to camelCase; used by the css and data modules
					// Support: IE <=9 - 11, Edge 12 - 15
					// Microsoft forgot to hump their vendor prefix (#9572)
					function camelCase(string) {
						return string
							.replace(rmsPrefix, "ms-")
							.replace(rdashAlpha, fcamelCase)
					}
					var acceptData = function (owner) {
						// Accepts only:
						//  - Node
						//    - Node.ELEMENT_NODE
						//    - Node.DOCUMENT_NODE
						//  - Object
						//    - Any
						return (
							owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType
						)
					}

					function Data() {
						this.expando = jQuery.expando + Data.uid++
					}

					Data.uid = 1

					Data.prototype = {
						cache: function (owner) {
							// Check if the owner object already has a cache
							var value = owner[this.expando]

							// If not, create one
							if (!value) {
								value = {}

								// We can accept data for non-element nodes in modern browsers,
								// but we should not, see #8335.
								// Always return an empty object.
								if (acceptData(owner)) {
									// If it is a node unlikely to be stringify-ed or looped over
									// use plain assignment
									if (owner.nodeType) {
										owner[this.expando] = value

										// Otherwise secure it in a non-enumerable property
										// configurable must be true to allow the property to be
										// deleted when data is removed
									} else {
										Object.defineProperty(owner, this.expando, {
											value: value,
											configurable: true,
										})
									}
								}
							}

							return value
						},
						set: function (owner, data, value) {
							var prop,
								cache = this.cache(owner)

							// Handle: [ owner, key, value ] args
							// Always use camelCase key (gh-2257)
							if (typeof data === "string") {
								cache[camelCase(data)] = value

								// Handle: [ owner, { properties } ] args
							} else {
								// Copy the properties one-by-one to the cache object
								for (prop in data) {
									cache[camelCase(prop)] = data[prop]
								}
							}
							return cache
						},
						get: function (owner, key) {
							return key === undefined
								? this.cache(owner)
								: // Always use camelCase key (gh-2257)
								  owner[this.expando] && owner[this.expando][camelCase(key)]
						},
						access: function (owner, key, value) {
							// In cases where either:
							//
							//   1. No key was specified
							//   2. A string key was specified, but no value provided
							//
							// Take the "read" path and allow the get method to determine
							// which value to return, respectively either:
							//
							//   1. The entire cache object
							//   2. The data stored at the key
							//
							if (
								key === undefined ||
								(key && typeof key === "string" && value === undefined)
							) {
								return this.get(owner, key)
							}

							// When the key is not a string, or both a key and value
							// are specified, set or extend (existing objects) with either:
							//
							//   1. An object of properties
							//   2. A key and value
							//
							this.set(owner, key, value)

							// Since the "set" path can have two possible entry points
							// return the expected data based on which path was taken[*]
							return value !== undefined ? value : key
						},
						remove: function (owner, key) {
							var i,
								cache = owner[this.expando]

							if (cache === undefined) {
								return
							}

							if (key !== undefined) {
								// Support array or space separated string of keys
								if (Array.isArray(key)) {
									// If key is an array of keys...
									// We always set camelCase keys, so remove that.
									key = key.map(camelCase)
								} else {
									key = camelCase(key)

									// If a key with the spaces exists, use it.
									// Otherwise, create an array by matching non-whitespace
									key = key in cache ? [key] : key.match(rnothtmlwhite) || []
								}

								i = key.length

								while (i--) {
									delete cache[key[i]]
								}
							}

							// Remove the expando if there's no more data
							if (key === undefined || jQuery.isEmptyObject(cache)) {
								// Support: Chrome <=35 - 45
								// Webkit & Blink performance suffers when deleting properties
								// from DOM nodes, so set to undefined instead
								// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
								if (owner.nodeType) {
									owner[this.expando] = undefined
								} else {
									delete owner[this.expando]
								}
							}
						},
						hasData: function (owner) {
							var cache = owner[this.expando]
							return cache !== undefined && !jQuery.isEmptyObject(cache)
						},
					}
					var dataPriv = new Data()

					var dataUser = new Data()

					//	Implementation Summary
					//
					//	1. Enforce API surface and semantic compatibility with 1.9.x branch
					//	2. Improve the module's maintainability by reducing the storage
					//		paths to a single mechanism.
					//	3. Use the same single mechanism to support "private" and "user" data.
					//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
					//	5. Avoid exposing implementation details on user objects (eg. expando properties)
					//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

					var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
						rmultiDash = /[A-Z]/g

					function getData(data) {
						if (data === "true") {
							return true
						}

						if (data === "false") {
							return false
						}

						if (data === "null") {
							return null
						}

						// Only convert to a number if it doesn't change the string
						if (data === +data + "") {
							return +data
						}

						if (rbrace.test(data)) {
							return JSON.parse(data)
						}

						return data
					}

					function dataAttr(elem, key, data) {
						var name

						// If nothing was found internally, try to fetch any
						// data from the HTML5 data-* attribute
						if (data === undefined && elem.nodeType === 1) {
							name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase()
							data = elem.getAttribute(name)

							if (typeof data === "string") {
								try {
									data = getData(data)
								} catch (e) {}

								// Make sure we set the data so it isn't changed later
								dataUser.set(elem, key, data)
							} else {
								data = undefined
							}
						}
						return data
					}

					jQuery.extend({
						hasData: function (elem) {
							return dataUser.hasData(elem) || dataPriv.hasData(elem)
						},

						data: function (elem, name, data) {
							return dataUser.access(elem, name, data)
						},

						removeData: function (elem, name) {
							dataUser.remove(elem, name)
						},

						// TODO: Now that all calls to _data and _removeData have been replaced
						// with direct calls to dataPriv methods, these can be deprecated.
						_data: function (elem, name, data) {
							return dataPriv.access(elem, name, data)
						},

						_removeData: function (elem, name) {
							dataPriv.remove(elem, name)
						},
					})

					jQuery.fn.extend({
						data: function (key, value) {
							var i,
								name,
								data,
								elem = this[0],
								attrs = elem && elem.attributes

							// Gets all values
							if (key === undefined) {
								if (this.length) {
									data = dataUser.get(elem)

									if (
										elem.nodeType === 1 &&
										!dataPriv.get(elem, "hasDataAttrs")
									) {
										i = attrs.length
										while (i--) {
											// Support: IE 11 only
											// The attrs elements can be null (#14894)
											if (attrs[i]) {
												name = attrs[i].name
												if (name.indexOf("data-") === 0) {
													name = camelCase(name.slice(5))
													dataAttr(elem, name, data[name])
												}
											}
										}
										dataPriv.set(elem, "hasDataAttrs", true)
									}
								}

								return data
							}

							// Sets multiple values
							if (typeof key === "object") {
								return this.each(function () {
									dataUser.set(this, key)
								})
							}

							return access(
								this,
								function (value) {
									var data

									// The calling jQuery object (element matches) is not empty
									// (and therefore has an element appears at this[ 0 ]) and the
									// `value` parameter was not undefined. An empty jQuery object
									// will result in `undefined` for elem = this[ 0 ] which will
									// throw an exception if an attempt to read a data cache is made.
									if (elem && value === undefined) {
										// Attempt to get data from the cache
										// The key will always be camelCased in Data
										data = dataUser.get(elem, key)
										if (data !== undefined) {
											return data
										}

										// Attempt to "discover" the data in
										// HTML5 custom data-* attrs
										data = dataAttr(elem, key)
										if (data !== undefined) {
											return data
										}

										// We tried really hard, but the data doesn't exist.
										return
									}

									// Set the data...
									this.each(function () {
										// We always store the camelCased key
										dataUser.set(this, key, value)
									})
								},
								null,
								value,
								arguments.length > 1,
								null,
								true,
							)
						},

						removeData: function (key) {
							return this.each(function () {
								dataUser.remove(this, key)
							})
						},
					})

					jQuery.extend({
						queue: function (elem, type, data) {
							var queue

							if (elem) {
								type = (type || "fx") + "queue"
								queue = dataPriv.get(elem, type)

								// Speed up dequeue by getting out quickly if this is just a lookup
								if (data) {
									if (!queue || Array.isArray(data)) {
										queue = dataPriv.access(elem, type, jQuery.makeArray(data))
									} else {
										queue.push(data)
									}
								}
								return queue || []
							}
						},

						dequeue: function (elem, type) {
							type = type || "fx"

							var queue = jQuery.queue(elem, type),
								startLength = queue.length,
								fn = queue.shift(),
								hooks = jQuery._queueHooks(elem, type),
								next = function () {
									jQuery.dequeue(elem, type)
								}

							// If the fx queue is dequeued, always remove the progress sentinel
							if (fn === "inprogress") {
								fn = queue.shift()
								startLength--
							}

							if (fn) {
								// Add a progress sentinel to prevent the fx queue from being
								// automatically dequeued
								if (type === "fx") {
									queue.unshift("inprogress")
								}

								// Clear up the last queue stop function
								delete hooks.stop
								fn.call(elem, next, hooks)
							}

							if (!startLength && hooks) {
								hooks.empty.fire()
							}
						},

						// Not public - generate a queueHooks object, or return the current one
						_queueHooks: function (elem, type) {
							var key = type + "queueHooks"
							return (
								dataPriv.get(elem, key) ||
								dataPriv.access(elem, key, {
									empty: jQuery.Callbacks("once memory").add(function () {
										dataPriv.remove(elem, [type + "queue", key])
									}),
								})
							)
						},
					})

					jQuery.fn.extend({
						queue: function (type, data) {
							var setter = 2

							if (typeof type !== "string") {
								data = type
								type = "fx"
								setter--
							}

							if (arguments.length < setter) {
								return jQuery.queue(this[0], type)
							}

							return data === undefined
								? this
								: this.each(function () {
										var queue = jQuery.queue(this, type, data)

										// Ensure a hooks for this queue
										jQuery._queueHooks(this, type)

										if (type === "fx" && queue[0] !== "inprogress") {
											jQuery.dequeue(this, type)
										}
								  })
						},
						dequeue: function (type) {
							return this.each(function () {
								jQuery.dequeue(this, type)
							})
						},
						clearQueue: function (type) {
							return this.queue(type || "fx", [])
						},

						// Get a promise resolved when queues of a certain type
						// are emptied (fx is the type by default)
						promise: function (type, obj) {
							var tmp,
								count = 1,
								defer = jQuery.Deferred(),
								elements = this,
								i = this.length,
								resolve = function () {
									if (!--count) {
										defer.resolveWith(elements, [elements])
									}
								}

							if (typeof type !== "string") {
								obj = type
								type = undefined
							}
							type = type || "fx"

							while (i--) {
								tmp = dataPriv.get(elements[i], type + "queueHooks")
								if (tmp && tmp.empty) {
									count++
									tmp.empty.add(resolve)
								}
							}
							resolve()
							return defer.promise(obj)
						},
					})
					var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source

					var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i")

					var cssExpand = ["Top", "Right", "Bottom", "Left"]

					var documentElement = document.documentElement

					var isAttached = function (elem) {
							return jQuery.contains(elem.ownerDocument, elem)
						},
						composed = { composed: true }

					// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
					// Check attachment across shadow DOM boundaries when possible (gh-3504)
					// Support: iOS 10.0-10.2 only
					// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
					// leading to errors. We need to check for `getRootNode`.
					if (documentElement.getRootNode) {
						isAttached = function (elem) {
							return (
								jQuery.contains(elem.ownerDocument, elem) ||
								elem.getRootNode(composed) === elem.ownerDocument
							)
						}
					}
					var isHiddenWithinTree = function (elem, el) {
						// isHiddenWithinTree might be called from jQuery#filter function;
						// in that case, element will be second argument
						elem = el || elem

						// Inline style trumps all
						return (
							elem.style.display === "none" ||
							(elem.style.display === "" &&
								// Otherwise, check computed style
								// Support: Firefox <=43 - 45
								// Disconnected elements can have computed display: none, so first confirm that elem is
								// in the document.
								isAttached(elem) &&
								jQuery.css(elem, "display") === "none")
						)
					}

					function adjustCSS(elem, prop, valueParts, tween) {
						var adjusted,
							scale,
							maxIterations = 20,
							currentValue = tween
								? function () {
										return tween.cur()
								  }
								: function () {
										return jQuery.css(elem, prop, "")
								  },
							initial = currentValue(),
							unit =
								(valueParts && valueParts[3]) ||
								(jQuery.cssNumber[prop] ? "" : "px"),
							// Starting value computation is required for potential unit mismatches
							initialInUnit =
								elem.nodeType &&
								(jQuery.cssNumber[prop] || (unit !== "px" && +initial)) &&
								rcssNum.exec(jQuery.css(elem, prop))

						if (initialInUnit && initialInUnit[3] !== unit) {
							// Support: Firefox <=54
							// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
							initial = initial / 2

							// Trust units reported by jQuery.css
							unit = unit || initialInUnit[3]

							// Iteratively approximate from a nonzero starting point
							initialInUnit = +initial || 1

							while (maxIterations--) {
								// Evaluate and update our best guess (doubling guesses that zero out).
								// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
								jQuery.style(elem, prop, initialInUnit + unit)
								if (
									(1 - scale) *
										(1 - (scale = currentValue() / initial || 0.5)) <=
									0
								) {
									maxIterations = 0
								}
								initialInUnit = initialInUnit / scale
							}

							initialInUnit = initialInUnit * 2
							jQuery.style(elem, prop, initialInUnit + unit)

							// Make sure we update the tween properties later on
							valueParts = valueParts || []
						}

						if (valueParts) {
							initialInUnit = +initialInUnit || +initial || 0

							// Apply relative offset (+=/-=) if specified
							adjusted = valueParts[1]
								? initialInUnit + (valueParts[1] + 1) * valueParts[2]
								: +valueParts[2]
							if (tween) {
								tween.unit = unit
								tween.start = initialInUnit
								tween.end = adjusted
							}
						}
						return adjusted
					}

					var defaultDisplayMap = {}

					function getDefaultDisplay(elem) {
						var temp,
							doc = elem.ownerDocument,
							nodeName = elem.nodeName,
							display = defaultDisplayMap[nodeName]

						if (display) {
							return display
						}

						temp = doc.body.appendChild(doc.createElement(nodeName))
						display = jQuery.css(temp, "display")

						temp.parentNode.removeChild(temp)

						if (display === "none") {
							display = "block"
						}
						defaultDisplayMap[nodeName] = display

						return display
					}

					function showHide(elements, show) {
						var display,
							elem,
							values = [],
							index = 0,
							length = elements.length

						// Determine new display value for elements that need to change
						for (; index < length; index++) {
							elem = elements[index]
							if (!elem.style) {
								continue
							}

							display = elem.style.display
							if (show) {
								// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
								// check is required in this first loop unless we have a nonempty display value (either
								// inline or about-to-be-restored)
								if (display === "none") {
									values[index] = dataPriv.get(elem, "display") || null
									if (!values[index]) {
										elem.style.display = ""
									}
								}
								if (elem.style.display === "" && isHiddenWithinTree(elem)) {
									values[index] = getDefaultDisplay(elem)
								}
							} else {
								if (display !== "none") {
									values[index] = "none"

									// Remember what we're overwriting
									dataPriv.set(elem, "display", display)
								}
							}
						}

						// Set the display of the elements in a second loop to avoid constant reflow
						for (index = 0; index < length; index++) {
							if (values[index] != null) {
								elements[index].style.display = values[index]
							}
						}

						return elements
					}

					jQuery.fn.extend({
						show: function () {
							return showHide(this, true)
						},
						hide: function () {
							return showHide(this)
						},
						toggle: function (state) {
							if (typeof state === "boolean") {
								return state ? this.show() : this.hide()
							}

							return this.each(function () {
								if (isHiddenWithinTree(this)) {
									jQuery(this).show()
								} else {
									jQuery(this).hide()
								}
							})
						},
					})
					var rcheckableType = /^(?:checkbox|radio)$/i

					var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i

					var rscriptType = /^$|^module$|\/(?:java|ecma)script/i

					;(function () {
						var fragment = document.createDocumentFragment(),
							div = fragment.appendChild(document.createElement("div")),
							input = document.createElement("input")

						// Support: Android 4.0 - 4.3 only
						// Check state lost if the name is set (#11217)
						// Support: Windows Web Apps (WWA)
						// `name` and `type` must use .setAttribute for WWA (#14901)
						input.setAttribute("type", "radio")
						input.setAttribute("checked", "checked")
						input.setAttribute("name", "t")

						div.appendChild(input)

						// Support: Android <=4.1 only
						// Older WebKit doesn't clone checked state correctly in fragments
						support.checkClone = div
							.cloneNode(true)
							.cloneNode(true).lastChild.checked

						// Support: IE <=11 only
						// Make sure textarea (and checkbox) defaultValue is properly cloned
						div.innerHTML = "<textarea>x</textarea>"
						support.noCloneChecked = !!div.cloneNode(true).lastChild
							.defaultValue

						// Support: IE <=9 only
						// IE <=9 replaces <option> tags with their contents when inserted outside of
						// the select element.
						div.innerHTML = "<option></option>"
						support.option = !!div.lastChild
					})()

					// We have to close these tags to support XHTML (#13200)
					var wrapMap = {
						// XHTML parsers do not magically insert elements in the
						// same way that tag soup parsers do. So we cannot shorten
						// this by omitting <tbody> or other required elements.
						thead: [1, "<table>", "</table>"],
						col: [2, "<table><colgroup>", "</colgroup></table>"],
						tr: [2, "<table><tbody>", "</tbody></table>"],
						td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

						_default: [0, "", ""],
					}

					wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption =
						wrapMap.thead
					wrapMap.th = wrapMap.td

					// Support: IE <=9 only
					if (!support.option) {
						wrapMap.optgroup = wrapMap.option = [
							1,
							"<select multiple='multiple'>",
							"</select>",
						]
					}

					function getAll(context, tag) {
						// Support: IE <=9 - 11 only
						// Use typeof to avoid zero-argument method invocation on host objects (#15151)
						var ret

						if (typeof context.getElementsByTagName !== "undefined") {
							ret = context.getElementsByTagName(tag || "*")
						} else if (typeof context.querySelectorAll !== "undefined") {
							ret = context.querySelectorAll(tag || "*")
						} else {
							ret = []
						}

						if (tag === undefined || (tag && nodeName(context, tag))) {
							return jQuery.merge([context], ret)
						}

						return ret
					}

					// Mark scripts as having already been evaluated
					function setGlobalEval(elems, refElements) {
						var i = 0,
							l = elems.length

						for (; i < l; i++) {
							dataPriv.set(
								elems[i],
								"globalEval",
								!refElements || dataPriv.get(refElements[i], "globalEval"),
							)
						}
					}

					var rhtml = /<|&#?\w+;/

					function buildFragment(elems, context, scripts, selection, ignored) {
						var elem,
							tmp,
							tag,
							wrap,
							attached,
							j,
							fragment = context.createDocumentFragment(),
							nodes = [],
							i = 0,
							l = elems.length

						for (; i < l; i++) {
							elem = elems[i]

							if (elem || elem === 0) {
								// Add nodes directly
								if (toType(elem) === "object") {
									// Support: Android <=4.0 only, PhantomJS 1 only
									// push.apply(_, arraylike) throws on ancient WebKit
									jQuery.merge(nodes, elem.nodeType ? [elem] : elem)

									// Convert non-html into a text node
								} else if (!rhtml.test(elem)) {
									nodes.push(context.createTextNode(elem))

									// Convert html into DOM nodes
								} else {
									tmp =
										tmp || fragment.appendChild(context.createElement("div"))

									// Deserialize a standard representation
									tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase()
									wrap = wrapMap[tag] || wrapMap._default
									tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]

									// Descend through wrappers to the right content
									j = wrap[0]
									while (j--) {
										tmp = tmp.lastChild
									}

									// Support: Android <=4.0 only, PhantomJS 1 only
									// push.apply(_, arraylike) throws on ancient WebKit
									jQuery.merge(nodes, tmp.childNodes)

									// Remember the top-level container
									tmp = fragment.firstChild

									// Ensure the created nodes are orphaned (#12392)
									tmp.textContent = ""
								}
							}
						}

						// Remove wrapper from fragment
						fragment.textContent = ""

						i = 0
						while ((elem = nodes[i++])) {
							// Skip elements already in the context collection (trac-4087)
							if (selection && jQuery.inArray(elem, selection) > -1) {
								if (ignored) {
									ignored.push(elem)
								}
								continue
							}

							attached = isAttached(elem)

							// Append to fragment
							tmp = getAll(fragment.appendChild(elem), "script")

							// Preserve script evaluation history
							if (attached) {
								setGlobalEval(tmp)
							}

							// Capture executables
							if (scripts) {
								j = 0
								while ((elem = tmp[j++])) {
									if (rscriptType.test(elem.type || "")) {
										scripts.push(elem)
									}
								}
							}
						}

						return fragment
					}

					var rkeyEvent = /^key/,
						rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
						rtypenamespace = /^([^.]*)(?:\.(.+)|)/

					function returnTrue() {
						return true
					}

					function returnFalse() {
						return false
					}

					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous, except when they are no-op.
					// So expect focus to be synchronous when the element is already active,
					// and blur to be synchronous when the element is not already active.
					// (focus and blur are always synchronous in other supported browsers,
					// this just defines when we can count on it).
					function expectSync(elem, type) {
						return (elem === safeActiveElement()) === (type === "focus")
					}

					// Support: IE <=9 only
					// Accessing document.activeElement can throw unexpectedly
					// https://bugs.jquery.com/ticket/13393
					function safeActiveElement() {
						try {
							return document.activeElement
						} catch (err) {}
					}

					function on(elem, types, selector, data, fn, one) {
						var origFn, type

						// Types can be a map of types/handlers
						if (typeof types === "object") {
							// ( types-Object, selector, data )
							if (typeof selector !== "string") {
								// ( types-Object, data )
								data = data || selector
								selector = undefined
							}
							for (type in types) {
								on(elem, type, selector, data, types[type], one)
							}
							return elem
						}

						if (data == null && fn == null) {
							// ( types, fn )
							fn = selector
							data = selector = undefined
						} else if (fn == null) {
							if (typeof selector === "string") {
								// ( types, selector, fn )
								fn = data
								data = undefined
							} else {
								// ( types, data, fn )
								fn = data
								data = selector
								selector = undefined
							}
						}
						if (fn === false) {
							fn = returnFalse
						} else if (!fn) {
							return elem
						}

						if (one === 1) {
							origFn = fn
							fn = function (event) {
								// Can use an empty set, since event contains the info
								jQuery().off(event)
								return origFn.apply(this, arguments)
							}

							// Use same guid so caller can remove using origFn
							fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)
						}
						return elem.each(function () {
							jQuery.event.add(this, types, fn, data, selector)
						})
					}

					/*
					 * Helper functions for managing events -- not part of the public interface.
					 * Props to Dean Edwards' addEvent library for many of the ideas.
					 */
					jQuery.event = {
						global: {},

						add: function (elem, types, handler, data, selector) {
							var handleObjIn,
								eventHandle,
								tmp,
								events,
								t,
								handleObj,
								special,
								handlers,
								type,
								namespaces,
								origType,
								elemData = dataPriv.get(elem)

							// Only attach events to objects that accept data
							if (!acceptData(elem)) {
								return
							}

							// Caller can pass in an object of custom data in lieu of the handler
							if (handler.handler) {
								handleObjIn = handler
								handler = handleObjIn.handler
								selector = handleObjIn.selector
							}

							// Ensure that invalid selectors throw exceptions at attach time
							// Evaluate against documentElement in case elem is a non-element node (e.g., document)
							if (selector) {
								jQuery.find.matchesSelector(documentElement, selector)
							}

							// Make sure that the handler has a unique ID, used to find/remove it later
							if (!handler.guid) {
								handler.guid = jQuery.guid++
							}

							// Init the element's event structure and main handler, if this is the first
							if (!(events = elemData.events)) {
								events = elemData.events = Object.create(null)
							}
							if (!(eventHandle = elemData.handle)) {
								eventHandle = elemData.handle = function (e) {
									// Discard the second event of a jQuery.event.trigger() and
									// when an event is called after a page has unloaded
									return typeof jQuery !== "undefined" &&
										jQuery.event.triggered !== e.type
										? jQuery.event.dispatch.apply(elem, arguments)
										: undefined
								}
							}

							// Handle multiple events separated by a space
							types = (types || "").match(rnothtmlwhite) || [""]
							t = types.length
							while (t--) {
								tmp = rtypenamespace.exec(types[t]) || []
								type = origType = tmp[1]
								namespaces = (tmp[2] || "").split(".").sort()

								// There *must* be a type, no attaching namespace-only handlers
								if (!type) {
									continue
								}

								// If event changes its type, use the special event handlers for the changed type
								special = jQuery.event.special[type] || {}

								// If selector defined, determine special event api type, otherwise given type
								type =
									(selector ? special.delegateType : special.bindType) || type

								// Update special based on newly reset type
								special = jQuery.event.special[type] || {}

								// handleObj is passed to all event handlers
								handleObj = jQuery.extend(
									{
										type: type,
										origType: origType,
										data: data,
										handler: handler,
										guid: handler.guid,
										selector: selector,
										needsContext:
											selector && jQuery.expr.match.needsContext.test(selector),
										namespace: namespaces.join("."),
									},
									handleObjIn,
								)

								// Init the event handler queue if we're the first
								if (!(handlers = events[type])) {
									handlers = events[type] = []
									handlers.delegateCount = 0

									// Only use addEventListener if the special events handler returns false
									if (
										!special.setup ||
										special.setup.call(elem, data, namespaces, eventHandle) ===
											false
									) {
										if (elem.addEventListener) {
											elem.addEventListener(type, eventHandle)
										}
									}
								}

								if (special.add) {
									special.add.call(elem, handleObj)

									if (!handleObj.handler.guid) {
										handleObj.handler.guid = handler.guid
									}
								}

								// Add to the element's handler list, delegates in front
								if (selector) {
									handlers.splice(handlers.delegateCount++, 0, handleObj)
								} else {
									handlers.push(handleObj)
								}

								// Keep track of which events have ever been used, for event optimization
								jQuery.event.global[type] = true
							}
						},

						// Detach an event or set of events from an element
						remove: function (elem, types, handler, selector, mappedTypes) {
							var j,
								origCount,
								tmp,
								events,
								t,
								handleObj,
								special,
								handlers,
								type,
								namespaces,
								origType,
								elemData = dataPriv.hasData(elem) && dataPriv.get(elem)

							if (!elemData || !(events = elemData.events)) {
								return
							}

							// Once for each type.namespace in types; type may be omitted
							types = (types || "").match(rnothtmlwhite) || [""]
							t = types.length
							while (t--) {
								tmp = rtypenamespace.exec(types[t]) || []
								type = origType = tmp[1]
								namespaces = (tmp[2] || "").split(".").sort()

								// Unbind all events (on this namespace, if provided) for the element
								if (!type) {
									for (type in events) {
										jQuery.event.remove(
											elem,
											type + types[t],
											handler,
											selector,
											true,
										)
									}
									continue
								}

								special = jQuery.event.special[type] || {}
								type =
									(selector ? special.delegateType : special.bindType) || type
								handlers = events[type] || []
								tmp =
									tmp[2] &&
									new RegExp(
										"(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)",
									)

								// Remove matching events
								origCount = j = handlers.length
								while (j--) {
									handleObj = handlers[j]

									if (
										(mappedTypes || origType === handleObj.origType) &&
										(!handler || handler.guid === handleObj.guid) &&
										(!tmp || tmp.test(handleObj.namespace)) &&
										(!selector ||
											selector === handleObj.selector ||
											(selector === "**" && handleObj.selector))
									) {
										handlers.splice(j, 1)

										if (handleObj.selector) {
											handlers.delegateCount--
										}
										if (special.remove) {
											special.remove.call(elem, handleObj)
										}
									}
								}

								// Remove generic event handler if we removed something and no more handlers exist
								// (avoids potential for endless recursion during removal of special event handlers)
								if (origCount && !handlers.length) {
									if (
										!special.teardown ||
										special.teardown.call(elem, namespaces, elemData.handle) ===
											false
									) {
										jQuery.removeEvent(elem, type, elemData.handle)
									}

									delete events[type]
								}
							}

							// Remove data and the expando if it's no longer used
							if (jQuery.isEmptyObject(events)) {
								dataPriv.remove(elem, "handle events")
							}
						},

						dispatch: function (nativeEvent) {
							var i,
								j,
								ret,
								matched,
								handleObj,
								handlerQueue,
								args = new Array(arguments.length),
								// Make a writable jQuery.Event from the native event object
								event = jQuery.event.fix(nativeEvent),
								handlers =
									(dataPriv.get(this, "events") || Object.create(null))[
										event.type
									] || [],
								special = jQuery.event.special[event.type] || {}

							// Use the fix-ed jQuery.Event rather than the (read-only) native event
							args[0] = event

							for (i = 1; i < arguments.length; i++) {
								args[i] = arguments[i]
							}

							event.delegateTarget = this

							// Call the preDispatch hook for the mapped type, and let it bail if desired
							if (
								special.preDispatch &&
								special.preDispatch.call(this, event) === false
							) {
								return
							}

							// Determine handlers
							handlerQueue = jQuery.event.handlers.call(this, event, handlers)

							// Run delegates first; they may want to stop propagation beneath us
							i = 0
							while (
								(matched = handlerQueue[i++]) &&
								!event.isPropagationStopped()
							) {
								event.currentTarget = matched.elem

								j = 0
								while (
									(handleObj = matched.handlers[j++]) &&
									!event.isImmediatePropagationStopped()
								) {
									// If the event is namespaced, then each handler is only invoked if it is
									// specially universal or its namespaces are a superset of the event's.
									if (
										!event.rnamespace ||
										handleObj.namespace === false ||
										event.rnamespace.test(handleObj.namespace)
									) {
										event.handleObj = handleObj
										event.data = handleObj.data

										ret = (
											(jQuery.event.special[handleObj.origType] || {}).handle ||
											handleObj.handler
										).apply(matched.elem, args)

										if (ret !== undefined) {
											if ((event.result = ret) === false) {
												event.preventDefault()
												event.stopPropagation()
											}
										}
									}
								}
							}

							// Call the postDispatch hook for the mapped type
							if (special.postDispatch) {
								special.postDispatch.call(this, event)
							}

							return event.result
						},

						handlers: function (event, handlers) {
							var i,
								handleObj,
								sel,
								matchedHandlers,
								matchedSelectors,
								handlerQueue = [],
								delegateCount = handlers.delegateCount,
								cur = event.target

							// Find delegate handlers
							if (
								delegateCount &&
								// Support: IE <=9
								// Black-hole SVG <use> instance trees (trac-13180)
								cur.nodeType &&
								// Support: Firefox <=42
								// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
								// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
								// Support: IE 11 only
								// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
								!(event.type === "click" && event.button >= 1)
							) {
								for (; cur !== this; cur = cur.parentNode || this) {
									// Don't check non-elements (#13208)
									// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
									if (
										cur.nodeType === 1 &&
										!(event.type === "click" && cur.disabled === true)
									) {
										matchedHandlers = []
										matchedSelectors = {}
										for (i = 0; i < delegateCount; i++) {
											handleObj = handlers[i]

											// Don't conflict with Object.prototype properties (#13203)
											sel = handleObj.selector + " "

											if (matchedSelectors[sel] === undefined) {
												matchedSelectors[sel] = handleObj.needsContext
													? jQuery(sel, this).index(cur) > -1
													: jQuery.find(sel, this, null, [cur]).length
											}
											if (matchedSelectors[sel]) {
												matchedHandlers.push(handleObj)
											}
										}
										if (matchedHandlers.length) {
											handlerQueue.push({
												elem: cur,
												handlers: matchedHandlers,
											})
										}
									}
								}
							}

							// Add the remaining (directly-bound) handlers
							cur = this
							if (delegateCount < handlers.length) {
								handlerQueue.push({
									elem: cur,
									handlers: handlers.slice(delegateCount),
								})
							}

							return handlerQueue
						},

						addProp: function (name, hook) {
							Object.defineProperty(jQuery.Event.prototype, name, {
								enumerable: true,
								configurable: true,

								get: isFunction(hook)
									? function () {
											if (this.originalEvent) {
												return hook(this.originalEvent)
											}
									  }
									: function () {
											if (this.originalEvent) {
												return this.originalEvent[name]
											}
									  },

								set: function (value) {
									Object.defineProperty(this, name, {
										enumerable: true,
										configurable: true,
										writable: true,
										value: value,
									})
								},
							})
						},

						fix: function (originalEvent) {
							return originalEvent[jQuery.expando]
								? originalEvent
								: new jQuery.Event(originalEvent)
						},

						special: {
							load: {
								// Prevent triggered image.load events from bubbling to window.load
								noBubble: true,
							},
							click: {
								// Utilize native event to ensure correct state for checkable inputs
								setup: function (data) {
									// For mutual compressibility with _default, replace `this` access with a local var.
									// `|| data` is dead code meant only to preserve the variable through minification.
									var el = this || data

									// Claim the first handler
									if (
										rcheckableType.test(el.type) &&
										el.click &&
										nodeName(el, "input")
									) {
										// dataPriv.set( el, "click", ... )
										leverageNative(el, "click", returnTrue)
									}

									// Return false to allow normal processing in the caller
									return false
								},
								trigger: function (data) {
									// For mutual compressibility with _default, replace `this` access with a local var.
									// `|| data` is dead code meant only to preserve the variable through minification.
									var el = this || data

									// Force setup before triggering a click
									if (
										rcheckableType.test(el.type) &&
										el.click &&
										nodeName(el, "input")
									) {
										leverageNative(el, "click")
									}

									// Return non-false to allow normal event-path propagation
									return true
								},

								// For cross-browser consistency, suppress native .click() on links
								// Also prevent it if we're currently inside a leveraged native-event stack
								_default: function (event) {
									var target = event.target
									return (
										(rcheckableType.test(target.type) &&
											target.click &&
											nodeName(target, "input") &&
											dataPriv.get(target, "click")) ||
										nodeName(target, "a")
									)
								},
							},

							beforeunload: {
								postDispatch: function (event) {
									// Support: Firefox 20+
									// Firefox doesn't alert if the returnValue field is not set.
									if (event.result !== undefined && event.originalEvent) {
										event.originalEvent.returnValue = event.result
									}
								},
							},
						},
					}

					// Ensure the presence of an event listener that handles manually-triggered
					// synthetic events by interrupting progress until reinvoked in response to
					// *native* events that it fires directly, ensuring that state changes have
					// already occurred before other listeners are invoked.
					function leverageNative(el, type, expectSync) {
						// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
						if (!expectSync) {
							if (dataPriv.get(el, type) === undefined) {
								jQuery.event.add(el, type, returnTrue)
							}
							return
						}

						// Register the controller as a special universal handler for all event namespaces
						dataPriv.set(el, type, false)
						jQuery.event.add(el, type, {
							namespace: false,
							handler: function (event) {
								var notAsync,
									result,
									saved = dataPriv.get(this, type)

								if (event.isTrigger & 1 && this[type]) {
									// Interrupt processing of the outer synthetic .trigger()ed event
									// Saved data should be false in such cases, but might be a leftover capture object
									// from an async native handler (gh-4350)
									if (!saved.length) {
										// Store arguments for use when handling the inner native event
										// There will always be at least one argument (an event object), so this array
										// will not be confused with a leftover capture object.
										saved = slice.call(arguments)
										dataPriv.set(this, type, saved)

										// Trigger the native event and capture its result
										// Support: IE <=9 - 11+
										// focus() and blur() are asynchronous
										notAsync = expectSync(this, type)
										this[type]()
										result = dataPriv.get(this, type)
										if (saved !== result || notAsync) {
											dataPriv.set(this, type, false)
										} else {
											result = {}
										}
										if (saved !== result) {
											// Cancel the outer synthetic event
											event.stopImmediatePropagation()
											event.preventDefault()
											return result.value
										}

										// If this is an inner synthetic event for an event with a bubbling surrogate
										// (focus or blur), assume that the surrogate already propagated from triggering the
										// native event and prevent that from happening again here.
										// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
										// bubbling surrogate propagates *after* the non-bubbling base), but that seems
										// less bad than duplication.
									} else if ((jQuery.event.special[type] || {}).delegateType) {
										event.stopPropagation()
									}

									// If this is a native event triggered above, everything is now in order
									// Fire an inner synthetic event with the original arguments
								} else if (saved.length) {
									// ...and capture the result
									dataPriv.set(this, type, {
										value: jQuery.event.trigger(
											// Support: IE <=9 - 11+
											// Extend with the prototype to reset the above stopImmediatePropagation()
											jQuery.extend(saved[0], jQuery.Event.prototype),
											saved.slice(1),
											this,
										),
									})

									// Abort handling of the native event
									event.stopImmediatePropagation()
								}
							},
						})
					}

					jQuery.removeEvent = function (elem, type, handle) {
						// This "if" is needed for plain objects
						if (elem.removeEventListener) {
							elem.removeEventListener(type, handle)
						}
					}

					jQuery.Event = function (src, props) {
						// Allow instantiation without the 'new' keyword
						if (!(this instanceof jQuery.Event)) {
							return new jQuery.Event(src, props)
						}

						// Event object
						if (src && src.type) {
							this.originalEvent = src
							this.type = src.type

							// Events bubbling up the document may have been marked as prevented
							// by a handler lower down the tree; reflect the correct value.
							this.isDefaultPrevented =
								src.defaultPrevented ||
								(src.defaultPrevented === undefined &&
									// Support: Android <=2.3 only
									src.returnValue === false)
									? returnTrue
									: returnFalse

							// Create target properties
							// Support: Safari <=6 - 7 only
							// Target should not be a text node (#504, #13143)
							this.target =
								src.target && src.target.nodeType === 3
									? src.target.parentNode
									: src.target

							this.currentTarget = src.currentTarget
							this.relatedTarget = src.relatedTarget

							// Event type
						} else {
							this.type = src
						}

						// Put explicitly provided properties onto the event object
						if (props) {
							jQuery.extend(this, props)
						}

						// Create a timestamp if incoming event doesn't have one
						this.timeStamp = (src && src.timeStamp) || Date.now()

						// Mark it as fixed
						this[jQuery.expando] = true
					}

					// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
					// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
					jQuery.Event.prototype = {
						constructor: jQuery.Event,
						isDefaultPrevented: returnFalse,
						isPropagationStopped: returnFalse,
						isImmediatePropagationStopped: returnFalse,
						isSimulated: false,

						preventDefault: function () {
							var e = this.originalEvent

							this.isDefaultPrevented = returnTrue

							if (e && !this.isSimulated) {
								e.preventDefault()
							}
						},
						stopPropagation: function () {
							var e = this.originalEvent

							this.isPropagationStopped = returnTrue

							if (e && !this.isSimulated) {
								e.stopPropagation()
							}
						},
						stopImmediatePropagation: function () {
							var e = this.originalEvent

							this.isImmediatePropagationStopped = returnTrue

							if (e && !this.isSimulated) {
								e.stopImmediatePropagation()
							}

							this.stopPropagation()
						},
					}

					// Includes all common event props including KeyEvent and MouseEvent specific props
					jQuery.each(
						{
							altKey: true,
							bubbles: true,
							cancelable: true,
							changedTouches: true,
							ctrlKey: true,
							detail: true,
							eventPhase: true,
							metaKey: true,
							pageX: true,
							pageY: true,
							shiftKey: true,
							view: true,
							char: true,
							code: true,
							charCode: true,
							key: true,
							keyCode: true,
							button: true,
							buttons: true,
							clientX: true,
							clientY: true,
							offsetX: true,
							offsetY: true,
							pointerId: true,
							pointerType: true,
							screenX: true,
							screenY: true,
							targetTouches: true,
							toElement: true,
							touches: true,

							which: function (event) {
								var button = event.button

								// Add which for key events
								if (event.which == null && rkeyEvent.test(event.type)) {
									return event.charCode != null ? event.charCode : event.keyCode
								}

								// Add which for click: 1 === left; 2 === middle; 3 === right
								if (
									!event.which &&
									button !== undefined &&
									rmouseEvent.test(event.type)
								) {
									if (button & 1) {
										return 1
									}

									if (button & 2) {
										return 3
									}

									if (button & 4) {
										return 2
									}

									return 0
								}

								return event.which
							},
						},
						jQuery.event.addProp,
					)

					jQuery.each({ focus: "focusin", blur: "focusout" }, function (
						type,
						delegateType,
					) {
						jQuery.event.special[type] = {
							// Utilize native event if possible so blur/focus sequence is correct
							setup: function () {
								// Claim the first handler
								// dataPriv.set( this, "focus", ... )
								// dataPriv.set( this, "blur", ... )
								leverageNative(this, type, expectSync)

								// Return false to allow normal processing in the caller
								return false
							},
							trigger: function () {
								// Force setup before trigger
								leverageNative(this, type)

								// Return non-false to allow normal event-path propagation
								return true
							},

							delegateType: delegateType,
						}
					})

					// Create mouseenter/leave events using mouseover/out and event-time checks
					// so that event delegation works in jQuery.
					// Do the same for pointerenter/pointerleave and pointerover/pointerout
					//
					// Support: Safari 7 only
					// Safari sends mouseenter too often; see:
					// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
					// for the description of the bug (it existed in older Chrome versions as well).
					jQuery.each(
						{
							mouseenter: "mouseover",
							mouseleave: "mouseout",
							pointerenter: "pointerover",
							pointerleave: "pointerout",
						},
						function (orig, fix) {
							jQuery.event.special[orig] = {
								delegateType: fix,
								bindType: fix,

								handle: function (event) {
									var ret,
										target = this,
										related = event.relatedTarget,
										handleObj = event.handleObj

									// For mouseenter/leave call the handler if related is outside the target.
									// NB: No relatedTarget if the mouse left/entered the browser window
									if (
										!related ||
										(related !== target && !jQuery.contains(target, related))
									) {
										event.type = handleObj.origType
										ret = handleObj.handler.apply(this, arguments)
										event.type = fix
									}
									return ret
								},
							}
						},
					)

					jQuery.fn.extend({
						on: function (types, selector, data, fn) {
							return on(this, types, selector, data, fn)
						},
						one: function (types, selector, data, fn) {
							return on(this, types, selector, data, fn, 1)
						},
						off: function (types, selector, fn) {
							var handleObj, type
							if (types && types.preventDefault && types.handleObj) {
								// ( event )  dispatched jQuery.Event
								handleObj = types.handleObj
								jQuery(types.delegateTarget).off(
									handleObj.namespace
										? handleObj.origType + "." + handleObj.namespace
										: handleObj.origType,
									handleObj.selector,
									handleObj.handler,
								)
								return this
							}
							if (typeof types === "object") {
								// ( types-object [, selector] )
								for (type in types) {
									this.off(type, selector, types[type])
								}
								return this
							}
							if (selector === false || typeof selector === "function") {
								// ( types [, fn] )
								fn = selector
								selector = undefined
							}
							if (fn === false) {
								fn = returnFalse
							}
							return this.each(function () {
								jQuery.event.remove(this, types, fn, selector)
							})
						},
					})

					var // Support: IE <=10 - 11, Edge 12 - 13 only
						// In IE/Edge using regex groups here causes severe slowdowns.
						// See https://connect.microsoft.com/IE/feedback/details/1736512/
						rnoInnerhtml = /<script|<style|<link/i,
						// checked="checked" or checked
						rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
						rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g

					// Prefer a tbody over its parent table for containing new rows
					function manipulationTarget(elem, content) {
						if (
							nodeName(elem, "table") &&
							nodeName(
								content.nodeType !== 11 ? content : content.firstChild,
								"tr",
							)
						) {
							return jQuery(elem).children("tbody")[0] || elem
						}

						return elem
					}

					// Replace/restore the type attribute of script elements for safe DOM manipulation
					function disableScript(elem) {
						elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type
						return elem
					}
					function restoreScript(elem) {
						if ((elem.type || "").slice(0, 5) === "true/") {
							elem.type = elem.type.slice(5)
						} else {
							elem.removeAttribute("type")
						}

						return elem
					}

					function cloneCopyEvent(src, dest) {
						var i, l, type, pdataOld, udataOld, udataCur, events

						if (dest.nodeType !== 1) {
							return
						}

						// 1. Copy private data: events, handlers, etc.
						if (dataPriv.hasData(src)) {
							pdataOld = dataPriv.get(src)
							events = pdataOld.events

							if (events) {
								dataPriv.remove(dest, "handle events")

								for (type in events) {
									for (i = 0, l = events[type].length; i < l; i++) {
										jQuery.event.add(dest, type, events[type][i])
									}
								}
							}
						}

						// 2. Copy user data
						if (dataUser.hasData(src)) {
							udataOld = dataUser.access(src)
							udataCur = jQuery.extend({}, udataOld)

							dataUser.set(dest, udataCur)
						}
					}

					// Fix IE bugs, see support tests
					function fixInput(src, dest) {
						var nodeName = dest.nodeName.toLowerCase()

						// Fails to persist the checked state of a cloned checkbox or radio button.
						if (nodeName === "input" && rcheckableType.test(src.type)) {
							dest.checked = src.checked

							// Fails to return the selected option to the default selected state when cloning options
						} else if (nodeName === "input" || nodeName === "textarea") {
							dest.defaultValue = src.defaultValue
						}
					}

					function domManip(collection, args, callback, ignored) {
						// Flatten any nested arrays
						args = flat(args)

						var fragment,
							first,
							scripts,
							hasScripts,
							node,
							doc,
							i = 0,
							l = collection.length,
							iNoClone = l - 1,
							value = args[0],
							valueIsFunction = isFunction(value)

						// We can't cloneNode fragments that contain checked, in WebKit
						if (
							valueIsFunction ||
							(l > 1 &&
								typeof value === "string" &&
								!support.checkClone &&
								rchecked.test(value))
						) {
							return collection.each(function (index) {
								var self = collection.eq(index)
								if (valueIsFunction) {
									args[0] = value.call(this, index, self.html())
								}
								domManip(self, args, callback, ignored)
							})
						}

						if (l) {
							fragment = buildFragment(
								args,
								collection[0].ownerDocument,
								false,
								collection,
								ignored,
							)
							first = fragment.firstChild

							if (fragment.childNodes.length === 1) {
								fragment = first
							}

							// Require either new content or an interest in ignored elements to invoke the callback
							if (first || ignored) {
								scripts = jQuery.map(getAll(fragment, "script"), disableScript)
								hasScripts = scripts.length

								// Use the original fragment for the last item
								// instead of the first because it can end up
								// being emptied incorrectly in certain situations (#8070).
								for (; i < l; i++) {
									node = fragment

									if (i !== iNoClone) {
										node = jQuery.clone(node, true, true)

										// Keep references to cloned scripts for later restoration
										if (hasScripts) {
											// Support: Android <=4.0 only, PhantomJS 1 only
											// push.apply(_, arraylike) throws on ancient WebKit
											jQuery.merge(scripts, getAll(node, "script"))
										}
									}

									callback.call(collection[i], node, i)
								}

								if (hasScripts) {
									doc = scripts[scripts.length - 1].ownerDocument

									// Reenable scripts
									jQuery.map(scripts, restoreScript)

									// Evaluate executable scripts on first document insertion
									for (i = 0; i < hasScripts; i++) {
										node = scripts[i]
										if (
											rscriptType.test(node.type || "") &&
											!dataPriv.access(node, "globalEval") &&
											jQuery.contains(doc, node)
										) {
											if (
												node.src &&
												(node.type || "").toLowerCase() !== "module"
											) {
												// Optional AJAX dependency, but won't run scripts if not present
												if (jQuery._evalUrl && !node.noModule) {
													jQuery._evalUrl(
														node.src,
														{
															nonce: node.nonce || node.getAttribute("nonce"),
														},
														doc,
													)
												}
											} else {
												DOMEval(
													node.textContent.replace(rcleanScript, ""),
													node,
													doc,
												)
											}
										}
									}
								}
							}
						}

						return collection
					}

					function remove(elem, selector, keepData) {
						var node,
							nodes = selector ? jQuery.filter(selector, elem) : elem,
							i = 0

						for (; (node = nodes[i]) != null; i++) {
							if (!keepData && node.nodeType === 1) {
								jQuery.cleanData(getAll(node))
							}

							if (node.parentNode) {
								if (keepData && isAttached(node)) {
									setGlobalEval(getAll(node, "script"))
								}
								node.parentNode.removeChild(node)
							}
						}

						return elem
					}

					jQuery.extend({
						htmlPrefilter: function (html) {
							return html
						},

						clone: function (elem, dataAndEvents, deepDataAndEvents) {
							var i,
								l,
								srcElements,
								destElements,
								clone = elem.cloneNode(true),
								inPage = isAttached(elem)

							// Fix IE cloning issues
							if (
								!support.noCloneChecked &&
								(elem.nodeType === 1 || elem.nodeType === 11) &&
								!jQuery.isXMLDoc(elem)
							) {
								// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
								destElements = getAll(clone)
								srcElements = getAll(elem)

								for (i = 0, l = srcElements.length; i < l; i++) {
									fixInput(srcElements[i], destElements[i])
								}
							}

							// Copy the events from the original to the clone
							if (dataAndEvents) {
								if (deepDataAndEvents) {
									srcElements = srcElements || getAll(elem)
									destElements = destElements || getAll(clone)

									for (i = 0, l = srcElements.length; i < l; i++) {
										cloneCopyEvent(srcElements[i], destElements[i])
									}
								} else {
									cloneCopyEvent(elem, clone)
								}
							}

							// Preserve script evaluation history
							destElements = getAll(clone, "script")
							if (destElements.length > 0) {
								setGlobalEval(destElements, !inPage && getAll(elem, "script"))
							}

							// Return the cloned set
							return clone
						},

						cleanData: function (elems) {
							var data,
								elem,
								type,
								special = jQuery.event.special,
								i = 0

							for (; (elem = elems[i]) !== undefined; i++) {
								if (acceptData(elem)) {
									if ((data = elem[dataPriv.expando])) {
										if (data.events) {
											for (type in data.events) {
												if (special[type]) {
													jQuery.event.remove(elem, type)

													// This is a shortcut to avoid jQuery.event.remove's overhead
												} else {
													jQuery.removeEvent(elem, type, data.handle)
												}
											}
										}

										// Support: Chrome <=35 - 45+
										// Assign undefined instead of using delete, see Data#remove
										elem[dataPriv.expando] = undefined
									}
									if (elem[dataUser.expando]) {
										// Support: Chrome <=35 - 45+
										// Assign undefined instead of using delete, see Data#remove
										elem[dataUser.expando] = undefined
									}
								}
							}
						},
					})

					jQuery.fn.extend({
						detach: function (selector) {
							return remove(this, selector, true)
						},

						remove: function (selector) {
							return remove(this, selector)
						},

						text: function (value) {
							return access(
								this,
								function (value) {
									return value === undefined
										? jQuery.text(this)
										: this.empty().each(function () {
												if (
													this.nodeType === 1 ||
													this.nodeType === 11 ||
													this.nodeType === 9
												) {
													this.textContent = value
												}
										  })
								},
								null,
								value,
								arguments.length,
							)
						},

						append: function () {
							return domManip(this, arguments, function (elem) {
								if (
									this.nodeType === 1 ||
									this.nodeType === 11 ||
									this.nodeType === 9
								) {
									var target = manipulationTarget(this, elem)
									target.appendChild(elem)
								}
							})
						},

						prepend: function () {
							return domManip(this, arguments, function (elem) {
								if (
									this.nodeType === 1 ||
									this.nodeType === 11 ||
									this.nodeType === 9
								) {
									var target = manipulationTarget(this, elem)
									target.insertBefore(elem, target.firstChild)
								}
							})
						},

						before: function () {
							return domManip(this, arguments, function (elem) {
								if (this.parentNode) {
									this.parentNode.insertBefore(elem, this)
								}
							})
						},

						after: function () {
							return domManip(this, arguments, function (elem) {
								if (this.parentNode) {
									this.parentNode.insertBefore(elem, this.nextSibling)
								}
							})
						},

						empty: function () {
							var elem,
								i = 0

							for (; (elem = this[i]) != null; i++) {
								if (elem.nodeType === 1) {
									// Prevent memory leaks
									jQuery.cleanData(getAll(elem, false))

									// Remove any remaining nodes
									elem.textContent = ""
								}
							}

							return this
						},

						clone: function (dataAndEvents, deepDataAndEvents) {
							dataAndEvents = dataAndEvents == null ? false : dataAndEvents
							deepDataAndEvents =
								deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents

							return this.map(function () {
								return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
							})
						},

						html: function (value) {
							return access(
								this,
								function (value) {
									var elem = this[0] || {},
										i = 0,
										l = this.length

									if (value === undefined && elem.nodeType === 1) {
										return elem.innerHTML
									}

									// See if we can take a shortcut and just use innerHTML
									if (
										typeof value === "string" &&
										!rnoInnerhtml.test(value) &&
										!wrapMap[
											(rtagName.exec(value) || ["", ""])[1].toLowerCase()
										]
									) {
										value = jQuery.htmlPrefilter(value)

										try {
											for (; i < l; i++) {
												elem = this[i] || {}

												// Remove element nodes and prevent memory leaks
												if (elem.nodeType === 1) {
													jQuery.cleanData(getAll(elem, false))
													elem.innerHTML = value
												}
											}

											elem = 0

											// If using innerHTML throws an exception, use the fallback method
										} catch (e) {}
									}

									if (elem) {
										this.empty().append(value)
									}
								},
								null,
								value,
								arguments.length,
							)
						},

						replaceWith: function () {
							var ignored = []

							// Make the changes, replacing each non-ignored context element with the new content
							return domManip(
								this,
								arguments,
								function (elem) {
									var parent = this.parentNode

									if (jQuery.inArray(this, ignored) < 0) {
										jQuery.cleanData(getAll(this))
										if (parent) {
											parent.replaceChild(elem, this)
										}
									}

									// Force callback invocation
								},
								ignored,
							)
						},
					})

					jQuery.each(
						{
							appendTo: "append",
							prependTo: "prepend",
							insertBefore: "before",
							insertAfter: "after",
							replaceAll: "replaceWith",
						},
						function (name, original) {
							jQuery.fn[name] = function (selector) {
								var elems,
									ret = [],
									insert = jQuery(selector),
									last = insert.length - 1,
									i = 0

								for (; i <= last; i++) {
									elems = i === last ? this : this.clone(true)
									jQuery(insert[i])[original](elems)

									// Support: Android <=4.0 only, PhantomJS 1 only
									// .get() because push.apply(_, arraylike) throws on ancient WebKit
									push.apply(ret, elems.get())
								}

								return this.pushStack(ret)
							}
						},
					)
					var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i")

					var getStyles = function (elem) {
						// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
						// IE throws on elements created in popups
						// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
						var view = elem.ownerDocument.defaultView

						if (!view || !view.opener) {
							view = window
						}

						return view.getComputedStyle(elem)
					}

					var swap = function (elem, options, callback) {
						var ret,
							name,
							old = {}

						// Remember the old values, and insert the new ones
						for (name in options) {
							old[name] = elem.style[name]
							elem.style[name] = options[name]
						}

						ret = callback.call(elem)

						// Revert the old values
						for (name in options) {
							elem.style[name] = old[name]
						}

						return ret
					}

					var rboxStyle = new RegExp(cssExpand.join("|"), "i")

					;(function () {
						// Executing both pixelPosition & boxSizingReliable tests require only one layout
						// so they're executed at the same time to save the second computation.
						function computeStyleTests() {
							// This is a singleton, we need to execute it only once
							if (!div) {
								return
							}

							container.style.cssText =
								"position:absolute;left:-11111px;width:60px;" +
								"margin-top:1px;padding:0;border:0"
							div.style.cssText =
								"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
								"margin:auto;border:1px;padding:1px;" +
								"width:60%;top:1%"
							documentElement.appendChild(container).appendChild(div)

							var divStyle = window.getComputedStyle(div)
							pixelPositionVal = divStyle.top !== "1%"

							// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
							reliableMarginLeftVal =
								roundPixelMeasures(divStyle.marginLeft) === 12

							// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
							// Some styles come back with percentage values, even though they shouldn't
							div.style.right = "60%"
							pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36

							// Support: IE 9 - 11 only
							// Detect misreporting of content dimensions for box-sizing:border-box elements
							boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36

							// Support: IE 9 only
							// Detect overflow:scroll screwiness (gh-3699)
							// Support: Chrome <=64
							// Don't get tricked when zoom affects offsetWidth (gh-4029)
							div.style.position = "absolute"
							scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12

							documentElement.removeChild(container)

							// Nullify the div so it wouldn't be stored in the memory and
							// it will also be a sign that checks already performed
							div = null
						}

						function roundPixelMeasures(measure) {
							return Math.round(parseFloat(measure))
						}

						var pixelPositionVal,
							boxSizingReliableVal,
							scrollboxSizeVal,
							pixelBoxStylesVal,
							reliableTrDimensionsVal,
							reliableMarginLeftVal,
							container = document.createElement("div"),
							div = document.createElement("div")

						// Finish early in limited (non-browser) environments
						if (!div.style) {
							return
						}

						// Support: IE <=9 - 11 only
						// Style of cloned element affects source element cloned (#8908)
						div.style.backgroundClip = "content-box"
						div.cloneNode(true).style.backgroundClip = ""
						support.clearCloneStyle = div.style.backgroundClip === "content-box"

						jQuery.extend(support, {
							boxSizingReliable: function () {
								computeStyleTests()
								return boxSizingReliableVal
							},
							pixelBoxStyles: function () {
								computeStyleTests()
								return pixelBoxStylesVal
							},
							pixelPosition: function () {
								computeStyleTests()
								return pixelPositionVal
							},
							reliableMarginLeft: function () {
								computeStyleTests()
								return reliableMarginLeftVal
							},
							scrollboxSize: function () {
								computeStyleTests()
								return scrollboxSizeVal
							},

							// Support: IE 9 - 11+, Edge 15 - 18+
							// IE/Edge misreport `getComputedStyle` of table rows with width/height
							// set in CSS while `offset*` properties report correct values.
							// Behavior in IE 9 is more subtle than in newer versions & it passes
							// some versions of this test; make sure not to make it pass there!
							reliableTrDimensions: function () {
								var table, tr, trChild, trStyle
								if (reliableTrDimensionsVal == null) {
									table = document.createElement("table")
									tr = document.createElement("tr")
									trChild = document.createElement("div")

									table.style.cssText = "position:absolute;left:-11111px"
									tr.style.height = "1px"
									trChild.style.height = "9px"

									documentElement
										.appendChild(table)
										.appendChild(tr)
										.appendChild(trChild)

									trStyle = window.getComputedStyle(tr)
									reliableTrDimensionsVal = parseInt(trStyle.height) > 3

									documentElement.removeChild(table)
								}
								return reliableTrDimensionsVal
							},
						})
					})()

					function curCSS(elem, name, computed) {
						var width,
							minWidth,
							maxWidth,
							ret,
							// Support: Firefox 51+
							// Retrieving style before computed somehow
							// fixes an issue with getting wrong values
							// on detached elements
							style = elem.style

						computed = computed || getStyles(elem)

						// getPropertyValue is needed for:
						//   .css('filter') (IE 9 only, #12537)
						//   .css('--customProperty) (#3144)
						if (computed) {
							ret = computed.getPropertyValue(name) || computed[name]

							if (ret === "" && !isAttached(elem)) {
								ret = jQuery.style(elem, name)
							}

							// A tribute to the "awesome hack by Dean Edwards"
							// Android Browser returns percentage for some values,
							// but width seems to be reliably pixels.
							// This is against the CSSOM draft spec:
							// https://drafts.csswg.org/cssom/#resolved-values
							if (
								!support.pixelBoxStyles() &&
								rnumnonpx.test(ret) &&
								rboxStyle.test(name)
							) {
								// Remember the original values
								width = style.width
								minWidth = style.minWidth
								maxWidth = style.maxWidth

								// Put in the new values to get a computed value out
								style.minWidth = style.maxWidth = style.width = ret
								ret = computed.width

								// Revert the changed values
								style.width = width
								style.minWidth = minWidth
								style.maxWidth = maxWidth
							}
						}

						return ret !== undefined
							? // Support: IE <=9 - 11 only
							  // IE returns zIndex value as an integer.
							  ret + ""
							: ret
					}

					function addGetHookIf(conditionFn, hookFn) {
						// Define the hook, we'll check on the first run if it's really needed.
						return {
							get: function () {
								if (conditionFn()) {
									// Hook not needed (or it's not possible to use it due
									// to missing dependency), remove it.
									delete this.get
									return
								}

								// Hook needed; redefine it so that the support test is not executed again.
								return (this.get = hookFn).apply(this, arguments)
							},
						}
					}

					var cssPrefixes = ["Webkit", "Moz", "ms"],
						emptyStyle = document.createElement("div").style,
						vendorProps = {}

					// Return a vendor-prefixed property or undefined
					function vendorPropName(name) {
						// Check for vendor prefixed names
						var capName = name[0].toUpperCase() + name.slice(1),
							i = cssPrefixes.length

						while (i--) {
							name = cssPrefixes[i] + capName
							if (name in emptyStyle) {
								return name
							}
						}
					}

					// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
					function finalPropName(name) {
						var final = jQuery.cssProps[name] || vendorProps[name]

						if (final) {
							return final
						}
						if (name in emptyStyle) {
							return name
						}
						return (vendorProps[name] = vendorPropName(name) || name)
					}

					var // Swappable if display is none or starts with table
						// except "table", "table-cell", or "table-caption"
						// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
						rdisplayswap = /^(none|table(?!-c[ea]).+)/,
						rcustomProp = /^--/,
						cssShow = {
							position: "absolute",
							visibility: "hidden",
							display: "block",
						},
						cssNormalTransform = {
							letterSpacing: "0",
							fontWeight: "400",
						}

					function setPositiveNumber(_elem, value, subtract) {
						// Any relative (+/-) values have already been
						// normalized at this point
						var matches = rcssNum.exec(value)
						return matches
							? // Guard against undefined "subtract", e.g., when used as in cssHooks
							  Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
							: value
					}

					function boxModelAdjustment(
						elem,
						dimension,
						box,
						isBorderBox,
						styles,
						computedVal,
					) {
						var i = dimension === "width" ? 1 : 0,
							extra = 0,
							delta = 0

						// Adjustment may not be necessary
						if (box === (isBorderBox ? "border" : "content")) {
							return 0
						}

						for (; i < 4; i += 2) {
							// Both box models exclude margin
							if (box === "margin") {
								delta += jQuery.css(elem, box + cssExpand[i], true, styles)
							}

							// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
							if (!isBorderBox) {
								// Add padding
								delta += jQuery.css(
									elem,
									"padding" + cssExpand[i],
									true,
									styles,
								)

								// For "border" or "margin", add border
								if (box !== "padding") {
									delta += jQuery.css(
										elem,
										"border" + cssExpand[i] + "Width",
										true,
										styles,
									)

									// But still keep track of it otherwise
								} else {
									extra += jQuery.css(
										elem,
										"border" + cssExpand[i] + "Width",
										true,
										styles,
									)
								}

								// If we get here with a border-box (content + padding + border), we're seeking "content" or
								// "padding" or "margin"
							} else {
								// For "content", subtract padding
								if (box === "content") {
									delta -= jQuery.css(
										elem,
										"padding" + cssExpand[i],
										true,
										styles,
									)
								}

								// For "content" or "padding", subtract border
								if (box !== "margin") {
									delta -= jQuery.css(
										elem,
										"border" + cssExpand[i] + "Width",
										true,
										styles,
									)
								}
							}
						}

						// Account for positive content-box scroll gutter when requested by providing computedVal
						if (!isBorderBox && computedVal >= 0) {
							// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
							// Assuming integer scroll gutter, subtract the rest and round down
							delta +=
								Math.max(
									0,
									Math.ceil(
										elem[
											"offset" + dimension[0].toUpperCase() + dimension.slice(1)
										] -
											computedVal -
											delta -
											extra -
											0.5,

										// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
										// Use an explicit zero to avoid NaN (gh-3964)
									),
								) || 0
						}

						return delta
					}

					function getWidthOrHeight(elem, dimension, extra) {
						// Start with computed style
						var styles = getStyles(elem),
							// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
							// Fake content-box until we know it's needed to know the true value.
							boxSizingNeeded = !support.boxSizingReliable() || extra,
							isBorderBox =
								boxSizingNeeded &&
								jQuery.css(elem, "boxSizing", false, styles) === "border-box",
							valueIsBorderBox = isBorderBox,
							val = curCSS(elem, dimension, styles),
							offsetProp =
								"offset" + dimension[0].toUpperCase() + dimension.slice(1)

						// Support: Firefox <=54
						// Return a confounding non-pixel value or feign ignorance, as appropriate.
						if (rnumnonpx.test(val)) {
							if (!extra) {
								return val
							}
							val = "auto"
						}

						// Support: IE 9 - 11 only
						// Use offsetWidth/offsetHeight for when box sizing is unreliable.
						// In those cases, the computed value can be trusted to be border-box.
						if (
							((!support.boxSizingReliable() && isBorderBox) ||
								// Support: IE 10 - 11+, Edge 15 - 18+
								// IE/Edge misreport `getComputedStyle` of table rows with width/height
								// set in CSS while `offset*` properties report correct values.
								// Interestingly, in some cases IE 9 doesn't suffer from this issue.
								(!support.reliableTrDimensions() && nodeName(elem, "tr")) ||
								// Fall back to offsetWidth/offsetHeight when value is "auto"
								// This happens for inline elements with no explicit setting (gh-3571)
								val === "auto" ||
								// Support: Android <=4.1 - 4.3 only
								// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
								(!parseFloat(val) &&
									jQuery.css(elem, "display", false, styles) === "inline")) &&
							// Make sure the element is visible & connected
							elem.getClientRects().length
						) {
							isBorderBox =
								jQuery.css(elem, "boxSizing", false, styles) === "border-box"

							// Where available, offsetWidth/offsetHeight approximate border box dimensions.
							// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
							// retrieved value as a content box dimension.
							valueIsBorderBox = offsetProp in elem
							if (valueIsBorderBox) {
								val = elem[offsetProp]
							}
						}

						// Normalize "" and auto
						val = parseFloat(val) || 0

						// Adjust for the element's box model
						return (
							val +
							boxModelAdjustment(
								elem,
								dimension,
								extra || (isBorderBox ? "border" : "content"),
								valueIsBorderBox,
								styles,

								// Provide the current computed size to request scroll gutter calculation (gh-3589)
								val,
							) +
							"px"
						)
					}

					jQuery.extend({
						// Add in style property hooks for overriding the default
						// behavior of getting and setting a style property
						cssHooks: {
							opacity: {
								get: function (elem, computed) {
									if (computed) {
										// We should always get a number back from opacity
										var ret = curCSS(elem, "opacity")
										return ret === "" ? "1" : ret
									}
								},
							},
						},

						// Don't automatically add "px" to these possibly-unitless properties
						cssNumber: {
							animationIterationCount: true,
							columnCount: true,
							fillOpacity: true,
							flexGrow: true,
							flexShrink: true,
							fontWeight: true,
							gridArea: true,
							gridColumn: true,
							gridColumnEnd: true,
							gridColumnStart: true,
							gridRow: true,
							gridRowEnd: true,
							gridRowStart: true,
							lineHeight: true,
							opacity: true,
							order: true,
							orphans: true,
							widows: true,
							zIndex: true,
							zoom: true,
						},

						// Add in properties whose names you wish to fix before
						// setting or getting the value
						cssProps: {},

						// Get and set the style property on a DOM Node
						style: function (elem, name, value, extra) {
							// Don't set styles on text and comment nodes
							if (
								!elem ||
								elem.nodeType === 3 ||
								elem.nodeType === 8 ||
								!elem.style
							) {
								return
							}

							// Make sure that we're working with the right name
							var ret,
								type,
								hooks,
								origName = camelCase(name),
								isCustomProp = rcustomProp.test(name),
								style = elem.style

							// Make sure that we're working with the right name. We don't
							// want to query the value if it is a CSS custom property
							// since they are user-defined.
							if (!isCustomProp) {
								name = finalPropName(origName)
							}

							// Gets hook for the prefixed version, then unprefixed version
							hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]

							// Check if we're setting a value
							if (value !== undefined) {
								type = typeof value

								// Convert "+=" or "-=" to relative numbers (#7345)
								if (
									type === "string" &&
									(ret = rcssNum.exec(value)) &&
									ret[1]
								) {
									value = adjustCSS(elem, name, ret)

									// Fixes bug #9237
									type = "number"
								}

								// Make sure that null and NaN values aren't set (#7116)
								if (value == null || value !== value) {
									return
								}

								// If a number was passed in, add the unit (except for certain CSS properties)
								// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
								// "px" to a few hardcoded values.
								if (type === "number" && !isCustomProp) {
									value +=
										(ret && ret[3]) || (jQuery.cssNumber[origName] ? "" : "px")
								}

								// background-* props affect original clone's values
								if (
									!support.clearCloneStyle &&
									value === "" &&
									name.indexOf("background") === 0
								) {
									style[name] = "inherit"
								}

								// If a hook was provided, use that value, otherwise just set the specified value
								if (
									!hooks ||
									!("set" in hooks) ||
									(value = hooks.set(elem, value, extra)) !== undefined
								) {
									if (isCustomProp) {
										style.setProperty(name, value)
									} else {
										style[name] = value
									}
								}
							} else {
								// If a hook was provided get the non-computed value from there
								if (
									hooks &&
									"get" in hooks &&
									(ret = hooks.get(elem, false, extra)) !== undefined
								) {
									return ret
								}

								// Otherwise just get the value from the style object
								return style[name]
							}
						},

						css: function (elem, name, extra, styles) {
							var val,
								num,
								hooks,
								origName = camelCase(name),
								isCustomProp = rcustomProp.test(name)

							// Make sure that we're working with the right name. We don't
							// want to modify the value if it is a CSS custom property
							// since they are user-defined.
							if (!isCustomProp) {
								name = finalPropName(origName)
							}

							// Try prefixed name followed by the unprefixed name
							hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]

							// If a hook was provided get the computed value from there
							if (hooks && "get" in hooks) {
								val = hooks.get(elem, true, extra)
							}

							// Otherwise, if a way to get the computed value exists, use that
							if (val === undefined) {
								val = curCSS(elem, name, styles)
							}

							// Convert "normal" to computed value
							if (val === "normal" && name in cssNormalTransform) {
								val = cssNormalTransform[name]
							}

							// Make numeric if forced or a qualifier was provided and val looks numeric
							if (extra === "" || extra) {
								num = parseFloat(val)
								return extra === true || isFinite(num) ? num || 0 : val
							}

							return val
						},
					})

					jQuery.each(["height", "width"], function (_i, dimension) {
						jQuery.cssHooks[dimension] = {
							get: function (elem, computed, extra) {
								if (computed) {
									// Certain elements can have dimension info if we invisibly show them
									// but it must have a current display style that would benefit
									return rdisplayswap.test(jQuery.css(elem, "display")) &&
										// Support: Safari 8+
										// Table columns in Safari have non-zero offsetWidth & zero
										// getBoundingClientRect().width unless display is changed.
										// Support: IE <=11 only
										// Running getBoundingClientRect on a disconnected node
										// in IE throws an error.
										(!elem.getClientRects().length ||
											!elem.getBoundingClientRect().width)
										? swap(elem, cssShow, function () {
												return getWidthOrHeight(elem, dimension, extra)
										  })
										: getWidthOrHeight(elem, dimension, extra)
								}
							},

							set: function (elem, value, extra) {
								var matches,
									styles = getStyles(elem),
									// Only read styles.position if the test has a chance to fail
									// to avoid forcing a reflow.
									scrollboxSizeBuggy =
										!support.scrollboxSize() && styles.position === "absolute",
									// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
									boxSizingNeeded = scrollboxSizeBuggy || extra,
									isBorderBox =
										boxSizingNeeded &&
										jQuery.css(elem, "boxSizing", false, styles) ===
											"border-box",
									subtract = extra
										? boxModelAdjustment(
												elem,
												dimension,
												extra,
												isBorderBox,
												styles,
										  )
										: 0

								// Account for unreliable border-box dimensions by comparing offset* to computed and
								// faking a content-box to get border and padding (gh-3699)
								if (isBorderBox && scrollboxSizeBuggy) {
									subtract -= Math.ceil(
										elem[
											"offset" + dimension[0].toUpperCase() + dimension.slice(1)
										] -
											parseFloat(styles[dimension]) -
											boxModelAdjustment(
												elem,
												dimension,
												"border",
												false,
												styles,
											) -
											0.5,
									)
								}

								// Convert to pixels if value adjustment is needed
								if (
									subtract &&
									(matches = rcssNum.exec(value)) &&
									(matches[3] || "px") !== "px"
								) {
									elem.style[dimension] = value
									value = jQuery.css(elem, dimension)
								}

								return setPositiveNumber(elem, value, subtract)
							},
						}
					})

					jQuery.cssHooks.marginLeft = addGetHookIf(
						support.reliableMarginLeft,
						function (elem, computed) {
							if (computed) {
								return (
									(parseFloat(curCSS(elem, "marginLeft")) ||
										elem.getBoundingClientRect().left -
											swap(elem, { marginLeft: 0 }, function () {
												return elem.getBoundingClientRect().left
											})) + "px"
								)
							}
						},
					)

					// These hooks are used by animate to expand properties
					jQuery.each(
						{
							margin: "",
							padding: "",
							border: "Width",
						},
						function (prefix, suffix) {
							jQuery.cssHooks[prefix + suffix] = {
								expand: function (value) {
									var i = 0,
										expanded = {},
										// Assumes a single number if not a string
										parts =
											typeof value === "string" ? value.split(" ") : [value]

									for (; i < 4; i++) {
										expanded[prefix + cssExpand[i] + suffix] =
											parts[i] || parts[i - 2] || parts[0]
									}

									return expanded
								},
							}

							if (prefix !== "margin") {
								jQuery.cssHooks[prefix + suffix].set = setPositiveNumber
							}
						},
					)

					jQuery.fn.extend({
						css: function (name, value) {
							return access(
								this,
								function (elem, name, value) {
									var styles,
										len,
										map = {},
										i = 0

									if (Array.isArray(name)) {
										styles = getStyles(elem)
										len = name.length

										for (; i < len; i++) {
											map[name[i]] = jQuery.css(elem, name[i], false, styles)
										}

										return map
									}

									return value !== undefined
										? jQuery.style(elem, name, value)
										: jQuery.css(elem, name)
								},
								name,
								value,
								arguments.length > 1,
							)
						},
					})

					function Tween(elem, options, prop, end, easing) {
						return new Tween.prototype.init(elem, options, prop, end, easing)
					}
					jQuery.Tween = Tween

					Tween.prototype = {
						constructor: Tween,
						init: function (elem, options, prop, end, easing, unit) {
							this.elem = elem
							this.prop = prop
							this.easing = easing || jQuery.easing._default
							this.options = options
							this.start = this.now = this.cur()
							this.end = end
							this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
						},
						cur: function () {
							var hooks = Tween.propHooks[this.prop]

							return hooks && hooks.get
								? hooks.get(this)
								: Tween.propHooks._default.get(this)
						},
						run: function (percent) {
							var eased,
								hooks = Tween.propHooks[this.prop]

							if (this.options.duration) {
								this.pos = eased = jQuery.easing[this.easing](
									percent,
									this.options.duration * percent,
									0,
									1,
									this.options.duration,
								)
							} else {
								this.pos = eased = percent
							}
							this.now = (this.end - this.start) * eased + this.start

							if (this.options.step) {
								this.options.step.call(this.elem, this.now, this)
							}

							if (hooks && hooks.set) {
								hooks.set(this)
							} else {
								Tween.propHooks._default.set(this)
							}
							return this
						},
					}

					Tween.prototype.init.prototype = Tween.prototype

					Tween.propHooks = {
						_default: {
							get: function (tween) {
								var result

								// Use a property on the element directly when it is not a DOM element,
								// or when there is no matching style property that exists.
								if (
									tween.elem.nodeType !== 1 ||
									(tween.elem[tween.prop] != null &&
										tween.elem.style[tween.prop] == null)
								) {
									return tween.elem[tween.prop]
								}

								// Passing an empty string as a 3rd parameter to .css will automatically
								// attempt a parseFloat and fallback to a string if the parse fails.
								// Simple values such as "10px" are parsed to Float;
								// complex values such as "rotate(1rad)" are returned as-is.
								result = jQuery.css(tween.elem, tween.prop, "")

								// Empty strings, null, undefined and "auto" are converted to 0.
								return !result || result === "auto" ? 0 : result
							},
							set: function (tween) {
								// Use step hook for back compat.
								// Use cssHook if its there.
								// Use .style if available and use plain properties where available.
								if (jQuery.fx.step[tween.prop]) {
									jQuery.fx.step[tween.prop](tween)
								} else if (
									tween.elem.nodeType === 1 &&
									(jQuery.cssHooks[tween.prop] ||
										tween.elem.style[finalPropName(tween.prop)] != null)
								) {
									jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
								} else {
									tween.elem[tween.prop] = tween.now
								}
							},
						},
					}

					// Support: IE <=9 only
					// Panic based approach to setting things on disconnected nodes
					Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
						set: function (tween) {
							if (tween.elem.nodeType && tween.elem.parentNode) {
								tween.elem[tween.prop] = tween.now
							}
						},
					}

					jQuery.easing = {
						linear: function (p) {
							return p
						},
						swing: function (p) {
							return 0.5 - Math.cos(p * Math.PI) / 2
						},
						_default: "swing",
					}

					jQuery.fx = Tween.prototype.init

					// Back compat <1.8 extension point
					jQuery.fx.step = {}

					var fxNow,
						inProgress,
						rfxtypes = /^(?:toggle|show|hide)$/,
						rrun = /queueHooks$/

					function schedule() {
						if (inProgress) {
							if (document.hidden === false && window.requestAnimationFrame) {
								window.requestAnimationFrame(schedule)
							} else {
								window.setTimeout(schedule, jQuery.fx.interval)
							}

							jQuery.fx.tick()
						}
					}

					// Animations created synchronously will run synchronously
					function createFxNow() {
						window.setTimeout(function () {
							fxNow = undefined
						})
						return (fxNow = Date.now())
					}

					// Generate parameters to create a standard animation
					function genFx(type, includeWidth) {
						var which,
							i = 0,
							attrs = { height: type }

						// If we include width, step value is 1 to do all cssExpand values,
						// otherwise step value is 2 to skip over Left and Right
						includeWidth = includeWidth ? 1 : 0
						for (; i < 4; i += 2 - includeWidth) {
							which = cssExpand[i]
							attrs["margin" + which] = attrs["padding" + which] = type
						}

						if (includeWidth) {
							attrs.opacity = attrs.width = type
						}

						return attrs
					}

					function createTween(value, prop, animation) {
						var tween,
							collection = (Animation.tweeners[prop] || []).concat(
								Animation.tweeners["*"],
							),
							index = 0,
							length = collection.length
						for (; index < length; index++) {
							if ((tween = collection[index].call(animation, prop, value))) {
								// We're done with this property
								return tween
							}
						}
					}

					function defaultPrefilter(elem, props, opts) {
						var prop,
							value,
							toggle,
							hooks,
							oldfire,
							propTween,
							restoreDisplay,
							display,
							isBox = "width" in props || "height" in props,
							anim = this,
							orig = {},
							style = elem.style,
							hidden = elem.nodeType && isHiddenWithinTree(elem),
							dataShow = dataPriv.get(elem, "fxshow")

						// Queue-skipping animations hijack the fx hooks
						if (!opts.queue) {
							hooks = jQuery._queueHooks(elem, "fx")
							if (hooks.unqueued == null) {
								hooks.unqueued = 0
								oldfire = hooks.empty.fire
								hooks.empty.fire = function () {
									if (!hooks.unqueued) {
										oldfire()
									}
								}
							}
							hooks.unqueued++

							anim.always(function () {
								// Ensure the complete handler is called before this completes
								anim.always(function () {
									hooks.unqueued--
									if (!jQuery.queue(elem, "fx").length) {
										hooks.empty.fire()
									}
								})
							})
						}

						// Detect show/hide animations
						for (prop in props) {
							value = props[prop]
							if (rfxtypes.test(value)) {
								delete props[prop]
								toggle = toggle || value === "toggle"
								if (value === (hidden ? "hide" : "show")) {
									// Pretend to be hidden if this is a "show" and
									// there is still data from a stopped show/hide
									if (
										value === "show" &&
										dataShow &&
										dataShow[prop] !== undefined
									) {
										hidden = true

										// Ignore all other no-op show/hide data
									} else {
										continue
									}
								}
								orig[prop] =
									(dataShow && dataShow[prop]) || jQuery.style(elem, prop)
							}
						}

						// Bail out if this is a no-op like .hide().hide()
						propTween = !jQuery.isEmptyObject(props)
						if (!propTween && jQuery.isEmptyObject(orig)) {
							return
						}

						// Restrict "overflow" and "display" styles during box animations
						if (isBox && elem.nodeType === 1) {
							// Support: IE <=9 - 11, Edge 12 - 15
							// Record all 3 overflow attributes because IE does not infer the shorthand
							// from identically-valued overflowX and overflowY and Edge just mirrors
							// the overflowX value there.
							opts.overflow = [style.overflow, style.overflowX, style.overflowY]

							// Identify a display type, preferring old show/hide data over the CSS cascade
							restoreDisplay = dataShow && dataShow.display
							if (restoreDisplay == null) {
								restoreDisplay = dataPriv.get(elem, "display")
							}
							display = jQuery.css(elem, "display")
							if (display === "none") {
								if (restoreDisplay) {
									display = restoreDisplay
								} else {
									// Get nonempty value(s) by temporarily forcing visibility
									showHide([elem], true)
									restoreDisplay = elem.style.display || restoreDisplay
									display = jQuery.css(elem, "display")
									showHide([elem])
								}
							}

							// Animate inline elements as inline-block
							if (
								display === "inline" ||
								(display === "inline-block" && restoreDisplay != null)
							) {
								if (jQuery.css(elem, "float") === "none") {
									// Restore the original display value at the end of pure show/hide animations
									if (!propTween) {
										anim.done(function () {
											style.display = restoreDisplay
										})
										if (restoreDisplay == null) {
											display = style.display
											restoreDisplay = display === "none" ? "" : display
										}
									}
									style.display = "inline-block"
								}
							}
						}

						if (opts.overflow) {
							style.overflow = "hidden"
							anim.always(function () {
								style.overflow = opts.overflow[0]
								style.overflowX = opts.overflow[1]
								style.overflowY = opts.overflow[2]
							})
						}

						// Implement show/hide animations
						propTween = false
						for (prop in orig) {
							// General show/hide setup for this element animation
							if (!propTween) {
								if (dataShow) {
									if ("hidden" in dataShow) {
										hidden = dataShow.hidden
									}
								} else {
									dataShow = dataPriv.access(elem, "fxshow", {
										display: restoreDisplay,
									})
								}

								// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
								if (toggle) {
									dataShow.hidden = !hidden
								}

								// Show elements before animating them
								if (hidden) {
									showHide([elem], true)
								}

								/* eslint-disable no-loop-func */

								anim.done(function () {
									/* eslint-enable no-loop-func */

									// The final step of a "hide" animation is actually hiding the element
									if (!hidden) {
										showHide([elem])
									}
									dataPriv.remove(elem, "fxshow")
									for (prop in orig) {
										jQuery.style(elem, prop, orig[prop])
									}
								})
							}

							// Per-property setup
							propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim)
							if (!(prop in dataShow)) {
								dataShow[prop] = propTween.start
								if (hidden) {
									propTween.end = propTween.start
									propTween.start = 0
								}
							}
						}
					}

					function propFilter(props, specialEasing) {
						var index, name, easing, value, hooks

						// camelCase, specialEasing and expand cssHook pass
						for (index in props) {
							name = camelCase(index)
							easing = specialEasing[name]
							value = props[index]
							if (Array.isArray(value)) {
								easing = value[1]
								value = props[index] = value[0]
							}

							if (index !== name) {
								props[name] = value
								delete props[index]
							}

							hooks = jQuery.cssHooks[name]
							if (hooks && "expand" in hooks) {
								value = hooks.expand(value)
								delete props[name]

								// Not quite $.extend, this won't overwrite existing keys.
								// Reusing 'index' because we have the correct "name"
								for (index in value) {
									if (!(index in props)) {
										props[index] = value[index]
										specialEasing[index] = easing
									}
								}
							} else {
								specialEasing[name] = easing
							}
						}
					}

					function Animation(elem, properties, options) {
						var result,
							stopped,
							index = 0,
							length = Animation.prefilters.length,
							deferred = jQuery.Deferred().always(function () {
								// Don't match elem in the :animated selector
								delete tick.elem
							}),
							tick = function () {
								if (stopped) {
									return false
								}
								var currentTime = fxNow || createFxNow(),
									remaining = Math.max(
										0,
										animation.startTime + animation.duration - currentTime,
									),
									// Support: Android 2.3 only
									// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
									temp = remaining / animation.duration || 0,
									percent = 1 - temp,
									index = 0,
									length = animation.tweens.length

								for (; index < length; index++) {
									animation.tweens[index].run(percent)
								}

								deferred.notifyWith(elem, [animation, percent, remaining])

								// If there's more to do, yield
								if (percent < 1 && length) {
									return remaining
								}

								// If this was an empty animation, synthesize a final progress notification
								if (!length) {
									deferred.notifyWith(elem, [animation, 1, 0])
								}

								// Resolve the animation and report its conclusion
								deferred.resolveWith(elem, [animation])
								return false
							},
							animation = deferred.promise({
								elem: elem,
								props: jQuery.extend({}, properties),
								opts: jQuery.extend(
									true,
									{
										specialEasing: {},
										easing: jQuery.easing._default,
									},
									options,
								),
								originalProperties: properties,
								originalOptions: options,
								startTime: fxNow || createFxNow(),
								duration: options.duration,
								tweens: [],
								createTween: function (prop, end) {
									var tween = jQuery.Tween(
										elem,
										animation.opts,
										prop,
										end,
										animation.opts.specialEasing[prop] || animation.opts.easing,
									)
									animation.tweens.push(tween)
									return tween
								},
								stop: function (gotoEnd) {
									var index = 0,
										// If we are going to the end, we want to run all the tweens
										// otherwise we skip this part
										length = gotoEnd ? animation.tweens.length : 0
									if (stopped) {
										return this
									}
									stopped = true
									for (; index < length; index++) {
										animation.tweens[index].run(1)
									}

									// Resolve when we played the last frame; otherwise, reject
									if (gotoEnd) {
										deferred.notifyWith(elem, [animation, 1, 0])
										deferred.resolveWith(elem, [animation, gotoEnd])
									} else {
										deferred.rejectWith(elem, [animation, gotoEnd])
									}
									return this
								},
							}),
							props = animation.props

						propFilter(props, animation.opts.specialEasing)

						for (; index < length; index++) {
							result = Animation.prefilters[index].call(
								animation,
								elem,
								props,
								animation.opts,
							)
							if (result) {
								if (isFunction(result.stop)) {
									jQuery._queueHooks(
										animation.elem,
										animation.opts.queue,
									).stop = result.stop.bind(result)
								}
								return result
							}
						}

						jQuery.map(props, createTween, animation)

						if (isFunction(animation.opts.start)) {
							animation.opts.start.call(elem, animation)
						}

						// Attach callbacks from options
						animation
							.progress(animation.opts.progress)
							.done(animation.opts.done, animation.opts.complete)
							.fail(animation.opts.fail)
							.always(animation.opts.always)

						jQuery.fx.timer(
							jQuery.extend(tick, {
								elem: elem,
								anim: animation,
								queue: animation.opts.queue,
							}),
						)

						return animation
					}

					jQuery.Animation = jQuery.extend(Animation, {
						tweeners: {
							"*": [
								function (prop, value) {
									var tween = this.createTween(prop, value)
									adjustCSS(tween.elem, prop, rcssNum.exec(value), tween)
									return tween
								},
							],
						},

						tweener: function (props, callback) {
							if (isFunction(props)) {
								callback = props
								props = ["*"]
							} else {
								props = props.match(rnothtmlwhite)
							}

							var prop,
								index = 0,
								length = props.length

							for (; index < length; index++) {
								prop = props[index]
								Animation.tweeners[prop] = Animation.tweeners[prop] || []
								Animation.tweeners[prop].unshift(callback)
							}
						},

						prefilters: [defaultPrefilter],

						prefilter: function (callback, prepend) {
							if (prepend) {
								Animation.prefilters.unshift(callback)
							} else {
								Animation.prefilters.push(callback)
							}
						},
					})

					jQuery.speed = function (speed, easing, fn) {
						var opt =
							speed && typeof speed === "object"
								? jQuery.extend({}, speed)
								: {
										complete:
											fn || (!fn && easing) || (isFunction(speed) && speed),
										duration: speed,
										easing:
											(fn && easing) ||
											(easing && !isFunction(easing) && easing),
								  }

						// Go to the end state if fx are off
						if (jQuery.fx.off) {
							opt.duration = 0
						} else {
							if (typeof opt.duration !== "number") {
								if (opt.duration in jQuery.fx.speeds) {
									opt.duration = jQuery.fx.speeds[opt.duration]
								} else {
									opt.duration = jQuery.fx.speeds._default
								}
							}
						}

						// Normalize opt.queue - true/undefined/null -> "fx"
						if (opt.queue == null || opt.queue === true) {
							opt.queue = "fx"
						}

						// Queueing
						opt.old = opt.complete

						opt.complete = function () {
							if (isFunction(opt.old)) {
								opt.old.call(this)
							}

							if (opt.queue) {
								jQuery.dequeue(this, opt.queue)
							}
						}

						return opt
					}

					jQuery.fn.extend({
						fadeTo: function (speed, to, easing, callback) {
							// Show any hidden elements after setting opacity to 0
							return (
								this.filter(isHiddenWithinTree)
									.css("opacity", 0)
									.show()

									// Animate to the value specified
									.end()
									.animate({ opacity: to }, speed, easing, callback)
							)
						},
						animate: function (prop, speed, easing, callback) {
							var empty = jQuery.isEmptyObject(prop),
								optall = jQuery.speed(speed, easing, callback),
								doAnimation = function () {
									// Operate on a copy of prop so per-property easing won't be lost
									var anim = Animation(this, jQuery.extend({}, prop), optall)

									// Empty animations, or finishing resolves immediately
									if (empty || dataPriv.get(this, "finish")) {
										anim.stop(true)
									}
								}
							doAnimation.finish = doAnimation

							return empty || optall.queue === false
								? this.each(doAnimation)
								: this.queue(optall.queue, doAnimation)
						},
						stop: function (type, clearQueue, gotoEnd) {
							var stopQueue = function (hooks) {
								var stop = hooks.stop
								delete hooks.stop
								stop(gotoEnd)
							}

							if (typeof type !== "string") {
								gotoEnd = clearQueue
								clearQueue = type
								type = undefined
							}
							if (clearQueue) {
								this.queue(type || "fx", [])
							}

							return this.each(function () {
								var dequeue = true,
									index = type != null && type + "queueHooks",
									timers = jQuery.timers,
									data = dataPriv.get(this)

								if (index) {
									if (data[index] && data[index].stop) {
										stopQueue(data[index])
									}
								} else {
									for (index in data) {
										if (data[index] && data[index].stop && rrun.test(index)) {
											stopQueue(data[index])
										}
									}
								}

								for (index = timers.length; index--; ) {
									if (
										timers[index].elem === this &&
										(type == null || timers[index].queue === type)
									) {
										timers[index].anim.stop(gotoEnd)
										dequeue = false
										timers.splice(index, 1)
									}
								}

								// Start the next in the queue if the last step wasn't forced.
								// Timers currently will call their complete callbacks, which
								// will dequeue but only if they were gotoEnd.
								if (dequeue || !gotoEnd) {
									jQuery.dequeue(this, type)
								}
							})
						},
						finish: function (type) {
							if (type !== false) {
								type = type || "fx"
							}
							return this.each(function () {
								var index,
									data = dataPriv.get(this),
									queue = data[type + "queue"],
									hooks = data[type + "queueHooks"],
									timers = jQuery.timers,
									length = queue ? queue.length : 0

								// Enable finishing flag on private data
								data.finish = true

								// Empty the queue first
								jQuery.queue(this, type, [])

								if (hooks && hooks.stop) {
									hooks.stop.call(this, true)
								}

								// Look for any active animations, and finish them
								for (index = timers.length; index--; ) {
									if (
										timers[index].elem === this &&
										timers[index].queue === type
									) {
										timers[index].anim.stop(true)
										timers.splice(index, 1)
									}
								}

								// Look for any animations in the old queue and finish them
								for (index = 0; index < length; index++) {
									if (queue[index] && queue[index].finish) {
										queue[index].finish.call(this)
									}
								}

								// Turn off finishing flag
								delete data.finish
							})
						},
					})

					jQuery.each(["toggle", "show", "hide"], function (_i, name) {
						var cssFn = jQuery.fn[name]
						jQuery.fn[name] = function (speed, easing, callback) {
							return speed == null || typeof speed === "boolean"
								? cssFn.apply(this, arguments)
								: this.animate(genFx(name, true), speed, easing, callback)
						}
					})

					// Generate shortcuts for custom animations
					jQuery.each(
						{
							slideDown: genFx("show"),
							slideUp: genFx("hide"),
							slideToggle: genFx("toggle"),
							fadeIn: { opacity: "show" },
							fadeOut: { opacity: "hide" },
							fadeToggle: { opacity: "toggle" },
						},
						function (name, props) {
							jQuery.fn[name] = function (speed, easing, callback) {
								return this.animate(props, speed, easing, callback)
							}
						},
					)

					jQuery.timers = []
					jQuery.fx.tick = function () {
						var timer,
							i = 0,
							timers = jQuery.timers

						fxNow = Date.now()

						for (; i < timers.length; i++) {
							timer = timers[i]

							// Run the timer and safely remove it when done (allowing for external removal)
							if (!timer() && timers[i] === timer) {
								timers.splice(i--, 1)
							}
						}

						if (!timers.length) {
							jQuery.fx.stop()
						}
						fxNow = undefined
					}

					jQuery.fx.timer = function (timer) {
						jQuery.timers.push(timer)
						jQuery.fx.start()
					}

					jQuery.fx.interval = 13
					jQuery.fx.start = function () {
						if (inProgress) {
							return
						}

						inProgress = true
						schedule()
					}

					jQuery.fx.stop = function () {
						inProgress = null
					}

					jQuery.fx.speeds = {
						slow: 600,
						fast: 200,

						// Default speed
						_default: 400,
					}

					// Based off of the plugin by Clint Helfers, with permission.
					// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
					jQuery.fn.delay = function (time, type) {
						time = jQuery.fx ? jQuery.fx.speeds[time] || time : time
						type = type || "fx"

						return this.queue(type, function (next, hooks) {
							var timeout = window.setTimeout(next, time)
							hooks.stop = function () {
								window.clearTimeout(timeout)
							}
						})
					}

					;(function () {
						var input = document.createElement("input"),
							select = document.createElement("select"),
							opt = select.appendChild(document.createElement("option"))

						input.type = "checkbox"

						// Support: Android <=4.3 only
						// Default value for a checkbox should be "on"
						support.checkOn = input.value !== ""

						// Support: IE <=11 only
						// Must access selectedIndex to make default options select
						support.optSelected = opt.selected

						// Support: IE <=11 only
						// An input loses its value after becoming a radio
						input = document.createElement("input")
						input.value = "t"
						input.type = "radio"
						support.radioValue = input.value === "t"
					})()

					var boolHook,
						attrHandle = jQuery.expr.attrHandle

					jQuery.fn.extend({
						attr: function (name, value) {
							return access(
								this,
								jQuery.attr,
								name,
								value,
								arguments.length > 1,
							)
						},

						removeAttr: function (name) {
							return this.each(function () {
								jQuery.removeAttr(this, name)
							})
						},
					})

					jQuery.extend({
						attr: function (elem, name, value) {
							var ret,
								hooks,
								nType = elem.nodeType

							// Don't get/set attributes on text, comment and attribute nodes
							if (nType === 3 || nType === 8 || nType === 2) {
								return
							}

							// Fallback to prop when attributes are not supported
							if (typeof elem.getAttribute === "undefined") {
								return jQuery.prop(elem, name, value)
							}

							// Attribute hooks are determined by the lowercase version
							// Grab necessary hook if one is defined
							if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
								hooks =
									jQuery.attrHooks[name.toLowerCase()] ||
									(jQuery.expr.match.bool.test(name) ? boolHook : undefined)
							}

							if (value !== undefined) {
								if (value === null) {
									jQuery.removeAttr(elem, name)
									return
								}

								if (
									hooks &&
									"set" in hooks &&
									(ret = hooks.set(elem, value, name)) !== undefined
								) {
									return ret
								}

								elem.setAttribute(name, value + "")
								return value
							}

							if (
								hooks &&
								"get" in hooks &&
								(ret = hooks.get(elem, name)) !== null
							) {
								return ret
							}

							ret = jQuery.find.attr(elem, name)

							// Non-existent attributes return null, we normalize to undefined
							return ret == null ? undefined : ret
						},

						attrHooks: {
							type: {
								set: function (elem, value) {
									if (
										!support.radioValue &&
										value === "radio" &&
										nodeName(elem, "input")
									) {
										var val = elem.value
										elem.setAttribute("type", value)
										if (val) {
											elem.value = val
										}
										return value
									}
								},
							},
						},

						removeAttr: function (elem, value) {
							var name,
								i = 0,
								// Attribute names can contain non-HTML whitespace characters
								// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
								attrNames = value && value.match(rnothtmlwhite)

							if (attrNames && elem.nodeType === 1) {
								while ((name = attrNames[i++])) {
									elem.removeAttribute(name)
								}
							}
						},
					})

					// Hooks for boolean attributes
					boolHook = {
						set: function (elem, value, name) {
							if (value === false) {
								// Remove boolean attributes when set to false
								jQuery.removeAttr(elem, name)
							} else {
								elem.setAttribute(name, name)
							}
							return name
						},
					}

					jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (
						_i,
						name,
					) {
						var getter = attrHandle[name] || jQuery.find.attr

						attrHandle[name] = function (elem, name, isXML) {
							var ret,
								handle,
								lowercaseName = name.toLowerCase()

							if (!isXML) {
								// Avoid an infinite loop by temporarily removing this function from the getter
								handle = attrHandle[lowercaseName]
								attrHandle[lowercaseName] = ret
								ret = getter(elem, name, isXML) != null ? lowercaseName : null
								attrHandle[lowercaseName] = handle
							}
							return ret
						}
					})

					var rfocusable = /^(?:input|select|textarea|button)$/i,
						rclickable = /^(?:a|area)$/i

					jQuery.fn.extend({
						prop: function (name, value) {
							return access(
								this,
								jQuery.prop,
								name,
								value,
								arguments.length > 1,
							)
						},

						removeProp: function (name) {
							return this.each(function () {
								delete this[jQuery.propFix[name] || name]
							})
						},
					})

					jQuery.extend({
						prop: function (elem, name, value) {
							var ret,
								hooks,
								nType = elem.nodeType

							// Don't get/set properties on text, comment and attribute nodes
							if (nType === 3 || nType === 8 || nType === 2) {
								return
							}

							if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
								// Fix name and attach hooks
								name = jQuery.propFix[name] || name
								hooks = jQuery.propHooks[name]
							}

							if (value !== undefined) {
								if (
									hooks &&
									"set" in hooks &&
									(ret = hooks.set(elem, value, name)) !== undefined
								) {
									return ret
								}

								return (elem[name] = value)
							}

							if (
								hooks &&
								"get" in hooks &&
								(ret = hooks.get(elem, name)) !== null
							) {
								return ret
							}

							return elem[name]
						},

						propHooks: {
							tabIndex: {
								get: function (elem) {
									// Support: IE <=9 - 11 only
									// elem.tabIndex doesn't always return the
									// correct value when it hasn't been explicitly set
									// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
									// Use proper attribute retrieval(#12072)
									var tabindex = jQuery.find.attr(elem, "tabindex")

									if (tabindex) {
										return parseInt(tabindex, 10)
									}

									if (
										rfocusable.test(elem.nodeName) ||
										(rclickable.test(elem.nodeName) && elem.href)
									) {
										return 0
									}

									return -1
								},
							},
						},

						propFix: {
							for: "htmlFor",
							class: "className",
						},
					})

					// Support: IE <=11 only
					// Accessing the selectedIndex property
					// forces the browser to respect setting selected
					// on the option
					// The getter ensures a default option is selected
					// when in an optgroup
					// eslint rule "no-unused-expressions" is disabled for this code
					// since it considers such accessions noop
					if (!support.optSelected) {
						jQuery.propHooks.selected = {
							get: function (elem) {
								/* eslint no-unused-expressions: "off" */

								var parent = elem.parentNode
								if (parent && parent.parentNode) {
									parent.parentNode.selectedIndex
								}
								return null
							},
							set: function (elem) {
								/* eslint no-unused-expressions: "off" */

								var parent = elem.parentNode
								if (parent) {
									parent.selectedIndex

									if (parent.parentNode) {
										parent.parentNode.selectedIndex
									}
								}
							},
						}
					}

					jQuery.each(
						[
							"tabIndex",
							"readOnly",
							"maxLength",
							"cellSpacing",
							"cellPadding",
							"rowSpan",
							"colSpan",
							"useMap",
							"frameBorder",
							"contentEditable",
						],
						function () {
							jQuery.propFix[this.toLowerCase()] = this
						},
					)

					// Strip and collapse whitespace according to HTML spec
					// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
					function stripAndCollapse(value) {
						var tokens = value.match(rnothtmlwhite) || []
						return tokens.join(" ")
					}

					function getClass(elem) {
						return (elem.getAttribute && elem.getAttribute("class")) || ""
					}

					function classesToArray(value) {
						if (Array.isArray(value)) {
							return value
						}
						if (typeof value === "string") {
							return value.match(rnothtmlwhite) || []
						}
						return []
					}

					jQuery.fn.extend({
						addClass: function (value) {
							var classes,
								elem,
								cur,
								curValue,
								clazz,
								j,
								finalValue,
								i = 0

							if (isFunction(value)) {
								return this.each(function (j) {
									jQuery(this).addClass(value.call(this, j, getClass(this)))
								})
							}

							classes = classesToArray(value)

							if (classes.length) {
								while ((elem = this[i++])) {
									curValue = getClass(elem)
									cur =
										elem.nodeType === 1 &&
										" " + stripAndCollapse(curValue) + " "

									if (cur) {
										j = 0
										while ((clazz = classes[j++])) {
											if (cur.indexOf(" " + clazz + " ") < 0) {
												cur += clazz + " "
											}
										}

										// Only assign if different to avoid unneeded rendering.
										finalValue = stripAndCollapse(cur)
										if (curValue !== finalValue) {
											elem.setAttribute("class", finalValue)
										}
									}
								}
							}

							return this
						},

						removeClass: function (value) {
							var classes,
								elem,
								cur,
								curValue,
								clazz,
								j,
								finalValue,
								i = 0

							if (isFunction(value)) {
								return this.each(function (j) {
									jQuery(this).removeClass(value.call(this, j, getClass(this)))
								})
							}

							if (!arguments.length) {
								return this.attr("class", "")
							}

							classes = classesToArray(value)

							if (classes.length) {
								while ((elem = this[i++])) {
									curValue = getClass(elem)

									// This expression is here for better compressibility (see addClass)
									cur =
										elem.nodeType === 1 &&
										" " + stripAndCollapse(curValue) + " "

									if (cur) {
										j = 0
										while ((clazz = classes[j++])) {
											// Remove *all* instances
											while (cur.indexOf(" " + clazz + " ") > -1) {
												cur = cur.replace(" " + clazz + " ", " ")
											}
										}

										// Only assign if different to avoid unneeded rendering.
										finalValue = stripAndCollapse(cur)
										if (curValue !== finalValue) {
											elem.setAttribute("class", finalValue)
										}
									}
								}
							}

							return this
						},

						toggleClass: function (value, stateVal) {
							var type = typeof value,
								isValidValue = type === "string" || Array.isArray(value)

							if (typeof stateVal === "boolean" && isValidValue) {
								return stateVal ? this.addClass(value) : this.removeClass(value)
							}

							if (isFunction(value)) {
								return this.each(function (i) {
									jQuery(this).toggleClass(
										value.call(this, i, getClass(this), stateVal),
										stateVal,
									)
								})
							}

							return this.each(function () {
								var className, i, self, classNames

								if (isValidValue) {
									// Toggle individual class names
									i = 0
									self = jQuery(this)
									classNames = classesToArray(value)

									while ((className = classNames[i++])) {
										// Check each className given, space separated list
										if (self.hasClass(className)) {
											self.removeClass(className)
										} else {
											self.addClass(className)
										}
									}

									// Toggle whole class name
								} else if (value === undefined || type === "boolean") {
									className = getClass(this)
									if (className) {
										// Store className if set
										dataPriv.set(this, "__className__", className)
									}

									// If the element has a class name or if we're passed `false`,
									// then remove the whole classname (if there was one, the above saved it).
									// Otherwise bring back whatever was previously saved (if anything),
									// falling back to the empty string if nothing was stored.
									if (this.setAttribute) {
										this.setAttribute(
											"class",
											className || value === false
												? ""
												: dataPriv.get(this, "__className__") || "",
										)
									}
								}
							})
						},

						hasClass: function (selector) {
							var className,
								elem,
								i = 0

							className = " " + selector + " "
							while ((elem = this[i++])) {
								if (
									elem.nodeType === 1 &&
									(" " + stripAndCollapse(getClass(elem)) + " ").indexOf(
										className,
									) > -1
								) {
									return true
								}
							}

							return false
						},
					})

					var rreturn = /\r/g

					jQuery.fn.extend({
						val: function (value) {
							var hooks,
								ret,
								valueIsFunction,
								elem = this[0]

							if (!arguments.length) {
								if (elem) {
									hooks =
										jQuery.valHooks[elem.type] ||
										jQuery.valHooks[elem.nodeName.toLowerCase()]

									if (
										hooks &&
										"get" in hooks &&
										(ret = hooks.get(elem, "value")) !== undefined
									) {
										return ret
									}

									ret = elem.value

									// Handle most common string cases
									if (typeof ret === "string") {
										return ret.replace(rreturn, "")
									}

									// Handle cases where value is null/undef or number
									return ret == null ? "" : ret
								}

								return
							}

							valueIsFunction = isFunction(value)

							return this.each(function (i) {
								var val

								if (this.nodeType !== 1) {
									return
								}

								if (valueIsFunction) {
									val = value.call(this, i, jQuery(this).val())
								} else {
									val = value
								}

								// Treat null/undefined as ""; convert numbers to string
								if (val == null) {
									val = ""
								} else if (typeof val === "number") {
									val += ""
								} else if (Array.isArray(val)) {
									val = jQuery.map(val, function (value) {
										return value == null ? "" : value + ""
									})
								}

								hooks =
									jQuery.valHooks[this.type] ||
									jQuery.valHooks[this.nodeName.toLowerCase()]

								// If set returns undefined, fall back to normal setting
								if (
									!hooks ||
									!("set" in hooks) ||
									hooks.set(this, val, "value") === undefined
								) {
									this.value = val
								}
							})
						},
					})

					jQuery.extend({
						valHooks: {
							option: {
								get: function (elem) {
									var val = jQuery.find.attr(elem, "value")
									return val != null
										? val
										: // Support: IE <=10 - 11 only
										  // option.text throws exceptions (#14686, #14858)
										  // Strip and collapse whitespace
										  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
										  stripAndCollapse(jQuery.text(elem))
								},
							},
							select: {
								get: function (elem) {
									var value,
										option,
										i,
										options = elem.options,
										index = elem.selectedIndex,
										one = elem.type === "select-one",
										values = one ? null : [],
										max = one ? index + 1 : options.length

									if (index < 0) {
										i = max
									} else {
										i = one ? index : 0
									}

									// Loop through all the selected options
									for (; i < max; i++) {
										option = options[i]

										// Support: IE <=9 only
										// IE8-9 doesn't update selected after form reset (#2551)
										if (
											(option.selected || i === index) &&
											// Don't return options that are disabled or in a disabled optgroup
											!option.disabled &&
											(!option.parentNode.disabled ||
												!nodeName(option.parentNode, "optgroup"))
										) {
											// Get the specific value for the option
											value = jQuery(option).val()

											// We don't need an array for one selects
											if (one) {
												return value
											}

											// Multi-Selects return an array
											values.push(value)
										}
									}

									return values
								},

								set: function (elem, value) {
									var optionSet,
										option,
										options = elem.options,
										values = jQuery.makeArray(value),
										i = options.length

									while (i--) {
										option = options[i]

										/* eslint-disable no-cond-assign */

										if (
											(option.selected =
												jQuery.inArray(
													jQuery.valHooks.option.get(option),
													values,
												) > -1)
										) {
											optionSet = true
										}

										/* eslint-enable no-cond-assign */
									}

									// Force browsers to behave consistently when non-matching value is set
									if (!optionSet) {
										elem.selectedIndex = -1
									}
									return values
								},
							},
						},
					})

					// Radios and checkboxes getter/setter
					jQuery.each(["radio", "checkbox"], function () {
						jQuery.valHooks[this] = {
							set: function (elem, value) {
								if (Array.isArray(value)) {
									return (elem.checked =
										jQuery.inArray(jQuery(elem).val(), value) > -1)
								}
							},
						}
						if (!support.checkOn) {
							jQuery.valHooks[this].get = function (elem) {
								return elem.getAttribute("value") === null ? "on" : elem.value
							}
						}
					})

					// Return jQuery for attributes-only inclusion

					support.focusin = "onfocusin" in window

					var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
						stopPropagationCallback = function (e) {
							e.stopPropagation()
						}

					jQuery.extend(jQuery.event, {
						trigger: function (event, data, elem, onlyHandlers) {
							var i,
								cur,
								tmp,
								bubbleType,
								ontype,
								handle,
								special,
								lastElement,
								eventPath = [elem || document],
								type = hasOwn.call(event, "type") ? event.type : event,
								namespaces = hasOwn.call(event, "namespace")
									? event.namespace.split(".")
									: []

							cur = lastElement = tmp = elem = elem || document

							// Don't do events on text and comment nodes
							if (elem.nodeType === 3 || elem.nodeType === 8) {
								return
							}

							// focus/blur morphs to focusin/out; ensure we're not firing them right now
							if (rfocusMorph.test(type + jQuery.event.triggered)) {
								return
							}

							if (type.indexOf(".") > -1) {
								// Namespaced trigger; create a regexp to match event type in handle()
								namespaces = type.split(".")
								type = namespaces.shift()
								namespaces.sort()
							}
							ontype = type.indexOf(":") < 0 && "on" + type

							// Caller can pass in a jQuery.Event object, Object, or just an event type string
							event = event[jQuery.expando]
								? event
								: new jQuery.Event(type, typeof event === "object" && event)

							// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
							event.isTrigger = onlyHandlers ? 2 : 3
							event.namespace = namespaces.join(".")
							event.rnamespace = event.namespace
								? new RegExp(
										"(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)",
								  )
								: null

							// Clean up the event in case it is being reused
							event.result = undefined
							if (!event.target) {
								event.target = elem
							}

							// Clone any incoming data and prepend the event, creating the handler arg list
							data = data == null ? [event] : jQuery.makeArray(data, [event])

							// Allow special events to draw outside the lines
							special = jQuery.event.special[type] || {}
							if (
								!onlyHandlers &&
								special.trigger &&
								special.trigger.apply(elem, data) === false
							) {
								return
							}

							// Determine event propagation path in advance, per W3C events spec (#9951)
							// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
							if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
								bubbleType = special.delegateType || type
								if (!rfocusMorph.test(bubbleType + type)) {
									cur = cur.parentNode
								}
								for (; cur; cur = cur.parentNode) {
									eventPath.push(cur)
									tmp = cur
								}

								// Only add window if we got to document (e.g., not plain obj or detached DOM)
								if (tmp === (elem.ownerDocument || document)) {
									eventPath.push(tmp.defaultView || tmp.parentWindow || window)
								}
							}

							// Fire handlers on the event path
							i = 0
							while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
								lastElement = cur
								event.type = i > 1 ? bubbleType : special.bindType || type

								// jQuery handler
								handle =
									(dataPriv.get(cur, "events") || Object.create(null))[
										event.type
									] && dataPriv.get(cur, "handle")
								if (handle) {
									handle.apply(cur, data)
								}

								// Native handler
								handle = ontype && cur[ontype]
								if (handle && handle.apply && acceptData(cur)) {
									event.result = handle.apply(cur, data)
									if (event.result === false) {
										event.preventDefault()
									}
								}
							}
							event.type = type

							// If nobody prevented the default action, do it now
							if (!onlyHandlers && !event.isDefaultPrevented()) {
								if (
									(!special._default ||
										special._default.apply(eventPath.pop(), data) === false) &&
									acceptData(elem)
								) {
									// Call a native DOM method on the target with the same name as the event.
									// Don't do default actions on window, that's where global variables be (#6170)
									if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
										// Don't re-trigger an onFOO event when we call its FOO() method
										tmp = elem[ontype]

										if (tmp) {
											elem[ontype] = null
										}

										// Prevent re-triggering of the same event, since we already bubbled it above
										jQuery.event.triggered = type

										if (event.isPropagationStopped()) {
											lastElement.addEventListener(
												type,
												stopPropagationCallback,
											)
										}

										elem[type]()

										if (event.isPropagationStopped()) {
											lastElement.removeEventListener(
												type,
												stopPropagationCallback,
											)
										}

										jQuery.event.triggered = undefined

										if (tmp) {
											elem[ontype] = tmp
										}
									}
								}
							}

							return event.result
						},

						// Piggyback on a donor event to simulate a different one
						// Used only for `focus(in | out)` events
						simulate: function (type, elem, event) {
							var e = jQuery.extend(new jQuery.Event(), event, {
								type: type,
								isSimulated: true,
							})

							jQuery.event.trigger(e, null, elem)
						},
					})

					jQuery.fn.extend({
						trigger: function (type, data) {
							return this.each(function () {
								jQuery.event.trigger(type, data, this)
							})
						},
						triggerHandler: function (type, data) {
							var elem = this[0]
							if (elem) {
								return jQuery.event.trigger(type, data, elem, true)
							}
						},
					})

					// Support: Firefox <=44
					// Firefox doesn't have focus(in | out) events
					// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
					//
					// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
					// focus(in | out) events fire after focus & blur events,
					// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
					// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
					if (!support.focusin) {
						jQuery.each({ focus: "focusin", blur: "focusout" }, function (
							orig,
							fix,
						) {
							// Attach a single capturing handler on the document while someone wants focusin/focusout
							var handler = function (event) {
								jQuery.event.simulate(
									fix,
									event.target,
									jQuery.event.fix(event),
								)
							}

							jQuery.event.special[fix] = {
								setup: function () {
									// Handle: regular nodes (via `this.ownerDocument`), window
									// (via `this.document`) & document (via `this`).
									var doc = this.ownerDocument || this.document || this,
										attaches = dataPriv.access(doc, fix)

									if (!attaches) {
										doc.addEventListener(orig, handler, true)
									}
									dataPriv.access(doc, fix, (attaches || 0) + 1)
								},
								teardown: function () {
									var doc = this.ownerDocument || this.document || this,
										attaches = dataPriv.access(doc, fix) - 1

									if (!attaches) {
										doc.removeEventListener(orig, handler, true)
										dataPriv.remove(doc, fix)
									} else {
										dataPriv.access(doc, fix, attaches)
									}
								},
							}
						})
					}
					var location = window.location

					var nonce = { guid: Date.now() }

					var rquery = /\?/

					// Cross-browser xml parsing
					jQuery.parseXML = function (data) {
						var xml
						if (!data || typeof data !== "string") {
							return null
						}

						// Support: IE 9 - 11 only
						// IE throws on parseFromString with invalid input.
						try {
							xml = new window.DOMParser().parseFromString(data, "text/xml")
						} catch (e) {
							xml = undefined
						}

						if (!xml || xml.getElementsByTagName("parsererror").length) {
							jQuery.error("Invalid XML: " + data)
						}
						return xml
					}

					var rbracket = /\[\]$/,
						rCRLF = /\r?\n/g,
						rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
						rsubmittable = /^(?:input|select|textarea|keygen)/i

					function buildParams(prefix, obj, traditional, add) {
						var name

						if (Array.isArray(obj)) {
							// Serialize array item.
							jQuery.each(obj, function (i, v) {
								if (traditional || rbracket.test(prefix)) {
									// Treat each array item as a scalar.
									add(prefix, v)
								} else {
									// Item is non-scalar (array or object), encode its numeric index.
									buildParams(
										prefix +
											"[" +
											(typeof v === "object" && v != null ? i : "") +
											"]",
										v,
										traditional,
										add,
									)
								}
							})
						} else if (!traditional && toType(obj) === "object") {
							// Serialize object item.
							for (name in obj) {
								buildParams(
									prefix + "[" + name + "]",
									obj[name],
									traditional,
									add,
								)
							}
						} else {
							// Serialize scalar item.
							add(prefix, obj)
						}
					}

					// Serialize an array of form elements or a set of
					// key/values into a query string
					jQuery.param = function (a, traditional) {
						var prefix,
							s = [],
							add = function (key, valueOrFunction) {
								// If value is a function, invoke it and use its return value
								var value = isFunction(valueOrFunction)
									? valueOrFunction()
									: valueOrFunction

								s[s.length] =
									encodeURIComponent(key) +
									"=" +
									encodeURIComponent(value == null ? "" : value)
							}

						if (a == null) {
							return ""
						}

						// If an array was passed in, assume that it is an array of form elements.
						if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
							// Serialize the form elements
							jQuery.each(a, function () {
								add(this.name, this.value)
							})
						} else {
							// If traditional, encode the "old" way (the way 1.3.2 or older
							// did it), otherwise encode params recursively.
							for (prefix in a) {
								buildParams(prefix, a[prefix], traditional, add)
							}
						}

						// Return the resulting serialization
						return s.join("&")
					}

					jQuery.fn.extend({
						serialize: function () {
							return jQuery.param(this.serializeArray())
						},
						serializeArray: function () {
							return this.map(function () {
								// Can add propHook for "elements" to filter or add form elements
								var elements = jQuery.prop(this, "elements")
								return elements ? jQuery.makeArray(elements) : this
							})
								.filter(function () {
									var type = this.type

									// Use .is( ":disabled" ) so that fieldset[disabled] works
									return (
										this.name &&
										!jQuery(this).is(":disabled") &&
										rsubmittable.test(this.nodeName) &&
										!rsubmitterTypes.test(type) &&
										(this.checked || !rcheckableType.test(type))
									)
								})
								.map(function (_i, elem) {
									var val = jQuery(this).val()

									if (val == null) {
										return null
									}

									if (Array.isArray(val)) {
										return jQuery.map(val, function (val) {
											return {
												name: elem.name,
												value: val.replace(rCRLF, "\r\n"),
											}
										})
									}

									return { name: elem.name, value: val.replace(rCRLF, "\r\n") }
								})
								.get()
						},
					})

					var r20 = /%20/g,
						rhash = /#.*$/,
						rantiCache = /([?&])_=[^&]*/,
						rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
						// #7653, #8125, #8152: local protocol detection
						rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
						rnoContent = /^(?:GET|HEAD)$/,
						rprotocol = /^\/\//,
						/* Prefilters
						 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
						 * 2) These are called:
						 *    - BEFORE asking for a transport
						 *    - AFTER param serialization (s.data is a string if s.processData is true)
						 * 3) key is the dataType
						 * 4) the catchall symbol "*" can be used
						 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
						 */
						prefilters = {},
						/* Transports bindings
						 * 1) key is the dataType
						 * 2) the catchall symbol "*" can be used
						 * 3) selection will start with transport dataType and THEN go to "*" if needed
						 */
						transports = {},
						// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
						allTypes = "*/".concat("*"),
						// Anchor tag for parsing the document origin
						originAnchor = document.createElement("a")
					originAnchor.href = location.href

					// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
					function addToPrefiltersOrTransports(structure) {
						// dataTypeExpression is optional and defaults to "*"
						return function (dataTypeExpression, func) {
							if (typeof dataTypeExpression !== "string") {
								func = dataTypeExpression
								dataTypeExpression = "*"
							}

							var dataType,
								i = 0,
								dataTypes =
									dataTypeExpression.toLowerCase().match(rnothtmlwhite) || []

							if (isFunction(func)) {
								// For each dataType in the dataTypeExpression
								while ((dataType = dataTypes[i++])) {
									// Prepend if requested
									if (dataType[0] === "+") {
										dataType = dataType.slice(1) || "*"
										;(structure[dataType] = structure[dataType] || []).unshift(
											func,
										)

										// Otherwise append
									} else {
										;(structure[dataType] = structure[dataType] || []).push(
											func,
										)
									}
								}
							}
						}
					}

					// Base inspection function for prefilters and transports
					function inspectPrefiltersOrTransports(
						structure,
						options,
						originalOptions,
						jqXHR,
					) {
						var inspected = {},
							seekingTransport = structure === transports

						function inspect(dataType) {
							var selected
							inspected[dataType] = true
							jQuery.each(structure[dataType] || [], function (
								_,
								prefilterOrFactory,
							) {
								var dataTypeOrTransport = prefilterOrFactory(
									options,
									originalOptions,
									jqXHR,
								)
								if (
									typeof dataTypeOrTransport === "string" &&
									!seekingTransport &&
									!inspected[dataTypeOrTransport]
								) {
									options.dataTypes.unshift(dataTypeOrTransport)
									inspect(dataTypeOrTransport)
									return false
								} else if (seekingTransport) {
									return !(selected = dataTypeOrTransport)
								}
							})
							return selected
						}

						return (
							inspect(options.dataTypes[0]) || (!inspected["*"] && inspect("*"))
						)
					}

					// A special extend for ajax options
					// that takes "flat" options (not to be deep extended)
					// Fixes #9887
					function ajaxExtend(target, src) {
						var key,
							deep,
							flatOptions = jQuery.ajaxSettings.flatOptions || {}

						for (key in src) {
							if (src[key] !== undefined) {
								;(flatOptions[key] ? target : deep || (deep = {}))[key] =
									src[key]
							}
						}
						if (deep) {
							jQuery.extend(true, target, deep)
						}

						return target
					}

					/* Handles responses to an ajax request:
					 * - finds the right dataType (mediates between content-type and expected dataType)
					 * - returns the corresponding response
					 */
					function ajaxHandleResponses(s, jqXHR, responses) {
						var ct,
							type,
							finalDataType,
							firstDataType,
							contents = s.contents,
							dataTypes = s.dataTypes

						// Remove auto dataType and get content-type in the process
						while (dataTypes[0] === "*") {
							dataTypes.shift()
							if (ct === undefined) {
								ct = s.mimeType || jqXHR.getResponseHeader("Content-Type")
							}
						}

						// Check if we're dealing with a known content-type
						if (ct) {
							for (type in contents) {
								if (contents[type] && contents[type].test(ct)) {
									dataTypes.unshift(type)
									break
								}
							}
						}

						// Check to see if we have a response for the expected dataType
						if (dataTypes[0] in responses) {
							finalDataType = dataTypes[0]
						} else {
							// Try convertible dataTypes
							for (type in responses) {
								if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
									finalDataType = type
									break
								}
								if (!firstDataType) {
									firstDataType = type
								}
							}

							// Or just use first one
							finalDataType = finalDataType || firstDataType
						}

						// If we found a dataType
						// We add the dataType to the list if needed
						// and return the corresponding response
						if (finalDataType) {
							if (finalDataType !== dataTypes[0]) {
								dataTypes.unshift(finalDataType)
							}
							return responses[finalDataType]
						}
					}

					/* Chain conversions given the request and the original response
					 * Also sets the responseXXX fields on the jqXHR instance
					 */
					function ajaxConvert(s, response, jqXHR, isSuccess) {
						var conv2,
							current,
							conv,
							tmp,
							prev,
							converters = {},
							// Work with a copy of dataTypes in case we need to modify it for conversion
							dataTypes = s.dataTypes.slice()

						// Create converters map with lowercased keys
						if (dataTypes[1]) {
							for (conv in s.converters) {
								converters[conv.toLowerCase()] = s.converters[conv]
							}
						}

						current = dataTypes.shift()

						// Convert to each sequential dataType
						while (current) {
							if (s.responseFields[current]) {
								jqXHR[s.responseFields[current]] = response
							}

							// Apply the dataFilter if provided
							if (!prev && isSuccess && s.dataFilter) {
								response = s.dataFilter(response, s.dataType)
							}

							prev = current
							current = dataTypes.shift()

							if (current) {
								// There's only work to do if current dataType is non-auto
								if (current === "*") {
									current = prev

									// Convert response if prev dataType is non-auto and differs from current
								} else if (prev !== "*" && prev !== current) {
									// Seek a direct converter
									conv =
										converters[prev + " " + current] ||
										converters["* " + current]

									// If none found, seek a pair
									if (!conv) {
										for (conv2 in converters) {
											// If conv2 outputs current
											tmp = conv2.split(" ")
											if (tmp[1] === current) {
												// If prev can be converted to accepted input
												conv =
													converters[prev + " " + tmp[0]] ||
													converters["* " + tmp[0]]
												if (conv) {
													// Condense equivalence converters
													if (conv === true) {
														conv = converters[conv2]

														// Otherwise, insert the intermediate dataType
													} else if (converters[conv2] !== true) {
														current = tmp[0]
														dataTypes.unshift(tmp[1])
													}
													break
												}
											}
										}
									}

									// Apply converter (if not an equivalence)
									if (conv !== true) {
										// Unless errors are allowed to bubble, catch and return them
										if (conv && s.throws) {
											response = conv(response)
										} else {
											try {
												response = conv(response)
											} catch (e) {
												return {
													state: "parsererror",
													error: conv
														? e
														: "No conversion from " + prev + " to " + current,
												}
											}
										}
									}
								}
							}
						}

						return { state: "success", data: response }
					}

					jQuery.extend({
						// Counter for holding the number of active queries
						active: 0,

						// Last-Modified header cache for next request
						lastModified: {},
						etag: {},

						ajaxSettings: {
							url: location.href,
							type: "GET",
							isLocal: rlocalProtocol.test(location.protocol),
							global: true,
							processData: true,
							async: true,
							contentType: "application/x-www-form-urlencoded; charset=UTF-8",

							/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

							accepts: {
								"*": allTypes,
								text: "text/plain",
								html: "text/html",
								xml: "application/xml, text/xml",
								json: "application/json, text/javascript",
							},

							contents: {
								xml: /\bxml\b/,
								html: /\bhtml/,
								json: /\bjson\b/,
							},

							responseFields: {
								xml: "responseXML",
								text: "responseText",
								json: "responseJSON",
							},

							// Data converters
							// Keys separate source (or catchall "*") and destination types with a single space
							converters: {
								// Convert anything to text
								"* text": String,

								// Text to html (true = no transformation)
								"text html": true,

								// Evaluate text as a json expression
								"text json": JSON.parse,

								// Parse text as xml
								"text xml": jQuery.parseXML,
							},

							// For options that shouldn't be deep extended:
							// you can add your own custom options here if
							// and when you create one that shouldn't be
							// deep extended (see ajaxExtend)
							flatOptions: {
								url: true,
								context: true,
							},
						},

						// Creates a full fledged settings object into target
						// with both ajaxSettings and settings fields.
						// If target is omitted, writes into ajaxSettings.
						ajaxSetup: function (target, settings) {
							return settings
								? // Building a settings object
								  ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
								: // Extending ajaxSettings
								  ajaxExtend(jQuery.ajaxSettings, target)
						},

						ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
						ajaxTransport: addToPrefiltersOrTransports(transports),

						// Main method
						ajax: function (url, options) {
							// If url is an object, simulate pre-1.5 signature
							if (typeof url === "object") {
								options = url
								url = undefined
							}

							// Force options to be an object
							options = options || {}

							var transport,
								// URL without anti-cache param
								cacheURL,
								// Response headers
								responseHeadersString,
								responseHeaders,
								// timeout handle
								timeoutTimer,
								// Url cleanup var
								urlAnchor,
								// Request state (becomes false upon send and true upon completion)
								completed,
								// To know if global events are to be dispatched
								fireGlobals,
								// Loop variable
								i,
								// uncached part of the url
								uncached,
								// Create the final options object
								s = jQuery.ajaxSetup({}, options),
								// Callbacks context
								callbackContext = s.context || s,
								// Context for global events is callbackContext if it is a DOM node or jQuery collection
								globalEventContext =
									s.context &&
									(callbackContext.nodeType || callbackContext.jquery)
										? jQuery(callbackContext)
										: jQuery.event,
								// Deferreds
								deferred = jQuery.Deferred(),
								completeDeferred = jQuery.Callbacks("once memory"),
								// Status-dependent callbacks
								statusCode = s.statusCode || {},
								// Headers (they are sent all at once)
								requestHeaders = {},
								requestHeadersNames = {},
								// Default abort message
								strAbort = "canceled",
								// Fake xhr
								jqXHR = {
									readyState: 0,

									// Builds headers hashtable if needed
									getResponseHeader: function (key) {
										var match
										if (completed) {
											if (!responseHeaders) {
												responseHeaders = {}
												while ((match = rheaders.exec(responseHeadersString))) {
													responseHeaders[match[1].toLowerCase() + " "] = (
														responseHeaders[match[1].toLowerCase() + " "] || []
													).concat(match[2])
												}
											}
											match = responseHeaders[key.toLowerCase() + " "]
										}
										return match == null ? null : match.join(", ")
									},

									// Raw string
									getAllResponseHeaders: function () {
										return completed ? responseHeadersString : null
									},

									// Caches the header
									setRequestHeader: function (name, value) {
										if (completed == null) {
											name = requestHeadersNames[name.toLowerCase()] =
												requestHeadersNames[name.toLowerCase()] || name
											requestHeaders[name] = value
										}
										return this
									},

									// Overrides response content-type header
									overrideMimeType: function (type) {
										if (completed == null) {
											s.mimeType = type
										}
										return this
									},

									// Status-dependent callbacks
									statusCode: function (map) {
										var code
										if (map) {
											if (completed) {
												// Execute the appropriate callbacks
												jqXHR.always(map[jqXHR.status])
											} else {
												// Lazy-add the new callbacks in a way that preserves old ones
												for (code in map) {
													statusCode[code] = [statusCode[code], map[code]]
												}
											}
										}
										return this
									},

									// Cancel the request
									abort: function (statusText) {
										var finalText = statusText || strAbort
										if (transport) {
											transport.abort(finalText)
										}
										done(0, finalText)
										return this
									},
								}

							// Attach deferreds
							deferred.promise(jqXHR)

							// Add protocol if not provided (prefilters might expect it)
							// Handle falsy url in the settings object (#10093: consistency with old signature)
							// We also use the url parameter if available
							s.url = ((url || s.url || location.href) + "").replace(
								rprotocol,
								location.protocol + "//",
							)

							// Alias method option to type as per ticket #12004
							s.type = options.method || options.type || s.method || s.type

							// Extract dataTypes list
							s.dataTypes = (s.dataType || "*")
								.toLowerCase()
								.match(rnothtmlwhite) || [""]

							// A cross-domain request is in order when the origin doesn't match the current origin.
							if (s.crossDomain == null) {
								urlAnchor = document.createElement("a")

								// Support: IE <=8 - 11, Edge 12 - 15
								// IE throws exception on accessing the href property if url is malformed,
								// e.g. http://example.com:80x/
								try {
									urlAnchor.href = s.url

									// Support: IE <=8 - 11 only
									// Anchor's host property isn't correctly set when s.url is relative
									urlAnchor.href = urlAnchor.href
									s.crossDomain =
										originAnchor.protocol + "//" + originAnchor.host !==
										urlAnchor.protocol + "//" + urlAnchor.host
								} catch (e) {
									// If there is an error parsing the URL, assume it is crossDomain,
									// it can be rejected by the transport if it is invalid
									s.crossDomain = true
								}
							}

							// Convert data if not already a string
							if (s.data && s.processData && typeof s.data !== "string") {
								s.data = jQuery.param(s.data, s.traditional)
							}

							// Apply prefilters
							inspectPrefiltersOrTransports(prefilters, s, options, jqXHR)

							// If request was aborted inside a prefilter, stop there
							if (completed) {
								return jqXHR
							}

							// We can fire global events as of now if asked to
							// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
							fireGlobals = jQuery.event && s.global

							// Watch for a new set of requests
							if (fireGlobals && jQuery.active++ === 0) {
								jQuery.event.trigger("ajaxStart")
							}

							// Uppercase the type
							s.type = s.type.toUpperCase()

							// Determine if request has content
							s.hasContent = !rnoContent.test(s.type)

							// Save the URL in case we're toying with the If-Modified-Since
							// and/or If-None-Match header later on
							// Remove hash to simplify url manipulation
							cacheURL = s.url.replace(rhash, "")

							// More options handling for requests with no content
							if (!s.hasContent) {
								// Remember the hash so we can put it back
								uncached = s.url.slice(cacheURL.length)

								// If data is available and should be processed, append data to url
								if (s.data && (s.processData || typeof s.data === "string")) {
									cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data

									// #9682: remove data so that it's not used in an eventual retry
									delete s.data
								}

								// Add or update anti-cache param if needed
								if (s.cache === false) {
									cacheURL = cacheURL.replace(rantiCache, "$1")
									uncached =
										(rquery.test(cacheURL) ? "&" : "?") +
										"_=" +
										nonce.guid++ +
										uncached
								}

								// Put hash and anti-cache on the URL that will be requested (gh-1732)
								s.url = cacheURL + uncached

								// Change '%20' to '+' if this is encoded form body content (gh-2658)
							} else if (
								s.data &&
								s.processData &&
								(s.contentType || "").indexOf(
									"application/x-www-form-urlencoded",
								) === 0
							) {
								s.data = s.data.replace(r20, "+")
							}

							// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
							if (s.ifModified) {
								if (jQuery.lastModified[cacheURL]) {
									jqXHR.setRequestHeader(
										"If-Modified-Since",
										jQuery.lastModified[cacheURL],
									)
								}
								if (jQuery.etag[cacheURL]) {
									jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])
								}
							}

							// Set the correct header, if data is being sent
							if (
								(s.data && s.hasContent && s.contentType !== false) ||
								options.contentType
							) {
								jqXHR.setRequestHeader("Content-Type", s.contentType)
							}

							// Set the Accepts header for the server, depending on the dataType
							jqXHR.setRequestHeader(
								"Accept",
								s.dataTypes[0] && s.accepts[s.dataTypes[0]]
									? s.accepts[s.dataTypes[0]] +
											(s.dataTypes[0] !== "*"
												? ", " + allTypes + "; q=0.01"
												: "")
									: s.accepts["*"],
							)

							// Check for headers option
							for (i in s.headers) {
								jqXHR.setRequestHeader(i, s.headers[i])
							}

							// Allow custom headers/mimetypes and early abort
							if (
								s.beforeSend &&
								(s.beforeSend.call(callbackContext, jqXHR, s) === false ||
									completed)
							) {
								// Abort if not done already and return
								return jqXHR.abort()
							}

							// Aborting is no longer a cancellation
							strAbort = "abort"

							// Install callbacks on deferreds
							completeDeferred.add(s.complete)
							jqXHR.done(s.success)
							jqXHR.fail(s.error)

							// Get transport
							transport = inspectPrefiltersOrTransports(
								transports,
								s,
								options,
								jqXHR,
							)

							// If no transport, we auto-abort
							if (!transport) {
								done(-1, "No Transport")
							} else {
								jqXHR.readyState = 1

								// Send global event
								if (fireGlobals) {
									globalEventContext.trigger("ajaxSend", [jqXHR, s])
								}

								// If request was aborted inside ajaxSend, stop there
								if (completed) {
									return jqXHR
								}

								// Timeout
								if (s.async && s.timeout > 0) {
									timeoutTimer = window.setTimeout(function () {
										jqXHR.abort("timeout")
									}, s.timeout)
								}

								try {
									completed = false
									transport.send(requestHeaders, done)
								} catch (e) {
									// Rethrow post-completion exceptions
									if (completed) {
										throw e
									}

									// Propagate others as results
									done(-1, e)
								}
							}

							// Callback for when everything is done
							function done(status, nativeStatusText, responses, headers) {
								var isSuccess,
									success,
									error,
									response,
									modified,
									statusText = nativeStatusText

								// Ignore repeat invocations
								if (completed) {
									return
								}

								completed = true

								// Clear timeout if it exists
								if (timeoutTimer) {
									window.clearTimeout(timeoutTimer)
								}

								// Dereference transport for early garbage collection
								// (no matter how long the jqXHR object will be used)
								transport = undefined

								// Cache response headers
								responseHeadersString = headers || ""

								// Set readyState
								jqXHR.readyState = status > 0 ? 4 : 0

								// Determine if successful
								isSuccess = (status >= 200 && status < 300) || status === 304

								// Get response data
								if (responses) {
									response = ajaxHandleResponses(s, jqXHR, responses)
								}

								// Use a noop converter for missing script
								if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1) {
									s.converters["text script"] = function () {}
								}

								// Convert no matter what (that way responseXXX fields are always set)
								response = ajaxConvert(s, response, jqXHR, isSuccess)

								// If successful, handle type chaining
								if (isSuccess) {
									// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
									if (s.ifModified) {
										modified = jqXHR.getResponseHeader("Last-Modified")
										if (modified) {
											jQuery.lastModified[cacheURL] = modified
										}
										modified = jqXHR.getResponseHeader("etag")
										if (modified) {
											jQuery.etag[cacheURL] = modified
										}
									}

									// if no content
									if (status === 204 || s.type === "HEAD") {
										statusText = "nocontent"

										// if not modified
									} else if (status === 304) {
										statusText = "notmodified"

										// If we have data, let's convert it
									} else {
										statusText = response.state
										success = response.data
										error = response.error
										isSuccess = !error
									}
								} else {
									// Extract error from statusText and normalize for non-aborts
									error = statusText
									if (status || !statusText) {
										statusText = "error"
										if (status < 0) {
											status = 0
										}
									}
								}

								// Set data for the fake xhr object
								jqXHR.status = status
								jqXHR.statusText = (nativeStatusText || statusText) + ""

								// Success/Error
								if (isSuccess) {
									deferred.resolveWith(callbackContext, [
										success,
										statusText,
										jqXHR,
									])
								} else {
									deferred.rejectWith(callbackContext, [
										jqXHR,
										statusText,
										error,
									])
								}

								// Status-dependent callbacks
								jqXHR.statusCode(statusCode)
								statusCode = undefined

								if (fireGlobals) {
									globalEventContext.trigger(
										isSuccess ? "ajaxSuccess" : "ajaxError",
										[jqXHR, s, isSuccess ? success : error],
									)
								}

								// Complete
								completeDeferred.fireWith(callbackContext, [jqXHR, statusText])

								if (fireGlobals) {
									globalEventContext.trigger("ajaxComplete", [jqXHR, s])

									// Handle the global AJAX counter
									if (!--jQuery.active) {
										jQuery.event.trigger("ajaxStop")
									}
								}
							}

							return jqXHR
						},

						getJSON: function (url, data, callback) {
							return jQuery.get(url, data, callback, "json")
						},

						getScript: function (url, callback) {
							return jQuery.get(url, undefined, callback, "script")
						},
					})

					jQuery.each(["get", "post"], function (_i, method) {
						jQuery[method] = function (url, data, callback, type) {
							// Shift arguments if data argument was omitted
							if (isFunction(data)) {
								type = type || callback
								callback = data
								data = undefined
							}

							// The url can be an options object (which then must have .url)
							return jQuery.ajax(
								jQuery.extend(
									{
										url: url,
										type: method,
										dataType: type,
										data: data,
										success: callback,
									},
									jQuery.isPlainObject(url) && url,
								),
							)
						}
					})

					jQuery.ajaxPrefilter(function (s) {
						var i
						for (i in s.headers) {
							if (i.toLowerCase() === "content-type") {
								s.contentType = s.headers[i] || ""
							}
						}
					})

					jQuery._evalUrl = function (url, options, doc) {
						return jQuery.ajax({
							url: url,

							// Make this explicit, since user can override this through ajaxSetup (#11264)
							type: "GET",
							dataType: "script",
							cache: true,
							async: false,
							global: false,

							// Only evaluate the response if it is successful (gh-4126)
							// dataFilter is not invoked for failure responses, so using it instead
							// of the default converter is kludgy but it works.
							converters: {
								"text script": function () {},
							},
							dataFilter: function (response) {
								jQuery.globalEval(response, options, doc)
							},
						})
					}

					jQuery.fn.extend({
						wrapAll: function (html) {
							var wrap

							if (this[0]) {
								if (isFunction(html)) {
									html = html.call(this[0])
								}

								// The elements to wrap the target around
								wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true)

								if (this[0].parentNode) {
									wrap.insertBefore(this[0])
								}

								wrap
									.map(function () {
										var elem = this

										while (elem.firstElementChild) {
											elem = elem.firstElementChild
										}

										return elem
									})
									.append(this)
							}

							return this
						},

						wrapInner: function (html) {
							if (isFunction(html)) {
								return this.each(function (i) {
									jQuery(this).wrapInner(html.call(this, i))
								})
							}

							return this.each(function () {
								var self = jQuery(this),
									contents = self.contents()

								if (contents.length) {
									contents.wrapAll(html)
								} else {
									self.append(html)
								}
							})
						},

						wrap: function (html) {
							var htmlIsFunction = isFunction(html)

							return this.each(function (i) {
								jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html)
							})
						},

						unwrap: function (selector) {
							this.parent(selector)
								.not("body")
								.each(function () {
									jQuery(this).replaceWith(this.childNodes)
								})
							return this
						},
					})

					jQuery.expr.pseudos.hidden = function (elem) {
						return !jQuery.expr.pseudos.visible(elem)
					}
					jQuery.expr.pseudos.visible = function (elem) {
						return !!(
							elem.offsetWidth ||
							elem.offsetHeight ||
							elem.getClientRects().length
						)
					}

					jQuery.ajaxSettings.xhr = function () {
						try {
							return new window.XMLHttpRequest()
						} catch (e) {}
					}

					var xhrSuccessStatus = {
							// File protocol always yields status code 0, assume 200
							0: 200,

							// Support: IE <=9 only
							// #1450: sometimes IE returns 1223 when it should be 204
							1223: 204,
						},
						xhrSupported = jQuery.ajaxSettings.xhr()

					support.cors = !!xhrSupported && "withCredentials" in xhrSupported
					support.ajax = xhrSupported = !!xhrSupported

					jQuery.ajaxTransport(function (options) {
						var callback, errorCallback

						// Cross domain only allowed if supported through XMLHttpRequest
						if (support.cors || (xhrSupported && !options.crossDomain)) {
							return {
								send: function (headers, complete) {
									var i,
										xhr = options.xhr()

									xhr.open(
										options.type,
										options.url,
										options.async,
										options.username,
										options.password,
									)

									// Apply custom fields if provided
									if (options.xhrFields) {
										for (i in options.xhrFields) {
											xhr[i] = options.xhrFields[i]
										}
									}

									// Override mime type if needed
									if (options.mimeType && xhr.overrideMimeType) {
										xhr.overrideMimeType(options.mimeType)
									}

									// X-Requested-With header
									// For cross-domain requests, seeing as conditions for a preflight are
									// akin to a jigsaw puzzle, we simply never set it to be sure.
									// (it can always be set on a per-request basis or even using ajaxSetup)
									// For same-domain requests, won't change header if already provided.
									if (!options.crossDomain && !headers["X-Requested-With"]) {
										headers["X-Requested-With"] = "XMLHttpRequest"
									}

									// Set headers
									for (i in headers) {
										xhr.setRequestHeader(i, headers[i])
									}

									// Callback
									callback = function (type) {
										return function () {
											if (callback) {
												callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null

												if (type === "abort") {
													xhr.abort()
												} else if (type === "error") {
													// Support: IE <=9 only
													// On a manual native abort, IE9 throws
													// errors on any property access that is not readyState
													if (typeof xhr.status !== "number") {
														complete(0, "error")
													} else {
														complete(
															// File: protocol always yields status 0; see #8605, #14207
															xhr.status,
															xhr.statusText,
														)
													}
												} else {
													complete(
														xhrSuccessStatus[xhr.status] || xhr.status,
														xhr.statusText,

														// Support: IE <=9 only
														// IE9 has no XHR2 but throws on binary (trac-11426)
														// For XHR2 non-text, let the caller handle it (gh-2498)
														(xhr.responseType || "text") !== "text" ||
															typeof xhr.responseText !== "string"
															? { binary: xhr.response }
															: { text: xhr.responseText },
														xhr.getAllResponseHeaders(),
													)
												}
											}
										}
									}

									// Listen to events
									xhr.onload = callback()
									errorCallback = xhr.onerror = xhr.ontimeout = callback(
										"error",
									)

									// Support: IE 9 only
									// Use onreadystatechange to replace onabort
									// to handle uncaught aborts
									if (xhr.onabort !== undefined) {
										xhr.onabort = errorCallback
									} else {
										xhr.onreadystatechange = function () {
											// Check readyState before timeout as it changes
											if (xhr.readyState === 4) {
												// Allow onerror to be called first,
												// but that will not handle a native abort
												// Also, save errorCallback to a variable
												// as xhr.onerror cannot be accessed
												window.setTimeout(function () {
													if (callback) {
														errorCallback()
													}
												})
											}
										}
									}

									// Create the abort callback
									callback = callback("abort")

									try {
										// Do send the request (this may raise an exception)
										xhr.send((options.hasContent && options.data) || null)
									} catch (e) {
										// #14683: Only rethrow if this hasn't been notified as an error yet
										if (callback) {
											throw e
										}
									}
								},

								abort: function () {
									if (callback) {
										callback()
									}
								},
							}
						}
					})

					// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
					jQuery.ajaxPrefilter(function (s) {
						if (s.crossDomain) {
							s.contents.script = false
						}
					})

					// Install script dataType
					jQuery.ajaxSetup({
						accepts: {
							script:
								"text/javascript, application/javascript, " +
								"application/ecmascript, application/x-ecmascript",
						},
						contents: {
							script: /\b(?:java|ecma)script\b/,
						},
						converters: {
							"text script": function (text) {
								jQuery.globalEval(text)
								return text
							},
						},
					})

					// Handle cache's special case and crossDomain
					jQuery.ajaxPrefilter("script", function (s) {
						if (s.cache === undefined) {
							s.cache = false
						}
						if (s.crossDomain) {
							s.type = "GET"
						}
					})

					// Bind script tag hack transport
					jQuery.ajaxTransport("script", function (s) {
						// This transport only deals with cross domain or forced-by-attrs requests
						if (s.crossDomain || s.scriptAttrs) {
							var script, callback
							return {
								send: function (_, complete) {
									script = jQuery("<script>")
										.attr(s.scriptAttrs || {})
										.prop({ charset: s.scriptCharset, src: s.url })
										.on(
											"load error",
											(callback = function (evt) {
												script.remove()
												callback = null
												if (evt) {
													complete(evt.type === "error" ? 404 : 200, evt.type)
												}
											}),
										)

									// Use native DOM manipulation to avoid our domManip AJAX trickery
									document.head.appendChild(script[0])
								},
								abort: function () {
									if (callback) {
										callback()
									}
								},
							}
						}
					})

					var oldCallbacks = [],
						rjsonp = /(=)\?(?=&|$)|\?\?/

					// Default jsonp settings
					jQuery.ajaxSetup({
						jsonp: "callback",
						jsonpCallback: function () {
							var callback =
								oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++
							this[callback] = true
							return callback
						},
					})

					// Detect, normalize options and install callbacks for jsonp requests
					jQuery.ajaxPrefilter("json jsonp", function (
						s,
						originalSettings,
						jqXHR,
					) {
						var callbackName,
							overwritten,
							responseContainer,
							jsonProp =
								s.jsonp !== false &&
								(rjsonp.test(s.url)
									? "url"
									: typeof s.data === "string" &&
									  (s.contentType || "").indexOf(
											"application/x-www-form-urlencoded",
									  ) === 0 &&
									  rjsonp.test(s.data) &&
									  "data")

						// Handle iff the expected data type is "jsonp" or we have a parameter to set
						if (jsonProp || s.dataTypes[0] === "jsonp") {
							// Get callback name, remembering preexisting value associated with it
							callbackName = s.jsonpCallback = isFunction(s.jsonpCallback)
								? s.jsonpCallback()
								: s.jsonpCallback

							// Insert callback into url or form data
							if (jsonProp) {
								s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName)
							} else if (s.jsonp !== false) {
								s.url +=
									(rquery.test(s.url) ? "&" : "?") +
									s.jsonp +
									"=" +
									callbackName
							}

							// Use data converter to retrieve json after script execution
							s.converters["script json"] = function () {
								if (!responseContainer) {
									jQuery.error(callbackName + " was not called")
								}
								return responseContainer[0]
							}

							// Force json dataType
							s.dataTypes[0] = "json"

							// Install callback
							overwritten = window[callbackName]
							window[callbackName] = function () {
								responseContainer = arguments
							}

							// Clean-up function (fires after converters)
							jqXHR.always(function () {
								// If previous value didn't exist - remove it
								if (overwritten === undefined) {
									jQuery(window).removeProp(callbackName)

									// Otherwise restore preexisting value
								} else {
									window[callbackName] = overwritten
								}

								// Save back as free
								if (s[callbackName]) {
									// Make sure that re-using the options doesn't screw things around
									s.jsonpCallback = originalSettings.jsonpCallback

									// Save the callback name for future use
									oldCallbacks.push(callbackName)
								}

								// Call if it was a function and we have a response
								if (responseContainer && isFunction(overwritten)) {
									overwritten(responseContainer[0])
								}

								responseContainer = overwritten = undefined
							})

							// Delegate to script
							return "script"
						}
					})

					// Support: Safari 8 only
					// In Safari 8 documents created via document.implementation.createHTMLDocument
					// collapse sibling forms: the second one becomes a child of the first one.
					// Because of that, this security measure has to be disabled in Safari 8.
					// https://bugs.webkit.org/show_bug.cgi?id=137337
					support.createHTMLDocument = (function () {
						var body = document.implementation.createHTMLDocument("").body
						body.innerHTML = "<form></form><form></form>"
						return body.childNodes.length === 2
					})()

					// Argument "data" should be string of html
					// context (optional): If specified, the fragment will be created in this context,
					// defaults to document
					// keepScripts (optional): If true, will include scripts passed in the html string
					jQuery.parseHTML = function (data, context, keepScripts) {
						if (typeof data !== "string") {
							return []
						}
						if (typeof context === "boolean") {
							keepScripts = context
							context = false
						}

						var base, parsed, scripts

						if (!context) {
							// Stop scripts or inline event handlers from being executed immediately
							// by using document.implementation
							if (support.createHTMLDocument) {
								context = document.implementation.createHTMLDocument("")

								// Set the base href for the created document
								// so any parsed elements with URLs
								// are based on the document's URL (gh-2965)
								base = context.createElement("base")
								base.href = document.location.href
								context.head.appendChild(base)
							} else {
								context = document
							}
						}

						parsed = rsingleTag.exec(data)
						scripts = !keepScripts && []

						// Single tag
						if (parsed) {
							return [context.createElement(parsed[1])]
						}

						parsed = buildFragment([data], context, scripts)

						if (scripts && scripts.length) {
							jQuery(scripts).remove()
						}

						return jQuery.merge([], parsed.childNodes)
					}

					/**
					 * Load a url into a page
					 */
					jQuery.fn.load = function (url, params, callback) {
						var selector,
							type,
							response,
							self = this,
							off = url.indexOf(" ")

						if (off > -1) {
							selector = stripAndCollapse(url.slice(off))
							url = url.slice(0, off)
						}

						// If it's a function
						if (isFunction(params)) {
							// We assume that it's the callback
							callback = params
							params = undefined

							// Otherwise, build a param string
						} else if (params && typeof params === "object") {
							type = "POST"
						}

						// If we have elements to modify, make the request
						if (self.length > 0) {
							jQuery
								.ajax({
									url: url,

									// If "type" variable is undefined, then "GET" method will be used.
									// Make value of this field explicit since
									// user can override it through ajaxSetup method
									type: type || "GET",
									dataType: "html",
									data: params,
								})
								.done(function (responseText) {
									// Save response for use in complete callback
									response = arguments

									self.html(
										selector
											? // If a selector was specified, locate the right elements in a dummy div
											  // Exclude scripts to avoid IE 'Permission Denied' errors
											  jQuery("<div>")
													.append(jQuery.parseHTML(responseText))
													.find(selector)
											: // Otherwise use the full result
											  responseText,
									)

									// If the request succeeds, this function gets "data", "status", "jqXHR"
									// but they are ignored because response was set above.
									// If it fails, this function gets "jqXHR", "status", "error"
								})
								.always(
									callback &&
										function (jqXHR, status) {
											self.each(function () {
												callback.apply(
													this,
													response || [jqXHR.responseText, status, jqXHR],
												)
											})
										},
								)
						}

						return this
					}

					jQuery.expr.pseudos.animated = function (elem) {
						return jQuery.grep(jQuery.timers, function (fn) {
							return elem === fn.elem
						}).length
					}

					jQuery.offset = {
						setOffset: function (elem, options, i) {
							var curPosition,
								curLeft,
								curCSSTop,
								curTop,
								curOffset,
								curCSSLeft,
								calculatePosition,
								position = jQuery.css(elem, "position"),
								curElem = jQuery(elem),
								props = {}

							// Set position first, in-case top/left are set even on static elem
							if (position === "static") {
								elem.style.position = "relative"
							}

							curOffset = curElem.offset()
							curCSSTop = jQuery.css(elem, "top")
							curCSSLeft = jQuery.css(elem, "left")
							calculatePosition =
								(position === "absolute" || position === "fixed") &&
								(curCSSTop + curCSSLeft).indexOf("auto") > -1

							// Need to be able to calculate position if either
							// top or left is auto and position is either absolute or fixed
							if (calculatePosition) {
								curPosition = curElem.position()
								curTop = curPosition.top
								curLeft = curPosition.left
							} else {
								curTop = parseFloat(curCSSTop) || 0
								curLeft = parseFloat(curCSSLeft) || 0
							}

							if (isFunction(options)) {
								// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
								options = options.call(elem, i, jQuery.extend({}, curOffset))
							}

							if (options.top != null) {
								props.top = options.top - curOffset.top + curTop
							}
							if (options.left != null) {
								props.left = options.left - curOffset.left + curLeft
							}

							if ("using" in options) {
								options.using.call(elem, props)
							} else {
								if (typeof props.top === "number") {
									props.top += "px"
								}
								if (typeof props.left === "number") {
									props.left += "px"
								}
								curElem.css(props)
							}
						},
					}

					jQuery.fn.extend({
						// offset() relates an element's border box to the document origin
						offset: function (options) {
							// Preserve chaining for setter
							if (arguments.length) {
								return options === undefined
									? this
									: this.each(function (i) {
											jQuery.offset.setOffset(this, options, i)
									  })
							}

							var rect,
								win,
								elem = this[0]

							if (!elem) {
								return
							}

							// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
							// Support: IE <=11 only
							// Running getBoundingClientRect on a
							// disconnected node in IE throws an error
							if (!elem.getClientRects().length) {
								return { top: 0, left: 0 }
							}

							// Get document-relative position by adding viewport scroll to viewport-relative gBCR
							rect = elem.getBoundingClientRect()
							win = elem.ownerDocument.defaultView
							return {
								top: rect.top + win.pageYOffset,
								left: rect.left + win.pageXOffset,
							}
						},

						// position() relates an element's margin box to its offset parent's padding box
						// This corresponds to the behavior of CSS absolute positioning
						position: function () {
							if (!this[0]) {
								return
							}

							var offsetParent,
								offset,
								doc,
								elem = this[0],
								parentOffset = { top: 0, left: 0 }

							// position:fixed elements are offset from the viewport, which itself always has zero offset
							if (jQuery.css(elem, "position") === "fixed") {
								// Assume position:fixed implies availability of getBoundingClientRect
								offset = elem.getBoundingClientRect()
							} else {
								offset = this.offset()

								// Account for the *real* offset parent, which can be the document or its root element
								// when a statically positioned element is identified
								doc = elem.ownerDocument
								offsetParent = elem.offsetParent || doc.documentElement
								while (
									offsetParent &&
									(offsetParent === doc.body ||
										offsetParent === doc.documentElement) &&
									jQuery.css(offsetParent, "position") === "static"
								) {
									offsetParent = offsetParent.parentNode
								}
								if (
									offsetParent &&
									offsetParent !== elem &&
									offsetParent.nodeType === 1
								) {
									// Incorporate borders into its offset, since they are outside its content origin
									parentOffset = jQuery(offsetParent).offset()
									parentOffset.top += jQuery.css(
										offsetParent,
										"borderTopWidth",
										true,
									)
									parentOffset.left += jQuery.css(
										offsetParent,
										"borderLeftWidth",
										true,
									)
								}
							}

							// Subtract parent offsets and element margins
							return {
								top:
									offset.top -
									parentOffset.top -
									jQuery.css(elem, "marginTop", true),
								left:
									offset.left -
									parentOffset.left -
									jQuery.css(elem, "marginLeft", true),
							}
						},

						// This method will return documentElement in the following cases:
						// 1) For the element inside the iframe without offsetParent, this method will return
						//    documentElement of the parent window
						// 2) For the hidden or detached element
						// 3) For body or html element, i.e. in case of the html node - it will return itself
						//
						// but those exceptions were never presented as a real life use-cases
						// and might be considered as more preferable results.
						//
						// This logic, however, is not guaranteed and can change at any point in the future
						offsetParent: function () {
							return this.map(function () {
								var offsetParent = this.offsetParent

								while (
									offsetParent &&
									jQuery.css(offsetParent, "position") === "static"
								) {
									offsetParent = offsetParent.offsetParent
								}

								return offsetParent || documentElement
							})
						},
					})

					// Create scrollLeft and scrollTop methods
					jQuery.each(
						{ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
						function (method, prop) {
							var top = "pageYOffset" === prop

							jQuery.fn[method] = function (val) {
								return access(
									this,
									function (elem, method, val) {
										// Coalesce documents and windows
										var win
										if (isWindow(elem)) {
											win = elem
										} else if (elem.nodeType === 9) {
											win = elem.defaultView
										}

										if (val === undefined) {
											return win ? win[prop] : elem[method]
										}

										if (win) {
											win.scrollTo(
												!top ? val : win.pageXOffset,
												top ? val : win.pageYOffset,
											)
										} else {
											elem[method] = val
										}
									},
									method,
									val,
									arguments.length,
								)
							}
						},
					)

					// Support: Safari <=7 - 9.1, Chrome <=37 - 49
					// Add the top/left cssHooks using jQuery.fn.position
					// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
					// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
					// getComputedStyle returns percent when specified for top/left/bottom/right;
					// rather than make the css module depend on the offset module, just check for it here
					jQuery.each(["top", "left"], function (_i, prop) {
						jQuery.cssHooks[prop] = addGetHookIf(
							support.pixelPosition,
							function (elem, computed) {
								if (computed) {
									computed = curCSS(elem, prop)

									// If curCSS returns percentage, fallback to offset
									return rnumnonpx.test(computed)
										? jQuery(elem).position()[prop] + "px"
										: computed
								}
							},
						)
					})

					// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
					jQuery.each({ Height: "height", Width: "width" }, function (
						name,
						type,
					) {
						jQuery.each(
							{ padding: "inner" + name, content: type, "": "outer" + name },
							function (defaultExtra, funcName) {
								// Margin is only for outerHeight, outerWidth
								jQuery.fn[funcName] = function (margin, value) {
									var chainable =
											arguments.length &&
											(defaultExtra || typeof margin !== "boolean"),
										extra =
											defaultExtra ||
											(margin === true || value === true ? "margin" : "border")

									return access(
										this,
										function (elem, type, value) {
											var doc

											if (isWindow(elem)) {
												// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
												return funcName.indexOf("outer") === 0
													? elem["inner" + name]
													: elem.document.documentElement["client" + name]
											}

											// Get document width or height
											if (elem.nodeType === 9) {
												doc = elem.documentElement

												// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
												// whichever is greatest
												return Math.max(
													elem.body["scroll" + name],
													doc["scroll" + name],
													elem.body["offset" + name],
													doc["offset" + name],
													doc["client" + name],
												)
											}

											return value === undefined
												? // Get width or height on the element, requesting but not forcing parseFloat
												  jQuery.css(elem, type, extra)
												: // Set width or height on the element
												  jQuery.style(elem, type, value, extra)
										},
										type,
										chainable ? margin : undefined,
										chainable,
									)
								}
							},
						)
					})

					jQuery.each(
						[
							"ajaxStart",
							"ajaxStop",
							"ajaxComplete",
							"ajaxError",
							"ajaxSuccess",
							"ajaxSend",
						],
						function (_i, type) {
							jQuery.fn[type] = function (fn) {
								return this.on(type, fn)
							}
						},
					)

					jQuery.fn.extend({
						bind: function (types, data, fn) {
							return this.on(types, null, data, fn)
						},
						unbind: function (types, fn) {
							return this.off(types, null, fn)
						},

						delegate: function (selector, types, data, fn) {
							return this.on(types, selector, data, fn)
						},
						undelegate: function (selector, types, fn) {
							// ( namespace ) or ( selector, types [, fn] )
							return arguments.length === 1
								? this.off(selector, "**")
								: this.off(types, selector || "**", fn)
						},

						hover: function (fnOver, fnOut) {
							return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
						},
					})

					jQuery.each(
						(
							"blur focus focusin focusout resize scroll click dblclick " +
							"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
							"change select submit keydown keypress keyup contextmenu"
						).split(" "),
						function (_i, name) {
							// Handle event binding
							jQuery.fn[name] = function (data, fn) {
								return arguments.length > 0
									? this.on(name, null, data, fn)
									: this.trigger(name)
							}
						},
					)

					// Support: Android <=4.0 only
					// Make sure we trim BOM and NBSP
					var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g

					// Bind a function to a context, optionally partially applying any
					// arguments.
					// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
					// However, it is not slated for removal any time soon
					jQuery.proxy = function (fn, context) {
						var tmp, args, proxy

						if (typeof context === "string") {
							tmp = fn[context]
							context = fn
							fn = tmp
						}

						// Quick check to determine if target is callable, in the spec
						// this throws a TypeError, but we will just return undefined.
						if (!isFunction(fn)) {
							return undefined
						}

						// Simulated bind
						args = slice.call(arguments, 2)
						proxy = function () {
							return fn.apply(
								context || this,
								args.concat(slice.call(arguments)),
							)
						}

						// Set the guid of unique handler to the same of original handler, so it can be removed
						proxy.guid = fn.guid = fn.guid || jQuery.guid++

						return proxy
					}

					jQuery.holdReady = function (hold) {
						if (hold) {
							jQuery.readyWait++
						} else {
							jQuery.ready(true)
						}
					}
					jQuery.isArray = Array.isArray
					jQuery.parseJSON = JSON.parse
					jQuery.nodeName = nodeName
					jQuery.isFunction = isFunction
					jQuery.isWindow = isWindow
					jQuery.camelCase = camelCase
					jQuery.type = toType

					jQuery.now = Date.now

					jQuery.isNumeric = function (obj) {
						// As of jQuery 3.0, isNumeric is limited to
						// strings and numbers (primitives or objects)
						// that can be coerced to finite numbers (gh-2662)
						var type = jQuery.type(obj)
						return (
							(type === "number" || type === "string") &&
							// parseFloat NaNs numeric-cast false positives ("")
							// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
							// subtraction forces infinities to NaN
							!isNaN(obj - parseFloat(obj))
						)
					}

					jQuery.trim = function (text) {
						return text == null ? "" : (text + "").replace(rtrim, "")
					}

					// Register as a named AMD module, since jQuery can be concatenated with other
					// files that may use define, but not via a proper concatenation script that
					// understands anonymous AMD modules. A named AMD is safest and most robust
					// way to register. Lowercase jquery is used because AMD module names are
					// derived from file names, and jQuery is normally delivered in a lowercase
					// file name. Do this after creating the global so that if an AMD module wants
					// to call noConflict to hide this version of jQuery, it will work.

					// Note that for maximum portability, libraries that are not jQuery should
					// declare themselves as anonymous modules, and avoid setting a global if an
					// AMD loader is present. jQuery is a special case. For more information, see
					// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

					if (true) {
						!((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
						(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
							return jQuery
						}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
							(module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
					}

					var // Map over jQuery in case of overwrite
						_jQuery = window.jQuery,
						// Map over the $ in case of overwrite
						_$ = window.$

					jQuery.noConflict = function (deep) {
						if (window.$ === jQuery) {
							window.$ = _$
						}

						if (deep && window.jQuery === jQuery) {
							window.jQuery = _jQuery
						}

						return jQuery
					}

					// Expose jQuery and $ identifiers, even in AMD
					// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
					// and CommonJS for browser emulators (#13566)
					if (typeof noGlobal === "undefined") {
						window.jQuery = window.$ = jQuery
					}

					return jQuery
				})

				/***/
			},

		/***/ "./node_modules/.pnpm/style-loader@1.2.1_webpack@4.43.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
			/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/style-loader@1.2.1_webpack@4.43.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \*********************************************************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				"use strict"

				var isOldIE = (function isOldIE() {
					var memo
					return function memorize() {
						if (typeof memo === "undefined") {
							// Test for IE <= 9 as proposed by Browserhacks
							// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
							// Tests for existence of standard globals is to allow style-loader
							// to operate correctly into non-standard environments
							// @see https://github.com/webpack-contrib/style-loader/issues/177
							memo = Boolean(window && document && document.all && !window.atob)
						}

						return memo
					}
				})()

				var getTarget = (function getTarget() {
					var memo = {}
					return function memorize(target) {
						if (typeof memo[target] === "undefined") {
							var styleTarget = document.querySelector(target) // Special case to return head of iframe instead of iframe itself

							if (
								window.HTMLIFrameElement &&
								styleTarget instanceof window.HTMLIFrameElement
							) {
								try {
									// This will throw an exception if access to iframe is blocked
									// due to cross-origin restrictions
									styleTarget = styleTarget.contentDocument.head
								} catch (e) {
									// istanbul ignore next
									styleTarget = null
								}
							}

							memo[target] = styleTarget
						}

						return memo[target]
					}
				})()

				var stylesInDom = []

				function getIndexByIdentifier(identifier) {
					var result = -1

					for (var i = 0; i < stylesInDom.length; i++) {
						if (stylesInDom[i].identifier === identifier) {
							result = i
							break
						}
					}

					return result
				}

				function modulesToDom(list, options) {
					var idCountMap = {}
					var identifiers = []

					for (var i = 0; i < list.length; i++) {
						var item = list[i]
						var id = options.base ? item[0] + options.base : item[0]
						var count = idCountMap[id] || 0
						var identifier = "".concat(id, " ").concat(count)
						idCountMap[id] = count + 1
						var index = getIndexByIdentifier(identifier)
						var obj = {
							css: item[1],
							media: item[2],
							sourceMap: item[3],
						}

						if (index !== -1) {
							stylesInDom[index].references++
							stylesInDom[index].updater(obj)
						} else {
							stylesInDom.push({
								identifier: identifier,
								updater: addStyle(obj, options),
								references: 1,
							})
						}

						identifiers.push(identifier)
					}

					return identifiers
				}

				function insertStyleElement(options) {
					var style = document.createElement("style")
					var attributes = options.attributes || {}

					if (typeof attributes.nonce === "undefined") {
						var nonce = true ? __webpack_require__.nc : undefined

						if (nonce) {
							attributes.nonce = nonce
						}
					}

					Object.keys(attributes).forEach(function (key) {
						style.setAttribute(key, attributes[key])
					})

					if (typeof options.insert === "function") {
						options.insert(style)
					} else {
						var target = getTarget(options.insert || "head")

						if (!target) {
							throw new Error(
								"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.",
							)
						}

						target.appendChild(style)
					}

					return style
				}

				function removeStyleElement(style) {
					// istanbul ignore if
					if (style.parentNode === null) {
						return false
					}

					style.parentNode.removeChild(style)
				}
				/* istanbul ignore next  */

				var replaceText = (function replaceText() {
					var textStore = []
					return function replace(index, replacement) {
						textStore[index] = replacement
						return textStore.filter(Boolean).join("\n")
					}
				})()

				function applyToSingletonTag(style, index, remove, obj) {
					var css = remove
						? ""
						: obj.media
						? "@media ".concat(obj.media, " {").concat(obj.css, "}")
						: obj.css // For old IE

					/* istanbul ignore if  */

					if (style.styleSheet) {
						style.styleSheet.cssText = replaceText(index, css)
					} else {
						var cssNode = document.createTextNode(css)
						var childNodes = style.childNodes

						if (childNodes[index]) {
							style.removeChild(childNodes[index])
						}

						if (childNodes.length) {
							style.insertBefore(cssNode, childNodes[index])
						} else {
							style.appendChild(cssNode)
						}
					}
				}

				function applyToTag(style, options, obj) {
					var css = obj.css
					var media = obj.media
					var sourceMap = obj.sourceMap

					if (media) {
						style.setAttribute("media", media)
					} else {
						style.removeAttribute("media")
					}

					if (sourceMap && btoa) {
						css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(
							btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))),
							" */",
						)
					} // For old IE

					/* istanbul ignore if  */

					if (style.styleSheet) {
						style.styleSheet.cssText = css
					} else {
						while (style.firstChild) {
							style.removeChild(style.firstChild)
						}

						style.appendChild(document.createTextNode(css))
					}
				}

				var singleton = null
				var singletonCounter = 0

				function addStyle(obj, options) {
					var style
					var update
					var remove

					if (options.singleton) {
						var styleIndex = singletonCounter++
						style = singleton || (singleton = insertStyleElement(options))
						update = applyToSingletonTag.bind(null, style, styleIndex, false)
						remove = applyToSingletonTag.bind(null, style, styleIndex, true)
					} else {
						style = insertStyleElement(options)
						update = applyToTag.bind(null, style, options)

						remove = function remove() {
							removeStyleElement(style)
						}
					}

					update(obj)
					return function updateStyle(newObj) {
						if (newObj) {
							if (
								newObj.css === obj.css &&
								newObj.media === obj.media &&
								newObj.sourceMap === obj.sourceMap
							) {
								return
							}

							update((obj = newObj))
						} else {
							remove()
						}
					}
				}

				module.exports = function (list, options) {
					options = options || {} // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
					// tags it will allow on a page

					if (!options.singleton && typeof options.singleton !== "boolean") {
						options.singleton = isOldIE()
					}

					list = list || []
					var lastIdentifiers = modulesToDom(list, options)
					return function update(newList) {
						newList = newList || []

						if (Object.prototype.toString.call(newList) !== "[object Array]") {
							return
						}

						for (var i = 0; i < lastIdentifiers.length; i++) {
							var identifier = lastIdentifiers[i]
							var index = getIndexByIdentifier(identifier)
							stylesInDom[index].references--
						}

						var newLastIdentifiers = modulesToDom(newList, options)

						for (var _i = 0; _i < lastIdentifiers.length; _i++) {
							var _identifier = lastIdentifiers[_i]

							var _index = getIndexByIdentifier(_identifier)

							if (stylesInDom[_index].references === 0) {
								stylesInDom[_index].updater()

								stylesInDom.splice(_index, 1)
							}
						}

						lastIdentifiers = newLastIdentifiers
					}
				}

				/***/
			},

		/***/ "./src/_css/images/workdayplanner1.jpg":
			/*!*********************************************!*\
  !*** ./src/_css/images/workdayplanner1.jpg ***!
  \*********************************************/
			/*! no static exports found */
			/***/ function (module, exports) {
				module.exports =
					"data:image/jpeg;base64,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"

				/***/
			},

		/***/ "./src/_css/style.css":
			/*!****************************!*\
  !*** ./src/_css/style.css ***!
  \****************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				var api = __webpack_require__(
					/*! ../../node_modules/.pnpm/style-loader@1.2.1_webpack@4.43.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/.pnpm/style-loader@1.2.1_webpack@4.43.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js",
				)
				var content = __webpack_require__(
					/*! !../../node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader??ref--5-1!./style.css */ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/index.js?!./src/_css/style.css",
				)

				content = content.__esModule ? content.default : content

				if (typeof content === "string") {
					content = [[module.i, content, ""]]
				}

				var options = {}

				options.insert = "head"
				options.singleton = false

				var update = api(content, options)

				module.exports = content.locals || {}

				/***/
			},

		/***/ "./src/_js/index.js":
			/*!**************************!*\
  !*** ./src/_js/index.js ***!
  \**************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				"use strict"

				var _jquery = __webpack_require__(
					/*! jquery */ "./node_modules/.pnpm/jquery@3.5.1/node_modules/jquery/dist/jquery.js",
				)

				var _jquery2 = _interopRequireDefault(_jquery)

				__webpack_require__(/*! ../_css/style.css */ "./src/_css/style.css")

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj }
				}

				// start..
				var activeSession = (0, _jquery2.default)("#mainContentContainer").data(
					"received-session",
				)

				if (activeSession) {
					// hide when signed in
					;(0, _jquery2.default)("#nav-signup-link").hide()
					;(0, _jquery2.default)("#nav-login-link").hide()

					// show when signed in
					;(0, _jquery2.default)("#nav-logout-link").show()
					;(0, _jquery2.default)("#nav-dashboard-link").show()
				}

				/***/
			},

		/******/
	},
)
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL19jc3Mvc3R5bGUuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3MtbG9hZGVyQDAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3MtbG9hZGVyQDAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2pxdWVyeUAzLjUuMS9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHlsZS1sb2FkZXJAMS4yLjFfd2VicGFja0A0LjQzLjAvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovLy8uL3NyYy9fY3NzL2ltYWdlcy93b3JrZGF5cGxhbm5lcjEuanBnIiwid2VicGFjazovLy8uL3NyYy9fY3NzL3N0eWxlLmNzcz9jYzU3Iiwid2VicGFjazovLy8uL3NyYy9fanMvaW5kZXguanMiXSwibmFtZXMiOlsiYWN0aXZlU2Vzc2lvbiIsImRhdGEiLCJoaWRlIiwic2hvdyJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFD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QUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7O0FBRWxFO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sS0FBMEI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRiw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtB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O0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHNDQUFzQztBQUM5QyxRQUFRO0FBQ1IsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0Usc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFVBQVUsNENBQTRDO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxjQUFjLHFDQUFxQztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw4QkFBOEI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWMsV0FBVztBQUN4RSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLHNCQUFzQixjQUFjLHNCQUFzQixnQkFBZ0I7QUFDMUUsZ0JBQWdCLFdBQVcsWUFBWTtBQUN2QyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLGFBQWE7O0FBRWI7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxlQUFlLDZEQUE2RDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUssSUFBMEM7QUFDL0MsQ0FBQyxpQ0FBa0IsRUFBRSxtQ0FBRTtBQUN2QjtBQUNBLEVBQUU7QUFBQSxvR0FBRTtBQUNKOzs7OztBQUtBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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IFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL19qcy9pbmRleC5qc1wiKTtcbiIsInZhciBlc2NhcGUgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nzcy1sb2FkZXJAMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qc1wiKTtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3NzLWxvYWRlckAwLjI4LjExL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiBAaW1wb3J0IFxcXCIuL2dsb2JhbC9yZXNldC5jc3NcXFwiOyAqL1xcblxcbmh0bWwge1xcblxcdG1pbi1oZWlnaHQ6IDEwMCU7XFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG5ib2R5IHtcXG5cXHRtYXJnaW4tYm90dG9tOiA2MHB4O1xcbn1cXG5cXG4qIHtcXG5cXHRmb250LWZhbWlseTpcXG5cXHRcXHQtYXBwbGUtc3lzdGVtLFxcblxcdFxcdEJsaW5rTWFjU3lzdGVtRm9udCxcXG5cXHRcXHRcXFwiU2Vnb2UgVUlcXFwiLFxcblxcdFxcdFJvYm90byxcXG5cXHRcXHRPeHlnZW4sXFxuXFx0XFx0VWJ1bnR1LFxcblxcdFxcdENhbnRhcmVsbCxcXG5cXHRcXHRcXFwiT3BlbiBTYW5zXFxcIixcXG5cXHRcXHRcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLFxcblxcdFxcdHNhbnMtc2VyaWY7XFxufVxcblxcbjpyb290IHtcXG5cXHQtLW9yYW5nZTogI2ZmNzgzYTtcXG5cXHQtLWJhY2tncm91bmRjb2xvcjogI2Y3ZjdmNyAhaW1wb3J0YW50O1xcblxcdC0tYmxhY2s6ICMwNzA3MDcgIWltcG9ydGFudDtcXG5cXHQtLWJsYWNrLWZhZGVkLTE6ICMwNzA3MDdjNyAhaW1wb3J0YW50O1xcblxcdC0td2hpdGU6ICNmNGY0ZjQgIWltcG9ydGFudDtcXG5cXHQtLXdoaXRlLWZhZGVkLTE6ICNmNGY0ZjRlMCAhaW1wb3J0YW50O1xcblxcdC0tZ3JheTogI2E3YTdhNyAhaW1wb3J0YW50O1xcblxcdC0tbGluay1ibHVlOiAjMDA3YmZmICFpbXBvcnRhbnQ7XFxuXFx0LS1jb2xvci1wYXN0OiAjNzk3OTc5ICFpbXBvcnRhbnQ7XFxuXFx0LS1jb2xvci1jdXJyZW50OiAjYjdiN2I3ICFpbXBvcnRhbnQ7XFxuXFx0LS1jb2xvci1mdXR1cmU6ICM1OWMwNDQgIWltcG9ydGFudDtcXG59XFxuXFxuaGVhZGVyIHtcXG5cXHRiYWNrZ3JvdW5kOiB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vaW1hZ2VzL3dvcmtkYXlwbGFubmVyMS5qcGdcIikpICsgXCIpO1xcblxcdGJhY2tncm91bmQtcG9zaXRpb246IDAlIDAlO1xcblxcdGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuXFx0bWluLWhlaWdodDogMzY5cHg7XFxufVxcblxcbmhlYWRlciA+IC5jb250YWluZXIge1xcblxcdGJhY2tncm91bmQ6IHZhcigtLXdoaXRlLWZhZGVkLTEpO1xcblxcdGNvbG9yOiB2YXIoLS1ibGFjayk7XFxufVxcblxcbmhlYWRlciBoMSxcXG5oZWFkZXIgcCB7XFxuXFx0bWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuXFxuYmxvY2txdW90ZSB7XFxuXFx0bWFyZ2luLWJvdHRvbTogMC41cmVtO1xcblxcdHBhZGRpbmctdG9wOiAxcmVtO1xcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuZm9ybSNzaWdudXAsXFxuZm9ybSNsb2dpbiB7XFxuXFx0bWFyZ2luOiBhdXRvO1xcbn1cXG5cXG5mb3JtI2RlbW8tbG9naW4ge1xcblxcdGZvbnQtc2l6ZTogMTJweDtcXG5cXHRtYXJnaW46IGF1dG87XFxuXFx0bWFyZ2luLXRvcDogM3JlbTtcXG59XFxuXFxuI2Jsb2NrcXVvdGVCb2R5IHtcXG5cXHR0ZXh0LWFsaWduOiBqdXN0aWZ5O1xcbn1cXG5cXG4jcHJvZmlsZS1oZWFkZXItcm93IHtcXG5cXHRsaW5lLWhlaWdodDogMzJweDtcXG5cXHRwYWRkaW5nOiA2cmVtIDFyZW07XFxufVxcblxcbi5sb2dpbi1jb250YWluZXIsXFxuLnNpZ251cC1jb250YWluZXIge1xcblxcdG1hcmdpbi10b3A6IDIuNjVyZW07XFxufVxcblxcbi50ZXh0LWRhdGUge1xcblxcdGNvbG9yOiB2YXIoLS1vcmFuZ2UpO1xcblxcdGZvbnQtc2l6ZTogMS43cmVtO1xcblxcdGZvbnQtd2VpZ2h0OiA3MDA7XFxuXFx0d29yZC13cmFwOiBicmVhay13b3JkO1xcbn1cXG5cXG4uYmctcGFzdCB7XFxuXFx0YmFja2dyb3VuZDogdmFyKC0tY29sb3ItcGFzdCk7XFxuXFx0Y29sb3I6IHZhcigtLXdoaXRlLWZhZGVkLTEpO1xcbn1cXG5cXG4uYmctY3VycmVudCB7XFxuXFx0YmFja2dyb3VuZDogdmFyKC0tY29sb3ItY3VycmVudCk7XFxufVxcblxcbi5iZy1mdXR1cmUge1xcblxcdGJhY2tncm91bmQ6IHZhcigtLWNvbG9yLWZ1dHVyZSk7XFxufVxcblxcbi5iZy1ncmF5IHtcXG5cXHRiYWNrZ3JvdW5kOiAjZGJkYmRiO1xcbn1cXG5cXG4uZm9vdGVyIHtcXG5cXG5cXHQvKiBWZXJ0aWNhbGx5IGNlbnRlciB0aGUgdGV4dCB0aGVyZSAqL1xcblxcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJhY2tncm91bmRjb2xvcik7XFxuXFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkICMwMDA7XFxuXFx0Ym90dG9tOiAwO1xcblxcdGhlaWdodDogMzBweDtcXG5cXHRsZWZ0OiAwO1xcblxcblxcdC8qIFNldCB0aGUgZml4ZWQgaGVpZ2h0IG9mIHRoZSBmb290ZXIgaGVyZSAqL1xcblxcdGxpbmUtaGVpZ2h0OiAxNTBweDtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0cmlnaHQ6IDA7XFxuXFx0d2lkdGg6IDEwMCU7XFxufVxcblxcbi5saW5rLWJ1dHRvbiB7XFxuXFx0YmFja2dyb3VuZDogbm9uZTtcXG5cXHRib3JkZXI6IG5vbmU7XFxuXFx0Y29sb3I6IHZhcigtLWxpbmstYmx1ZSk7XFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcblxcdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuLmxpbmstYnV0dG9uOmZvY3VzIHtcXG5cXHRvdXRsaW5lOiBub25lO1xcbn1cXG5cXG4uZGlzYWJsZS1jbGljayB7XFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi50aW1lU2xvdFJvdyB7XFxuXFx0aGVpZ2h0OiA3MHB4O1xcbn1cXG5cXG4udGltZS1kaXNwbGF5IHtcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgIzg4ODtcXG5cXHRwYWRkaW5nLXRvcDogMC41cmVtO1xcbn1cXG5cXG4ubm90ZS1zbG90cyB7XFxuXFx0Ym9yZGVyOiBub25lO1xcblxcdGhlaWdodDogNTBweDtcXG5cXHRoZWlnaHQ6IDEwMCU7XFxuXFx0cGFkZGluZy1sZWZ0OiAwLjI1cmVtO1xcblxcdHJlc2l6ZTogbm9uZTtcXG59XFxuXFxuLmZhLXNhdmUge1xcblxcdGZvbnQtc2l6ZTogMThweDtcXG59XFxuXFxuLmNoZXZyb25zOmhvdmVyIHtcXG5cXHRiYWNrZ3JvdW5kOiAjMjkyYjJjMzQ7XFxuXFxuXFx0Lyogb3BhY2l0eTogLjI7ICovXFxufVxcblxcbi8qIFRoZSBNb2RhbCAoYmFja2dyb3VuZCkgKi9cXG5cXG4ubW9kYWwge1xcblxcblxcdC8qIEVuYWJsZSBzY3JvbGwgaWYgbmVlZGVkICovXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYmxhY2spO1xcblxcblxcdC8qIEZhbGxiYWNrIGNvbG9yICovXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYmxhY2stZmFkZWQtMSk7XFxuXFx0ZGlzcGxheTogbm9uZTtcXG5cXG5cXHQvKiBGdWxsIHdpZHRoICovXFxuXFx0aGVpZ2h0OiAxMDAlO1xcblxcblxcdC8qIExvY2F0aW9uIG9mIHRoZSBib3ggKi9cXG5cXHRsZWZ0OiAwO1xcblxcblxcdC8qIEZ1bGwgaGVpZ2h0ICovXFxuXFx0b3ZlcmZsb3c6IGF1dG87XFxuXFxuXFx0LyogU2l0IG9uIHRvcCAqL1xcblxcdHBhZGRpbmctdG9wOiAxMDBweDtcXG5cXG5cXHQvKiBIaWRkZW4gYnkgZGVmYXVsdCAqL1xcblxcdHBvc2l0aW9uOiBmaXhlZDtcXG5cXHR0b3A6IDA7XFxuXFx0d2lkdGg6IDEwMCU7XFxuXFxuXFx0LyogU3RheSBpbiBwbGFjZSAqL1xcblxcdHotaW5kZXg6IDE7XFxuXFxuXFx0LyogQmxhY2sgdy8gb3BhY2l0eSAqL1xcbn1cXG5cXG4vKiBNb2RhbCBDb250ZW50ICovXFxuXFxuLnNldHRpbmdzLW1vZGFsLWNvbnRlbnQge1xcblxcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJhY2tncm91bmRjb2xvcik7XFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzg4ODtcXG5cXHRtYXJnaW46IGF1dG87XFxuXFx0cGFkZGluZzogMjBweDtcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxuXFx0d2lkdGg6IDY4JTtcXG59XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNTc2cHgpIHtcXG5cXG5cXHQubW9kYWwtY29udGVudCB7XFxuXFx0XFx0Zm9udC1zaXplOiBzbWFsbDtcXG5cXHRcXHRwYWRkaW5nOiAyMHB4O1xcblxcdFxcdHdpZHRoOiAxMDAlO1xcblxcdH1cXG59XFxuXFxuLyogVGhlIENsb3NlIEJ1dHRvbiAqL1xcblxcbi5jbG9zZSB7XFxuXFx0Y29sb3I6IHZhcigtLWdyYXkpO1xcblxcdGZsb2F0OiByaWdodDtcXG5cXHRmb250LXNpemU6IDhweDtcXG5cXHRmb250LXdlaWdodDogNjAwO1xcbn1cXG5cXG4ubW9kYWwtc2F2ZS1idXR0b24ge1xcblxcdGJhY2tncm91bmQ6ICMwMDg0ZmZkYTtcXG5cXHRtYXJnaW4tdG9wOiAwLjI1ZW07XFxuXFxuXFx0LyogZmxvYXQ6IHJpZ2h0OyAqL1xcblxcdHBhZGRpbmc6IDAuNWVtIDFlbTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUodXJsKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICB9XG4gICAgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG4gICAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICAgIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICsgJ1wiJ1xuICAgIH1cblxuICAgIHJldHVybiB1cmxcbn1cbiIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My41LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIwLTA1LTA0VDIyOjQ5WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuZmxhdC5jYWxsKCBhcnJheSApO1xufSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xufTtcblxuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjUuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGZsYXQoIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNVxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAyMC0wMy0xNFxuICovXG4oIGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoIHt9ICkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoTmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0WyBpIF0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxcIiArXG5cdFx0XCJpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaWRlbnQtdG9rZW4tZGlhZ3JhbVxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxuXHRcdC8vIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblxuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKCAxICkgLSAweDEwMDAwO1xuXG5cdFx0cmV0dXJuIG5vbkhleCA/XG5cblx0XHRcdC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuXHRcdFx0bm9uSGV4IDpcblxuXHRcdFx0Ly8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHRcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHRcdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgK1xuXHRcdFx0XHRjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KCBhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApICksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggZWxzICkgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICggdGFyZ2V0WyBqKysgXSA9IGVsc1sgaSsrIF0gKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAoIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAoIG0gPSBtYXRjaFsgMSBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSApICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOCBvbmx5XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdCggbm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcblx0XHRcdFx0Ly8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCByY29tYmluYXRvcnMudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHN1cHBvcnRzIGl0ICYgaWYgd2UncmUgbm90IGNoYW5naW5nIHRoZSBjb250ZXh0LlxuXHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAhPT0gY29udGV4dCB8fCAhc3VwcG9ydC5zY29wZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKCBuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbIGkgXSA9ICggbmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdHRvU2VsZWN0b3IoIGdyb3Vwc1sgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoIFwifFwiICksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbIGkgXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5uZXh0U2libGluZyApICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuICggbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcblx0XHRcdFx0XHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5hbWVzcGFjZSA9IGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdGRvY0VsZW0gPSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXG5cdC8vIFNhZmFyaSA0IC0gNSBvbmx5LCBPcGVyYSA8PTExLjYgLSAxMi54IG9ubHlcblx0Ly8gSUUvRWRnZSAmIG9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxuXHQvLyBTYWZhcmkgNi4wIHN1cHBvcnRzIDpzY29wZSBidXQgaXQncyBhbiBhbGlhcyBvZiA6cm9vdCB0aGVyZS5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXHRcdHJldHVybiB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0IWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKCBcImNsYXNzTmFtZVwiICk7XG5cdH0gKTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggXCJcIiApICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFsgXCJUQUdcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbIFwiQ0xBU1NcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoICggc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSApICkge1xuXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHR2YXIgaW5wdXQ7XG5cblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlttc2FsbG93Y2FwdHVyZV49JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XG5cdFx0XHQvLyBPbGQgRmlyZWZveCBkb2Vzbid0IHRocm93IG9uIGEgYmFkbHktZXNjYXBlZCBpZGVudGlmaWVyLlxuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCJcXFxcXFxmXCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIltcXFxcclxcXFxuXFxcXGZdXCIgKTtcblx0XHR9ICk7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmVuYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IE9wZXJhIDEwIC0gMTEgb25seVxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKiw6eFwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIsLio6XCIgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoICggbWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yICkgKSApICkge1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSApO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoICggYiA9IGIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbIGkgXSA9PT0gYnBbIGkgXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFsgaSBdLCBicFsgaSBdICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdGFwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fFxuXHRcdFx0XHRtYXRjaFsgNSBdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByWyBcIkNISUxEXCIgXS50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcdFx0XCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJiBjbGFzc0NhY2hlKFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG5cdFx0XHRcdCggIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkgKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1sgXCJlbXB0eVwiIF0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1sgXCJudGhcIiBdID0gRXhwci5wc2V1ZG9zWyBcImVxXCIgXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhcblx0XHRcdFx0c2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsXG5cdFx0XHRcdFtdXG5cdFx0XHQpLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdHRva2Vuc1xuXHRcdFx0XHRcdFx0LnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kWyBcIlRBR1wiIF0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKFxuXHRcdFx0c2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKVxuXHRcdCk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFsgXCJJRFwiIF0oIHRva2VuLm1hdGNoZXNbIDAgXVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbIFwibmVlZHNDb250ZXh0XCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIiNcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgX25hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT0gbnVsbDtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0gKTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSApKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxuXHRcdFx0Ly8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG5cdFx0XHRnZXRQcm90byggZWxlbS5jb250ZW50RG9jdW1lbnQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBfaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblx0XHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuXHRcdFx0aGFuZGxlcnMgPSAoXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRlc3QsIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBmbGF0KCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEJlaGF2aW9yIGluIElFIDkgaXMgbW9yZSBzdWJ0bGUgdGhhbiBpbiBuZXdlciB2ZXJzaW9ucyAmIGl0IHBhc3Nlc1xuXHRcdC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuXHRcdFx0aWYgKCByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGFibGVcIiApO1xuXHRcdFx0XHR0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidHJcIiApO1xuXHRcdFx0XHR0ckNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdFx0XHRcdHRhYmxlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHhcIjtcblx0XHRcdFx0dHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSBwYXJzZUludCggdHJTdHlsZS5oZWlnaHQgKSA+IDM7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJncmlkQXJlYVwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtbkVuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG5cdFx0XCJncmlkUm93XCI6IHRydWUsXG5cdFx0XCJncmlkUm93RW5kXCI6IHRydWUsXG5cdFx0XCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKFxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG5cdFx0XHRcdC8vICh2aWEgYHRoaXMuZG9jdW1lbnRgKSAmIGRvY3VtZW50ICh2aWEgYHRoaXNgKS5cblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZS5ndWlkKysgKSArXG5cdFx0XHRcdFx0dW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBhIG5vb3AgY29udmVydGVyIGZvciBtaXNzaW5nIHNjcmlwdFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmIGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm9wcy50b3AgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHByb3BzLnRvcCArPSBcInB4XCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm9wcy5sZWZ0ID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRwcm9wcy5sZWZ0ICs9IFwicHhcIjtcblx0XHRcdH1cblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBfaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xufTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiBidG9hKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELzRRQWlSWGhwWmdBQVRVMEFLZ0FBQUFnQUFRRVNBQU1BQUFBQkFBRUFBQUFBQUFELzRnSWNTVU5EWDFCU1QwWkpURVVBQVFFQUFBSU1iR050Y3dJUUFBQnRiblJ5VWtkQ0lGaFpXaUFIM0FBQkFCa0FBd0FwQURsaFkzTndRVkJRVEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBOXRZQUFRQUFBQURUTFd4amJYTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXBrWlhOakFBQUEvQUFBQUY1amNISjBBQUFCWEFBQUFBdDNkSEIwQUFBQmFBQUFBQlJpYTNCMEFBQUJmQUFBQUJSeVdGbGFBQUFCa0FBQUFCUm5XRmxhQUFBQnBBQUFBQlJpV0ZsYUFBQUJ1QUFBQUJSeVZGSkRBQUFCekFBQUFFQm5WRkpEQUFBQnpBQUFBRUJpVkZKREFBQUJ6QUFBQUVCa1pYTmpBQUFBQUFBQUFBTmpNZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIwWlhoMEFBQUFBRWxZQUFCWVdWb2dBQUFBQUFBQTl0WUFBUUFBQUFEVExWaFpXaUFBQUFBQUFBQURGZ0FBQXpNQUFBS2tXRmxhSUFBQUFBQUFBRytpQUFBNDlRQUFBNUJZV1ZvZ0FBQUFBQUFBWXBrQUFMZUZBQUFZMmxoWldpQUFBQUFBQUFBa29BQUFENFFBQUxiUFkzVnlkZ0FBQUFBQUFBQWFBQUFBeXdISkEyTUZrZ2hyQy9ZUVB4VlJHelFoOFNtUU1oZzdra1lGVVhkZDdXdHdlZ1dKc1pwOHJHbS9mZFBENlRELy8vL2JBRU1BQWdFQkFnRUJBZ0lDQWdJQ0FnSURCUU1EQXdNREJnUUVBd1VIQmdjSEJ3WUhCd2dKQ3drSUNBb0lCd2NLRFFvS0N3d01EQXdIQ1E0UERRd09Dd3dNRFAvYkFFTUJBZ0lDQXdNREJnTURCZ3dJQndnTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EUC9BQUJFSUFrQURBQU1CSWdBQ0VRRURFUUgveEFBZkFBQUJCUUVCQVFFQkFRQUFBQUFBQUFBQUFRSURCQVVHQndnSkNndi94QUMxRUFBQ0FRTURBZ1FEQlFVRUJBQUFBWDBCQWdNQUJCRUZFaUV4UVFZVFVXRUhJbkVVTW9HUm9RZ2pRckhCRlZMUjhDUXpZbktDQ1FvV0Z4Z1pHaVVtSnlncEtqUTFOamM0T1RwRFJFVkdSMGhKU2xOVVZWWlhXRmxhWTJSbFptZG9hV3B6ZEhWMmQzaDVlb09FaFlhSGlJbUtrcE9VbFphWG1KbWFvcU9rcGFhbnFLbXFzck8wdGJhM3VMbTZ3c1BFeGNiSHlNbkswdFBVMWRiWDJObmE0ZUxqNU9YbTUranA2dkh5OC9UMTl2ZjQrZnIveEFBZkFRQURBUUVCQVFFQkFRRUJBQUFBQUFBQUFRSURCQVVHQndnSkNndi94QUMxRVFBQ0FRSUVCQU1FQndVRUJBQUJBbmNBQVFJREVRUUZJVEVHRWtGUkIyRnhFeUl5Z1FnVVFwR2hzY0VKSXpOUzhCVmljdEVLRmlRMDRTWHhGeGdaR2lZbktDa3FOVFkzT0RrNlEwUkZSa2RJU1VwVFZGVldWMWhaV21Oa1pXWm5hR2xxYzNSMWRuZDRlWHFDZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJpNCtUbDV1Zm82ZXJ5OC9UMTl2ZjQrZnIvMmdBTUF3RUFBaEVERVFBL0FQeTcvYVowOWRiL0FHY2I2U09QYzJtNnJiWERFZndCZzhaUEh1NEhOZktQMmZ6VzVZS09mcWErcWZqQ2I2SDRMK05OTHY3ZWFDOXRWdDVIaGRTckx0dUl6bkhwZ24yd0srWmRBMGlUWHI3eVk4YnNibkovaFhvVDlmYXZpZURaY21DcUtUMFUzOXpqRi9xZWJnNUtNVzMzL1JEZFBTWjVVZUJwRWFJZ3E2a2hsSTZZSTcvU3YyNy9BT0NKdi9CVG04L2FLK0hnK0YvajdVV2s4YmVHWUIvWkYvTzM3M1dMTlJqYTdINzBzZU1FOVdYQjVPYS9IelNQQ1RYTExhV2NPZXdZOS9xZW1SeitIUFNtNk44VmRTK0d2ai9UZFk4STZuY1dGOW9Od3QxYlgxdjhza2t5bmh2OXpPUmc1M0FuUFd1SGpIaHZDOFM0Q2VYMVVyMnZHWFdMNlA1OXV2eUtwNGx6bjdxMFA2VFBpTnBFZmlXeWtoa1RiY1I4Z2ppdkdwZE1lMHZXaGxIbHlSbjVYQVBYai9QcFZqL2dudjhBdHFhTiszMSt6OWI2MUUxdForTk5EUkxmWDlQUmhtS2JIK3RVWnpzZmxsOU9SMUZlcWVMUGg5RDRtdERKQ3ZrM0VYSjdIL09QNjEvRXRUSzhmbFdaenkzTVkybEY2UDU3cnVudWFWZFBmZ2VZV0dyK2JwOTNaT3FSeVRNVDhxZjYwNEh6SDN4NjE0Qiswei93VVBqK0JPa3dlQS9Dc2R4cStxeHhuKzNidXl1a2ptczg4aUNQZGpjK0Q4d0JHT0IxUEh2WGlCYmpSYjhmSisraElLdWVveFhqL3dBVi93RGduNTRIL2FaK0tFUGpCcnk2MFcvMitaclduNmZDaW5WV0dDSEJQM0dJNFk0T1JqdnlmdXNseUhMcW1QVmJNVTJtcjI2U2xzcjJhZTIxckp1MTdubjFaeWttNHUzY2QreHAvd0FGR3g0anZvdFAxVFhOUWtqenRGbHJsb3lYQzlzQ1U1ejdZWWl2ciswK0t1bGE1YTdZNDVJSjJIRzQ3bE9lZU8vNTE0WDhQL2dENGI4RTJVTmxvdWpXZWwyVVdDekFibmsvMzVHK1luNm44aFhZNnJjNmZvYUt6TTBxcUI4cUFuQit0ZG1aY0tPcmlKVmNOUDJjWHRHU1V2eTVXdnZaNUgxeFEwVjJ2NjJPdTF2V3RVSVpyVzN2cG8xQlptaVlCUVBmYmsvaWE4NStJSGlSL0Yya3o2ZHFXazZicWxuTUNzbHZleExjeHlIMHc0SVA1Vm9hSDhhWk5MbnhwdHZlTE1PRS9kbGxiOEtvYWw0bHVqdW1iVE5QaHg4eDgzQy96STl1ZjhLN3NueXI2dHJXVUZLK2pnMjcrdDluODJjK0lxYzdUcFNmenNlVDN2d3c4RTZkYklZL0EraWFidFVuZnB0djlqS1pKSjRqd0NNNU9DTVo1cjVDL2JtK0dXcWVEcm15OFZlSGJ1ODFEdzNZbzBkN0EwbVpyUXlOa3ZJcTQ4eFB1amNPbUJrZDYrL05SdVk5YmpaYmpSWVdXVEdERkp0TGVoR0Q3OWVhOEQvYWorRlV1cStCdFl0WTdHKzh1NnRtVjdaOXhhVGduNVRqSlBBNmVuRmZaWmZOMHNSR3ZVU2ZSK2owWXFibjlwM1BDLzJZL3dCdWIvaFdqU2FiZVhmOW5mdXdFVzlSN2dqUEtpTlFEd2VnWURCREQwNDg3MTc0eFhQeGEvYTF2TlMxSnBmTWdVbVF5WUdkZzI1d0R3TUFqcit2QStaZmpQcU1taWZFM1Q3aEpkeTJKV05HUnV2bE1NZmtRZXRlZy9EL0FNWld2L0M4dkVWMU5NcVJhcGRlY1pKTUtGU1hFamQvUmorQXI3bXZ3N0NsUm5pcWQzejAzcDJ1MWUzL0FBVHRyVTZqcHFwTjM3ZmZiNW5zM3hoK1Blc2ZEVHgxOEpmRHZobzNEK0xOVTFNNnpkVzlzek5KSTBwVzNzNFNvUFUvdmlRZXpLYSs3LzJoUDJtZFk4ZCtHZkRuaC9VdFFqa3NmRGRsSGJORGJUZWRITGM0K2JhM0c4S1NVVStpREdlRFg1aS9zNy9FR3o4WWZIL3hWOFM3NlNGcnk2dTIwL1JFbVVac1lBb1h6VkorNjZRZVZHcHgvd0F0SkR3UURYMko4TXZEOS84QUVyVWRPYTF0YnByZVpHRm5HUDhBV09BY3RMbitCQUNQM2pEQTNjQmpnVjg3eFRUeE9Id05MSU1NbWxvNmx1c25yeXJ5dTdmSmRqME9aMDRLa3QrdnErbnlPMDhHcW1uM3BudW9WdXJwQ2NJM3pSd0hKNFlkR0l5T09nOURYWFMrT1YxRWI3aVdXWmpuTzNPU00rcE9BSzlKL1ovL0FHTTcvd0NMMm9qU2RIaWp1STdJaGRVMVNjTU5QMDBrQTdmNzAwMkR4R0N2WXR0RmZjWHdnL1lqOEEvQ0xUWTBYUjdmWE5RQ2dTWHVwUXBLV1BmWkZqWkdQUUFFais4YStkeTN3bXhtWXk5cGlKcU1mTDh0dnl2YnVhMDhES2F2SjJSK2JsanJkM2ZnZlpOTHVKOXJEbll6NTZlMWRYNGE4Q2VQdkZYL0FCNGVGZFVtVTR3VnRYMm44eG4vQUQrTmZxUFkrSHJIU0l0bG5ZMmRxbzZMRGJwR1AvSFJWdFN5amJ1STY4VjlmaC9BL0s0cjk5VWIrLzhBei9RNkk1ZFJXN2JQemFnL1o2K0xFTnVySHdiZmJlcW55U1NUK0grZWxHb2ZDWDRsNlJDczAzaEcvamlYbG4rek0yTWM1NEg4eCtkZnBKbm4rdFNSVFlQZjZacm9sNEk1SDltVXZ4L3pScC9aOUxwZjcvOEFnSDVkL3dCdCtJckNiOTlwb0RKOHBSa1lIOVFEL24zNDBZZkZyM0RxMXhwYktPQTJ3Wkk5UDVWK2xlb2VIZE4xcE50NXA5amRxUjgzbXdLNStuSXJuOVcvWjA4RzYvSDgraTIwTEVERFFqYi9BUFdyek1YNE53anJoSkwvQU1Da24rcS9Femxsc2ZzeVBoM3duNGd0UmVib1paYlhPTnZPTnZiajgvNWZqN2Q4UHZqZnFtbENOWTlRZVJWd2NxM1g4SzlEMS84QVlhMGE3TFNhZGNMQy93RGRtaUJYNlpIMTlLNER4Tit5WHJuaE9SNUk3ZVNXTFA4QXJJRHZHUDU5dmF2aE16NER6Ykw1KzJpcHh0OXBhMi83ZWk5UG5ZbU9GcjAzZU92b2V0ZUVmMm9ZUnRqMURFaTkyKzZ3K3ZhdlR2Q1h4RjBueGxDcldOMGpPd3pzWTRiL0FPdlh4cVBEdXJhYXJSc1ZtMm43cnJ0WVZmMFh4SGRhRk9wamU0c1psWUhuUFA4QStxdXJLdkVuaVBKNUpZejkvUlhmNHJlVWxyOTZadkRFVzkyU1B0bGZtTk9SY1Y0RjREL2FidmROa2poMVpmdFZ2MDh3RERBZld2YVBDdmpmVGZHTnFzbGpjcEkyT1VKMnN2NFYrNThNOGZaUG5uN3ZDMU9XcjFoTFNYeTZTWHBmenNkY1pKbXVSbWtIK2MwOEtCN1ZtNjM0djB2dzNFWHZMMjN0d296aG5HVCtIV3ZzYTFhblNpNTFaS0tYVnV5KzlsRi9PS1pjWE1kckdYbGRZMFhxV09BSzhzOFZmdEt4bG5oME96YTRmL250Tnd2MUFyaXRSdk5iOGVUN3RTdTVwSTJQRUtaRVkvQWYxcjgrem54TXlyQnB4dzc5ckx5MGovNEYxK1NZYXZZOVU4VS9IYlNkRGZ5YlZqcVZ6MHhGeXEvVTlLNHU3OFYrSWZIbDJJek5KYlc4aHdJTGZLNUh1M1dyM2c3NFFYRjBJMmVIeVUvdkVZSXIwTFN2REZyNGV0OXNTZ3VveVhQVTE4elQvd0JaT0o1TG1idytIN3BOTnJ5NnkrZG9sY2lXcy91T04wTDRmdzZGRDUxeXF6UzlRblVmVTFsK0s1bWtaaC9DT2dGZHhyajRWdjhBR3VEMXdlYktmYXYwWEorSE1EbE5IMmVFanIxazlaUDFmNmJIVlNkOVRqOWNHMk51dWY1MTIzZ2pTUDdIOElXY2UzYThpZWEzcVMvemM4ZWhBLzRDSzVXNTBzNnRxVnRhNC80K0pWakp4eXFuN3gvQVpOZWpYRVdCOG80SFhBNkN2cE1ESFZ5K1JPSWwwTStkZm14M3o2VlZsajlQeUI5ZXRYcDAzTHUrNzcxVmxIempydUhWY1Y2Unp4S3VQM2ZkU01kSzZMNFc2SC9iL2p6VGJkbDNSckw1MG51c2Z6bjg5dVB4ckJDWUsvSjgzcDZkNjlJK0FHbUMzT3Jhb3cycmJ3aTNUL2VZN20vRUJSLzMxUUtic3JuTy90ai9BQmQwL3dDRmZ3NjhSZUpOV204blMvRHVuWE9wM3NoL2dnZ2lhV1UvZ2lONzEvSWo4SnRHSDdaUDdZdWtXbml6Vk5VMCs2K0tmaW5GN2VhZFpMZVhDM2QvY0VydGphU01iVE5LcXN4Sjh0Q3poSkNvamIranovZ3Y1TjR3MTcvZ25aOFVyUHdacDk5cUdwWHRoSEJjSlp4UExNdGkxekNMeHdxQXN3RnQ1eGJBUHk3emc0eFg4emZ3UStLbHY4SXZpanB2aU9UUk5HOFRSNllKaC9aK3BSSk5ieUdTR1NJU2JYVjA4eUl5Q1dNdWpvSkkwTEk0QlVrV3Vhek1yTlFPNCtQbndwOE4ySHdYOEorTmZEK254K0VScWwzZGFjTkJ2dGZYVWRUMUsyam1uamgxWUt5UlNiV2x0N3UybEFnaWpXUzJqWlZIbkZFOFp6Z1Y2SisxRjhlNS93QnBUNHdYWGlpVzMxS3hoa3RMU3l0N1c5MVJ0Umt0a2hnU05zU0ZJMVVQSUpKZkxpaWlpUXpNcUlxZ0N2UE1mL1hxWld2b0JHemJqU1pVRHJTa1oveHByQXNmOGFrQjluZlRhZmRSendUUzI5eENROGNzYmxIallkQ0dISUk5UlgzRC93QUV3djhBZ3FyKzBiOFBQMmsvQlBoMngrSW5pcnhqNGJ2dFV0Ykc1OE82L2R2cTF2ZHh6VFIyNlc4Um1MU1c3UEpMR2l2RXk3V2RTUXlncWZodlpuditsZmYvQVB3YmovcytINHhmOEZEL0FBM3FzMXVKTlA4QUJxM0hpVzRKNmJMSkVFZjRycUY1cFVnLzY1bjNyU25KcDJSTW9SZTUrMEgvQUFVci93Q0NzL3dwL3dDQ1ptbmFEYWVOYlBYUEZHc2VLdk9Oam91ajI4TXNyVzhaQ3lYRXpUT2lKSGxnb3lXWjJ5QXVGWmwrTll2Mm4vOEFnbDcvQU1GRmtXUHhoNFY4Ty9EZnhKZk1mbjFMUlpmQzExNWg2dTk3cDdHMVk5OHp5SFBwMXI0RC93Q0RoYjlvUC9oZm4vQlVMeGxid3pSejZiOFA3VzI4SldqS2M0TUFhYTVCOXhkWEZ3di9BQUVWOFJ0d1BRVW00UDRvMy9Ncm1tdmhkdnkrNC9jWHhwL3dhdGZCdjQ3NkpINGgrQmZ4NDFhUFJMZzdra3VVcy9GVmkrYzhKYzJqd2JRT3dJYzhjazlhK3M5ZC93Q0NiV3IvQUxMWC9CRzN4MThDZmhEZVRlS2ZHR3BlSHRRamZVYmtKWnplSUw2NWlXS1lxdS9aRHV0MFMzaVZuSVJJb1F6dGd1ZjVwZmh4OFV2Rkh3YzhSTHJIZy94SjRnOEo2dWd3dDlvdXBUV0Z5UHBKRXl0K3Rmb1Yvd0FFNC84QWc0Qi9hVThOL0gzd2I0VzhWK0p2K0ZwK0Z0VHY0ckc3c2RhczQ1TlNlSnlGL2NYa2FDZHJna2dJSldrVm5aUVJ6bW5HRUhwRnRYNzYvai93QWRTZThrbjZhZmgvd1Q4OXZpcDhJdkZmd0w4VXlhRDQwOEwrSXZCK3NRRWhySFd0T2xzTGdBY1oyU0tEajM2ZTljNW5Kcit0VC9ncEIrM1g4QlAyTnZoeFkydng0bTAzV3ROOFJUUzIxaDRlbjBSTmRrMVB5OXZtdUxXUlRHSTBEcnVhUXF2ekFBbGlGcjRabC9aai93Q0NXLzhBd1VqZHBQQ25pUHd2OE92RW1vRUtJOUoxbC9DTjRISjRSTEsvWDdLNXlmdXd3blBZNEZSN09wMFYvVGY3aXBTcGQ3ZXUzMy84QS9CSjVHbGNzek16TWNrazVKUHZYN1kvOEduSHdGaHNJZmlaOFV0VFdPM3Q5TDAyUFNMVzZrVUJWTjNONTExazlqRkRwdG0rZjdsOGNjRTV5L2pyL3dBR2dPdXgvd0NtZkNuNDBhTHFWdGNIZkRhZUx0S2xzOWtmSFM2dFBQRXZmbnlFRmZhL2hmOEE0SjgrTGY4QWduei9BTUVRL2lWOExmQk14OGMvRTdVdkRPclhGNWNhVmF2RWRSdjdpelcxMjJrZk1qR0sxaGhpaXlBOHJ3aHRxR1RZcEdWcnQ2QjdPOXJPNS9PaCsxMThlSnYyb1AycHZpSjhSSjJtUC9DWmVJYjNWWVZsUHpRd1NUTVlZL29rWGxvUFphN3ovZ25KOEs5SzhlZkZ2eFRyM2lEVGJmVnZEL3c5OEk2anJ0NWIzR2t5NnRiK2RJSTlPc3BKTFdMNTVvNGIyK3RwM1VaL2R3T1NDQVJYZ3VwNlhOb1dwM0duM2tNMW5lV1RtR2FDZU5vNVltVTRLc2pBTUNPNE9DTVZaOExlTE5XOENhL2JhdG9lcWFsb3VxMlRpUzN2YkM1ZTJ1TGRoMFpKRUlaVDdnMDQyV3BNci9NMGZpdHEybjY1OFN0YXVkTHNmRCttNmMxMDZXOE9oSmRwcHJJdnlDU0JidDN1RlNUYjVtMlVobDM0Mm9BRVg2Ui80SWxmczZMKzB6L3dVZCtHbWdYRnVMalRZOVpodTcxU3U1WHQ3YmZmWEViL0FPekphV2QxRnp4bVJSM3I1T2tsYVdSbmRtWm5KWm1ZNUxFOGtrKzlmdEIvd2FNZnM3aS8rSTN4RStKMTFEaE5GMFpOSXRKWFg1Zk52N25HOVNlTjhVZW1YQ2s5a3Z6NjgxVDN1RWp5Zi9nNisvYU9iNG4vQUxmdmg3d0xiM1RUV2Z3MzhPbzF6RVRueTcrL2I3UkorZHV0bWZYT2Zhdnk5UzRhMW5EeHV5U1JzR1IwYkJVOVFRZW9JcjFiOXZMOW9WdjJyLzIwZmlqOFJQT00xcjRxOFIzZDFZRTlWc2xrTWRxbi9BYmRJbC9DdXMvNEpqZnN4V0g3VXY3U0YxcE9zYWZwT3JhWG8rZ1gxLzhBWWRVdmJpeXNyKy9sVmJIU2JhV1czWlpsU1hWYnl3aklqWlhZTVZCQmJJaU4yOUJ5dGMwdjJlUCtDeUg3VDM3TG9oaThKL0dmeGtkUGd3cWFick55TmFzVlVmd3JEZUNWVUgrNXRQdUsvUTc5akQvZzdaOFphdjQvMGZRZmpOOE4vQzJwYUxlU2lLODF6d3UwMWpkV01JVXRKY3lXMHp5eHpoRkRPeUkwT1ZCeHpnSDhtZjJxOUY4QytIUGp0ckZwOE43eVMrOEt4dzJiUnNaWlpvNEx0clNGcjJDR1NhT09XU0NLOE54SEZKSWl1OGNhTWNrbGo2MS93UjUvWnhQN1UzL0JRcjRaK0VacmMzRmpxR3QyNjNxSDdzbG9oYTR2a1A4QXZhZGIzK1BjQ3RZeWszYVd2NG1McFJTdkhUMDBQNlFQMjQvMkJQMlBmRlhoRFVQRW54MDhCL0IvdzdweG5FRTNpVzhsaDhNenlUdHUycWIyRjRKSkpHd3hDc3pFN1NkdkJyNFY4WS84R3JmN092N1VXZ3Y0aC9aLytPMnNXT256UHYzeFhOajR5MHFJSCtCSklIaGtRZjc4c2pWODgvOEFCM0orMHBjZkVQOEFiUThGL0RlRzhrbDAvd0FDNkMycTNjUWsrVkwvQUZDVEozS09NaTNnZ1lFOGdUSEhVNS9LL3dBQWZFWHhCOEovRThHdWVGTmUxcnd2clZxY3c2aHBGOUxZM1VSNi9MTEV5c1B3TllxblQ3VzlQOGplVlNyM1Q5VmY4ZWgvVkI4SFArQ1pONSt3dC93U2MrSVB3VytFK3VUZUpQSG5pRHcvckR4NjNjeFI2Y2RSMWk1c0JheE9xYm1XM1JWaXQ0MURPMkNtOW1KWmpYOHdQeG4rQVhqejltSHhHZkQvQU1RL0JYaXJ3UHFzQk1ZdDliMHVheGFYYWNGazNxQTZucUdRbFNEa0VqbXZySDluZi9nNUMvYTArQUJ0NGJyeDlhZkViVGJkUW90UEdlbnBxVWpnZjNydERIZUUvV2MxK2cvN0xIL0IyRjREL2FQMWpTdkFIeDIrREVXazZUcjBxV2QzcU5qZEpybWlwdjRhUzQwKzRpRHJBbytaeUpKbUNoanRiR0RmSzI3d2E5SC9BRll6VlJLTnFrWDZyWDhOL3dBajhuditDZTM3Y2RqK3hSNHMxN1U3dlE5ZTFWZFpPblNHVFJOWGowdTd1RXM3dGJwdE5ubGVHYmRwOTJ5UnJjUktvWnhERnlRR1J2bnpWci8rMU5UdXJyeWJlMysxVFBONU52SDVjTUpaaTJ4Ri9oUVp3QnpnWUZmMVNmdFRmOEcvUDdIbngwc05RMVBXZmh2cEh3NXVJa1BuYXg0UzFEL2hIb3JRY0tHOG9ac2w1eHkwSEpQdlh3bjhmdjhBZ3pnbm50MjFMNFAvQUJ3dGJpenVBSkxTeDhZNlNWaktIdjhBYjdNdUpNajB0bEh1YWlVNVc5NWZQK3Rmd05GR0YvZGx2MGVuL0EvRXgvOEFnejcvQUdjeHFmeE8rSjN4UXZMZFZqMGZTNGRHczVaUHVPOTNNM3pvZXpSclpYU01mN3R5TzJhL05YOXU3OW8vL2hySDl0djR3L0V3WEp1clB4ZDRvdXBOTmtMSC9rSHhPWWJRZmhieHhMK0hhdjZJUDJYUCtDYi9BSXMvNEpuL0FQQkh6NGovQUE2OEczdHY0eStMdXErSGRhMUZMblNvR2hodU5YbDA5b2JlQzFEa095b3lSbFMrMHZLN3R0akQ3Ri9sNDFqVDd6d0hxazJnNnZaWDJqYXRwYm0zdXJLK3QzdHJpM2tCK1pYamNCbFlIc1FDSzJqVWp6K2lKNVdvTitmNUhvdjdMRWZqUWZHaTF2dkFHbjZYckhpTFRyVzViK3piK2EzV1BVN2FhRnJTNXR2S21sak01bGh1Skl6RkVUTVZkMlFBcVdWMzdYWHh0OFUvRnJ4N3AybitMdkROcjRNMWJ3RHB5ZUZaZEZndEo3UnJGclNSNGdzMFU3UE1MaU9OWWJkMmxacFdGb205bVlHcWY3UEh4ajBuNEU2eHFuaXIreVcxanhycDl1ZzhJTmNSeHlhYm85NnpmTnFVeU5reXkyNkROdkZ0MmVlNlN1U3NIa3plZDZ2cU54cTE5Y1hWMU5jWFYzZHlOTlBjVFNHU1dlUmp1WjNZOHN6TVNTU2Nra2sxVXBhV0pYYytudjhBZ2pGK3prdjdWZjhBd1VpK0dmaFc0dGx1dE5tMWFLZS9pWmNwTmFSSHpydU52OTZ6aXU4ZTRyN2svd0NEc3o0L1MvRkw5dS93SDhON2U2RTJuL0Rmd3JKck45RUdPMlBVZFNsT1F3NkVpMmd0WEI5SkcvRzkvd0FHZnY3T1RlSlBqejhRUGlSY1FlWkQ0YjBsYkMxRHJ3dHpkeUdLR1ZENmlHSFU0ejdTKzlmQ2YvQlJEOW9wZjJwdjI4UGpoOFNJNWxtc3ZFWGl5NXM5S21CeXI2ZlpEN0xac0Q3d3hKMDcrdE9FYnpqRjlOZjYvQVhTVWw1SStlZnNFaytxUjI5dVZNMDB5eFJBeUJBWEpDcU54SUE1STVKQUhVNEZmWDF4KzJEKzJwL3dTWjhWYVRvZDE4UnZpSjRVVzRzMXVMTFM5VTFEKzNOSWFMQ01ZNG83b1RXcmJROGVUQmtMdkFEWjZmS2ZnM1RQRUd1ZU5kT2g4SjIydVhYaVNPY1hPbXg2TkZOSnFDVFJmdlJKQ0ljeUIwMkY5eThyczNaR01peDhhL2ozNHUvYUU4VFcrcmVOTmN1TmMxR3h0RTArM2ttampqK3pXNkZpa0txaXFBaWxtd3VQbHlRTWRLMWxMb21Ma1V2aVZ6OWIvd0JpL3dENE80L2lGSjQ5MEhRZmpOOFAvQ1BpRFJkUXVvclM2MXZ3MTV1bDZoYUl4dzA3UVNQTEJNVkIzRkY4Z0VEZ2l2MVQvYngvWSsvWkc4YitBcjd4ViswSjRMK0R0aHBFa2l3eitKZGJXRFJMcHBIeVVRYWhHME53Wkd3eENDVGNjSGpnMS9NcC93QUVrLzJkZitHci93RGdvajhNUEJjdHY5cTAvVXRZaC90Q0RIRTFrR0J2QjlWc3hjeWZTSTErai84QXdkaS9INlg0bC90bGZESDRYUVhESFRmaC93Q0dycnhicU1TUzRqYTkxQ2J5SWxkUnh2aml0bGRTUmtMY05qRzQxaEtuR2JpcmF0LzErb1UrZUxmSkpyVHVmcHYvQU1Fd1AyRGYyVS8yYUl0ZThXZnMxdDRkMTV2RVVRdEx6V2RPOFZ0NGthQzMzSy8yV09UelpCREdYUkdaUmhuTWNlOHQ1YWJmeTgvNExBZjhHN1g3UkhqNzlzZjRqZkZ2NFYybWtmRS9RL2lCckV1dVBwLzlydzJHdGFZOG9CZUFwY2xJcFkwSUt4bU9SbUtiUnNCSFA1UDZacjJxL0RyeFZEclhoL1U5UzBIV2JVN29kUTAyN2tzN3VFOFkyU3hsWFg4R0ZmWm53YS80THovdGtmc2dUNlBhNm44UUx2eFpwOTlZUWFwYTZaNDV0WXRaTnphVEtURkswN010OHF5SUE2Wm5VbEdTUUFvNk0ycnc5bmVFclB6MUhHcE5YNWtwTDd2dS93Q0h0NUh5OThRZmhmOEFGNzloN3h2YjNQaTd3cDhUdmhEcjBKbGh0TDY5MCs4MGlRN2tlSi9KdVFGM0t5T3lreHZobFlqa0U1aytKWDdVdmp6NCsrQ1BEbWcrSlBHT3IrSnREOEdRQzMwTFRaYmhUYjJDbFFwS0tvQ21Sd28zeXZtUnlNc3hKSnI5a2YyU1ArRHN2US9qRDRrMGZ3VDhidmhIWjZUcHZpQ2FPd3ZOYTBMVVB0K25MNWhDK1pOcDF5bTRRaklMYlo1VzI1d2pIQ243Ty9hdy93Q0NGZjdHL3dBY05FdnRhOFYvQzN3ZjRFYTFqTFM2L3dDRzdvZUYxdGR4QTgxakEwZHFTU1I4MHNiWkpIVW1qMjFhQ3ROWFhsL1QvUVM5bEozMWkvTlgvRlcvQzUrQi93QU5mMkZySFd2MmtQaHI0WDhLL0VMdy93Q09MTDRnYTAraTJ0M3BrY2tOeFo0dll0TisyUEMyU3NIMm1ZdkRKa2lXTzNad0JobFQ5Q2YrRHVYNC9RNlJOOEJ2Z2JvYzBkcHBjQnUvR1dwNmRHTnNhUVc2clo2WUN2UW9HKzJnS2Y3cTE5YWY4RTkvK0RkNzRMZnNMZnRFYWY4QUZ6d3I0MCtJUGpsdFBpa2ZRSU5adnJPNHNiUjVZWGhOd1pMZUZQdERDT1J3bVNFVXNIMnM2b3kvRlA4QXdjZ2Y4RXkvMmd2aTUrM0MzeGs4RitBdGUrS0hnbTY4TTJXalJRZUhZaGVhbG9SdHpJWkltdEZQblNLOGp0S3J4cXcvZU1DVklHYzUxb3luSG0wVjlibFU0TnR1T3J0cGI5TCtSK1ZIaC94UnFQaGZYb2RTMHpVcjdTZFNoTytHOHNibVMydVlUNnJMR1ZkVDlDT3ZhdnNiOW5yL0FJTFlmdFgvQUxQZWwydDFZL0V2WC9GUGgxWmpieHcrTXJJYTlaVHlxb0xSRzZsQXVpUXBVbEV1VklES2NZT2ErSTlkMU9Qd2o0am0wWFg3WFV2RE9zV3IrVmNhZHJOcEpZM051ZlIxbFViVDlmOEE5WHIzaXo5bzd4bCswSDhNZmhwOFA5VzFXMTFEUS9oMkxqVC9BQTN2WklVdG83dVNETWNrZ0lUWXBpakFkaGxWenVKeG12UzkyYTkyei9FNTVRczdUVm45elAxYS9aOS80T3Y1dkt0YmY0cWZCK09ST0JjYXA0TzFYYWVjY2l5dk1BRDYzWlBhdjF2K0RQeFc4UGZ0Qy9DdncvNHo4TDNUYWw0ZjhUV2lYdGpLMExSU0ZXeUNyeHNOeVNLd1pXUWpLc3JBOUsvbFo4ZGZzbWFoOE8vQ3R2NHFoMXZSZkVmZ1c2MVI5TWoxZXhjcVo5azB5TXdpYmxmM2NCbUdHTzZLV05sSi9laVA5WC8rQ3lueEExdi9BSUp6L3dEQnYzOFAvaGZwTjVQb1BqVDRpSFMvQ0dwTmFUbUdlS1M2U1hVTlpaU01IWThnbWhmSDhGMWc5YTRjVkNFVXVYZTVwU2pKenRmU3pmZlkvS3Y0cTJscjQ0OEwzK2krSUlacGJhN2lNUDJ5RDViaUJjZ2pEWTVBWUE3V3lEaXZDSlAyZVUrSEhocVpySzZoMXkzbmtMdmR4cnRZTC9BcnJ6dHgzd1NDU2ErM2ZGZmhyUWZIbHZKNTF1MEUwaTRNMXNNZlRjaEdEK2hyeHZ4ajhGdFc4SHlQZldCODZ6NXkwUHpMdE9mdkwxQXdlUVIrTmZ5NXc5eEU2VlA2dkdYSW03dUwyYjhuMCtYelI1MVNqVVVIRjZyeVBsWDRqWGkrRGZEOE9ud050MUhXRkx6dG41NGJma0FkZXJuSTljS2ZYTmZSSGdmOWdYUWRiL1lMMDN4UmZYT29ONG0xOHZQWTI4S29zZHVBK0VmUDNtQlhxdmNlK0NPQjhlZkRxMTF2WHBkVUdsd1hXb1NiVW5nbWsySzRWUXErVTMzVkl4OTFoZytvcmJrL2JoMXJ3OW8xcjRVdnRNMUE2ZFlJa2NjTXNZV2EzMmpDYmVjSHVPT0NLKzB6TEZaamlzTlJobER0TlNVNXU2dTB1aTdyWmVhWGU0Nk5TS2h5SmFubmY3TWZ4OThjZjhFNC93QnAzVDllczFtamt0OXNXcFdKWXJEckZremZNaEI5Y0VxU01xdyt0ZnZkOEV2Mm1QRC9BTzBiOEtkSjhkZUZYdUpOSDFxTGRJczhUUnkyMGc0WkhVK2h5TWpnOVFhL01UOW1EL2dsbHEydmsvRTc0cFdGMWUzV3RFWG1sNkhkQS9KRWVVYTQ1UEcwamFuSEhYMHIyNy9odm53Zit4OTR1K3phL3JpVDJzZ1MydTlGMDJJM01zVVhPQ0VUaVBhT2VjWjVGZm0zaUZqTU54RGlhZUZ5Nms2dUpwNlNuQk96ZldLVm5kWCsxZEpkRytuVEtzbGFNdmk2MlBzLzRnK0Y3ZnhiWXlYRnVxcklnTGRjY2V2RmVOZjJoZGVDZGVXNFdRaVNGZ1ZiKytQUWl2VFBDM2pXMzFuU3ROMXJSYnlIVXREMXEzUzZzYnBjN0o0bkdRZnh6ajJQNVZ6M3hjOE5wcUduM0Y5QnRSRUpFb0IrNGUvVC9QVHZYNXJoc1ZWb1hwMUZvdE5kMGNuT295S1h4SytLVnY0VytIVno0cWowM1U5V2pzOE5kMlZteTc0Z1RqZjh4R0ZCNU9Na2RlbWE4bjhJZnRTM3Z4UnVwb0k5SnM5SGpuQlZBOHJTU2ozRDRDZy84QklyUzhMZVBUNGJ2MmhtMnpXMHdNVTBML2NsVG9RUmowUDZWeXZpMzRlV1BoN1VEZjZJelM2VEsvN3ZuNXJVbi9sbTNmam9DZW9yM0srTW45WGNkYnY3WDZIRmlNTERuNWtkb2ZCR3RhbGEzTnV0OWVhbkhkUjVtc3JxWmhJVTlVS25EcjdwZ2p1Qml2a240N2ZzaXplQlBFamF6cG4ydlVQRGR3VEhleFRONWsrbWxqZzdzOHRHYzhPZVZJNTlUOVMrRVBpMU5aZVRaM3FzeXhPQ3N1Zm1qYnNRZXhIWElyMW1HRFRQaVBwenpYQ3Ewd1FxMTJzWUt5cVJnaVplNEkvaXh4bm12R3kzaWJFNWRWWHRYYStqMTkyUy93RGJYMmZmUjZHdUhsR2Z1U1ZtZml2NGwvYUM4VWZBaWVQdzk5dSsxMnNjOHEzTmxlUmllQUJXMi9LcmNvQ1FlVUtub2VLM1BEdnh2OFFXT3p4ZDhPdkVXcjZmTHAvN3pVZkRzdDZiZ2JBTXM4VWI1U2VJQU1jRmR5ak9SZ1pQc24vQld2OEE0SjFhNTRXOFEzSHhNOEwyTWw1b2YyZEYxU3d0a0x2WUJQbCswUjR6NWtUZFdJNVE1SjQ2ZkJuZzd4TGNhRHFrY2tVMGtXMXQ4YnhOaG9uQnlyS2V2QkhVY2l2NnA0ZmhnTTJ5NkdPd3R1ZHIzMWJkOVl5WDVQZTFtbmJmc2xnWThuUEhmOHo2UytNMTlZZnRkYWRxT3B6NmJwK2wrTnJPM2E4czduVEloRGI2MG8rWm9wb3M3Zk5JREZaRXdTZUdEWkJYeTVQQ1RlTHJhenVvMnU0N204Z2pSbGhIenZsUUNlL1BKQTlPSzFmK0UwbTBqU0xQeExwbmx1MEwrVnFjUUNxc0V4YjVaRlVIaFg0emdZRDVIQWRSWHBQdzEvYTgrSFhnYnhKdDFqd21zMWpNRUl1OUtnUmJpMVlwODJVYzRZQmlRTUZTQnpnOEN0by9Yc1BUNU1QQnpTdlpYV25kYTlObWw5MmxqQ25HbzBvOW4vU1BkdjJFZitDZldsK0Q5TFhXUEZ0amJhbGQzQ2Y2SFoza1prUzNCYk80cjBKd09wSEp6d3ZRL1kvaDN4UC9BTUloYlgybnlhVnBjeTNNQ3d1OEVIMk9aWWlSOG9lUGFjRmlYR2VNbnA2ZUJlQmZpRDRmMWZTWWRTOEs2dEpxa1Uxb2w1SENqdDUwY0JKQWthRmdzcUtTQ0FTb0I0eG5qUHFIaEQ0MmZiNEZXNGlqdUl0b1ViMTVBNmpuQTlmU3Y1djRxeG5FTXNkTEYxcHk1dXliankrU1hUOWVvcTN0bmRyOEQ3by9abi9iUzhJK0JmQm1qK0Y1dEQvc0hUckZmSlNTRW1USlBXUnlmbWRtUExNVGtubm12cHJ3dDQ5MFB4ekQ1bWs2cFozb3huYkcvd0F3L0RyWDVlNlg0azAzVTlOVllaSTQ1Sk1ZOHpISDQvalY3Uy9FT3VlRDcvN1JhM0VqSnc4UmpZakREMHg5UFgwK3RkL0R2alpuT1hyNnZtRk9OYUMwVjdRa2wyVFM1WDgxZnpNYU9hVm92bG1yL21mcVk4TzA4L0xVVEljLzU0cjRmK0VQN2YzaWp3YkVzT3NLdXEyWUJIbHo3ak11UFJ1djRHdnBmNFcvdGIrRC9paEhISDlzWFM3NXVEQmRIYXVmWnVuNTRyOTQ0YjhVY2h6aTFPRlQyVlYvWW5vNzlrL2hmeWQvSTlxamlxYzEyUFJpcGI2WTZVNU92cHgxcVRDeUlHVmxaV0dRUnlEUjVlUHVpdjBKOXpyV3c2RVovclZ1MytoeFZlSmR4NzFiZ0czODZReTNDUHpOV1ZIemZyVmVGZmxxTFUvRW1uNkZDMGw1ZHdXNnIvZWJuOHF5clY2ZEdEcVZaS01WdTI3TDcyQkJyL3c5MGZ4Ukd3dmJHR1JqL0dvMnVEOVJYbmZqTDltUnB3emFaTEhjUjlmSm40WWZRMXRhL3dEdEphRHBaWmJOWnRRa1grNnUxZnpOY2pyWDdSR3U2MFA5QnQ0N0tNampqYzM1bitsZmtYRlhFbkJrN3hyU1ZTcDNwSzcrY2w3citiWlVxWE10VHozWHZnL3FHaTNra2NXK3praDRaSnVFUDQwN1FiaTc4SlhFY3EzMzc1T2R0dm4rWnJYdU5QMWJ4ZGMrZGVUWEZ3em5PV0pyUzB2d0lrQkhtN1N6RHQxcjhEeEZURHl4UHRzTlRjVW5kTnV6OHRGcGY3ek9uaDR4ZWhIcS93QVYvRlhpeUpZRGV5V3R2amJpRUJXZjZ0ak5aMXQ0T212N2p6TGlTU1ppZjQyTGZqNjEyRm5vc05oQjVrMjJPTmU3Vmk2aDhXYkhTTlJqaHRyT1NUYS9Na3cycWZYanI3VjFZek5NYmpWejRtcTVMdkp0cGVpL3lSbzR3aHJOMk9nOEhmQzZiVUhVUXdrci9leDhxL2pYcVhocjRhMmVncUhsVVRUZXBIeWo4S3EvRGY0czZQNHZ0a2hoS1dkMkJnd053Q2ZZOTY3UXg1Ly9BRjErL2NEY0Y1TENqSEh3cXJFei9tK3pGOWxIbzEvZTE5Q25VVnJRMFJWS0FMeGlxVjJuSituTmFjaTdlMVo5K3UzUDVWK3JHWnkvaUUvSzMwcmk5VGozU04zL0FCN1YybmlJWXJsTCtMQzV3ZWVmcFhMVU8ybXRDaDRMMHI3VDRtZVlxR1cwakp6Nk0zeWo4eHVycTd1UEJ3UDVZd2FyZUI5TSt5NlZKY2Z4WEVwN2Z3cjhvL1hkVis1ajY4WjcvV3ZRdzhlV21qbXJTdkl6SmszTGxmWEdLcHlSNGJiNmMvMHJRdUZ3eEhMZC93Q1ZWSlI4eWpJN0N1aE1tSldkR0cxYy9MNzk2OWM4S1czL0FBaTN3bHQ4amJKZkZycC9mZHd2L2pxclhsOWxZU2FuZncyMFh6UzNFaXhKa2Z4TndPUHFhOVErTDE3SHBXbUxhdy82bTNqRWFMbm9GR0JWR2RUc2Ztdi9BTUZVUCtDNHZndi9BSUp4ZkZQUmZDTW5oUFdQSGZpclVyWmRVdXJXMXY0OVBoMHUxWjNTTjJsWkpOMHJza2hFWVVZVmNsZ0dYUHpiYy84QUJUVC9BSUo2L3dEQlFKaXZ4ZCtIMXA0VzF5OUlFMTk0aDhObTN1SkdQcHFlbU0wMjBmM3BHai9DdnpEL0FPQ3JueCtQN1N2L0FBVVQrTFhpbU9kYml3L3QyWFNkT2tWdHlQYTJJRnBFNitpdUlmTXgvd0JORDYxODhsOXE3ZTJjMUxsRjZTVnlieWo4TGFQMjQxLy9BSU56L3dCbW45cnZScm5YUDJmZmpSZVdLTWQvbDJPcFduaXZUYmIwUXFycGNSK243eVptSG9Ud2ZrLzQvZjhBQnN6KzBwOEpSSmNlRjRQQi93QVR0UGpKSUdoNnA5a3ZRZzVCZUM3RVEzZjdFVHllMmEvUC9RTmN2UEMrdFcrcDZYZVhXbWFsYXR2aHU3U1pyZTRnYjFTUkNHVSs0TmZXZjdQdi9CZDM5cUw5bmg3ZUcxK0psOTR2MHkzSUgyRHhiYnByS3lLUDRUUEovcEtyMitTWmFQWnc2TnI4ZitDUDJqKzBrL3dQbkw0MS9zNWZFSDltL1dWMC93Q0lYZ2J4YjRJdXBHS3hwcmVreldRbXgvY2FSUXJqM1VrVnhZRzZQY3BHTWRhL2RmOEE0SjgvOEhKWC9EWFB4VzBINFYvRmo0WWFQcDMvQUFtRnhGcFExWFJyaDdqUzJ1SjVZN2VDTzRzYmdPeXhTVFN4b1hFejdTNEpYYmxoOUkvdGxmOEFCSTM5aW54Rm92OEFiSHhFOEwrQS9oTzJvekcxdDlaMC9XNHZDU3ZNMlRzalRlbHJKSjFPREU1L0NwNUo5TmZUL0wvZ2ovZHRYdmIxL3dBeitaWFBOZnVKL3dBRzJuZ0RUZjJkZjJPL2k5OGJ2RVVaaDAreHQwdEhsQXd3dHJPMmZWYngwemdIZkhkMmNaNSsvWkVkcXkvaVYvd2FZZUZ2R2FRNnQ4Sy9qeGRyb0Y1Z3dycldrdzZxam9lcFc4dEpJa2ZqcGlJQStvNjE5VWZ0YS9zRWVLUGdKL3dSQzhWZkEvNE9wcVBpL3dBUzIrakdPYTRXM1dHOThRdlBmcmM2azZ4S1NBOGtUM0NSd2dzUW5seEJuS2dtbExsVHVyRlJoZDZhbjgzZnhBOGQ2ajhWUEgrdWVLdFprOC9WdkUycFhHcjM4Z0dQTW51Sldsa1A0c3hyNkwvNEpvZUZmaG5vZnhBdFBIWHhHOFRmRCtHODAzVnJleThOZUd2RXlUM05ucWx6NWtMWEYxZVJRd3pCWUlZWlAzSzNJamhudUdRTXp4Vzl4RzN6ZDR2OExhcDRDOFNYV2o2N3BlcGFMcTFtL2x6MldvMnIydHpDM28wY2dES2ZZaXM3R2FJU1Nkek9TZTJ6T3IrUEhnQnZoVDhjL0czaFdTSm9YOE5lSU5RMG94c01HTXdYTWtXMGoyMllyNjQvNE42djJlbStQSC9CU253Vk5MR3NtbStFYmovaEk3ME1tN2FsaURkUXVQcGZSNmVoOXB6MUdSWHc3dTh4L21PU3g1T2VUNm12MjIvNE5kL2hUWi9DbjRCZkY3NHo2OEZ0ZE5zN1pOSlc3a0dQczZLZ3Y5UTUvdS9aMDBpVC92cW5UM3VHK2g4ZS93REJ5SjhmditGMC93REJUelg5SmdtYVhUL2g1cFZwNGVpdzJVTXhYN1ZPUU94RWx3WXozekQ3VjhFc2dZWWI1aDN5TTExUHh0K0sxLzhBSGY0eStMdkhHcWNhaDR5MXE4MXU1WFAzWHVKM21LajJHL0FIWUFDdlh2OEFnbkQ4SWwrS2Z4aHZJN3p3RnEzakt4bHQ0OUZ0YjIyMEtiWHJUd3pxbDlLRXNyeThzWWlHdUxjbU9hTXJ6dE1pdUZsZEVpa1VZdVRzZ2xMcWNkK3p2KzNSOFpQMlRMbUZ2aHY4VHZHbmcrR0tUemZzVmhxa24yQ1Evd0MzYXNUQko5R1ExK2ozL0JQdi9nNkErTnQxOFpQRFBoWDRzYVg0WDhlK0h0VXVWdDc3VkxUVFJwZXRXMGZKYVpCYjdiZVZsVU1SRjVLbVE0WGVoTzZ2eXQrTDFndWxmRnJ4UmF4Mk9nNmF0cnE5M0FMVFE3cVM2MHUzMlRPdXkxbGtra2VTQVl3anRJN011MGxpVG12cTcvZ2daK3p4L3dBTkRmOEFCUzc0ZDI4OXVKOU4wRFZZTmJ2dHd5c2NkbHYxRWJ2OWgzc2tnUHI5cEE3MXBDcEs2VGQwUktuSCt2OEFnSDlCMy9CU0dYOWx2d1Q0RWgxYjlwNnorR0xhWGVYRFdGbmRlSk5JVyt2cDVRUG1TMmFLTjd2NVFjbG9jQkF3eVJrVjhKU2Y4RUdQMkZmK0NndHA5cS9aOStLemVIOVRlSXNMUHczNGxqMTZLQVl5SGwwKzhZM3FuMUJsakg4cStOUCtEcFA5b2R2aTUvd1VsWHdoRGN5U2FmOEFERHc5YTZlOGYvTE1YbDBQdHN6cjdtS2ExUSs4V08xZm0zQkkxcmRSendzMFUwTEIwbFJpcnhzT1FRUnlDRGc1RllxRlB0OTJocktwVldpZjNxNStxbng5L3dDRFJ2NCtlQUx1YVh3QjR3K0gzeEZzVmJiSEROY1NhRnFSNTZ0Rk1HZ0hicGNFNTdHdjBBK0NmN0YzamIvZ2xQOEE4RUpmaWxvU3cybXFmRmE5OFA2dnJWK21nNzdpTzB1bnNFdElFZ2JhR2tNTUVFY3JrTGd6R2ZadVVxemZpcCt6bi93VzUvYW0vWmVGdmIrSGZqRjRvMUxTN2NyalRQRWJwcnRwc0g4Q3JkaVJvbFBUOTB5SDBJcjlIZjJEditEc254QjhRL2lwNGY4QUN2eGkrR3ZoK0cxMVc1RUUzaVR3cmN6V3Y5bUlBV2E0a3M3aHBmTVZBcFovTGxWZ0FTaU8yRU9paG8xR1cvZGYxK1pIdFdtbktQM1AvUDhBeVB3MlVLaWJRd1lMOHVSejBxL3B2aVBWdkNjMXhIWTZocUdsdk5zVzRXM25lRXlHT1JaVUQ3U003SkVSeG43cklwR0NBYS9xOC9ieC93Q0NhZjdISGpmUU5ROFRmSER3UDhLL0JzY2wySWJqeFBQZnhlRkpXdW4zQWI3cUtTQVRTc1ZZZ1NGeWRwT0NBYStGZmloL3dhVi9DSDQ1K0dQK0VrL1ovd0RqcnFVT2wzQU1rUDhBYUp0UEUrbHpFOGhVdkxNeEZGSFRKV1ZzZGNtczF6cFhhK2EvcTVvMUJ1eWw5K24rYVB3djhZK0xkVCtJWGkvVnZFR3MzYlgyc2E5ZXphaGYzVHFGYTV1SnBHa2trSVVCUVdkbU9BQU9lQUsvWDcvZzBVL1owYnhCOGZ2SEh4R3VJRmFId3JvWnQ3Vm1IL0x6ZnpHM2drVStxdzJtcklmYWNldUsrZC9qNS93YkRmdGJmQlM1a2ZSL0NmaC80bWFhbWY4QVMvQ3V0d3lQaklBLzBhNjhpNEovM0kyQXdjbnZYNmhmc1dmczArTmYrQ08zL0JDajRzYTM0ajBkZEwrS1YxbzJxZUk1cksybmp1cE5JZVBUMXQ3T0o1SWl5TnNlTjdwOXJFSWJ1VmM1VTBScUt6WXBVNVhTWitHUC9CVUg5b1lmdFUvOEZEUGpGNDhodUZ2TERXUEU5emI2Wk1wNGtzTFUvWmJRL2pid3hINjF4ZjdIL3dBTjRmakorMWI4T1BCdHhvc2ZpR0h4ZjRpc3RDT255WHNsbWs1dXBsZ1VtYVA1NHdwa0RsaGtEWnlDTWl2TzJnYTFSWXpqY29BT0NEZzk2MnZoejhSOWQrRVhqT3o4UmVHdFNuMGZYTk9FbjJXOGhDbVMzTWtieE1WM0FnTnNkZ0dIS2s1QkJBSWNkSHFUTFUydjJpSlBoNi94ZjFsZmhiYStLclh3VERjUEZwMy9BQWtPb3czOTlPaXlNb21Na1Z2QW9WMENzRUtaVEpCWjhiajZaL3dTMS9aeWI5cXo5dTc0YitCMmplV3gxN1c3V3p2MVh2WlBLUHQyUGRiQVhrZy82NVY4K2hkcWdEcDBITmZyMS93YUwvczVIeHgrMTE0bytJTnhhdEpiZUJkQ2xlQnl2K3J2TDBteXRXVS83VnYvQUcwcC93QjBlbE9udmZzRXRVZEYvd0FIZmY3VkYvNG8vYUUrSFB3YnRiK1pkRDBQU1pQRnVyV1VjbUxlYTh1WlpJTGZ6RXpndERERElWeU9GdTJ4OTQxK1hmN1BuN2EveGUvWkt2MW0rR1h4TThiK0IxV1R6SHQ5SzFlYUd6bWIvcHBiN2pESjlIUmhYcFAvQUFXQy9hRlg5cDcvQUlLZC9HdnhmRE45bzAvL0FJU0dUUk5Qa1dUZWtscHA2TFl3dXB5ZUhXM0VuSGR5ZTllT2ZzMC9DL1RmamgrMEg0UjhGNnRxVStpMnZpM1VvOUdqdm9vdy93Qm11TGpNVnN6QS93RExQejNpRGtjaEN4SElGRk9VdE9YZGhVakhaN0kvUkQ5bkgvZzdTL2FQK0ZUVzl2NDgwcndMOFY5UGpQN3lhOHNQN0cxTmwvMlpyUGJDRDd0YnNhKzF2aFYvd2NIL0FMSHYvQlRmWE5COEQvSGo0TmpSZFcxdVpMRzFuOFU2UFplSXRJdEpYSVZRTDRLdHhiNVk0OHp5RVZmdk02akpINEsvSHY0TFArei9BT05vZkROOXIyaTYxNGhzN1JXMTIzMHVVM0VHaDNwWnc5ZzA0L2R6VFJLRTh4b1MwYXV6SUhZb3hydHYrQ2NuN1BjMzdWWDdhL3c5OEJ3ckpzOFJheGIyRncwZjM0SUo1a2dsbVgzaVNWcGM5aEVmU3FqeXpmTE5KcjBJNVhEV0RhZnIvWDZIOUFYN1JQOEF3YWgvc3Y4QXhta21sOEcydmpmNFQ2cWQyMWRCMVY5UXN0NTd2YjNubk9RRC9ESExHT3d3SytEUDJoUCtEUHY0NGVCTHlhVDRjL0ViNGY4QWoreGpCSzIrclJ6K0g5U1k5bENFVFFmaVoxK2xlcy84SGIzN2RQaW53NzhSL2g1OEV2QzNpVFdQRCtsMzJsemVMUEUxdHB0eTl0L2FLeVR2YjJVTXpJUVdqUXdYTCtVVHRKZU5pQ1ZRajgxUDJkUCtDenY3VDM3S0FodC9CL3hvOFpOcGRydFZOTDF1ZGRjc0VVY0JWaHZGbEVhNDQvZDdEN2lzNDA0MnVtMS9YbitocktwVVc2VC9BQS9MOVdmdlArd1Qrd2g4UVA4QWdrdi9BTUVkZmlacHNNT242MThacGRCMWp4QkhiYUF6M1N3M3lXRWdzclNHUXFyVHVzcXRLZHE0ODI1a1JONmhYYitaclE5YnR2OEFoSGJHeWhtaHpER053M2NsamtuOVNmOEFJcjllZjJjditEeHJ4N29FbHZiL0FCWCtFWGhmeFBDcFZYMUR3dGZ6YVBkQWNaY3dUZmFJM2Z2aFdpSDByNk84Ty90MC93REJOSC9nc1Q0enRkRThmZUE5RzhQL0FCQThWWFNXa0VuaWZRRG9lcDZoY3VjSXY5cmFmSVZabVk0WHpyaGR4SUFCSnhXMFpUakxtamFYNW1jWndjZVdhY2V1MTE4OWRQdlB5Vi80SmdmR2I0YS9BLzRqK0pOUzhmNmhaNmI5dmhzTEFTYWdtcXRhejZTYnhKZFZnai9zd3JjQy9lS0dBV3pPeXdiaEtKR1hjaEh6WDhWZkcxMThUZmlYNGs4VFgwMXhjMzNpVFZyelZwNXBvNDQ1SlpMaWQ1V1oxaUN4cXhMNUlRQkFTUW9Bd0svZkQ5b24vZ3o2K0V2aTRYRng4TFBpaDQ4K0h0NUpJV0ZscmNNT3Y2Y2c3UnBqN1BPZ0dPcnlTc1BmRmZCMzdRSC9BQWF3L3RaZkNLNGR2RE9rK0NmaXRwcWs3SmZEMnV4MmR5cWRpMEY5NUJ6L0FMTVprK3BvbGlJeTNUUnBHaTllVnAvMTUyWjY3L3dhRC9zNWY4SnArMVQ0MStJMXhiaVNEd1hvN1FXNVljeFhsMlRid092czBCMU5EN3I3Vjh4LzhGSC9BSTdyKzB6L0FNRkQvd0JvVHg4ay93QnFzZFE4V3krSHRKa1Y5eVBZNlhHTE9GMUhUYklzU1B4M0o5Ni9ZRC9nbG4reVA0OC80SkFmOEVjZml4NGs4VmVINHJMNHFMbzJyK0tUcEZ0Y1IzMDFrdG5ZU3RaV2p5UWxvM2J6L3RNK0VaZ291OWhKWlRYODgzZzd4QkJGNEMwMnpqbmp1SkZReVR0NWdkaks1TE5udm5KeCtGYllhMHExK3kvUCttWlNUakMvZC9sL1NLbmltUE1Nbjd4WU40WlZjbm9jSHBudldyKzBmOFZvL2paOGJQRVBpbTFzMjB5eDFPWkVzTEI1Uko5Z3M0WVk3ZTJ0d3dBQkVVRVVVWUlBNFFjVjd2OEE4RTYvMmdQRFB3QytKWGpEVnZGSGlYeEI0TnM3enc5OW1UWFBERjQ5cjRvdFdTL3M3bjdQcGJyQktublhDMjVnazgxb0kvSWxsM1RCY3h5L09QeGs4YkQ0bWZGUHhONG1qMG13OFBwNGsxZTgxUWFaWUx0dGRNRTg4a3d0NFJqaU9QZUVYZ2ZLbzRIU3VxcGNVTE8vYzlTLzRKbWZBRi8yc2YyNnZoejRGTVR6V211YXZiMjErcUQ1bHM1WlVpdW5VLzNvN2VTZVVlbms1NDZqOVF2K0RzcjlvUzQrSUg3UjN3cCtDOXZkeWYyRjRiMFM2OGVhM1liczI4OXpQSTFuWkdSZWhlRllyZ3Jub3QweDcxNUovd0FHa1g3TzMvQ2ZmdG5lSnZpRmNXN1RXdmdYUjVtZ2tBLzQ5cjI0VTJrSVB0SkJjNmpqM3QvYm54Yi9BSUtiL0crUDlwUC9BSUtiL3RFZU5vNW1tMDYyOFJKNFAwdHM3ayt6NlRDbHE3SjIyU1NSZWI2RXVUM3JramVWV01mbi9YNEZMN1V2Ukh6aDhLUDJqZmlaK3l2cnJYbnczOGVlTVBBczhrZ2VSZEUxZWV4am1iL3BwSEV3ams1NUlkV0I3anJYM0Q4RS93RGc1LzhBMnEvMmZaTlB0L2lCYStHZmlScDk1QkZldy84QUNRNkdOTHZybTFaaXFTUTNGbUlVS3RzWUNSNFpjbFQxT2EvUDN4TWhDeU11RzRKRzQ4Wi9EOC95cVQ5cHI0cWFmOFN2aURiU2FIYjNscDRlOFBhUHAzaHpSNDd3S3R5MXJaV2tkdUpwbFJtVkpaNUVsdUpFVm1WWHVIVU13VU1lcW91NW5HbkZ1LzVhSDdsZkJ6L2c0My9aaC80S0VhcG9mZ0g0K2ZCeGRKazF5N2pzNEpOZXNyTHhUNGZ0NVpEc1F0TElpVHc1WmdONjI1Qzdzc3lxTTE3TiswRC9BTUd0UDdLdnhvdTdpNThMNkY0dStFZXRTTTdtNDhIYTNLSVdZLzNyYTY4K0lML3N4Q01ZOUsvbmYvWUMrQnR4KzFUKzJ2OEFEWHdCQ3NoajhTYTdhV1Z3MFpPNkNGNWxSNXZYOTN2M25IWkNhL1lmL2c2Ly9heDFxOStLdndyK0F1aTZ0ZmFmb04xcFYzNDM4VTJOdEswYWFuRjVyVzJueFRiU044YVN3M0RtTnNxU1VZZ2xGeHd6cFFjbzhpczJ6U0ZTcW5KTjNpbGZYK3JmcWRYOEN2OEFnMUwxTDRQL0FMUS9oL1V0ZStPNitMdmhycGVvSnFON29WeDRUK3gzK3BvcEFhMWFSYmhvMVdXTWVWSk1CdjJNd1ZWTzFselArRHR2NEsvRXI0aTNId1M4WDZQNFg4UStJdmh4NEpUV0pOYnVOSHNwTHh0SnZMajdPRW11VWpCWklmS2hPSkNOcWxYQklMS0cvTUw0SWY4QUJVYjlvZjhBWkhtaWc4Qi9GbnhscE9tMnZ5eDZYUGUvMmxwcUtQNFV0YnNTd0lQOTFGSTlhKzR2MmIvK0R1WDRwZUVwSWJmNG0vRHJ3ajR5dDR4c2U5MGFhYlFyL2pxNzU4K0dSc2Z3cEZFRDdWclV3OVJOTlN2YmEvOEFYNmt3cUtMOTZHL2IrdjA3bmd2MlNUU3JwbEc2RjFJeXBKeC85YjhLMHJPL210SmxmYXdiQkxNT3c2Zk1PdjQveXJ6MzROZnRPNmY4VXRHa2g4U1c2NmJmV3pMQjl1akg3cTRHQmd5S09VSk9ja2NmVG12UUw2R1RUcmVPV05sdXJOeHVTVkQ1a2JaSFkvNGYvci9qUEhZT3BRcU9qaVk4c3Z3Zm8vME1JMVUxelJNTHhsOExQRHZqdUdTU2EzRmpkTUNUUGFFYldQOEF0SWVQcmpCOTY5Wi9ZeS9ZUjhNK0I3ZTQrTFh4VmJTNy93QU0rRk0zV2ptNmkrK1VBSmxjTjFWVGdCZVFXSEdjQ3VmK0VQd3pYNDBmRS9TZEZ0WGt0Wk5RbkN5TWgrVkl4eTVJOU5vUDQ0K3Rlbi90N2ZIeGROOFcydmdIUVl4YitHL0RNS1JTZ0Q5M1BJQmphZlpSajJKUHRYTkRNc1dwZlVxVlIydGQ2NnBkazkxZmIwNkdOUnh0elFWcFByMjh6NTIvNEtCLzhGSC9BQnYrMEV0MXB2Z05wdEk4RXFwU1ZkT21NZXJYYWR6Snh1Vk1md3huT092b1BnTVNhVGRUc1pmdFViRmlXTExsaVRrbm4xN2M1Ny9oOW0rTGZnNW8vaXhUZWFCNWVnNnVUdmFGbllXdHdmVUhueXo5UGw1NkN2S1BGdWcyY2VvUzJQaTNSWTdTK2tKSzNxMjRMTU9PVDJjY2RRYzErcjhNNTNoY1BSOWhRaGEyNlZsTDFhKzE2cjdqejVVWlV0K3ZVOWUvNEpqL0FMZDhQd0hrajhCZUlkVS90RHdMcWszN2lhNEpXVFFKWC9pUW5qeW1PTnljYlRsZ2VvUDMzNHkxeTVSL3NrTHh5MjgrSkZkVHZTWlNNZ2c5RHdSejZHdnhzOFFmQlhXdEx2SW0wV2FPN3Q1dUxVbUpaWXBTZWlpUlV5RzYvSzRHYzljVjlqZnNFL3RYZUt2Q3RoWS9EMzR0ZUhKdEZzeTZRNkpyeFlQSEM1NEVGd056R05DY0JYKzZwT0RnRUd2bGVPK0Y2V0xielhMWlJjbnJPRjBuTCs4bzZYa3VxVy9xaXBVNVNqZTkvd0F6NkErSTNob1FrWEVMQXg5QTJmbEI3ai9QclhFNkI4VWw4TmFqTmIzQ3h5V3R3REZkUk0yTjYvNGl1NCtKbDI4Y3phYnMydG45NEY5Zjd3cnhUeHg0Tk9udWJoZHpjNVVZNjgvMHI0ckNSYm9xTlg0V2E0ZVYxYVI2OTRWOEpXZmlPOVpMUzhqdVlXVVNSQU9QTVpEN2VvNkhIZjhBS3ZSdkJhM25nZTRSb21ab2VwVXQwcjVWOEZlTlBLakdrelhrMWtyT0pMTytoLzFsaGNjaFhYSGIxQjRJSkhOZC93REJqOXVxeWw4V1RlRHZpUWx2b3V1V3NwdDAxVkJpMHVXeng1by81WmxoZ2hobFNDRDh2ZjV2UE9GOGJXcHlxWVZlMGlsZHgrMGwzWGRlbXE3TTJsVHB4dGJUelBzTFFwYlh4Wlk3YlZvTGVWaGw3ZVpOOEVoSTU0L2hKOXZ5TmZHbjdhZi9BQVE4OEovSHpXYnp4RDRKdUxmNGIrS0xnbVNlMCt6bVhSdFFrSnp1d21EQXhQVXFDdmNybXZwMnowNmV3OHU2czVGWldHOVhSdHl1dllnOU1mNFY2RjRKK0k4ZCtFdDczOTNKL2ZQb1BYL1BldmdjajR1enpoM0VlM3lpcTdkWXZYNU5QZGV1M1E3c1BVK3pVMDh6OEhmajUvd1R6K05uN05PbjZoYStJUEErclhPblhTS0JxZWp4blViR1VLNnQ5K0lFcnlQNHdwOXV0ZUMySi80UlRXa2x2ckdPU2UyWU9MUzlqWUt4QkJ4SW1ReFU0NmNaRmYwNS9FNzRmYXQ4UXZBMHNQaFR4TTNoSHhJRmFUVHRTVzJXNHR2TTdKY1FNTVNSRTljWVlaNElyOE1QK0NwL3hDL2FOMFQ0Z3llQS9qaGE2SGE3WkJlV3MybWFKYXcybXJLcElXZUc2V01TU0x5UVFXQkhSbEI0cit1ZkMzeE14ZkV0Nk9KcDA0VDNrdWVVWk5XM2pGeGFrcmIya3JkVWxZMGROUnVvbnlxdmp2V0xIeFgvQUc5YTZ0cVZycklrODFMNjNuYTN1STI2Zks2RUZjRGdZd0FCZ0FBVjlxZnM0ZjhBQlU2M2sweTIwbjRyYVcxMXR4R3ZpYlM3ZFZ1dnZZemNXL0N5NEg4VVJWdU1sWE9hK0hZN1pZVXpJR0xaK1UrL3ZXLzROK0hmaUQ0bStJTFhSZkRPaDZ2NGkxVjR3MzJUVHJXUzZtSlBKTzFBU0Jnam12MWZPc2x5L01NUDdQR3dYS3V1emo2UHArUk1xYWxvajlmL0FJYlgybC9FRFFqclhnM3hGcGZpalFjNE05cko1aHQyL3V5SWNQRVJuN3JxcDV6OWV3OE4rUEwyeG04bHBmTWFIN3lFOU1mNS93RDFWNS8vQU1FUHYyZnZGMzdGZmlIeEpySHhTc2RQMFRSZGRoYUFhUkpkUTNkN2NkR0crS01rSXUvQU85Z2VEOHVTRFgwWjhZTHI0WjZ2NCt1OVM4SStGcnpUNEpzdDluZThjd2I4OVFCZ2ovZHpnZTFmeWp4dGxPUzRTY3BZZkZScjYyNVZaeVhtM0gzV3U3dW4yVFBQeEdGcDk3bVhwbmlLejF5MGpqdU50dEx1eHZYN3BQdmlyOW40WTFLMXU0bmdobm5XUnZsTWVjYzhEQjZmNU5aL2dtSHhONGkxVlk5RDhQbXp0eGtlYmIyWmtidHh2YlB2M3IxUFN2MmJmR0hpZkRhdHE4R2tRNCs3SklacEcvNEF1UVB4TmZrendkUjFPV2l0T3F2ZTN6MlgzazBjTEo2eHVkTjhMUDJrdkUzd2gyQysxYlRQN1BqQUQyYzgzbmxoanNGenRQYnFLOVEvNGVTK0daSm80YmZSOVJ1YmhseXdqY2JjKzNHU1B3cnp2dzEreU40VHRJY2FwZWFscTBtQm5jd2dSajM0R1QrdWE5RzhMK0J0QytIOXNrZWk2VFk2ZXE4ZVlxQXlOOVdiTGZyMnI5SXlIam5pTExLUDFXaGlHb0xaU1NuYjBjazlQblk5aWxoNTI5NlNYNG0xcG43VTNpYlg0NDVyWHdaTlkya2dKOHk5Znk4ajhjSDlLMG92MmlkZVJXTTBPbXg3dnVyQWpQai9BSUV4eFdCSkhlYXo4c2Naa083bGlEZ2MrOVhySHdDQ29hNmxWZWgycDh4cjBxWEhYRWxTVG04WEszbnl4WDNKSTZPV0MwUkpxUHh2OFJheXJSaTZhM1Evd3dxRlA1OWZ5ck1pMHZVL0U4bTZUelpGYnFYSmI5ZjYxMWVtZUdyR3liTU52NWttZnZTYy9wVzNhNlZOY2piOTFmUURBcng4YmpjVG1GUlBHMTUxWDZ0cjVYL1JGUmk3ZTZqbGRJK0cwY1cxcm1UYjZnY2ttdWkwM3cvWjJRL2R3cXo5aTNOVjljOFhhSDRXVnZ0bC9HODBmL0xDSDU1RDdZSDlhNFhYL2pUckdyeU5Ib2VseTJzSFFTT202Umg5T2dyenNSbStCd0w5bk9VWXZ0dS91L3pOSTBaUFcxejArNU1OcEVXbW1odDFYbkJJQi9BVmphbjQ5aDAvNWRQdC9PbHh6Skw5d2ZRZGE4cFRUL0VtcHplWTFyZnpNeHpsMVkvMDRxNURvSGlhTS84QUlQdldJR1FCRXhyeksrZXVyRC9abTFmN1hLMjE2YVdYNHNQWjFiNlJQUWRSK0kyb2F4YXh3M0ZqcG5seFl3VWoydG42NXFoTnA5cHJyZ1RXVVRkdzIvR0s1bTM4SitLTHFYNWJDOHpnSEhsc0swTFB3ZDRzODBCTEc3YnVSNVpGZWJpTXl6S3JWNXFzNnM5bDhGOXRMYUluNnRPV2pnZE5vM2dpeXNuV1NFM0VMTDkzYkxuai93Q3RYcVhoVDRqSFNMRmJlN2trdXRnd3JzUnVIc1QzcnlEUi9BdmpTK2orWFRybjVRUU0vTCtwcXhjZUMvRjlpV2FhMHVJMVhnbHVuNTE5anc3eEJtbVIzeHVEbzFZcVMxYnB5NVg2NlcwSmVIbnNrdnZQZElmaVhwZHluelNTUWtmMzFQOEFNVWszaWpUNzMvVjNrSjlzNHJ3cTNzTllpd0pER3U3Z2JwSzZleCtIZmlDNnNWbVdTMkNTREkrZXYwbktQRjdpUEdTOW5oOEo3VnBYYVVKWHQ4bitoSHNtdC96UjIrcHdOZTdtaFpaRlBJS3NEWFA2dnBzMFN0KzdrOXNDczVQQk9zUk5ocHJlUDFQbTlLbHM5QTFxVzdFTU9vSXNqWnhsbTR3TSsvMHI3bkJjZFo3V1M5cmxWVDVYWDRTUy9NMVhNbDBPdnQ5Ti9zM1RvWVArZUtCU1IzSTZuODhtcXQxRUNNZW5YMnJuN2p3MTRyaVZ2K0poRzNPT0pUL2hXWFBvdmk1VzNDNlZzYzQ4M1A4QVN2cG84Y1l5Sy9lWlhYWG9rLzFNZVZ2cWpwYmxjQnZ2S2VCejI2VlV1Rnd4emtkc2V0Y3lMSHhjWCthV0ZlY0hMcndmeXBJYlR4UXR3clNUV3pMMzNFRlJqOEs2WWNjVlpKTlpkaVAvQUFCZi9KRktpKzYrODlRK0QyanJxSGptR1psR3l3amU1UGZrZkt2L0FJOHluOEs4bS80S2svdEpMK3pSK3lWOFRQSGZuSkZjZUdkQXVycXpMbkN0ZGxDbHNwLzNyaDRrOTl3SGV2ZGZnM1pUYWY0T3Z0UXVQTEUwekNFYlIxQ2pKUDB5MzZWOENmOEFCd0Y4QlBpTisxTit3bjRoOE0vRGZUN25YTDk5UnNiMi93Qk10QUd1dFVzNEp4SzhjS0VxSGRYRVVvVElMQ0VoY3NWVS9iWWZFZTBveHF5aTQzVjdPeWE5Yk42L001K1c4N0kvbTUrQ2Z3TjFyNDhlSU5RMC9TN3ZTN1greDlMdU5hMU85MUs2OHRMU3p0MDh5NHVOaWg1NS9MVGRJMGR2RkxMc1IyMkZVZGxoK01Qd21iNFdhcHBqMnVwUmEvNGY4UmFmSHFtaTZ4RkEwRVdwUUV0Ry93QzdjN28zaW5qbWhkRzVEUkVqY2pJemFXamFoNG8vWk4rS1UzOXZlRTV0TDFwYks3MDI5MFh4UnBselp0TmJYVUVsdGNSc2hNTTZiNHBaRTNSc2pnTWNNS3AvR240NGE1OGNOY3RialZKV3Q5TDB1M2lzZEcwYUM1dUpOUDBLMWlnaWdTQzJTYVNSbFVSd1JBbG1aM0tiblptNXJvOTF4dWlXbW5abkZrNDl4U0JjbmlsMjROQ0xrL2pqclVnZmVQOEF3YjJmcytmOExsLzRLRWVFYjZhMU0rbitGYmlUeEZjdVZ5cXhhZXF6SWNlcTZqTnBCN2NFK3RNLzRPSi8yanJqNDkvOEZKdkVHaGk2ZTYwWDRaMk52NGRzNC9OTHhSemxQdEYyd1hPMVpQT204cGpqSkZ1Z1AzUUI5ay84RzFQd3gwejRJL3M3ZkZuNHkrSW1XMTAzVExHSFRXdXYrZU1NY0IxYS9jZXh0NXRMQkg5NjFQOEFkRmZqVjhVdmlUcUh4bCtKZmlUeGxxeEIxVHhkcTExclY0UWNnUzNNenpQejlYeCtGYVMwMEs2Ri93Q0RuN1F2ajc5bkRXLzdTK0gzamp4ZDRIdm5JTWsyZzZ2UHA1bHgyY1JNb2NlekFnanJ4WDJ2OEFQK0RtejlwcjRNK1RiZUpMM3duOFR0TmpJRExyMmxyYjNtenVGdUxReEV0L3RTTElmWE5mRWZ3aStJMXI4TWZFOGw5ZmVGUEMvaksxdUxjMmsybjY3RE5KQVkyZEM1UXhTUnZIS1VWa0Vxc0hqRWpNaFZ3cnJpZU5kVXNOZjhWWDk1cGVqMjNoL1RybVV2YmFiQmNUWEVkbW5RSUpKbWFSK21TekhrazRBR0ZCN1NTV2orWDlhR2JoRnU5djYvTS9lVDltRC9BSUwyL0FYL0FJS2VlT3ZEL3dBTGZqSjhFN1hUOVU4UTNLYWZwcDF1M3RQRkdpZmFaR1dPSlRKTENrbHMwa2pJaXQ1UlZXWlFYVUhjUFZQMmcvOEFnMmUvWlorTTl2Y1gyamFONGorRmQ2N1pOeDRkMWxqYWIyNmI0THNUUmdlaXhtUHZYNC9mOEVHUDJlLytGL2Y4Rkl2aDdhelJ0SnAraDZtbXZYaDI4SkZweXRxS3NmOEFaTnphMlVKLzYraDZtdldQK0RuSDlxL1ZQak4rM2dmaHZIcWwxTDRWK0YybTIwUDJBUDhBNk0rcFhNWXVacDl2UnBCRExieFpQM2ZLWURHVG1aUmhvMnRmTFEwakthamErbm5xZW9mSEgvZzBLK0pYaC9VbC93Q0ZkL0Z6d1Q0aXMyYmxQRXVuM1doM01RSjQvd0JTdDByNEhmS1o3QWRLK3hmMmgvMkt2Rlg3Q0gvQkFqeHQ4S3ZCY2JlTXZHeDBHWmRYdU5LdEpGR295WFUwVWQ4WVk4YjJTR3h6Q21SdmVPMlFsUVcyajhPdjJkUCtDbXY3UVg3SnB0NC9BSHhjOGFhUFkyb3hGcHM5Ny9hR21JUGEwdWhKQi80NVgzWCt6ei93ZHAvRnZ3U3NOcjhTL2g1NE44ZTI4WVVOZWFWTkpvV29QNnMyQk5iazk4TENnK2xPTUZhMFpmZi9BTUFYdEhlN2o5My9BQVQ4bTJkUSt4V0dWTzBqL3dDdDEvT3JHbWF2ZWFIY1BMWTNsMVpUU1J2QzcyOHpSTTZNTU1oS2tFcVJ3UjBJcitnWDRWLzhGRGYyQnY4QWdzYjhSZE44RytQL0FJVTJ1ai9FRHhWS2xuYXQ0azBLS3p1TlN1bndGZ2cxYXhrODdlemZLdm10Q1hZcW9CWmxVei9IL3dENE5KZmduOFNXdWJyNGJlTlBIUHc1dnB2bWp0YmhVMS9UWXY4QVpWSE1kd0I3dE81OXFoODhOV3Z1ZHh4VUpiUDcxWS9ucXh0R1B3cjl0djhBZzB5K0JWdm9lbGZGRDR0YXI1ZHRhNmZwOGVpMnQxSjhxZ1hFdm4zWVkvOEFUS1BUN0p3Zjd0MjNRRTUrZWZqbi93QUdwdjdUZnc0dnBENFB1UEFQeE1zV2ZFUnNOYUdsM1FVbnJKSGVpS05UNmhKWCtwcjlDL0VYN0wzaXIvZ2xaL3didWZFbnd3dHRCcVh4Q3VQRGQ5ZDYrZEdkcG9iYWE4aWhzWkhTVEFKK3kyQ1JGNUFNRjdlUjFPMGcwNDFFazJQMmJ1bCt2K1IrQTM3VjN4MHVQMm5mMm12aUY4UkxwcHQzalh4QmU2dkdrcHkwTVVzek5GSDlFajJJQjJDaXV1L1ppOEgrRTlFK0NQeFIrSlhqYndyYmVOTlA4Tm5TZkR1aWFWYzN0M1p4VDZ0cUZ5MDI4eVcwa2NoS2FmWWFqdEc0cUpKSW1aWEEydDRrbTFRRlVydFhqZzVycy9nOSswajhSUDJlWjd1VHdGNDY4WGVDNU5RMkc2T2lhdFBZaTRLWjJNNGpZQm1YSjJzZVZKeUNEVGpaUFVpVjJibjdhZndVMHY4QVp5L2FtOFkrQ3RIbTFCdFAwSzZqalczMUNSSkw3UzNlQ0tXU3d1V1FLclhGckpJOXRLd1ZBWklIT3hNN1I3Si93UkUvWnpIN1MzL0JTSDRaNkhjUUxQcGtXdHdYZDhHWGNwZ3R0OS9QRzMrekxhMlYxRm4xbEE3MThuMytvVDZ0ZnozZDFjVFhWMWRTdE5QUE5JWkpKcEdPV2RtUExNU1NTVHlTYS9aLy9nMFIvWnkvdEw0bC9FUDRtWE1JMjZMb3k2VFpTTjkxcGIrNXh1QjdQRW1tVHFmOW0rOURWVTk3aWxkbm1YL0IybCswMU44VVAyN1BDL3czdDcrU2JTL2h2NGVTNXU3YmQ4c1dwNmd4bWtZanBrMnFXWEo1K1krdGZtWDhMZmpGNHUrQlhpaGRhOEQrS3ZFbmczV0krRnY5QzFTZlRybGYrMmtMSzM2MTZGL3dVRS9hSlA3V3Y3Yi9BTVZ2aVFzN1hGbjRxOFNYYzJuTzNVV0NQNU5tdi9BYmVPSmZ3by9ZYy9adTAzOXBqNHkzdWs2NU5kVytnNkhvT282OXFCdDlUdGRLZVZiZTNmN05BTHk2RFc5dTF4ZXZaMndrbFVxRGM1d1NGVnBoek4rN3VPcGJaN0gxQit6bC93QUhPSDdXSHdGTUZ2cTNpclEvaWZwY0lDaTM4WDZXczg1QTlicTNNTnd6RWQ1Skg1NmcxK2kvN0ZQL0FBZGFmRHY5cFh4L28vZ2Y0b2ZDL1ZQQWR4NGdsRmdkVnNiOU5hMFpTNm5jOXpFOGNjc0Z2ak85djN3VmNsdmxERWZnUjhZdkQraytFL2lqcm1sYUhIcnNPbTZiY20xV0hXZkorM1c4aUFMTkhJWVNZbTJTaVJRNllES3F0aFNTbzkyLzRJKy9zNmY4TlIvOEZDdmhuNFJtZ2E0czlTMXVCTDFNNFY3UlNaNzFTZmZUNEw4ajNXdEl5NW55ejEvcnVadUNpdWFPbjlkaitnYjlxRC9nM0QvWkYrUDZhbHFOeDREbStHT3BPeGVmVXZCK3BuU1lZR0xZQit6U0NTeWpYY1FNTENvNUFyNEovYVAvQU9ETnp4VHBTU1hud2orTW1pYTNGSWQ4R25lTDlMazAyUVI5Z3QxYkdkSlNmVXd4ajZkYXdmOEFnNzQvYTIxTHhwKzByNEQrRGRucVZ4L1lQaGpSajRsMWV6aW1LdzNHbzNrcnBGNXlBNFpvcmVFTW03TzBYYjQrOGMvbTMremgvd0FGRGZqcCt5QkxDdncxK0xIam53bloyN2IxMDYyMVI1ZE5ZOGZlczVkOXUvOEF3S00xakdFUE5lbitXeHRLcFB5ZnIvbXRUMHo5b0QvZ2hSKzFwK3pmZE91c2ZCSHhocmxtckVMZmVGSUY4Uld6S1A0aWJJeXRHRC8wMFZEN1Yrdy8vQkpUNEhlS3YrQ1RIL0JFL3dDTEh4TjhZK0c5UThNK1BMelNOUThVUTZScU5zWUwremhzdFBZV01GekdSdmpaN3hydWJZNERJbDR1UXAzS1BpWDltMy9nN3QrUG53ME5yYS9FandqNEYrS0ZsRU1TM1VVVGVIOVVsOS9NZ0RXdy9DMkZmb0wreXQvd2NvL3N6L3Q1YXZaZkRmeGo0ZjhBRTNnblZQR3lIU0pkUDhTMkVHb2FEZm1jR00yclhNVE44anF4Vm1uaGlqd3gzTUJtcTluS3pVV21aKzFpbW5LTFZ2bi9BRjh6K2FhYXp1ckswaGU2aXVFa3VsYVpaSmtaZnRBM3NqTUMzM2h2UjFKNStaR0hVRVZ0L0J6NHNhcDhDUGk3NFo4YmFISFl5YTM0UzFPRFY5TysyUW1hRkxtQnhKRTdKa2J0cnFyQVp4bFJuSXlLL293L2FSLzROTC8yYnZqTmVYbDM0RnZ2SEh3ajFXYmNVdDlNdlA3VzB1TnU1K3pYV1pzWi9oVzRVRG9NREFINS93RDdTUDhBd2FMZnRFZkMwWFZ6OFBmRTNnSDRwV01JekRhL2FXMExWcGZyRmMvNk1Qb0xvMW43UnA2cHIrdkkyOW5mWnAvaCtmNkg1VGpjdjk1aTNKSk9TZnJYNndmOEdrWDdPeCtJL3dDM2RySGpxNXQyYXorSCtpWGQ1RExqL1Yza3lMWlF4bjJraXZieHgvdFdnOU1qOC92Mmp2MkEvamQreUhjU3I4VFBoVDQ2OEgyOEw3UHQxOXBNcDArUTUvNVozU0JvSlBxcmtWKzVmL0J2MzRHdVArQ2QzL0JHNzRuZkhyeEpvMXhZM1dwYWJjK0piS0s4Z2FHVFV0TjAyMG51TFp0allaUkpkM044aUVnZVpHc1RqS3VwTjA1cXprbnNpWlU1M1NhM1B5Yi9BT0M0MzdRNC9hWC9BT0NyL3dBYXRlaHVHbjB6UXRZLzRSWFQrY3hpTFRrVzBZcC9zdk5GTElQK3VtYStmZmc5OEZsK0svaDM0aWExY2FyL0FHUnB2dzg4TVA0aHVKUmJmYUd1NUd2TFd4dHJWUnZVS1piaThpQmJKMm9zamJXMjRybDdpK3VkWGprdnI2ZVc2djcrVjdxNm1sYmRKTks3Rm1jbnVTVGtuMXpYWi9BYjQrdy9CN1R2RldpYXg0WTAvd0FaZUVmRzFwQmFhdnBWeGR6V01oTUU2endUd1hFSkRSU3h1RGpjSFJnN0JrYmdyY1lxeWpJbWN0YnIrdjZSZ2ZFajRSYXQ4SjlJOEczbXJTV2Evd0RDYmFDdmlPeWdpa1pwN2ExZTZ1YmVQejFLZ0k4bjJZektvTEF4VFF0a0ZpbzdMOWhQNFBhaCswUCsxNThQL0JlbHlUVzk1NGsxdTAwMk81anlXczJ1Smt0MG40NS9keVNvNTlsSjZDdVUvYUQrTmw1KzBIOFVicnhKZGFicCtpd3JaV09sYWRwZGkwald1bFdGbGFRMmRuYlJ0SXpTT0k3ZUNOUzdzWGRnenNTekUxK2hQL0JwL3dEczYvOEFDMmYrQ2xNZmk2NWkzV1B3MzBTKzFrTVZKUnAyaUZsSEdlMjdkZnJNdWU5dGtjclJUMG42RVQrRSsyUCtEcGovQUlLZS9FTDltTHhIOE8vaEg4S2ZHMnRlQmRROFEyVno0bDhRNmhvdDY5cHFuMlJaQkRad3gzS0VTUkk4a1Z5WDJFTS9sb000M0J2enEvWjMvd0NEbFg5cmI5bldTM3Ryang5Wi9FalNiY0JQc1BqVFRrMUZtSHZkSVlydGoyeTA1cm5QK0RnYjlvOC90RmY4RmNQakJleFhCbTAzd2RkUmVETEFBNUVRc0VFTndvOWpkaTViaisvK2Z4bDRWOE5hbjhRZkdPbGFEbzlwTGZheHJsN0RwOWpheDh2Y1R6U0NPT01lN013SDQwUWsxSFRxWFVoSFo5UDZaKzlQN092L0FBZVNlRHRiOG0xK0xud2ExL1FaTm9FdXBlRXRUaTFLR1JqMVAyVzVFTG92c0pwRDlhN2JTUGdaL3dBRXJ2OEFncjM0cGp0ZkNjL2hmd2I4UWRlWlVndHRFbnVQQmVzU3p2enNpczVVV3p1SmllMFVVcEp5Y25tdjU1ZmlKNFBtK0cveEMxN3c1Y1htbjZoY2VIdFN1Tk1sdTdDWXpXbDA4RXJSTkpDNUNsNDJLa3F4VUVxUWNEcFhiL3NiZUF0WitMdjdVM2dEd3Y0Zm1lMjE3WGRkc3RQMHlkUm43UGVUenBEYlNIcjhxenlSRWs4QUE1eFFsQ2JTa3ZtdC93Q3Z1SnZPbW55djVQVkg3SmZ0RC84QUJubHExb3QxZC9CejQ2UjNTOWJiUi9IV2xFYlIvdFg5cnV6N2Y2S29yNFIvYUgvNElNL3RmZnM3UEt1by9CVFdQR1dueHZzajFEd1JLbXZyTU04TUlJQzF5by82NlJLYS9Xei9BSU9VditDdUh4RS80Si9MOE9mQUh3ZjF5SHcvNHY4QUdpM21zYXByRDJsdmUzZGpwMXVWampTT09lT1NJTlBJWmN5RkN5L1o4TGpjVFh3RCt6Ny9BTUhhWDdSM3drbmh0ZkhtbCtCZml6cDhiZnZaYnV3L3NiVXBCL3N6V2V5QWZWclpqVHA4OXJ4bHA1Ni84RXVVdXJqOTJqL3lQMEMvNEluZnMrZUp2K0NWZi9CSXo0cWZGVHgxNFIxWHczNHhiUjlROFdObzJwd0czMUZMTFRMRzR1YmFLNGhQelJTUGNTWGpCSEFZUnlSN2dweUIrRVBnUFVuVDRiV0gyaTRlNXZyN3pMNjhtY2t2TFBMSVpHTEh1MkdBSjY1OTYvYzM0QWY4SGFIN052eHEwNGFUOFRQQ3ZqVDRjeWFoRTBGNnQxWXgrSU5GS09Ockl6d2Z2M1JnU0NEYVlJOWVsWWNIL0JGdi9nbnIvd0FGSWJpVFVQZ0Q4VFkvQ1BpQytWN3Y3RDRIOFZwTnRKeVMwdWszdSthTkJ5ZkxRUWdBWUFBRmEwNms2YzNVbEcrblRwL1hxWlhweWp5TjhydmZXK3Y5YW41ZmZzVitGN2Z4SkY0NnVkUGJ3RC93bmxuQnBrUGgrWHhtZE9rMHJUTGFhK1VhbHFiUmFqbTJsTnZib0ZJZFhNY2QxTEtxNzRsZFBuVDlxN1UvQyt0L3RDK1A3N3dMYW14OERYdmlYVXJqdzViK1VZdkkweHJxUnJSZGg1WEVCakcwOGpwempKL1Q3OW9qL2cwMi9hQThBck5jZkRiNGtmRDM0cGFkQ205TFRWNEpmRHVxU0hzcUwrOXRpZVQ4enpvUGF2Z1g5cDMvQUlKdy90QmZzdlBOL3dBTEkrQi94RThOMnR1Q1pOVHQ5T09xYVdPU2YrUHUxM3dmaHZ6V3p4VktXdDdQek5JMGFpdWxyNmEvMXYyL0krdVArRFNiOW5kdmlaL3dVVTFieDFjVzdOWmZEblFMdTdobTJibEYxT3EyaVJIMExKZFBJRDYyOWNYL0FNRmF2amIvQU1OSWY4Rll2Mmd2RTBjLzJqUy9DdXBRZUE5TUdjckdtbklJcmxWLzJXdW81SEdQK2VuNDEraUgvQnVSOElici9nbmwvd0FFby9pdDhlUEdtZzZobzgycjIxMTRtUzF2YmQ3ZWE4MHJTcldlZUtUWTREcUpIa25RRWo1MWpSeHVWbFkvaWo4TzlZdk5XK0hpYWhxRnkxOXJYaVM2dU5aMUtkMithZWU0a0xOSTMrMFFGUEhlcHcwVkt1cmZaWDUvMHpPVjFUYi9BSm4rWDlJenRTdmhwbXNXdDIxdGEzb3RaMGwreTNTczBOeHRjTjVjZ1ZsWW9jYlNGWUVnbkJCd2FpK0t2ajdRL0hHcjJkeG8vZ3ZTZkE4a2FNdDVCcFdvWHR6YVhVaGJoMFM3bG1lSEFHQ29sWmU0Mi9kcmEwTFJmRHVvZUtvSVBGR29hOXBPZ3NzZ211dEcwdUhVN3VJNE94bHQ1YmkyUmh1eGtlY3B4bkdTQUs4ejFnTGJOTDVlNHg1K1FsUUdJeU9veVFEalBHU09NWk5laFUwTTQrUjlLZnM2ZkNIKzBQRGVweUxjcmRCTHpFbmxxd0FPMGNjZ2QvUUgrdGFuN1MzeGIxTDltdWZ3bkhZM2h0WVo0cDdtNHRXakVrTjB1NUFBNm5uam5sY0hrODlSWHBIN0FQN052aXI0TWZEM3hSby9pL1Q0NHAxMVJacldXS2RaNGJtSXhxQzhiS2Z1N2xQQkFJN2l2QWYrQ21ldHdOKzFJTkh1dm1zZEwwaTBnWlZPVEdYRFNsZ1BVYndmcHgzcitWc0RHbG1IRXNzTEthclVveGNycXpUVmt2TlgxL3BubjFJY2sxRkgyWi93U04vYVo4Ti9GUHhSNHU4Y1gxZ2ZEMmsrQmRGbXVOUzFPZVRicHNMTUFGVVRTQmNPZjduSjkrZWVEK0lYaStieFRyMS9xdDB2bXBxMDhsMHJxMjlTckVrRlNNaGh6Mi9yWDVzK01MWFYvQlZoTG9zR3Izc25oblVabHZSYlEzTC9BR0tlVUFxc3BqQjJsZ0NRQ1JrY2lwdmcvd0R0Q2VMZmc5UDVla2FqNW1uazVsMDI3UG1Xc25xUWhQeW4vYVFxZVB3cjNjVjRXNGVWU2VPeXlwWnl0YU1yMnNsdHpicDN2bzAva2R6cHFwRk9QOWR6N3Z2TGVQWThsdk1VNTNGQ1BsSFhyeC85YXNmVXRhdC9FbGkybjZoYjJ1cTI3TmhJcENkNk54Z28zM2xQYksvVG5wWGxQaEw5cnp3NzQ3c0k3ZlVESDRaMVY4Z3BNKzYxYytxeVkrWG5zK1BxYStoUDJKdmc3ZCtQdmpIRHJ0MUhITm9maGVQKzBKcGo4MGR4Si95eGpCQndkemZOOUZOZkpabGdhbVZVcDE4ZW5Cd1RhdnBlMjFtdDd2UldaaktMVHROYUhOYUQ0WWovQUdjTlh1N1N4Z3ZMclVMNEF5elN0djhBc2k5ZklCVUFaQnp1YmdudDB5YjNpSDRvYVByL0FJWW1Gd3EyOG1TdUpCbFFlaDkrZnk2VjlPYXQ4UExhN2ludUdzNDVKSkdMeUtWQnpubkZmT1B4WitIbW5YdmlqYmEyeklYYkJRRDVmL3I1NHI1cktjK280K3R6VjArZlJ1VjczdCtYa2VSS0hQTFE2cjlsejQ2WEhqeUY5RzFrWEVpNmJpTzAxV2MvTHNPQXNEc2NIUElDTjZjSHNhN3I0czZjMXZidSt6NWNjcVYrWUhucCtINWZsWHpoOGNmaUJOOEVZN0x3cnBtblNTU0pHbHpldEhFY2VhNEpXTThZd3FzRDlXejFyZjhBaFYrMTNlK09vVzBQeE5wOTg5d3dBdE5SRURGWXdCOTJVampISERkdWg3WTlqRlpiWHEwWGpzUEMxTjYyNnRkN2QzdjZHdFIyOTJQUXI2bnFQL0V6WWhtVmtibGNZSlBzUGFzdjlvTFRZL2lENEZ0L0UxbkhHMnMrSEVFZW9ubzF6YWRGbFBxVWJHZlppZTNHQjhZZkZjbWdlSlB0VWZ5U1JuRXVEZ1Budi9uaW8vQm54Yld5dmJYVXJYOTVDN2VYY3hFQXF5dHc2c3ZRaGhuZyt1SzlIRFlHdFRWUEdVVnQrUGVMOVZ0NTY5Q28xcnJsbnNldmZza2Z0ZytJdmhyWTZXdjJnYXI0Zmt1QkJlV003bHZKUW43OFo2b3d6N2oyNzE5MGZDMzQwK0Jmalo0aDFiUnZEK3RXc25pTFFaUEsxTFMzY0plVzNBWlcySGw0eUNDSFVFY2dIQjRINUthYklmaDk4WTc3dyt1OWRKMUlDNTB4aVR0V0NUTFJqSjY3U05oNzVTcy85dEdXOThDZkdEd2g4UU5EMUhYdEw4UTY5WXh4eDNla3llWFBEZldRamhMZktBek0wWmpiNzJUdnh3b0dmT3gzaDFsK2I1aGFNdlpUcVJjb1NTdW05SGFTNjZjMTlVMVkyeTJzM0tWR3ByL1hRL2Nyd3A0bHV2RFVxeDNIenc5Qm4rSC9BRC9LcmZ4MitCbncvd0QyenZoZk40UjhmYUpiNjFvMDUzMjc1QzNPblRZd0pvSlI4MGJqMjRJNElJeUsrVFArQ2NuN1pIajc0dy9EdHJmNDBlR1c4UHpXc01Bc1BFVndGdFRyU3VPc2x0OTVXQUdTNjRYNWdNQTgxOVpwRE5vMDBjOXZPSkluK1pXVWhsY2RzTU9EK0hGZmxOVEtzWmsyUGRLYzE3U20xYWNKWFhsYVNlajh0R3RqMTVSbFQrSFkvTmJWUCtDR1dtL3N6ZkZxYldkZWE2K0luaEdHOVdiUXJSWWRrYzRHU0V2d3ZKWlRnYlV3c20zcmdsSytrUGc3OEg5ZC9zVCt5TkQwblFmQnVreWMvWmJXT0hUa2x5eFBLUi9NeCtaaU53empOZlhXbCtNNDlWdG10WlczTElOckkzektSL2g3MXduajc0UFlpa3Z0TVo5aEdXUlA5WkNmWFBVclhvOFFjVFp4bVN2aTZybWwwdlpmY3ZkdjNkakoybHZlM1k1L3dkK3g5YXhYRFM2MXIzbWhqazI5aEQxSGZNai9BTkZyMVh3eDhJdkN2ZzJSRzAzUTdYek1qOTdPVFBJRC93QUNPUHlGZVcrQi9IK3ArSDcrT3h2WVJOQ3hBVjJHSzl1ME83akZvck0yZk1UUDA5SytSampzUFVYSkJYbGJVMm9jdHJ3Um9JN1NvRXl5cU1EYm5BL0tybHRZaWNqRzQ0T2VSVks5MW1LMkNLZys5NmRUVDdYVkxpYTVqUlkyWldIUDk0Vm5UeEVsVXQwT2hYZWhyUWFRcW5jenFwOVBTdEN3dFlGbCtXUHpHNjVZL3dBNmswSDRmNno0aklNTUUyM2prcjFyc3JMNElYMmw2WkpNWTB2TGhWeXR1SlJIdlBwazhWOXpoY2h6akcwYjVkUWxKV3ZkUmJYMzdmZHFhUnAyZnZhR0hicHVLcW1TT09BT2xhVWVtTFl3ZVplTkhCSDFKa0lHSzhhK0pIeDU4V2VHTlhtMHR0R1h3enRPM2NGOHlZKys1aGpuMUEvR3VJaThjNjBkUWE5bXZycTdra1B6Q2VRc0c5ZU9uNVY4N1VvVnNJNVBFSnltblpyYTNmZnQyMEZVeFVJUGxpajZRWDRsNkxZWEtyNVU5MUdHd1dRQURIdG5yWHAzaHkwMFB4ZHBLeVc3TGQyN0Q1bExFWVBvdzYxOG1hRDhRTGErS3JkUnRielNEYmxSaGZyL0FKL2xYb3ZnYlhialFYanV0UHVHNDZFSGdqMFBxSyswNFI0MndPV1loeHh1SGpVcHZmM1U1UjlMNk5kMStKbDlZbk42SDBCWitBTkV0STlzZWthY3E1ei9BS2hldGFsdHBkdmFxQkhid1IvN3FBZnlyaS9CZnhwdGRXRWNPb0o5bW42YjFIeUUvd0JLN3EydVk3eUZaSTVFa1J1aktkd05mMDl3N2pzaXpDaXEyVktGdXFVVkZyeWFzbXZ5N0ZlMGs5RzJPV05WSHlxbytncDIzajYwN1p4bitkQU8xZS9GZlVjcUpHa2pQOWFrak9EVVRIUDQwOVd5S29DWkQvU2xualdlRmxZS3lzTUVIb2FpVjhIL0FEeFE4bkhVMHBSVWxhV3dISCtMZmhUYWFubVMxMnd5ZGNIb2ZwWFBhVmZYbmcyL052Y3F6V3JIREw2ZTRyMGU3bC95YXd0YU52ZXhlWGNwdlE5eDk1ZnBYNWRuM2gvQ0ZiKzBzaGZzYThkYkxTTXZMeXYyMmZZT1MrcTNNcTZjU3grYXJibzNHVlA5S2s4TFc0ZTd1SnY3b0VZT1BYay95WDg2ejN0bTBGbWFOdnRGZzNEN2Z2SjcrMWJtaVJ4d2FXdmx5Q1FTTVhManY2Zm9BUHdyNkhoUGlKNCtUdzJNajdQRVUvaWkrdjhBZWozVC9BMWRTOGJQY211eUdCL3ppczI2NTU5UDhLdlhiWkI0K21LenJvNURmcnowcjd1TzVrVXBsR1BwM3F1d1VEY1FBUGNmai9uL0FQVlZpYmx2WEo5T3RXL0NlamYyL3dDSnJLMFB6UnpUTHZ4L2RCeTM2WnFnTzgxQWY4SXI4T2RQdE9rZ2hFa2dQOTU4czJmeFlpdnhnLzRLMy84QUJ3cjRvL1l0L2F5dVBobDhOL0NIZzdYcFBEZHZieStJZFE4UWZhcHN6enhpWmJhM1NDYUxadGhlSXRJN1BscENvVmRtVy9ZajQ2ZUpyZlRyRzRudXJpTzF0YlpHa21ta2Jha0tLQ1dZbnNGQUpKOXEvalIvYWIrTjF6KzByKzBYNDgrSUYxNWdrOFo2OWVhdXFTSG1DS1dabWlqK2lSYkVIb0ZGWEdWak5MUzUrdVhnWC9nNTIrRVB4NjhOTDRkK1BYd1J2UDdObHdraXdSMm5pYlMySkdHZHJhNldKa0hzdm10empKcmFpL1pCL3dDQ1p2OEF3VVJsM2VDZkZtaCtBdkVkODRDd2FMcmtuaHE4YVE5RVN3MUpEQzNQQkVNT0QyUGV2dzUyOE5udFVFa1N5Y01GSzV6Z2lsS01IcTQvZG94ODgxb245K3FQMTMrUHYvQnBuNHowV0o3ejRYL0Zqdzk0aGhmOTVEWStKN0NYUzVtVHJoWjRQT1NRKzVTTUgycjR6K0tuL0JFYjlxejRTNjlGcCtvZkJMeGhyQXVaUkRGYytIQkZyY0Q1T0EyKzFlVHl3ZXVaUW1PNEZldGY4RzdYeHY4QWlab1g3ZlBnL3dBSCtIL0ZIaUErRU5ZbG10OVUwQ1Mva2JTWm9oYTNGeEpLMERFb3NrY050Tzhib0ZiekZSZHhWM1J2MG8vNEtqZjhIQkdoL3dEQk8zNC8ydncxMGY0ZlA4Uk5mdExLSFVOY2xrMTBhWGI2YUpodmh0MXhCTTBrelI0a0pJVlVWNC92bGlFWHMydmhsOS8vQUFDbEpXOTVmZHArZWg1eisyWDhOdFovNEp1ZjhHOWVvZUVKYkpMRHhsNHFnV3cxeUszWVhDMmQxcTk2WkxtM0xvU2pMRGF5UGFCMUpWdktRcVNDTS9nNnpiUHU5Sy9mYndsL3djWS9zcGZ0Z2VBYnZ3ZjhaL0NQaUR3cnBldFFDSFViTFhkSkd1YVBLTndPM3pMWGRLU3JCV1Z6QWhWbERBcXlnamw3di9nZzUreFgrM2haeVh2N1AveGVmUWRRa2kzcFphRDRoZzhSVzl0bmtHV3d1SCsySWY4QVphWlBwVlNqTzk3WDlCS1VHclhzL081K0ovaFg0bFhIaFB3WDRtMEVhVDRkMU96OFVRUVJ5UzZocHlUWGVuU1F5RjQ1N1NmaVdDVERTSXdWdGtpU0VPajdVS2N5UndhL1RmOEFhRy80TlcvMmdQaHExMWNlQk5iOEUvRTZ4ako4cTNTNk9pYW80OTRiaytRRDdDNGJtdmlyNHcvOEUrdmpwOEJOWVhUdkdId2grSTJoVFRUQzNnbGwwQzRtdHJtUThBUlR4cTBVcHovenpacXk5b3RuL2tWN09YVC9BRFAxRy80TlYvZ2hiK0Z2RGZ4VitMbXJxdHJZNlpwMFdod1hjd3drUm5aYjIrNTlFdDdYU3BNOWhNM3JYNUovdEkvR2k1L2FRL2FFOGVmRUM4Vm83anh0NGd2dGI4dG1QN2xKNTJrU01aendpRlZBendGQXI5dVBHdmdqVlA4QWdtSC9BTUcyZml1eDFEVGJ6UXZHdmphd24rMjZmY1JtRzZzN2pXWjRyR09HVVl6SFBiNlg5blJsT0NyMnhYZ2l2d1QyaU9QYVB1cXVCOUsyYlY5Q2RrZWhmc3VmQkd4L2FDK0tSOE0za25pUzFFOWxOY3BkNlBZMnQwdW4rWHRhUzR1emRYTnJERFp4eGVZMGs4azZMR0FyTWRvTmNmOEFFcnczcGZoRDRnYTFwV2llSXJQeGJvK25Ya2x2WjYzYVcwMXRiNnJFckVMUEhGTXF5b3JnWkFkUTJPb0ZkNzhIdjJwYm40V2ZDYnhENEN2dkNmaHZ4UjRSOFZYc045cXR0Y1NYZGhlM0R3ajkwcHVyT2FLU1NKR0c5SVp4TkFzbjd3UjcvbXJ5ZFZJVmZteTJPZU90VEsxdENUNnovd0NDSVB3SG4vYUEvd0NDbFB3dDAxVmxOcFk2L2FhbmVNaEkyd1dUTnFVb1lnOExKRFlTeFo5Wmw3NHI3Qy80T2EvK0NqZmo2Mi9hOTA3NFArQy9HM2lEdzM0ZThGNlRiYWhyTUdqNmhMWlBlYW5jZ3pwNXp4TXJPc2RzMXN5S1NRcGxjNHlhNkwvZzBzK0FDM2ZqMzRrZkV5NmpqV0xRZEhqMGkwa2tYQ21YVUp5emtIb0doaTB6azlsdi9ScS9NWDl1WDlvQnYycS8yeWZpaDhSZk9rdUxYeFg0anU3cXdaODVGaXJtTzFYbis3YnBFdjRWVjJySkJ5cHB0bnR2N09uL0FBWDUvYXUvWnROdkJhL0ZMVVBHR2wyNTUwL3hoQ3V0cElQN3ZueS82U280eGhKbHI3dS9aOC80UEFZYmlLR3orTDN3WCs4bUo5UzhIYWx1UmozeFpYWjZIME55ZnhyOGhQZ1I4QWRaL2FNOFFhMW9maHBaTDd4Ulo2UkxxbWxhSmJXcjNGNzRpa2lsaTgyMXRrVEphWmJkcDdqYmc3a3RYQStZaXViK0pIZ1c2K0dQamZVZkQ5OWRhUGVYMmxTaUM1bDByVUl0UXRQTjJxV1NPNGhab3BkakVvWGpaa0xLMjFtWERFOXBMN1d2cVQ3Tkw0ZFBRL2ZUd1g0Zi93Q0NYLzhBd1dDOFdXdWk2TG9lZ2VFL2lMcjI1cmF3czdLNThIYXZKS2NraU1SQVdGek1lVHRIbk1ldUR6WG5QN1JmL0JubHBkMzUxMThJZmpMZldSQy91ZEw4YTZhdHdHYi9BR3IyMENFRC90MU5mbW4vQU1FZFBncmYvSFQvQUlLUS9DZlJkUGttaGtYeERaM1RUeGNOREZES3M5eXluczYya04xSXA3TkVDT1FLL1RUL0FJT1R2K0N3UHhXL1p1L2FMOE0vQ1g0UmVOTDd3T3RsbzBldStJTlEwaGxTK25udUpaQkJhbVFxV2pSSW9oSVFoRy83U04yUXFnVEtuQ3lhMDlQMFJwR3BQcjczci9tZkIveDIvd0NEY3Y4QWE4K0IxOUlJL2hqL0FNSjFwNnVFanY4QXdqcVVHcUxNVDNFRzVMcFI3dkNvOTYvVmI0Ri9BdnhYL3dBRWhmOEFnM3ArSjE5cm1sVGFQOFNOUTBQVWRZdnJHQ1JMaVhScnE0dG9kTnRBWGpKVW1PT09HNWt3U0Vra21HVGdrL25YK3p4L3dkTy90US9CMHcyM2lpNDhHL0ZQVDR5QWY3ZDBsYlM5Q0RzTGl6TU9XLzJwRWtQMXI3cytDUDhBd2RpL0FQNDFhTEpvUHhmK0d2aXp3VkJxa1QybDZCSEI0bjBXYUoxS3VzeTdZcFdqWUVncDluazRKQnpSeU96VVpKL2gvWHlKOW91Wk9VV3ZUWDd1djNuOCtLd2VRbmwveFIvS2VlNHJXOE4rT2RaOExhSjRnMGZUTDJhMXN2RjFsRnBtcVFJZ2IrMExkTHFHNlNFbkJJQXVMZUNUQUl5MFM5UnhYNzZXWC9CSnIvZ20vd0Q4RlJycWFYNEsrTnJIdzE0b3Zsa3UxMC93ZjRpTnJlSEF5ek5wR29LMGl4cjFJaGppVlIzRmZPdjdSZjhBd1o5L0ZUd2lacnI0VmZGTHdkNDd0VkRNdGxyMXJMb0Y4M1hDS3ltZUJ6MjNQSkVEMXdLbHVVZmlUUlNqR1h3U1QvQS9IMlMzTnJJMGJxMGJSc1ZaU01GU09DQ08ySy9Zei9nMFIvWjAvd0NFbi9hSThiZkVTNHQ5MFhoSFJqRGJOdCs3YzNzaHQ3ZVJUN1EyK3J4bkgvUFFlb3o4Qy9Iei9najkrMC8rek5jdXZpNzRHL0VHTzFqd0RxR2s2Y2RhMDhaT0FEYzJmbXhMbnNDd1B0WDdRZjhBQk9mNForSXYrQ1RIL0JBdjRuZkVMeEpvbXArRmZIZXBhUHFIaU9EVHRTdFRiMytuTXRtbHJwMFU4WitaTjEzNXR5RmI1bFcrK1lBZ2dWVHFSczJtRXFjcnBOYm40cmY4RldmMmlWL2FzLzRLUmZHangxYnp4M1duNmg0bHVMRFM1bFlzczFoWllzN1Z4bnB1Z3Q0MngyTEd1Qi9aKytBZGw4V3RNOFkrSXZFWGlLVHduNEkrSCtuUlgrczZsQnAvOW8za2p6enBiMjFwYTJ4a2lXYTRsbGNuRHpSSXNjTXpsL2tDdDUxREVZSWZMWUhldkRaSElQZk5kMThFdmo5ZS9CS0h4RllOb2VnK0svRFBpK3pqc3RiMEhXbHVEWjN5eFRMUERKdnQ1WVo0cG9wRURKSkZJakFNNkhja2pxeEcyekprN3U2SWYyamZnMUQ4QnZpbGNlSFlkUjFUVUJEYnczREpxdWczT2hhbllNNjdtdHJ1em55WXA0end3amtsalBCU1Z3Y2owTC9nbUY4QUp2Mm5mMjVmaDM0TGpXWHlkZjFpMnNMeG9qaDQ3U2FWWXJ1UlQvZWp0SHVaUjBQN25xT3RlYi9IbjQ0NngrME44UTI4UWF6RFlXUGsyVnBwV242ZHA2U0paYVJZV2tDVzl0YVFMSTd5ZVhIRkdvM1NPOGp0dWQzZDNaeittMy9CcFA4QXM4ZjhKeCsySjRrOGZYRnY1MXI0RjBhYVdGeW1mSXZiaFRaMi9QOEEwMGd1TlR4N3dleHFvL0ZjbVd4N0ovd2RrLzhBQlEveHA0SCtLdmdENE0rQ2ZGbXVlRnJTYlRaUEZmaVVhTmZTMmNsODBzencybHZMSkdWWXh4K1JQSjVlZHJHV05pQ1VRajg3L3dCbkgvZ3U5KzFmK3kySUxmUS9qSDRqMTdTYmRoL3hMUEZXenhCYkZSeHNVM1FlV05mYUtSS3pQK0MwUDdSUC9EVWYvQlVYNHorS0lwak5wdGpyYmVIZE9JZmZIOW0wOUZzbFpQOEFaZG9Xazl6SVRYaG53VytCK3BmSEM2OFdOWXp4MmRyNE04TVgzaWpVYmlTSjVBa051RlZJd3FBbmROY1RXOEFQUlRNR1BBTlRHVWt0R1ZVcHhjclc4ajlodjJaditEekh4RHBNME5yOFhQZzlwOTdHeEFtMVB3VHFrdGpJaSt2Mk82TW9kdmI3UWcrbmI3eitCWC9CY1A4QVpBLzRLWmFmSjhNN3J4Vk5ZYWg4UXJlVFJadkMzalBUWnROazFaYmhERTF0OW9VdmJNOGdjb3FyY2IySkFVRTRyK1c3eGg4TTlaOEJlSHZDdXFhcGJ4MjluNDEwcDlhMGtpWlhlZTBXOHViTXlNb0pNZVpyU2NBTmdsVkRBYldCUHBmL0FBVHorQytwZnRFZnRsZUFQQitseVhGdmQ2OXE5dFlDZUhQbVdndUprdGZQR09jUk5Pc2hQWlVKN1ZVYlNmTEpmMStSbnl1SHZRZTM5ZXY0bjdSZnRMZjhHZDN3L3dERlYzYzMvd0FJL2kzNHE4R1RTTThpNlg0bXNvOWFzd3hKd2l6eG1HYU5Ca0RMck0zSEpKcjgvdjJqditEWTM5cnI0QS9hTGpUZkJ1aC9GRFNvRloydlBCMnJSM0UyQjBBdExqeWJwbUk3UnhQMDYrdjZKZjhBQjBYL0FNRldmaVIreXo0aStIdndwK0V2aS9WUEEycytLclM1OFRlSWRTMHFUeWRSV3lFeGh0SVlwc2JvVmVXSzdMbENHYnlrR1F1NVcrQXYyZWYrRG52OXJUNEF0RGJhejRtOE8vRlBUSVFxQzM4VzZRajNBVWRmOUt0VEJPekgrOUkwbjQxbkduZFhVbjg5Vi9tYlNxTmJ4VDlOSC9rZkFIeFUrRXZpejRIK0pXMFh4dDRWOFRlQzlhakdXc05kMHViVDdsZnJITXF0K2xmdk4vd2JHK0NiUDlqci9nbGg4YWYyaU5ldDJoczlRaXVMNkdSaGhieXcwYTFudUhsalBVN3JpNG50emorT3l4MUZSZkN2L2c3ZStESHgyMEJQRHZ4OCtCZXI2ZnA4eFZKRFppMDhWNlU1N3U5dGRKQzhhOWVGRXh4NjE5MC9ERDl2TDlrWC9ncHo4SXRTK0VQaFA0bWVEZFcwM3hscEUzaDF2Q1lrYlFOVGt0cElXUm9MVzBuU0tUS3g3c2VRckJkdVJ3QWFybHFKTmIrbjlhRTg5UG1UbGRlditmVS9rbDhVZUs5UThiYXhxV3VhcmNOZGFycjE1TnFON014K2FhYVp5N3NmcXpFL2pYVGZzdS9ISmYyWi93Qm9Md3Y4UUYwcGRadmZCdDJkVjAyM2E0OGxVdjRvM2F5blk3V3lzTno1TXhUSHppSXJsZDI0ZnI1KzA1L3dacCtLZFBudkwzNE0vR2JSZGF0V2xMMitrK010UGtzSjRZK29UN1hiQ1ZKVzY4bUNGZW5Bcjg5LzJsZitDRjM3V1g3Sy93Qm9tOFMvQlR4WnFtbHdGaTJxZUdZMTErekNMeVpIYXpNaGlYSGVWVVAwclAyaVhrYVNwdVcydnAvVi93QUQ1SlE3RUFyOUovOEFnMWIvQUdlZitGMmY4RlQ5QjF5NXR4THAzdzcweTk4VFRGeDhqTkVpMjhJLzNsdXJ5emxBL3dDbUpQWTErYlY1YnRhWGNsdk5ISmIzRUxGSklwRktQR3dPQ0NEeUNEMk5mMEFmOEdrbnd0MC85bmY5aXo0NmZIN3hLcVFhUkk2MjMyaHdQa3N0S3RaYis5a1Ivd0M2MzJtRkdIOSt6d2VWSUdrR2t1YnlNcFJiZkwxYlBoSC9BSU9PL3dCbzMvaGZYL0JZTDRtTGJ6UjNPbC9EbXdzL0JWaXc1Mk5BZ2x1bFB1dDVOZHJ4MkE3MThUL0NUNE4rS1AyZ3ZHY21oK0ZkTlRVTDJDMGwxQzVrbnU0TEd6MCsxaUdaYm01dXJoNDRMYUJNamRMTklpQXNvTFpaUWF2eEkrSldwZkdIeDc0bjhaYXhKNW1zK05OWXU5Y3YzSE82ZTRtZWFRLzk5T2E3YjlsdjR5K0ZmQS9oYjRuZURQR2t1dmFYNGUrS0doV3VrejYxb3RqSGYzdWt2YTZsYWFoR1RheVRRTGNReVBhaEhqODZNcVRIS0N4aTh0Nmo4TVlsMUphdHIra2NYOFcvaEw0bStBM2pSL0QvQUlxMDRhYnFRZ2l2SXZMdVlieTJ1N2VaUThWeGIzRUR2RFBESXBCU1dKM1JoMFkxMG43SWRuNGs4Ui90US9EK3g4SDNFbHI0dW4xNjBUUTU0emg0Yjh5cUxkZ2V4TXBqR1J6eUtQMnIvalA0ZitLdXQrRGRKOElXMnJRK0VmaHo0WHQvQ3VrWE9xeHBGcUdwb2x4YzNjOTVQSEc4aVF0TGRYbHk2d3JKSUlZekhINWtoUXlOOWIvOEd3djdQSC9DL2Y4QWdyUjRNdkpyZGJyVC9BRnRjK0tyeENPRUZzZzhpWDZwZXlXUC9mZE9tN1R1dWhsVTFoWjlUOW1QK0RnYi9nc040cy80SmthRjhQOEF3djhBRFMzMEM4OGYvRVM2dkovdHVyMnB1N2ZTTlB0VlFQS0lWZE4wc2traWhDeEtBUlM1VWtxVitKL2dKL3dlSWZFRHdSY3gybnhVK0ZYaGp4VmIvS2o2ajRXdnB0RXVsVWRXYUdZM01jckhyZ05DdWVtQlh6MS93Y2lmdENSL0hIL2dzSDR3MCtOMWswMzRUZUc3SHdsYnNKTW9aMlZyeTRPTThNSmJ1V0k0NS9kQWRzajgrZkNuZ1RYUGpCOFJ0SjhMK0dOTXV0YzhSZUlyeU93MDZ3dFZEVFhjOGpiVVJlZzVKNm5BQXlTUUFUV3RLSzlsek5ic2RTSzVyTG9sOTUvVEo4SlArRGt2OWpYOXNEd3RlZUcvR0hpVFV2QThmaUsyazAyLzBqeHpvenBhM2tNeUZKWTVMaTNNOXNJMlZtVStiSW1RZWxlQ2VLLytEWGo0QmZ0SGVIcmp4Tit6TCswRnJIaC9TN2lVeVJ3MjJvV25qUHcvRG5rUnhsSkVsUWU4azByRHJ6WDREZkU3NForSlBneDQwdXZEdmpEdzlyUGhmWHJOWTNtMC9WTE43VzVSSkVEeHZzY0FsSFJsWldHVlpXREtTQ0RYWWZzWmZFVHhwOEx2Mm9mQk9zZkRmVU5TMHp4cEhxMEg5blBwODd3elhNbTdpQWxHVm5XVDdqSVR0Y050SUlKRlp4akdVOUx4ZmRNSEtwQ0w2cmV6WDlXKzQvUlQ0LzhBL0J0LysyQjhFMmttMGZRZkFmeG0wdFM1RTNocldsc05RV01meFBCZWlMTGtEN3NKa09Ud1RYd2o4ZS9oYjRxK0FtdExwbnhNOEErT1BodHFUa3BIRDRqMEtleUV4N21OMlVCMTl4a0hQWEhOZjByZjhGdGYrQ3ZkNS93U24rRy9nVzEwSHd6cFBpNzRqZkVhK3ViWFRyZS9sa2gwMnhndEk0M3U3dVZZL3dCNUlGTTBLSkVIVFBtTTIvOEFkN1crU1BnNy93QUhjdmhEeEhhZjJIOGF2Z3hmMnRuTWdTNHUvRGw5RHExcmM4OGxySzdFZXhSeGtlZklmVFBTdHFOVEVOWGkrWkx2L25vT1RwcmVMWHAvbHFlRGZELzRqK0dmakw0ZWJWUENPc3h6THNCbXR0KzI0dFNlY1BHY0VjanFPTzRyelg0L2ZzNStBZmpQTkxkZUtOS2RkWmxRSi9iTmpLWWJ6NVJ0WGQxVndBQU1NcDRIdFdoOEZQQjBtcGZGVzZXTmZLVjQzWE1QeVlLL04xSDQxUitLbnhCLzRSajRyYXpwR3JMdTArM25DUXpvdUpFRzFTY2orTGs5c0g2MS9GR0Z4RTRaaTQ0RnVNbEZOTk8wa3JyUzZzbnI1YTlqejQxRlpObnpUNDEvNEoxNjR1a3kyL2hmWHRQOFZhVUhKanRMci9STHVQbnFySE1lNzZNTTU2SHBYeXY4Vy9nbDRtK0IvaU0yWGlQU0w3UzNseVlIdUl0c2N3LzJXNVZzZjdKTmZxYjRiMDcrMFlrdk5MMUtLOHQrRHVpazNiZlpoMVg2TUJXL3Fnc2RkMEdUUzliMCt4MWF4bUlFbHRld0xOQzU5MVlGZVAwcjlPeUxqbk1jTzdZaEtySHI5bVhycHArR3B2VHFSZ2ZqTXkrYzQyL00yZG9VRExINlYrMmY3Rkg3TjBuN0lQN0syaCtIYmlhWjlaMTlVMXpXRWxHMzdQTktpa1FLTW5BalhBUHFjbkhOZWQvQ1A5Z2I0VCtOUGp2NGJ2TFh3elo2YTluZUpxRWx2R3ArenlyRis4eHRKNCs3MEJ4N1Y5VWVJUkpxMnJYTXJONWl5T2NFbjdvejJyNGp4aTQ3aG1WQ2hsbUhpNHh1NXpUdHJiU0swNlhiZnFrWjR5cHpVdVdQVTVIeC93Q0kxMC9SbldPTUt6RGJ2QTZuNlY0djRVMEJkVDhTWFdzWGkrWmE2YWZOMjUvMXNtY0tvOXlmU3V3K0sxekk5NUpCQzJlaXFCNjE0LzhBdGpmSHk0L1psK0ZlbitIdkRhMlUvalRVVUY1SWJoUzBXbnE0TzJWaGpEeVlCMnFlT1NUa1lCK0o0WHkydlhsRERZV1BOT28rdWlVZXJiNkxwZno3bkRRcHBMbWw2Rkg5b3I0bStHUGc3cFUrdWVLZ0xqVUw4bDdhemdVZmFyeHVlbWZ1eGpqTG5nQWNaNEJvL3N3L3M1YTUrMi84TjQvRWZpRFh2K0VlOE8zOHppMTBMUTMrek41U25HK2VVNWVRbnNEOHVBRGptdmdYeFI0dDhaZUpkYW12TmExQnRjdUx0dDBzbDVNSkdZK3hPQ01kQUJ3TWNEcFgwTit3NyszcGQvQUswYlFkZWc4alJZOHZhWEViTko1QkxjeHNGRE1GNUpCSU9PUWVNWS9vREZjSzRqQTRCVmNOYXBXVFRiajBqMmducW10UE5xOW4wTzdEMGFjRzNLejdIdjM3VEgvQlBLYjRjK0RKcDlGMTNVTlF0N09JdEd0L041ellBd3Fic0RZT2d6eVBZRTgvRWR2NDl1L0FXdU03ZVk2UnliTG0zUEJQT0NPL1QxK25TdnJiNC84QS9CVGV5OFFhTExwbHExcmVSWFNzeW0zbDNZYitFRS83MkR5QjM0SEZmRGVxZU9QUDFPNm11YmZiOW9rZVVxUnhrblA4L1N2UzRhd2VLclJuOVpwdmtkcmMyamU5L004djJiblhseXhmTHA1YStSNzE0enZHK0pmaEx3L2VhUHRtMVhTOVJpdDdZTDhyU1JUbkJWaWVnVndEazhEY3g0cjZrOEdRUjZYWjZMTkpGWVgyc2FTN3lSM3BqM216a2xWRWxNSllaWGNzYWpjTUU3ZW9CSXI1Yi9acjhZRFdibTFzN1dQYkkwYUxsU2M0QkpPZU9oVWpKUGNmbjlmZUNQQ3NXbjIwYzB5R1ZuSTJqQkF5TWNEL0FCcjg5NHlyUENPT0YyNVhLM2RxVzZ2MjMrOW0rRmhhOHV1eDJXamFsZDZ5aU0vbU5NMzNtWS9lcjNiNE0vRXpVdkJkdEhhek1MclRHUDhBeDdTdGhsOTBQYjZkRC9MeW53ZjROMWZ4RElrZW5XRjFNemdEOTNHZHY1OVA4L1d1dzhLK0dMVFVkVFhUNXZGZmhaYjd5V25hM2oxU0dXY1JqQUxlVWpGc0E0QnlPdjRWK1B5alZyemNLQ2Zta25MNzdYTytQTXZlMlBvelNidXg4V1d6WEdsM0t6R0w3OGZTU0w2ait0ZEY0ZThSVFdsd3Nkd0czZEJudUs4QnZQRk9pL0EvU3JiVm9adFkxS2NzUXNsb3F3aDhjWXpJUjh2SHBqdlhMK0IvK0N5WHd2dnZqaGVlQmZpRFlYWGdDWllvcExMV2JxVVhHbnpiL3dDR1oxVWVRMlFlU0NtQWNzSzdNdDRYempFUmxXb1VKV2pxMDdYYVc5bGZtdjhBSTFoV3BWSG8xZnkyUG9yNHIvQ1RVUEVxdzZyNGJaZnRWdXdhVzBJSDc1ZTVROWlQVG9mclhlZUEvaHhySGlDTzF0LytYbG9GbE1PNGVZRjRHU3ZCeG5qUHFhMFBEaXRaV2R2ZldVME45WTNDQ1dHZUdRU1J5cWNFTXJEaGdRZW9PTVYydmcrVFQ5UStJdWwrSTVTOXRxbGhhVFdCa1JzTGNXOHBSeWtnNzdaSTBaVC9BQS9OMllpamgvSjhzeE9aZXl6Q2NxTVphWFVWbzc5YjdMdm96cHA4c2Q5elY4Ry9zdnNWV2JWcnJ5KzRqaU81dmNFOUs5TDhPL0REUS9EcUo5bnNZMmRlZk1rK1pqL1NyOW5xU1hVQ1NSc3JLdys4RG1ya0V1UitQclg5VDVENGM4TzVkQ002RkNOU1Z2am5hYmZtcis2diszVWpUMmt0bG9XNGtWSTFWVjJqSFFEQXFRUjV4VUViWnF3cmJoWDNTU1NzaVRJOFdlQXRJOGIyRFcrcmFmYjMwYkRhREluekw5RzZqOEs4TCtJWDdGRGFidXV2RGM3VHdqa1drMlBNVWY3TGQvcFgwY3E4NXFVSUsrWDRoNE95dk9JTllxbmFkdEp4MGt2bjE5SGRBN1BSbnd6ZWVBcmpTYnA3ZlVMV1MybVU0S3NwVmhqL0FQV0t1NkNsN29oekRJeFhISU5mWW5pcndGcG5qUzI4dlVMVlpNRDVaQjhycjlEWGszaS85bXU5MFVTVDZTMzlvUVp6NVI0bEErbmYvUEZmekJ4bDRPNXpsdFI0bkFYeEZMVis3OGFYbkhyNnh2NkVxbkY2SEQrSGZGOGMrd1RLMGNnL3lhOUU4TGZFRzQwVFlZWkJKRGpsQ2V0ZVpYK2h0WnQ1YzBiUnVtUXlzcFVxYW5zMHV0TDJ2R3pTb0RuR2ErSnlUUGNWZ2F5blJtNFRqMTJmOWQwVmFVZHo2TzhNL0VDeDhSd3Fva0VVemNiRzQ1cmY2aXZtN1N2RWtjMkYrYUtaZXVhN3p3bDhUcnZSUXFYRWpYbG1Sd0dQeko5RFg5RzhMZUxrS3lWRE5vMi92eDIvN2VYVDFWL1FGcnNlcFNEYWFHNFA2MVMwSHhQWitKSVBNdFpsWnVqSWVIVSs0cTZ5L3dDYzErMDRiRlVjVFRWYkR5VW92WnAzVEFFZmFLYkxMNy9oUVRnZnpxQzVmNWZXdHJnVnJ5Zmc1N2MxenVxM1c1NjFOVnVOaWRmeHJtYjI1OHg4NS9HczU2RzFKZFI4VjY4VnpHc2VOMGpCQ0R5R3ljYzFZMUN5bThMeXRkV0pNbG01ekpFZTMrZmFxV2luenRaVTlvVkwvd0JCL1BQNFZ1L2F2TC9IZ2c5Ly93QmRlRG0vRGRQTVlLdlRrNmRhSHdUVzZmWjkwK3FaTmJleEZGZkxxRnI1MFB6Um5qM1gyTlZabWJKd0I3ZW1hcjNHbVBwZDFKZVdJM1JTRDk5Yi93QlJSOXBTNVRlamZLVGpqcURXdkQrZVZhOHBZSEh4NU1SRGRkSkwrYVBkUHF1aGluM0d6WS9XdXMrREduaDlZdkw1dVZzWU1LVDBEUHgvNkNHcmoyM2JzODVZOVAwcjBid1pCL1lYdzZlYzVWNzZWNVArQWo1Ui93Q2drL2pYMVlTMlBpTC9BSUw5ZnRLTit6OS93VGgrS21wUVQrVnFXdTZkL3dBSTFZWWJhelMzN0MyWXFmN3lRdk5JTWMvdTYvbGdCV0lCUjhvVWNDdjJ3LzRPMmZqaGQzR2kvQ2Y0ZDJ2bUd6dXIyOThUMytGSkc2M1JMVzJPZW5XN3VBZmNyNml2ek8rRjNqUDRPWC83SzExNFM4VjJkeEQ0cVNmVTlaaTFXM2hhM3VEZEhUN29XY0RUQlpSTENrMW5aUnJHVmpCYldMbGlWOGtTaW82azdhTThBejh0TmsrVTBieU9UMW9VUE13VkZhUjJPRlZSa3VUd0FQcjBxUVAxOC80TlZmZ0N1by9Fang3OFJyeUJmSzBMU0YwNjBsZmhETmZUa1pCL3Z4eDZkT0R6d3Q2UFd2emIvYncvYUQvNGFtL2JSK0tIeENqbWE0cy9FM2lPNm0wNWlNRVdFYm1HMFUrNHQ0NGhudVJYNisvc3l6ZjhPN2YrRGN2eDc0NWpJdE5kOFlXdC9lMlV5NDh6emJwb2RFMCtWTWRWWklZTHNkdjN6dDNOZmhLcStWR3FEb294K0ZWTGV4V3lKRm53M3BUN2U1YTJ1b3JpTjVJYmlBaDRwWTJLU1JrY2dxdzVCQjV5S3I5L3hvRDVQMTdVSWsvVGIvZ2hGL3dVZitQbDMrMjk0SCtIdDc4UVBGWGpUd1g0aXUxMCs4MGJYcnh0VFNHSmdTOHNFc3hhVzNNRUtUWEdJMkNzTGNxeWtOa2ZxVi93VVovNExyZkRQL2dtaDhTOUg4RjZ0by9penhkNHIxSzBUVWIyejBONFlZOUx0SGQxUnBaSldBYVZ5akZZbEJPMWNzeUJsM2ZtNy93YXJmQUp2RjM3VVhpcng3TmI3N2Z3UG9qbU55UDlWZDNwYTB0V1g2d0pyQ24vQUlEMDR6OHIvdHNmdEQrQmYybWYrQ3JYeFM4YS9FSTY1ZjhBZ2U0MXk0MDIyT2lTTDlvbXRiSlVzclprTEg1UTBNRzhFY2VZeWxnVjNnNlNrM1pNVVlwTFEvWSsyLzRMUC9zUi93REJSNzRWYWg4UC9pQjRoazhQYVg0a2pXRzUwYnh0WlM2VHlqTElqaThnZDdlSmtkRmRYRndyQmxCR0s4QStKZjhBd2FxZkN6NDNlRy8rRWwrQW54eXY0OUt1TXlXdzFGYmJ4SnBjMmVWVkx5MGFNb2d5T1Nzclk5YS9IWDQ2Mi9nV3k4VldNUGdHNDFLODB0Tk9qVzludXR3V2U3RHlBdkVyb3JvclFpQXNyYnNTbWJhZG14VngvaHI4VS9FM3dYOFNyclhnN3hMNGc4STZ3b0FXKzBUVVp0UHVCLzIwaFpXL1dwbEdEZXVqOG4vVnh4bEpMU3pYbXYxNkgyaCswTC93YmNmdFcvQWtUWEduK0VkRitKdW13Z3NicndmcWkzVWgrbHJPc055eDlraWI4YStLUGlUOE12RTN3WjhSeWFMNHc4TitJUENPdFJqTFdPdDZkTnA5d3ZibU9WVmI5Sy9VMy9nakYvd1crL2FLOGRmdGcrQ1BodDQ0OFVmOExLOEtlSnI2MjBtVk5Wc1lqcWRvWjdpS0JiaUs3alZKR2FNeUNWeE9aUTBVVW9HMWlycitxMy9CUUgvZ3JSOENmMkF0VThPK0h2aXhxbW9YK3JhNHE2bFphTHAya0RWYmkzdDFrWkZ2WkVabFNLUHpFZFZiZHZMUnR0VTdXSWwwNUw0WGYxMEtVNC9hVnZUWC9nbnh2K3o3cDAzL0FBVE8vd0NEYkh4eDR3dUxhNjBueEw0NjBpODFTMU1rWmh1a2ZVVWcwalNwc0hrRTJ5V2wxdFBUelc0SElyOERvWXZKaFJCOTFSZ2Y1L092NmhmR2Y3WmY3SGYvQUFXQytCdXQvREc2K0wzaDIrc2ZGeUpGTlkzZW90NGUxcUtkWkZsamtnVytTTXZOSEtpT3BWWlVKWEJEcVNEOEQvdEdmOEdobml2U1JOZmZDWDR1YU5yVnZJZk10OU44WDZkSnA4Mnc5RkYxYmVha3JlNWlpQjlxSlhpN3lUc0VlV1N0RjY5ajgwZjJYZjJ4TlUvWlUxS3prMFhRdEJsV2JWb3JqWDd0NEMybzY5cFFNWWwwVnBuTExEWnpLSlJLSVVSNWhPVmxhUkVqUmZJdFlGbi9BR3ZkZjJiSGNRNmNaM05ySGNPSkpvNGR4Mks3QUFNd1hBSkFBSkJPQlgwNyswYi9BTUVXL3dCcVA5bHdYRTNpWDRPZUtOUTB1M0xFNnA0Y1ZOZXNnZ0ovZU0xbzBqUktRTS92VlFnZFFLK1c3a2ZacmlTR1FOSGNRc1VraWRTam93T0NDcDVCSG9hbjJpa3JJSlUzSGMvWHIvZzBvL1o0YnhOKzBWNDMrSTF6YitaYitFZEVOdmFramxMeTlrTnZieXIvQU5zSWRYalAvWFFWK2Y4QS93QUZTUDJoL3dEaHF6L2dvZDhZUEhVY3kzTmhxWGlTZXkweVZXM0xKWTJtTFMxWWY3ME1FYmZWalg2OWY4RTBMOXYrQ2IzL0FBYjRmRUQ0dFpqc2RZOFNXR282M3BVN0l3SWRFWFRkUEdRT1VrdnhOY0llaGp2QXc0T2EvQTJHRHlyVlVYK0ZRRFZTZXRsMEJLeXVkVjhIL2dWNGkrT3VyYXBiNkJEcDhkdm9OaWRUMWJVZFQxR0RUZE8wcTFFaVJDV2U1bmRJNHcwc3NVYUF0dWVTVkVRTXpBSE4rSjN3eTFqNFFlT0x6dzdyc05wRHFWbWtNekcxdlliMjNtaW5oam5obGluaFo0cFk1SVpZNUZkR0tzcmdnMTNmd0YrTC9odnd6OE52SFBnSHhsSHIwUGhmeDNKcHQ0K3FhRkZEY2FocGwxWVBNMEo4aVo0a3VJWFc1bVY0akxFZDNrdUhQbGxIOHcxdUN4aTF1K1hTM3U1TkwrMFNDemU3aldPNGVIY2ZMYVJVTEtybGNGZ3JFQTV3U09hR3JJbTU3OS93U1orSDJ0L0V2L2dvcjhJOVA4UFhVOWpxeStKckI0YnFFZnZiUUc1amplZFBlR04zbStrSnI5bnYrRGlqL2d0ejhSdjJBdmlmNE4rR1h3YnU5SDBQeE5xMm1ONGkxdlZydlRJZFNrdExacG5odHJhR09kV2lVc1laMmRtUm0yK1Z0S2NsdmpuL0FJTk5mMmN2K0U4L2JOMXY0ZzNNSmEyOEE2UmRUMjc0L3dCWGR6eC9Zb2g5SklieStJOTdiMk5mS2Y4QXdXMi9hRC80YVkvNEtvL0dmWDQ3ano5TjBmV3o0WTA0cSs2UHlOT1ZiUGNoSDhMeVF5UzU3bVVudlZ0dEpSK1lLSzFaOW8vczRmOEFCNFA4VmZCTWtOdjhVUGhqNFA4QUcxdW1GYS8wQzZtMEcrUHF6QmhQQXg2OEtrWTl4WDIzOE5QK0RrSDlqWDl0RHdScUhnLzRpM091ZUNMTHhIYlBwdXBhWDQwMFZwZFB2b3BVS3lSbTR0R25UWVFTTjBubEh2d2NHdjV2ZkNYdzQxcjRnMjJ2VDZMWW0raThNNlhKcldwa1RSeC9aYk9PU0tONWNNd0w0ZWFNYlUzTjh4T01Ba1p1cGFGZjZIRFp2ZVdWNVl4NmpicmVXaG5nYUlYY0pabFdXUGNCdmpMSzZobHlwS3NNNUJ3cFR2cEpFcURXc1cxL1htZnZuNDUvNE5oZjJWLzJ6Tkd2dkUzN08veHF2TkZnbFBtaGRMMWExOFk2TmE1KzZoQWtXNGp5ZVAzbHc3Y2RNMThaZnRHZjhHby83VVh3ZEUxMTRQOEErRUgrTE9uSXhLRFJkV0ZoZjdCM2VDOUVLN3Y5bUtTUSttYStVLzhBZ2xIL0FNSmRIL3dVTytFdi9DQ1gxMXBQaW1meEZhV3RyZFc4am9FYWVWTGRmTjJFYm9DOHFDUld5cklXREFxU0svZXovZ3ZML3dBRnk5WS80SmNhL3dDRGZCdnc3OE4rR2ZFWGpqeFZiemF4Y040aFc0a3N0SzA1SlRGSCs2Z2xpZVNTV1JaUUNaRlZCQTJWZmVOc1NwcXljWGEvek5JMUpOMmtrL1RRL25MK1BIN0szeE8vWmIxWmJINGxmRHZ4cjRDdVpIS1Ivd0J1Nk5QWXh6a2Y4ODNrVUpJUGRDUWZXdjNXL3dDQ0lYaCtUL2duci93UTIrSlB4eTFMVDVyUFV0WTBlOThTNmV0MUUwRWw3YVdWcEsxaUNHd2RzbDdQZUNOdWp4eXhPUGxjR3VLL1oyLzRQSWROdkxTUFRmakI4R3I2MFNRQVhPb2VEZFRXNWhmMyt3M2hVNDc0TnkzK1Ayam9QL0JZSDlpMy9ncFQ4TGRhOEI2ejhWUEQxdlkrTk5QazB6VTlEOFhOTjRkdUpZcDFLTkdKcmdKRVpPZmxNTXpGV0FJSUlGUDJjK1ZwV2QrMytXNVB0YWZNbTAxNi93Q2V4L0t5c2tsekI1MDhqVFR6RXl5eU9kelNNeHlTVDFKSlBYdlhjZkI3OXBUeFYrejc0VDhXMlBnNittMERWZkZ5V1VFMnVXTjFOYTZuWlc5dFA5cDhpQ1dOMTJMSk1rRHVlVy8wZEFDQVd6K3kzN1EvL0JubHBmaXkxbDEvNEkvSEdiN0hmQXpXZG40dnMxdm9KODg1L3RLenh1QjlSYk4xNm5yWHdMKzBsL3didGZ0ZWZzMXgzVnpjZkN5NjhkYVJibi9qL3dEQmQzSHJRbEhjaTJqSXZBQjZ0QUJVKzA1ZDlEVDJibDhObjZmNWJuemgrMTMrMGZlL3RWZkdHUHhSZU5xaEZyb1drNkpFZFJ1L3RkM045aXNJTGVXZVdUQTNTVHp4elhEbm41N2h1VDFyNzcvNE5SUDJkdjhBaFpmN2ZkeDR5dUlXYTE4QTZSZWFsRkx0eXB1REd0bWtMZjczOW9HVmZlelBwWDVpK0tmRFdvZUIvRU54cE91NmJxR2g2dFp2NWM5bHFGczlyY1FzT3p4dUF5bjZpdjZBditEYmJ3eHAvd0N4ai93U28rSi94LzFxM3paM01OMXF2bUVZVFVMRFI3ZTR1R0tISGU1dUxxMWJIVjdNQVp3SzBqTGVaazR1Nmg4ajgxUCtDNm43UUgvRFRIL0JYSDR2YWxGY05jNlQ0THVZdkIybktUOHNLMkNDR2RWSTZxYnY3VS92dnI0MjFJQ0ptWnZ1cXBKSUdPbGJGbnIxNzR3bDFMV3RXdUpMelY5Y3ZKdFF2YmlUNzgwMHJsM1krNVppVDlmcG5wUGdscS9nUHcvNC9qdXZpUjRlOFRlS1BEYUlKRFphRnEwR25YVFNyTEc0M1BOQk1yUk9peVJNb1ZXSG1odzJVMlAwVTZkcWFUSE9XcmtqbC9pejhMTmIrQ3ZqKys4TStKTFZMSFhOTldFM2Rzc3lURzNhV0NPY0l4UWtDUUxJb2RTY280Wld3eWtWMVg3RmZ3NzFyNHIvQUxXSGdIUWZEc3oydXZhbnJkcGE2ZGRLb0pzN3VhWklMYWJweHR1SlllZW82amtDdWY4QWpwOFY5UytQZnhvOFgrTzljRU1lcmVOZGJ2ZGR2VWlKOHVPVzZuZWQwVFBPMVM1VmZZQ3Z2ei9nMXMvWjNiNHQvd0RCU2ZUL0FCSGNRK1pZK0FiQzcxdVhjdVVmeTR2SVFaL3ZMZFhsaE12L0FGeHowQnJPUHhYSnFmQ2ZwTi93Y3BmOEZoL2lGL3dUd3N2aDk0SCtEdXFhZm92amZ4MGJ2VjcvQUZlNDArQy9uMHZUb0hTT0lSUTNDUENXdUpETUM3bzIxYmRnb0JiY3Z3ait6bC93ZDcvdEEvQ3lhMXQvaVI0UDhDZkZDeGhHSkxxQ0ovRCtxU0gxODJBUGJqOExZVjQ3L3dBSERQeCtIN1NIL0JYdjRsK1RjTGNhVDhNN0swOEZXTEsyZGpXNkdTNlUvUzhtdXdmcGl2aTd3TjhLdGErTG10YWxaNkRhUjNVMmw2UmY2N2RtU2RJSTRMT3l0cExxNGtMdVF2eXh4TmhjN25jcWlobVpRVlRpK1RuL0FLc1ZPTWVibC9VL2VUU2YrRGdYOWdYL0FJS0VSMjl2KzBGOEpvOUIxZ3hCR3ZQRi9oRzMxNjNnSlAzSXIrMVdTNlVlNWlpQS9PdnZmNFlUZnMzL0FMWmY3SG5pSDRPL0IzeGQ4T2JyNGVhMTRadnZEOHVsZUJOUXRFazBleXZJWlk1V1cyaithQno1enVUSkdDWFlzNFlrNS9rUitJWHdyOFNmQ2pWclN4OFZlSHRjOE4zOTlaUTZqQmE2clpTV2R4TmF5NU1VNGprVlc4dHdDVmJHR1hrWkJCUFhmc2JXUGlhNC9hbDhEZjhBQ0V6VDJmalQrMTRGMEs1dHl5VFJYN3VJclRZeThxV3VKSVVCQjZ1S2lOT0Rkcld2MkpsT3BGYzE5dS85ZjVuNkYvdEwvd0RCb2QrMFQ4THBMeTQrR1hpandIOFZ0SGhQK2kyclhCMExXSlI3eFhIK2pESHRjblBvSy9QYjlwajlnYjQyL3NlVHlMOFVmaFA0NjhFMjhUK1g5dnZ0S2svczZSc2dBSmRLREEvSng4am5xSy9wRS80TDlmOEFCWnp4Qi93U3I4SytCdEYrSCtqZUh0ZStJWGorNXU1SW4xbUtXYXgweXh0UWdrbU1VVXNiTkpKSktvakcvYUJISVNHd0JYeFgrenYvQU1IbVhpUFNURlovR0g0TDZUcWtFamJaOVI4R2FwSllzRTcvQU9oM1JtVnpnOVB0Q0Q2ZG9VSnZaL2YvQUVqU1ZSYnlqOTM5UDhEOEx3RW0rNHl0WDc2LzhHZWZ3S3N2aHQ4RC9qUjhiUEVDeDJlbmJvZERqdTVSZzJrRUVadnI4bmo3cGlPbnYvd0ExM1VIN1V2L0FBU1kvd0NDbjExSEo0MThNK0NmQWZpalVITWt2OXU2UlA0TnZHa1BWcHIreGRMV1EvOEFYUzRiUDByOUJmQTM3R2Z3aXY4QS9nbmRydndYK0M4MmorSC9BSVcrS3ZEdXA2RFozL2h1K0dxUlFDL2dsaWx1UmNHUnpQTG1VdHVlUmljS01nQUFQMzR4YmFKL2R5a2xmcnJmUm44bHZ4VytNV29mSC80bmZFRDRrYXB1ajFQNGorSmIvWDdoTjI3eXpjWER5bFJ4MFV1UjdESHRXbit4NThlZEIvWm4rTUdxZU5OYjBsOWV1dFA4TTZ2WWFKcHBFcTJ0NWYzdG85Z3YyaVNHYUthR0pJYm00bDh5RnhJSGlqQ2xTZDYvV2Y3UnYvQnRSKzE1K3piWjNFT2srQjlFK0xIaHpUMVowdjhBd2ZxaVNYSlRjY0EyZHg1ZHkwaEI1V0tKd09mbVBVL0Ivd0FXUGhyNGsrQy9pZHRFOGNlRmZGUGdmV2xYTGFmcitsVDZmY0QvQUlCS3F0K0pGZENyVTNCUWc5VXVvU3B6dTVOZGQxL3dEUS9hTy9hQ24vYUIxM3c4MGVnYVQ0VTBId2Zva1hoM1FkRzAyVzRuaDA2eVNlZTQybWE1a2tubGQ3aTV1SkdaM0lCbDJvRWpWRVg2bS80TnYvMmR2K0dqZitDdFB3MVM0dC9QMHZ3ZmRONG52V0F5MEFzbzN1WUgraHVZcmVNbjBtUHFCWHhCTEFzZ3pHeXlEMVZzMSs2bi9CbWYrenRGcFZuOFpQakJxY2JXOE1kdmJlR0xLOFk0alZIZjdUZUtmZEJiV1QrZ0V3OWF6VjAzSmtTVjBvcnJvZU0vOEhLSHg4SHhtLzRLNlgvaDJLWnBOTitEWGc2ejBYWmtlV3QvZWczc3JqSGZ5cmlLTSs4T090Zm5INGhLWEUyNDdtNXlQZjhBTHQvaDZacjBYNDJmSEdYOXB2NDkvRmo0clROTXJmRXp4aHFPdFd5U2ZNME5xOXcvMmVMbm5FYUhZQWV5Z2U0NWY0WmZDMjkrTlB4WTBQd3JZM0ZwcDkxcmwySVd1N3ZmOW5zSTFWbm11WmlnWnZLaWhTU1Z5cWx0a1p3Q2VENkdHankwVmZycjk0VkpmdkhicHA5Mmg5eWZzTy90ay9EajQwZkhTejBQU1pmRVVPdWFvbHhKRGJYMWdGamJiRXpOODZ1eWdoUVQ3NHJhL2FIdnZBZC84Vy9FRmxmZUx2REZycVZuZGVYYzJ0MWVwYnpRdjVZYkJENHo4dUNNRThmU3ZpUC9BSUpENmMrbWY4RkRQQXF6U1NCcERlb3E4OURaekRuMEhOZW9mOEZGZmc5Y2VQOEE0b2ZHalZyT1B5Ynp3L3I4RjVEdGZaNTZDMnQ0WHlmVWJzam4rRSt2UDhoNXB3ZmwrRzR0V0NvMXBVNE9oR1Y3cCs5S3E0ZFZ0K1hjNHEySGd1V0syMU93UGlqd3I0UjExWDBYNGllRWJPOFZ4aEUxZVA1dllrTVFjK2g0NXJ0TEg5b01SU0xENGkwMWZMbXlzZXFhUzYzRnZJRDZxcFBYL1pKNjhMWDV1Mm1yYy9aL0VBVU9HMnJkeE1Ha2lIKzBGNGRlZnI5ZWxkZDRPK0ZIaWp4cjRnaDAzd25aM25pSzZ1QVhpR2xsaklvQTNFbkdDdUJ5UzJNZnorN253UFRvZTlVcnZUcTByZjhBZ1NhWDMzTS9aeWk5RDllLzJQWWRQMS9XZFkxVFROUXQ5UmpzOU1sS3RCS0R0WnlGK1lkVk9DZUNBYTdlNEsyVmpjU1NjY0VESjRGZk5mOEF3UkIrSHZpVFFQRDN4Z3VQRmo2c3VvYWExbHAwZHRxT1ROYWxoSkl3eTNKejh2ZkJ4bXZwRDRrTEpaYVV5S2NzM0F3T282MS9OSEh5bEhpS2VDY2xKUVVVbXVxYXYrdHZrZFZTbGFFV3V2Nm5sMWhwSytKL2lEYnh5RE1LdjVzaDlGSE5lUGZIVHdMNFIrTUhpdlV0VDFyUWZ0RTl4TCs3dW83bDRaQ2lrcW1jSGJqYUJ4aXZhME1uaDN3enExMmlodFExUURUdFBSaUE4OHI1R0ZHZVNGM0hBOURXWjRKK0V5K0dUSE5xRWFYV3JmZkVZSk1WcDZBRG96RDFQVEdCenpYMkhDbU1oZ3FVOFhKNjZSaWs5ZE5XL1M3UytSTmFVYWNVcEh5OXFuL0JOanczcTk3YjNyYW5yMms2YzhvWjdXUlk1WlprSFVLU3FsTTg0WXEzcmcwdmpUOWhyNGY2ZEEwMXZwRFdjWWk0MzNVMCs4ampvWDYva01ub0srdHRiMDJFUnZKY1pZUmpsanlBY2RzOWV2NlY1MzRnMHh2R21wZlpZVWZ5ZitXekhHQW96a3NmOC9uWDFFZUxzZFdrbTYwb3JaSk5yOHQvbWM4S2twdlJXUjhVYTMreUhiK0piLzdObzJockl3ZkNQSFBJbS9rKzVIK0dQUVZtSDlqZTEwK010ZDZ0UGRSMnpFTW1uMmIzZ2hJSUpVeWZLbWVlMmMrdmF2dGp4SHBHb2FIYXRZNkJhaUszWEFsbVpnc2t4NkhCN0wrUFA0Y2VaK05QaFQ0bzhWRHk1SjJSNWljTHl3R2MvbGovQUNLK29oeExtRk9Lak9yeXJ6MWY0My9RMGtyTFIvaWVNK0NmaU44UHYyV0o3cTYreDZyckY5YXhzTVhjQmh1SjVNa0tpakhsb2c0TE52SndUakpBRGVwZkduOXF2eDU4RVBoOTROOGIzbDFwR2phWDQwOE96WG1qMkdtNlo1dHd0NjhmN3VHNGxtWi9sakJobExKc0pFaFhhY0FuenR2MlF0S3YvRkxmMjQxOWZYRms1QWlrY3JHd0J5M1RIeW4weitmU3ZvcjlyZjRLMi94MC9ZUTF6eW9kMTE0VXR4cmVuR0dNeU5CTGJSL3ZZZ0FNN1dnOHpnY1pWZjd0Y1dNekRLSlpsaFBhUjlxNmtyVkpTMXNtclI1VTlFcnU3ZHIydWt5cVZQM2JTUHpkOFQvdFRmRXo0aFdVOXRyWHhDOGFhaGF5a0NXQ2JXYmcyOG1BQU1wdkM1d0IyN1Y3Wi93UjZuc2JiOXM2R3psbjh1YldOQTFDMXRnb3dHbEVZbElQQjQ4dUtROVJ5QnllaCtXN2F6am1iYXJiaElTRkpVN1I3MTlNZjhFZWJaditIZ3ZoR0I5ck5KWjZyR1BueHovWjF5Y2UvUThIdjNyOXV6YWhTcFpiV2pTaW9wUmVpU1d5TnNUQmV3bWwyZjVINnZmRjNUUEwrSEdrTjhzbnpGc2YzZ0NSWDVTLzhGSXZDK29hbCswbTBlbjJON0pHMmtRWGI3SS9sWUFURXNXNmNiU0I3ampKcjljdmpOWnRINEYwT0YxSmtiZDFIUTVINWQ2L1BuOXVUd0czaXY4QWFWOE9hYmFHOCsyNnBwMXBhUGJwbEVrVVN6bEF4M2ZOeTdFTGpIeURKNElyODA0UHhFcU9KNXZLWDN0bzhmSll1VlJMMVAwTS93Q0NFUGcvVVBobCt3bFpEVWRTdXJxenVyaHBiYlQ3Z2xsdGsycnVLWjRWV2RtNEhCSWIweFgyZ2RKdDdwWWJpeG1XR1daZHl4TS9MRWdIQTllby9NVjVmOEVQQTFwOEsvMmVOQjhPV2ErWERwTmhEcHdKa01na2RXWnBYQjlETThoR2MvS0JrazFsL3RyYXczaGY5bWJYTHhETXNtbi9BR2VXSXduYkloUzV0dHVEakl4ako5czE3WEVmQUdXNTFHOVdQSlYvbmp2Zno3Ni9QelBxSldTWjlDZUIvaU5jK0dyNWJlOFZ2Slk0SUpyMS9STmFnMWUwV2FDUlpJMkE1QjZmV3VHSGcreThYNkJienN2bHpUUXBKdkhxVkJybDBIaUQ0U1g1bUN5WFZpV3djRGNDdWErRndPWlo3d08vWVp0QjE4RGY0NFhrNmZtMXVsM1QrVDd6eTMyUGRvbXlWL3ptclVQSDQxeWZnWDRnV1BqRzJYeVcyVHFQbWlZL01QY2V0ZFBBZWxmdUdXNXBoY3d3OGNYZ3FpbkNXelczL0Q5MDlVUTc3RnVMK3RXRVhQOEFucFZXRjhWYmkvaHIwQmtpSmcvMXA2cGovT2FFR0Z6N1ZJaWV0QUdONGs4QjZYNHZqLzA2empra1g3c29HMXgrTmVkZUl2MmQ1YkZubDAyWTNFZkpDSEFkZjZHdllBTTBwUVY4VHhMNGVaSG5qYzhaUlNxZnp4OTJmemEzK2R5NHphVmo1c3YvQUFrMGM3UjNFWmpsajlWMnNLcXBaM2Vqc3BYTXlkeDdWOUlhMzRac3ZFTU95NnQxazdCdWpEOGE0blgvQUlOeXdzWHNaUE9YKzR4Q3NQNkd2eERPdkNmTnNzdlV3Yjl2VDh2alhySHI4bS9SQzVZdDNXalBLN0hYcExTZnpvWkh0cDE1QlU3U0s5RDhML0dzSkhISHFpbHV4bFFkUHFLNWJXdkJ4ODlvNW9taWtUMjJrVmczbWgzV25vZnZTUkwzSFd2aXNsNG96Ykk2OHBZR1RYZUwydXU4ZS9tck11V254bjBGWWFuYjZ4YUNhMm1qbGpidXA2VkRldmo4cThKOE9lTHJ6dzFlcEpieXlSZDJVZEQ5UlhwSGg3NHBXdXZSTEhkWXRiZzhBbjdqL1ExL1FYQ1BpdGwrYVd3K08vY1Z1emZ1djBsK2orOWtTalozV3BlMXk0MksxYzdjVFpMZjFOYTJ1UzU3MWcza29SR0xic1lKTmZwbFNWenFwcXlOTHcwRDVNMG5UekhDajZEL0FPdVcvS3RGNXVEOTNubklxdHA4UDJTd2hqUERCUm4zWThuOVNhYzV3dWVQbHIwYWNlV0tSeXlsZDNEN1FZbTNMd1FjOGY1L3o3VlQxRDkzYy9hWUZ4dXg1c1E2TjdqM3FXUTdqeWZ1OVNhZ2R0cE5lVm5HVFU4ZkNMdTQxSU84WnJlTC9WZDFzeVZ2Y0ZZVElycjkxaGtISGF1dzhTZkVMVDdUd1Bwc0luamhaTFpZeXBJQkRxTU4rb0ovR3VObWNzQW56YlIweUtwNmhwMXZxdHMwZDFid1hFTFlKV1JQTVg4ajBQSFd2V3d2T29SVmZXVnRXdEZmdWtUS056eHI5c1Q5aHI0UC93REJRRHd4YWFUOFN2RHNlc0xwenlTYWRmVzEzSlozMWcwZ1VPWXBveUR0YmFwYU50MGJGRUxLU2lrZm5WOGVmK0RUYlF0U1NlNitGWHhlMVRUWk5wTU9tZUxkTlM4alp1b3pkMjNsc3E0LzZkM1B2WDZ3Uy9DK3dpZG5zWjczVFdQUDdxY3lSZ2ovQUdaTjM1REEvb3hmRC9pTFJ6bUM4czlTUmVna0RRU0VEL3ZwVGozSXpYVzZWS1h3dTM5ZmNYelBycWZ6aWZ0QWY4Ry9QN1Uzd0RXZTRqK0g2K1BkTmgvNWZQQjE2dXFOSi91MnBDWFovQ0d2bmo0VGZzMy9BQkI4Uy90S2VIL2gvWmVEL0VsdjQrMUMvVzNzZEl2TkxudDdsTG5reHRMRzZoa2lSd0drZGdGUkZkaVFBYS9yRFh4dGVhUi95Rk5OdnJOZTdsZDhmSGNPdVYvTS9oVzNwSGo2MDF5M1ZZYnd5SVZLL0xKbkE0T1BwMDQ5cVhzS2tkVTdpdkY5TEg1QmY4SE9YaS9UZjJldjJPZmdiOEF2REx5ZjJUREloakFiYVdzZEhzMHRMY09QOXRyaFh4Nnc1OTYvTzN3cDhKZmdMOFRQRGJhUlkrSWY3SDErNXRkRWgweS9iVUpFbWt1cFkyZ3ZWdW9MdFliZFcrM1hWbVNZWlRGRmFXMXk2bVY0MlovNkZQOEFnb0QvQU1FeHZoai9BTUZLL0JlbmFiNDJiWE5OMUhSekkybWF4bzEyc0Y1YUxJVU1rWkRvOGNrVHRGRVNqcWNHTUZTcDVyOHVmMmdmK0RUUDRoZUhXbnV2aGg4VWZDdml5MlhjeVdIaUswbDBlNzI4NFJaSXZQaWR1Z3kzbERudFU4emk3U1g5ZklPWG0xVC9BSytaK1Zmam1YUjRQSHV1bnd3MTh2aDM3ZmNwcEp2SEQzSnNqSTRoODFncWhuTVczY1FvQk9lQjBySFk3UXhQYXZvWDlvai9BSUpRL3RHL3N0eHpYSGpMNFErTG9kTnQ4bVRVOUxnWFY3Q05SM2FlMU1pSVA5OHFmYnRYaG5nVFQ3anhMNDIwblR0T3M1TlUxSyt2SXJlMHNJWXpKTGZUczRXT0JVSEphUnlxQUFkV3FZeVV0RVRLTWx1ZnVSL3dTOGxYL2ducC93QUVGL2lsOFg3aGxzOVoxcUxVcjdUNUdHTVMyeWYyWlpSazkxT3AvYW5VK2x6a2RlZndvaWo4bUpWenUyOEgrdGZ0di93Y0hhNWIvc2JmOEVxZmdyK3o3cDExSDlxdldzTk12V2o2WDhHazJzYjNVcDk1TDJTM2xKN2tuOFB5bitISHdOOEsvRnY0ZDJHbzZmcUhpcXoxcTNlNXROVnNMSzF0dGNtVjBXM2VHOFcyV1MzdUk3UjFsdUZZb3R5MGJXdVNXOHdCZE9WeWVncFdpck04Z0xmbm5uUGVrODBLUDg4MUo5bWdsc3BwSTdyekpvWmVFRVpDdkgvejBESCtSSFE5ZW9wdDRzTjFwa04xQkg1T3dpR2VNTXpZY0RoK2VjTmcrd0lQQUJBcU9WaVAwWS80Tnd2QjJpNkgrMDU0bytNSGl5WnJMd2w4Ri9ER3ArSzcrOCt6dk9MVjB0elp4RGFnTHN6UlgxOUlxcXBMTlo0QUp4WGczL0JXajlyVFJQMjUvd0J2angxOFFOTjFTK2w4TDNoczlNOE1tV0FveHNZYmNMNXBSdVZWcFJJNVE0WUdadTZrSDdSLzRKRmVIOUIrRFgvQkU3OXBUeGY0b1ZsaStJR2s2dHBMb01DV2V3dGJDZUtMWm4rSTNsN2VLRC9lUmZTdnlEdEdhNldDSEtqYTQ1Sng5NzVUaytnNiszTlhMb2c2RTBvNU1jaXI4cHdRZWVhOWQvWjQvYjgrTm43SnJSTDhPZmlwNDQ4STJjTGJocDlucXNyYWRJZjl1MGtMVzcvOENqTmN2OEcvMmEvaUYrMGw0anZOTDhEK0Q5ZThUWDJreEdUVXpaV3BhRFNZbElRelhVeHhGYlJBNEJrbVpFQjZ0WGQrSnYyUFBEbnd1OEk2bEw0dStNUGdpWHhkSGJQOWk4TGVEUS9pdTQrMC93QUNYZDlibGROaGlKKzg4TjFjU0x6KzVKNEtYTXRZZzBub3o3ZS9adS80T3pQang4TlpMZTMrSVhoWHdQOEFFeXppR0pMaUtOdEExU1QvQUxhMjRhM0gvZ05YM0YreTkvd1dGL1pCL3dDQ3VIeGcwRHdYOFEvZ3pwZHI4UWRaZFl0TFh4dDRZMDNYTFc0dUQ5MjNpMURZemhtT0ZVU3h4SzVLcU1zd1UvZ0JwUHdPMXJ4Q1o0OUxTVFVMaTF0L3RVcVJRc3lwSHVLWkxqS2o1bEk1NDRKSkFCTmZVLzhBd2IvL0FBR20rTmYvQUFWSCtIVnZMRE10djRUMU5OZXZUZ2hyZjdCdXYwM2V6VFdjVUIvNitBTzlYeTN0N1JmZ1RySDRXMGYwZWZ0bi9zTytHLzI2L3dCbFB4RjhJZFdrdk5FMExXN1NDQ0dUU0lWVnRNTnZKSExiTkhGd215T1NLUDhBZDRDbFYyL0xrRWZodiswYi93QUduUDdRM3dya3ViajRmK0lmQS94VTArSC9BRlZ1TGs2RnFzZ0hyRGNuN09wOWhjbXEvd0R3YzAvdDJlTFBpRiszbEw4TGRIOFQ2MXAvZy80WTJGbXNtbjJWNDl2YjNHcVhFUXVaTGg5aEhtU0pGTkRFcGJQbGxIQzRMTVcrYy8yYy93RGd1UisxWCt6R0lZTkQrTVhpWFd0TGlJSDltK0tkbmlDMUtqK0JUZGg1SWwvNjVPaEhxS3k1VStyWDVHblBKYU5KbmtQN1EvN0RQeG0vWk5abStKWHdyOGRlRExWWDJDLzFIU0pWMCtVLzlNN3BWTUwvQVBBWE5lVUxKSEtHWldWaDdWKzFmN09IL0I0RnIxakhGcC94ZCtEdWs2cGJ6RHk3blVQQitwdlpPVVBCSnM3b3lySWZiejR4OUs5bDBuOXFEL2dsUC93VWQxQ0tieGw0UjhEZUN2RVYzSjVzaWVJOUluOEczVWorc3Q3cDBxV3o1LzI3aHMwL1p6NldmNGZnVHp3NjNYNC9pUWY4RUpyTzMvWUUvd0NDSzN4VStPK29ReHJkWE50ZmF0WnV4QVc4ZzB1MmtFRU9jNEpPcVQ2akRrZGZrSFd2d0JtdXJpL0VsMWRUU3ozVjA3VFR5U05scFpHTzVtSjdra2s1cit1ajlwRDlpendMKzI1L3dUVjEvd0NEUHc2MW5RZkQvd0FQOWUwV0RTOUQxRHd5WXJ6UzlPRnZQRmNRQlBLZlpKR0pJVTNnUHVjTStXM05tdndOL2FTLzROclAycy8yZlpMbTQwN3dYby94TzBpRGM0dS9CdXByZFNFRG9CYVRpSzZZNDdKRy93QlQxcFRsYVh2YUZRanpSOTNVK1lmMklmaTk0TytEWHhmMWE2K0lGcnJtb2VDdGU4TGF2b2VxV21rRlZ2YnRaN1Z2S2lqZDhyRVhuU0ZQTklZUmhpKzE5dTA4VjhjdmpaclA3UTN4UjFUeFpyNjJOcmVhZ1k0b2JLd2g4bXgwbTFoaldHMnNyV0xKOHEydDRFamhpanlkc2NhakpPU2FQeEorSEhpVDRPK0pwTkU4WWVHdkVIaEhXb2VYc05hMDZiVDdwQjd4eXFyZnBXRkdtODVYQitocDh5YTBFNHVMc3o5UHYrRFV6OW5YL2hhSC9CUVdieGpjd2I3UHdEcE56cU1iTW1VbGwyQzNDZjd5eVhkdEtQZUgycnh2L2c0SC9hRkg3UjMvQUFWcStLdHhhM0gyclN2Qk1zSGcyd0gzbGord3hoTGxRZW1EZU5kdDlHcjlNUDhBZzJsOEZXSDdIWC9CTDc0dWZIYlg0UEx0NW9wOVVtM0QvVzJXbDJVdDZ6b2ZTUVhJaklIVnJVRG5BcjhGdkVIaVBVUEgycjZsNGcxaTRhNTFqeERmVDZsZnp0OTZhZWFReVNNZnF6RTFvMXFvOWtLT3pmY1o4Ty9oMzRnK0szamF4MER3eDRmMXp4UnJkOXZNR2w2UFl5MzE3ZEpIRzBzdmx4Ukt6dHRpU1IyS2c3VlJtT0FDYXg5VXNwTExVYnEzbXQ1TFdXR1Y0NWJlVkdWNEdERUZHVnVRUVJnZzhnam12cHovQUlKbi9FRHdYOExmRjN4RzFEeFJxM2d2VHRXMVR3bTJnNkJCNHNtMWExMG01YTd1N1pML0FNMjUweERjd0gremx2STFaV1RMWEFHV0FLTjV2KzNkOFdkTitPLzdhUHhUOFhhSnFrMnQ2RnIzaWE5bjBtL250amJ5WFZpSlNsczdJd0Q1TUt4NWFRZVkyTjBuN3d2VXlqWklOTDJPKy80SlIvdERmRlQ0SWZ0bStBYmI0VytKTmUwdSsxaldyZXpiU0xlL21qMDNXMmxjUngyMTFBcDh1V09TVjQwSVpUZ3NDTUVBaitoNy9ndEQvd0FGcmRCLzRKSVdIaEN4dC9COG54QThYK05wcnFXejAxdFZHbTI5alpRYlExek5LSXBXSlo1RlJJd2czYlpHTExzQ3YrTWYvQnIvQVBzNi93REM3UDhBZ3B2b2VzM0VQbmFmNEJzNS9FTndyRDVTSUFvaWNIKzhsN0xweHg2TWF6LytEbC85b2IvaGZmOEF3VnE4WWFmRElzMm0vQy9TYkh3aGFsVzRFaUsxMWNqNmk1dXBrUGY5MlBTcWxKMmlpWXhUY21mb0g0TC9BT0RvSDlsSDlzSFM3UFJmMmh2Z3RkNlN1ZWY3YTBTeThiYU5ibjF5MGF6ai9nTnNhKzR2QnZ4Ky9aVi80S1IvczVhdDhKL0FueEkrSHVyZUYvRldneStIejRmMFBVSWRKMUd6c3BJekZzZ3NIRWMwT3dINUI1TzFTQndSa1YvSXhIcDl4ZjhBbnRiMjgwLzJlTXpUR09NdjVVWUlCZHNmZFVFZ0VuZ1pIUElxcXdXVmw0VnRwNEovaC93ck5xRDNYM0ZYbXJXZTNmVS9aTDlwWC9nMEYrTUhnRzh1N3I0VGZFN3dkNDJzY3ZJbW0rSWJPVFFOUXdTU3NhbGZOdDNJR0J1WjRWUFhhbzRyOC9mMm12OEFnbForMGY4QXNxQzZ1UGlKOEQvSFdrMk5vaE1tczZkWm5VOU1oVWNaTjNhR1NCZm96ZzQ3Y1YzWC9CTXYvZ3E1KzBiK3puKzBGNEgwWHd0OFJ2R25pSHc5Y2FuRGF5ZUVkVDFLVFV0TzFHRW41cmVPR2N1c0xPbzJoNHRqQWtZWWRhL29vLzRLcS84QUJYcjRjLzhBQkkvd3A0ZXZ2RnVuZUkvRW11ZUw3dTV0dEUwYlJmS1dlZExjSVo1NVpaR1ZZb2tFc1M1d3pNMGloVklEc2g3eVM1WmFlWTQxRTNhVWZ1UDVIYnJYWWRZdkpwdDF2SEpJNWNwR2l4b3VUbkFVQUJSN0FZR0svZlQvQUlOYWZBbWwvczQvc0MvR0Q0NmVJUExpMHlNeWViTmdaVzEwMjJrdnJ0MGIrNnlUMnlFZG5zMkI1V3RoZitDc1gvQk12L2dwVmQ3ZmpCNEIwWHdyNGl2bVZKTHZ4aDRSK3lYVXJuL3FLYWEwajdmOXFXV01lb0ZmZmZodjRHZkEvd0RhbS9ZRzhRZkIvd0NEK3QrRFkvaFZyWGg2ODhPUXQ0Q3Y3YTd0OUppdW81RmQxOGxtSG1GcFhrYnpTV2R5eGNrc3hMNXA4cjArNE9hbTVKWDY5Vlkva3U4UWZFUFVmaXI0aThTZUw5YXVQTzF6eG5xOTNybW9Qay92SjdpWnBwRCtMT2V2cVBldld2OEFnbngrM0JhL3NHK1B2RVhpeVB3L2RhL3Jtc1dWcm9rUGwzSXRmczJuTmZ3WEdvK1hNUDNrTjFKRGJKRkJQSGhvV2xhUUVNaTUrb3Yyai84QWcxVi9hcCtCMDkxY2VCejRKK0wyaXhTTVlGMGpVaHBtcENJZEdrdHJ2eTBEZjdFVTB4N1pOZkJYeDYvWjQrSlg3TFdzL3dCbi9FLzRiK052QUY1TXhqaS90elNKN05KeU9waWVSUXNneC9FaEk3aml0NmVJcDJTWDRoS25OKzgvdzEvSXlQanhjYWJkZkdqeFpObzNpZlYvRzJrejZ4ZFNXWGlEVm9wSTlRMXVBeXNZN200V1FseE02RldjTVNReFBKNjE5dy84R3l2N093K09mL0JUWHd2cUZ4YS9hTEh3WHY4QUVWd0dHVjJXYW1TTmgvdEpmdnBaL3dDQjErZVJ1STdvQm81Rms5Z2EvZXovQUlOSHZndGFmQzM0Ri9GMzR4YThrZHJwOE1jR2xKZFNEYTFwR2tiYWpxRFo2Ykd0anBENS93Q21ack5hSnk3SWlwZVZvcnF6NDcvNE9Vdmp4L3d2Zi9ncjU0cTBtR1padEsrRXZoMnc4TVFGSk14dE95ZmJMajZNczEyOFRkRCs0SHBYNTY2RjRNMWI0aWVNdFAwUHcvcG1vYTNybXRYS1dkaHAxaGJ0Y1hWN1BJZHFSUnhvQ3pzekVBQUFtdXorS1B4aXZQMmd2aXA4UXZpUnFXNkhVdmlKNGt2OWRuUW5jSXpjVHlUQlBvdThnZHNMd0s2WDlnWHh6NGIrSEg3UjhtdCtJdkUybitEM3MvRGV1VytoNnRmV3QxY1dkbHE5enBseFoyVXMzMldHYVpGaWx1Qk9IU0o4TkF1UnprYlFwMnBSVDY2bFZKZTgydHR2MFBCMVlFZHR1TWdpdld2Mkkvak44UlBnUiswWDRiMWI0VjYzcldoK0xSZUw5alRUYnVXQWFqS0FTbHZLcUVDWkpHQVF4dUdWOTIwcXdKQjh4OFZlSG8vQ1BpVFVkTGkxSFRkWWkwdTVrdFk3L1QzZDdTOVZIS0NXRm5WSGFOc2JsTElwSUlKVWRLKzEvd0RnM0wvWjVYOW9qL2dxcDhPNDdtRDdScGZoYTlIaUM5NHlZaFpLOTdDLys2YmkyZ2liUEg3OER2V1ZOdFN1UlZ0eXRINzAvd0RCYS84QTRMSDJuL0JJL3dDRzNoTnJQd3JhK052SG5qeS91YlhTZE1tdldzN09DRzJSR3VicVZsVm5LcTBzQ0xHTnBiekdPNGJDRytNZmgvOEE4SGEvd1A4QTJndkM3ZUYvMmh2Z0hxVUdsM1cyS2RMWmJQeFpwRXVlR2VTMnVraFpGNi9Lb21PTzVyNUwvd0NEb240L0w4YVArQ3NVbmhlM21lVFRmaEQ0U3ROSmtqM2Z1eGUzVzY5bWRmOEFhOHU1Z1J2K3VHTzJLL01YV0VVU3UzeWhlVG5vQUtkT21uVDVtdXBVbzhza292VkxjL29Pai9Zci93Q0NUdjhBd1ZHdS9OOEMrSlBDWGdQeFJxa29WWU5BMTJUd2pxRHVmNEl0TnYxRURmOEFiRzNJOXlNVjkvZkNyL2dtVDROL1pWLzRKNitLdmdIOEpadFM4TDJIaVRSTlZzWTljdnBmdGQ5SmZYdG8xc2RRbmRRZ2trVWVWZ0lxcUVoUlZDZ0N2NUIvaS84QUROZmhiNDJmUVovN1pXL3RMTzBmVTdiVnRHazBtNjArOGt0NDVaN1Y0SldMNGlrZGtFamJmTUNod3FoZ0s5by9ZUDhBK0NqUHh4L1k0K0tQaDF2aDE4US9HTmxwdG5lTE5KNGNHcFN6NlBxRWE1YVNLU3lZdEMyNUF5NUNiaG5LbFd3d3pqUmcvZFdsOVBJY3ExU1B2dlcydm4vd1QyRDQ0ZjhBQkhYOXF6OWkzU20wM3hOOER2RS9pYlFkTE1rY2V2ZUN3TmZ0Sm8xSlBubElOMHNTZFd6TXNaOVF0ZUZmQjc0NmFWOExQRit0VHh4d0RWcjNRZFg4T0dEVXpKWXphYzEvWlRXTXNveng1aVJ6eUFLY2c1UFE0SS9xTC80S3EvOEFCV0x3ai93U2ErQkdnK0t2Rm1nNmw0aThUZUtyNyt6ZEY4T2FiZHh3eVhNNnhlWmNPOHo1RWR2Q0NxdElxTzI2V0liTU1XWDRqWC9ndmY4QXNFLzhGRTdhSFMvMmdmaFF1ajZsTEg1QnZQRkhoYURYSVlDZU1RWDFvSHZJL3dEZUVVV1BYSE5iVXNSWHRaV2t0dTM1ZjVBMVMwazAxMTcvQVBEZmVmazcvd0FFZS9CbjlvZnRVK0R0VGpVU1MydDlkTGRNY0V4cjlrZmFQb2Mvei9ENkUvYW84SzNXc2VEdjJsNzYxUXl6Mjd6UzdTdWNKR1ZKYmowVkNmd3J6ZjhBNEk4ZkM2YndUKzJUYXRiMzBselozbW0zWm5nZVArSkl5VWZPTWNFa2ZRa1Y5ZWVIL0RxZUh2RmZ4S2ZXTEg3WllhMTlxRXNXY0xPa3JNdU9ubzNOZnlYeExtOEljWFR4TGFjWVVxYjdhYzhwVys5VzlMSE5PS2xUVFhXLzZINHNhRDRabThVYTlhd3VzMGpYRWlySUdISzVQVDh1M1hKeFg2WC9BUEJPdjltcWI0WmZCVFdQRzA5dTBXdWZFYlU1cmUwTFJrRk5QaWNwR0FBTWdQSmxqMjJvT29xdit6eC93VGM4R3I0dHRaTjE5ZWJadDIrV2JPM25uSUFHVDIveno5WS90dTZWY2ZDLzRKZUhCNFowMVBzT2pzbGswY1VqSjVFSlhDL2Q1NmprOTgxOUJ4Tnh0RE1veHdlQ3VveWFXdWlkdGJlbWkrNndWb09WSjIzMCs2NTZmOEl2REZ2NEkrQ0xXY08xcExpNUlsY1NCMkxLbzRKK3BQQjZacmtQaWdtWWtYb01ISUE0NjFyL0FMTXdLL3N6K0U0Mmc4bWE2RXQyNkU1SU1qWnpucVRqSFg2VlI4YVJmYmRaRUkrYkxiZGdHY25OZnpGWG90WTdGVjV6NXVXVnIrYXNuOTJ4M3pwdjNJZVNLYStISUxid3ZwNCt5eHZmcnZsamtkZVlOdzJrcjZFakl6MXdTS3lkUXRMUFNJeTBrcDg1aC9DTWxqNmRQdy94cnNmaVBxMXY0VDBxSzMyN3JtT0pWMkE4blBhdkRQSCt2blI5QzFEeEZybDkvWm1pNmV1NjRtSU8wS2VBcWdINW1QUUFaSkp3SytueXFuN0tsVHAxTlp5MTVWdmR2YjVzOGJGSjFLemJlaTArNHpQRStxSFhieTZQbVEydW5XWWFTZTV1SkJIQmJScmtzek1UdFVBREpKNDQ1cjV1OFVmOEZadmhyNEc4UmFob2VsNkJyL2lEVDdlWHluMWV6bGloUzlJSjNlVWpjK1g2TVNOMmVnSFh5UDhBYksvYk52UGpOWVhYaHJTNFp0TjhHTTRWdE5EZVhkYW50Q3NKcDNVL0t1Y0ZZaGtESHpaNEorVjUvRE1EV0UxM3BwdUpHdEd6UEMvenNzZUNkK0FBUW9JSWJxQnVUa1p3UDZJNEo4UGFFYVgxck5sNzcxakZQU1BxMXZMOEY1dmE4TzRTMFd4K2tuZ3YvZ3FKOEZkZHVyU1BVcmZ4cm9zbDBwWVBQcFNYRWFNcFB5NWhrZHlmb244UTZkYTN0Wi80S3NmcytlRllOME54NHIxeVgvbmpZNkdZMlFqK0VtZDRnT25iT00vV3Z6OThJK0VWdnZoWmNhbEhHMGwzcGJicmFZWEN3eC92WUpkMGlzNHhpS1JFRFk3L0FNWEtnOEhwSHc5a3Y5ZWh0UmNwY1F0aDVaa0I2YzVVYnNESkkyam5saUIxcjZ5cHdYbE9JbEoxSE5LTzY1dFB5djhBaWEwOFBHcTNhK25vZnBSOEwvamZvZjdXT25YWGpUUmRKYlNmczk2MWpkYWJMZExjWEZ1RkFNY2o0QUFFaW5JR01aREFGc0d2b2I5bnlPRHczUDhBMmRmS0pOTzFxSjQ5bTdPTndLbFQ2SERFZlExK1Z2N05QeEp0ZjJYdmlkcUdzV3V0VytvWHl4Zlo3dlRkKzJ5dllUaDNRU3B1VjJBQTJzU2hSd1RnNDUvU0Q0Sy9IRHdyOGMvQjhOLzRWdkRQdFJKTHV3bC9kNmhvN2trYkpZK29PNEVieGxXSFE4NHI4ZjQ0NFhxWmZpZmE0ZUxlR2V6MTl6cWsvSlBaOWRqdG5SY1lwSDU1L3dEQlF2OEFaUHVQMlZmakRxRmsxd0pMYlhqNStqVDdWSDIyelluY1RqR0psWlNKT01aYmpoaFdsL3dScTAyUzcvNEtIK0JaSTdlTm83ZTIxV1NWdHU0ai9pVjNlRGsraHdjMStrbngxL1pWMEg5dTM0TFNlRGZFTTBPbGVKdE5MWFhoM1dXWGMxbmNZeGh1N1JQZ0s2ZDhLZUNvcjVNLzRJL2ZzeWVLUGdOKzMzNHowTHhocGJhWnJYZy93M2VOTkdXeUFaWmJhM1NSSEhESzZTdVZZZFFENmtWK2s4UDhYVThma2xiQzRpWCswUWcxSlA3VVhvcHg3cDZYN1M5VWNlS3JXb1NiM3MveVAwUCtPcU5mNmY0YlF4cXJTSm5JNmRpZnAwTmVFL3N4L3N0eitPLytDbEhqRHh4cm1sdGQ2ZjRNRmpwdW1wS3BWWmJpU3lnZFd6a2ZLb2FWeUIxV0lqT1R4OU5mRjN3czBrdWlLKzFZL0lWdVJuQXczYmpuL0R2WHAvd3A4RncrRHJ6V0x6N0xiMi8ycTY4OTVBdUdsazhxTkN6RWpPMVVqVlZBTzBmTnhrbXMrRFpSbGlKUWh0RmZxanpzamkrZDM3ZnFqclo3SkxhMnM5UHQxWXgySVRhWmZtNEMrV01rOVc1Sko3OCt0ZVRmdDM2bTJuZnM0K0lUSEN0eEpJYmVDT0pseXJscnFJRE9NZGlEMjZaeUFNMTZmb2tzMTVmM0Z3ck1zS2JrVlQwK1UvZS9YQTloWGsvN1hsaTNpelNQQ1BodUFFdDRnOFQ2ZEM0eVJtTkpmTmJwMUh5THhuR0I2WnI5TG95dk5NK2xsSDNkVDdjOEVmdS9EOWtyYnR5d1JxU2U1Mml1Z2pqV2RTa2lxeXR3Vkk0WUdzM1I3ZFlyTlZWY0twSUhIYXRhMmp3YTZaMmt1VjdFSEcrSXZoRTl0ZC8ybDRma2ExdW8yM21BSDVYL0FOMzArbGFIZzc0eFIvYlYwM1cxK3czeW5idlpjS3g5L1Q2OUs2K0ZkbnZXZDRyK0grbStOYmZiZHhCWmwrN01ndzYvajNyODB4ZkJlS3l6RXl6TGhXU3B5azd6b3kvaFZQUmY4dTVlYTA3b2NxaWFzenA3Wmd3ejFERHJWMkZzNDlhOHIwdVB4SDhLSkFtSk5hME5mUS92WVI3ZjRkSzc3d3A0eTAveGRhK1paWENzd0h6Um5pUlBxUDYxOVJrbkZOREd6K3ExNHVqaUZ2VG5vL1dMMm5IKzlINTJNK1ZyVTNsNVg4S21BNXFHTTdSVXljdFgxUURsR0ZwMUI2VUtNLzhBMXFhdDFBTVlGQUJhcEFNbWpIUFEvbFQwQXo5VzBLMTFtTXJjUXJKNkhvdy9HdUw4VGZET1dBdkphRDdRbjl6K0lWNkU2NUZSc3VSWHl2RUhCdVdaeEJyRXd0UCtlT2t2djYvTzVTazBlRjZ0NEtqdVR0a1V3emRBY1lJcmxkYjhPWGVsZjlORjZCbHI2SzF2UjdmVW84VFFvL1lOam44NjVYVmZDMXZiRDl6amFQNEg1eitOZmhYRUhoTmpjTENVNmI5ckJkVnBKTHpqMXQ1TitnUFYrN29lU2VIUEhsMXB4V0c3WnBvUUFBRys4dGRaWXpSYTVKRjVMZVpHWkJ1QTZnRGs1SHZnODB6eEw4TVl0UVZwSVY4aVFjN2VnUHZYSE5hYWg0VXVUdVdTTmtQREE0d2Zhdkc0ZDQyenJoeWNjUGlVNjJIN051NlhhTGVxOUhwNkZScU9Lc3oxT1J3U1J4L24vR29tZko5UjErbGN4b1B4SVNkZHQ0TWRCNWk5dnFQNjEwUzNFZHhFSkkzV1NOdnVsZVF3cittZUhPTE10enVqN1hBenUrc1hwSmVxN2VhdXZNenRZYlBKdEhYalBGUXZ5UG03SG5Bb2tjY3FEeXA3ZGFqRHF6OTkyY2M0Ni84QTY2K2xBY1pjYmZ1K3hGTlJnRDE3WituK2Y4S2FadG4zVHhqZ0Q4S2J1M0RrK3ZHS0FKMXh0N1p4bklQVDIvejdVcXlmTHU1SUlQRlFsL0xIM3UvK2Y4KzlNKzBiZ3VDdUQzeG10QUxxemJQbTZISEdLenRZOEw2WnJrdm1YVmpCSkpuSmtDYlpNK3U5Y0g5ZTlQRjRvWHN4ejkzdWF6NC9GRnJkV2NkeGIzRUZ4YlNBbEpJWkE2eURvU0dCSVBJSTQ3ajJwcVRXd3lHWHdEL1o3K1pwK3FYMXJ5Q0lwaUxpSWZUT0dINHNhUHRuaURTV09iV0hVbzE1QnRwUG1BeC9kYkEvSW42NHFPYnhwREhLcU5KR3U0N056SDVSbmdFKzFmbEQ4WFArQ2gzajM5cjcvZ2tuOFpKNU5TdXRCK00zd0w4VFFIVjMwd215dU5sdnFDdkhjaEl5Qkd5eEM0QlVaVXlhZTdZd2NEZU5WdjR0Uk9OajlXVDhhYkhTNTFGOFp0TmtiaFZ1RU1KSjlpY2ZvYStaditDblA3VjNodjhBWWwrQzYvSFBRZmgzNEM4WCtNOUoxdXdzWHY3dlM0djdRaXRiaDJqbU1kNHFpYUoyVWVXcjdpZ2FSZHlzdkJsL1lWL2JFSDdjMzdIL0FJUjhlQnJkdFQxTzFObnJ0ckdBWTdYVTRENWR5bXpKQ3F6RHpVVS84czVvL1d2SmYrQ21ud1ZIeFovWlk4ZmVGRnNJNFo5WjBxUjdJd3UwS1BkUXN0eGJncXAyOHpSUjlzOWFLa3FWcnRhbFFqSzN1cytKUCtDNG5pN1NmMnovQU50TDRIM1VuaXpVdE0rRC9qandicHVyNlpyL0FObU4xYitISXI2OGUybHVKWUM2S05zdjJUN1FBd2NBS3ArWkZXdkcvd0Jvai9nM2orTy93aHVMaVR3L0o0VCtJVm5DNTJycDkrTEc4Q0RxenczT3hNOFkyeHlPYzlNMXpmd0xHdWZ0Sy9EdndaOFA3SFQ5UTE5ZEJ2N2kxc2JlenNacjJTMTBMeERDMGQ1SXNjS3M4aWFkZnhHVWZKZ1NFbmpHSy9SYjRBZjhGanZobDhLUDJNL0JhL0dmWHBJL2lCcCtueWFSZTZUcDF2SnFXcDZoTlpUeTJUM0EyZnV2M2hnTDc1SkkxWm1iQk9DUWV4VXRZeXQvWC9Cc1p4cUpmR2o4UmZpUDhHUEd2d04xdGJieGg0VThRZUdaMlpvMVhVN0NXM1dZL3dDeXpBSzQ0NnFTS3pmQ2ZndldQRTBkOUxwK2o2bnFsbnByUXZmUGJXN3lKYkxMS3NVWmtZREVZZVIwUlMyQVdkUjFJRmZmUDdiSC9CYVh3OThjOUh1dEQ4T2ZCL1NiN1NXdkk3dUtmeHZlTmZnUEhobzVVc0xZeHhJeXQvQk5OY293eUdVaGl0ZUtmczQvdEE2WjRwOFVmRG53bjhTdGQ4UngvQitlYlVMRFV0THN0V210ZE4wWFZMb1hCdGRaRmxBeVJLYmE0dUlKc0toRHgyV3phd0d3NHhpK3JDVnI2SDNyOGF2Qy93QU5mRW43QWZnSDltUHdoNC8xTHhONDh0ZExzZjhBaEpkSCtHdWdTK050VWtsTG05djRveGF1bG9UOXZkcytiZHg0VlhKRGNDdms3OXFyOWpuUi93QmhTNitHMmorSnZnOXJIZ3U0OFo2bkJmV210ZU0vRWNHdGFuTGIyOXhDTGlON1MxOHV4c29tRXFsNGJtRzhrRzdCa0F6WDdKLzhFNS8rQ2t2N1AvdzQvd0NDY1hnUFh2RW5pejRWL0NLNnRyQmRQOFVhTmJKYTZUSWRYdDNhMnVKQlkyeWg1bWxraWFiZEZHNUt1U1R3MlB4Ky93Q0Mvd0Ivd1V2OEwvOEFCUm45cFhRVitIY2QzY2ZENzRlMkU5anArbzNWczl0TnJWMVBJcjNOeXNUZ1BIQ1ZpZ1JGZFE1OHRuWUx2Q0pjbTR6dlpXL3IrdGc1bEtPdS93RFg5Ym5rZnh1K0xYaWZ4NzRzOGU2VDR5OHFiVmRGSTBiVHBUYndSMjBRc0pMcVJZcmUzalZZWTR5aG04dGJhSklrTXBPQXpxMWVFMkdzTXlxb1B5S1BsVG9vNjloMHJLMWJ4cnFHb2FvdDNjWHJYRjFiR0lKS2NsbU1LcWtaUEdTUXFLTXR6aWswZUYwMCtOaUdIekZsRERHVjR4K2ZORlNwY21NYmJIMk4vd0FFeVBFUzY3NDAxdnd1Wm9ZR2tpVFU3ZVJsT1dWR0VjcTQ3NDN4TVBUREh1YS9Yei9nazUreGY0ZC9acytNZnhSK01jazBOakRxbmh5RzNiT0ZTSlpaUE92SmlvSHlnTFlXcHprNUxTY0RrdC9QYjhLZmlGcm53ejhjMk91YURxVW1sNnBiWlNHNFRIRzVkdUdCeUN2T0NEMnlLL1NYeHIvd1h5MG54Ti93VHg4WGVCN1h3anJ1aC9FVHhGNFp1ZEJrbHRwWTVkS0NYSUVNMHl1WFdXTWlNc1ZYWXhEWUc4akRWMXJFS1dIOW05MFlTaTFXNXVqUHpmOEEya3ZqVmRmdElmdEUrUFBpQmVlYUxqeHByMTdyT3h6a3dwTk16eHgvUkVLcUIyQ2l1T0RjL3dCNzNGVjR4c1FEc0JnYzFOR2E0WTlqZDZrcTRDNTlPdFBEWlhuOGFqKzZLY3pIYm1xSzVtZE44Si9qTjR3K0FuaVgrMnZBdml6eEw0SzFnQUQ3Ym9XcVRhYmNFZWhlRmxKSFhnNUZmY1g3T3Y4QXdjN2Z0V2ZBc1EyK3RlSXZEWHhTMDJFS25rZUxOSVZyZ0tPRGk2dFdnbVppUDRwR2s1Nmc5Sy9QUnY4QWdWQU9EVDUybFl6Y1UraCs5ZncxL3dDRHIzNElmdEZlRmw4TS90QS9BM1ZMYlM3akNUSkRIYWVMTkhZa1lMdGJYS3hPaSt5ckt3OTY2ZlNmMkkvK0NWZi9BQVV0MU5adkF1ditGZkNYaUsra0EreDZCNGluOEozMHJaKzRtblg0RWZ0KzVneHp3ZWhyK2U0TVFCU2pFaUZXVlhYcmhodXBjc0pQVmZkb1ZGelNzbjkrcVA2NmYyay8rQ2JtbDY1L3dTMjhVZnMxL0NjMi9nSFM3N3czTHBHaE5QSkxKSEc3Uy9hQ1o1RHVrWlo1ZC9uU1laaUpwQ0ZQQzEvT1QrMHIvd0FFWGYycHYyVWpjU2VKZmd2NHExRFJiWm54cXZodFY4UVdRaUdjTzcyaGRvbEk3eXBHZlZSWG5YN09IL0JSMzQ3L0FMSWh0NC9oejhYUEhmaFd4dFczcHBrT3F2UHBaUHZaVGI3WnZ4ak5mZlA3Ti84QXdkMWZIUDRjTmIyL3hHOEUrQmZpWGF3ajVycTEzK0hkVWtQcVpZUkpiNTZkTFphSEhXOEpmZWdqSnBXbEcvb3o4blpIalc1a2habWp1SXlVZU9SU2pvdzRJSVBJSTlLYkpGOVQyK3RmMEZRLzhGMC8yQWYrQ2l0b2xsOGZ2aGJINGYxYWFNUnZlK0xQQ2tXckxDVGpJaDFLeEQzY1kvMmlrWDRWS3Y4QXdicWZzTC90NHhOckh3RytLbW82V05xdTlwNFA4WFd2aUMxdHdlZjNsdGNlYmN4TjdQS3VQN3RTK2Ricjd0U3VlbTlMMjlURi93Q0RUNzRSNlo4RVAyUy9pMThhZkVteXgwM2NMV1c2Zjc5cGJXc0J2NzJRZjdEMjc2YzMxaE5maHA4V1BpZnFYeDErSi9peng3ckFVYXY0NjF5KzhRWG9CeUJOZFR2TytNOWd6a2ZsWDlWbnhFLzRKdHI4Si84QWdrUjQwL1p1K0RONWNRMzE5NFMxSFJ0T3Z0YnVGTnhxVjFjcS9tdGN5cXFxREtyTkNDRkN4Um1OUUFzWUZmekdmdEwvQUxFUHhpL1k3bm10L2lkOEtmSGZnbXp0NVBJaXY5UTB4MjArWWpvSTd5TUczazdjeHlNTTArYVBQcnBwb0VZdmx1dTUzbi9CT3Y0N2VBLzJkZEI4ZVh2aTY3Z2tQeEJ1TksrSGVwMkhrTkpjUitGdFFlNGsxeStqNDJySkNsdFpLaHlHM3pnZ1lVMXhYL0JRL3dBTTZMOE1mMmpWK0h1Z3lhRGRXUHd0MExUUENWenFHbEtoZzFYVW9MWlpOVHVmTlVmdnQyb3ozZ1dSc255a2lYT0ZBSGk0a2h1VTNSeVJzdlhyMXFGN2NMOG9HMFk0SHBWeXMxWW0xdjYvcnlQdWovZzNCL1p5L3dDR2dQOEFncXQ0RGx1TFVYV2wrQzVqNGt1M0M3dnM3V2l0YzI3ODltdUlZSWo3VCs0cnVmOEFnNmwvYUYvNFhQOEE4RlU3end2YnpOSllmQ253M1phSHRCK1EzVTZtK21ZZjdRRnpGR2ZlSEhhdnJmOEE0TkEvZ0phK0V2aDc4Vy9qRnEvbDIxb0ZqMEczdm5HMVlZc2k1dlZZbis0dHRaU2VnV2F2eHQvYWMrTk4xKzFKKzBYOFNQaWJlTElrL3dBUVBFMS9yb2pkaWZJam51SkpJNGhrOUVRcWdIWUtCU2xHOGxIc3JoRFp5NzZIbGMwdTA4NDY0K3RYL0J2akxXUGh6NG10dGE4UGF0cW1nYXhaUHZ0Ny9UYnVTMHVyZHZWSll5SFUrNE5mWmY4QXdTc3MvQnVsNk40dTBuVVBFM2hUU2ZHSHhrMFh4UDRJanVkWnVGanRmQ2VqeCtHNzI2dU5RdVdJUGxlZmV0cHlSdW9MbUt6djBBUG1LRDV2L3dBRkxQRDNnSHc3NGwrRVVmdzU4T0R3MzRmbStITnBPdm13TEZmNndHMVBVL3MrbzN1MGtHN3ViTVdzc21DVlV0c1Q1RVFVbkNVVnpDdW5vZS9mOEUvZitEaWI5cWI0Ry9GN3ducGV1ZkVEVnZpbDRQZTlpaTFEUnZFMFNhbmRYRnRuOTc1VjQyTHBaQkdHS2t5c29JQlpIQUtuK2h6L0FJS04vd0RCUmY0US93REJPVDROdzZyOFlyMjZtMHZ4SmR2cFZob0ZwcHcxSzgxMXdBMHFKYnNSR3lJcEJrYVJsUWJrWEpaMFZ2NW4vd0RnZ1Iremd2N1RIL0JWSDRWNlhjUStkcHVpNnJIcmw0R1RmR1k3TU5lTkc0NmJKRXRwSWpuZytZQjNyNmovQU9Ecno0K240dS84Rks5QjhCUXppYlQvQUlTK0VvamRSZGZLMURVV0Z6SWZxYlkySi80RFZmRW94Zlg4djZRcWNiU2JqMHQ5L3dEVFByZUcyLzRKSC84QUJUUytqbWVENGUvRC93QVRYUzU4dGpjL0QrNVJ5ZW1QM1ZoTklUL2RNcE9Sem12dnpTLytDZkh3NzhLLzhFM3ZFbndGK0VNZHY0TjhEK0xQREdxNkpZNmxaenRxT0gxRzNsaWt2WG1aeTF3NU11NG5meW9DS1ZSVkMveUZhSDRIMVg0Z2VLOVAwUFFkTDFEVzlhMW02anNyRFRyQzJlNXVyNmVSdGtjVVVTQXRKSXpFQlZVRWtrWUZlcStIL0dueDcvNEp2NjlZeWVIL0FCdjRuK0YrcmFudW1mVDlBOFlSSmNMNWJMbGIyeXRiaG1pSkpHSTd1TmQrR3dyYld3cFVvcTZXaFhOVXVuZS9yL21lN2Z0RmY4Rzkvd0MxL3dEc3FMZGJ2aFROOFF2RDlpMkl0VDhFWFM2d0oxNjVXMVhGNkFQOXFCZnFhK0x2Rm1uM1hnL3hEY2FUcittNnBvR3NXcmJMaXkxSzBlMXVJVzlHUndHVS9VVitvUDdEL3dEd2RTL3RGZkRyNGorSDlKK0tNL2h2NG4rRTdpOGpnMUdhNjBtT3gxaUdBbkRQRFBhQ09NdXE4L3ZZbnpqa2pPNGZ1bC93VVUrSkg3T2Z3cytDQTEvOXBxMytIMXg0S0YwbGxiLzhKWm9TYXdacmh3eFdLQzNNVXN6UzdWWnNSSVdVS3pIQVVrUG1xUlMxVFg5ZjFzRVpSZWpUVCs5ZjE4eitOdWEzRXNlNk5sY1k2ZzErNVgvQm5iK3p2SHBGbDhXZmk3cVNwYjI4TnBGNGR0THhqdFZVbW1FOTRwSjZiQlkyai9TYXZVclgvZ2poL3dBRXpQOEFncFpkUXpmQjN4NVkrRnRldnlaUnAvZzN4Z0xlK2tKL3ZhWHFTeXl4ai9aU0tNVjl0L0QzL2dsMW9IN0pQL0JOYnhwK3o3OEg5VTFiU3JqeEpvbXJXa1d2YTVQOW92SmRRdnJWcmNYbHcwYUlQM2ErU2dFYUtGamhRQUVna3hLYmluZU5uWUl4aE9VVXBhWDFQNWJQMmkvampjZnRUL3RGL0ZMNHBYQm04ejRpZUtiL0FGZTNSL3ZRMjhrN21HTDZKR1ZRZXkxNTc0VStIbXVmRkR4Ukhvbmg3U3I3V3RXdWttbGl0TFdNeVN5SkRDODByQmY3cVF4eU9UMlZHTmU4ZnRFLzhFeVAyanYySkxHNnRQaUY4RS9IVmxvZWw1WnRkMHUwT3JhUUVCd0hOM2JoNFZ6MXc3SzNQS2c5UElmaDE4UmZCK21hRDRxdDlROE82ZDRrMVhXOUxPbmFWY2FoZHl3eGFCSzdyNWwya0NBZWZPSXd5UkIzQ1JtUXVVa0tvRjdhY3FjcWFoQjdJbXB6S2ZOSmJzNFcvdkp0VXUzdXJpZWE2bXVENXJ6U3lHU1NVbitKbU9TU2ZVODE5ZGY4RUd2MmNoKzB0L3dWSitGT2ozRUN5YWZwK3RSYXRkbDEzUmlPelY3NTBjZjNaWXJTYUw2eUFkNitXOVEwSWhOeS9NcC9pWG8zK2NWKzBIL0JuYit6VjlyK0sveEsrSmQxRHRPajZURm85bzdwOHNqWHMvMzFiKzlHdGhjS2Nkcm4wTlp5ZzR2bUlxYXhzZWQvOEhhSHg1YjR2LzhBQlIvd1g4TzdlY1QySHdxOEpmYkxwQi95dzFEVTVQT2tCK3RyRll0K05mazdxMm5zYm5sUXE1NzloWDA1KzJ2OGF2OEFocjc5dkg0NC9GS080KzJXSGl6eGZlUTZQTmduek5OdG0rejJlUDhBdDNpaEdmYjA0cnlid3A4R3RkK0t2anZUZkRQaG5SNzdYdkVPczNLMm1uNmZZeEdXZTZsYkh5cUIyNExGaVFGVUZpUUFTTmFGSDl5bSt1djNsMXBmdkhIdHA5Mmg5by9zcCtPNWZnaHJXcmVOUHNTR0hTZE1uc3JVZERQY3pwdGlUR2NISExNUnlGVTE5VWZBblFmRW5qRDltdlRkUzE2MTM2aGVXT1k3a3R1ZWVESjh0cE9PSEl3ZS9HSytVZjJKOUc4YmZ0SXZKNTNndlJkSjhLMnR3WTVkUnVkVGFFVHk3ZjhBVjI4WkI4MlFjWndjREpCUGF2MHM4RjZzZEU4TlcralgybHREYTJ0c3RxbTBkVVJRQjA5Qml2NGg0NmxHbE9WT1NpcTByYTNUc29wMlYxZGJ0dHJ6OURIQnhsWk43ZjVuaEh3aTBuL2hHOWVqOHlSZk5EZmRQWWRQOC80VjdsNC8rR1Z2OGN2aGY0aThOM0UwMXVOVTA5MXRKNG1LeVc4NmpkRklwejk0TUJYbnZqUHdXMmkrSmZ0RUMvdW1iZWpZNElOZXlmQnFSYnZTQTMvTFplUngrbjg2L1BNVm5tSXJZVjFxT2xTbGFTK1RWMStGanVqVFNueXZabkRmQzdUYi93QU5mQ2p3ellhb3hiVUxIUzRZN3Bnb1g5NEVHN2dBQWNnMXo4Qk4xNHVaaUZiWXhZWUp4eFhyWHhTMDA2Yk5OUDhBd1RKNXlFTHcyZjhBQStuclhsWGg1L3NWM3FGOXRWdnNkckpMZ25na0tjVjh6aGF0VEZyMmV6cXpjdjhBd0ovOEU2SzhyVmVmc2poUEYycDNtbzZuY2F4cWR2TExDN2tXOENTQVBOendBV0lDcmpHVDJHZXZmNUkvYlUrQkh4TytPZDJ0L3B1c1hVMm1ReFBHbWp4M0t4cllzY2xab2szWVlqQVZnZm1LNTV3U0I5RU5xTTNqUFhwcHJobXVFamsvZlRNY0tBcEFNY1E2Y2NqUFJmYzVCcytWTzcrWGIyc2NlMXNJU204cUI2bHVNbkhZQWZUcFg3aHd6UmVYVjFqSTJjKzdTdDhyN2V2L0FBeDhaV3J0eXY4QU94K1hldGZzaGVPUEN1b3hONHcwKzRtdDJtOGxQN1B0cFdOL0w4MkU4d2hVWEpBNllKM1lHT284a3M3WlBCUGlGTGpXcldhSm9idHZPanRuOHVXTlNkcktNWUl4endjWTZIdUsvWTN4TjhNNzNVYlh5WnZOV09RTXhhU1FxQWZvUHg0R09QVHBYeW4rM0Q0UjhQOEFoL3cvQ21yNnhETk5jUk5icGFrZ1RPRG5oUmpjZXVjWXI5aXlYamg0aXNxRlNLYmxaV2pmVDBTUnJSeDEvZDVkK3g4WDNueFpmeDM0V2c4TCtYRG9Pa3RPWjVQTEpsOCtSbitUZXgrNnFaWThZVW5IQXdNWStrZURkV3M5U2pnM1NXc09XOGlXVDVvTi9VYnp5QmtBKythNSs0aDJhYjVVS1R1MGN6anA5OGNZSkhiSHYweml2VlBoejhPOWN1UGhycE91Tkd0MXBzbDNNOG0yVkF5UVI0VXlNQ2R4QWJldjNUaGNuKzZSK2sxK1REdzl5eVRlejd2WDczNW4xV0VveCtHSzgvOEFoemxmRCttekR3bGRYdG9saWw3WitkSkpMSXloclpBbVVDQWo1MmZKMm5ucHh6akI4SVBqZjRvK0IveEZzdkdPaDMwemF2cHNtWGxueklzNnZuZkZMejh5T29JSVBzUmdnRVZwN2kwMTM3ZkhGSk5GSTBmbklyU2d4bmF3VUFFRHJna0RQWGpwbXNhMHU3VzBoWlZVL3Y0c1BrNTJ0d2VoK25yMzYxcExEd3JVNTA2MFZKUzBhYTBhYTFUN3JjSjdwSjZIN1Jmc2UvdGtlRVAyd29yZXowVi83RDhZV2RtdDdkYUZPKzZaVndDMHNEOUpJZ1d4ajd5OXhnZ242azhKNkJwdXZlSXY3U3ZMTzN0dkdEV0NhWC9hQlhhYnkwV1h6QkV6ZXpjalAwelg4N09rZkVsdkJ1dTJkMXBkM3EyaVhsakZtMzFIVHBqSGZReTV6a09NRUwwRzBFREF4bmtzZjNJLzRKTWZHTHhUKzJkK3lXdmlEeGxjMnVvYXJhNnhKcE5ycU52Ym1CN3BZN2Uza01qakF5Kytaa0pWUVBrNnRuTmZnSEUzQVZUSkpySDVkSit5djhMK0tEZlNMKzFGL3dBcjFYbXppeGxPazROVGVqM1BvWDRoMk1rdmovU2JQYnVoamppalpYWEpQeW9DUHpiSC93Q3F1MzhZYWczMmdXOGJMNWt6N0FNWndBZmJwZ0RBSEhmaml1TGtqdWZDL2lhM1hVcmR0U2owODdsbGhKTDdRZjRoM0h5OWZiclc5cFRycXVxVGFxMGl6VzZoaW9VL2R5UndSMUhQOWE5emdYTk1POFJWaFZmSlVsYTBYcGZmYSsvNStSbmx0RlU1UzFOeFYrd1dNTnFvOHZhQW5BeHQ5UjE2bnIrSGF2STdHV1Q0amY4QUJRZjRlNkxEekQ0WHNidldid2tuNUhkUWtZWEhYY3FUS2M4WU9NSGRYcW1vYWdwamtrM0ttMGJwQjJISEhCOUNEazlPQ2ZTdk9mOEFnbGo0Vm0rS1h4aCtLUHhjdUpWbnM5WnZZOUMwUmd4WlRaMjJSdlgwM2tCd1I5NFNnOU1WK3Q0ZmZtUFVsZDZIM1BZUmJJRlhQRzNOYWNFZmI4YXJXOEhUOHNWZGdqMkFDdXRhbVJQQkh1WDlSVmhFNS8zalRJNCtuK3oxcWFGTW10REJrMXNpdXZQUDE3MWcrSVBoZmI2cGVMZldNMG1sNmxHZHdtaDRESC9hSHBYUlJyaHFtakgzZndyemMweWZCNWpTOWxqSUtTV3FlelQ3eGtyT0w4MDB5b3phZWhENFdiVXY3UDI2bXNQMmlOaW9lTDdzbzdOanQ5SzJGNFlWWGdiRlRSbmovZHJ2d3RIMlZLTlBtY3JLMTI3dCtyNnZ6R3liNjA5UHU4VkVqWkZTSTJCNzF1QTVCbi85Vk8yLzV4UVcrbjUwWi96bXFHTksxR2V2NGVsU1B5UDUxR3grYjhLRWhGTy80U3VYOFFUQ05UOWZXdWkxVjlxVnh2aVM4dzNXc1o3RlU5WFl5MjErV3o0Yjk1R09OcmR2b2F0THAxdjRrdFZZYlI1d3o1Y25YOERYTjZuZE5LeXhwL3JKQ0VVWjducC9PdC9JZ1FScm5aR0FvQTlCeFh5MmFjSTVmbWwzV2phWGRhUDU5R2FWVWprdkdId3BraG5hUzF6dVhuWWVEajJOY3hwMnQ2aDRUdjhBeTJMTEYvRkd3T1BmUCtJcjFKZGNraWk4cy92Rnh4dUhPUHJWVFdMTFMvRWRuc21WVlp2NzM5RFg0bG4zaHRtMlVWLzdReW1UOTNWT0xkL210L1hkZHpPT2hqNlI0cnRkZWdYYTNseVlIN3Mrdit5ZTQrbFd6TW9QTzdQZm11VjhTL0RXNDB2NTdObTI1eXBIODZwNmQ0NnVOUGtXMjFBYmdwMmlYdVByL2pYMW5DdmpCVDVvNEhpSktuVTJVMThML3dBUyt6NjdlZ1N0ME95YVQ1am52eGs0d2FpYTYzUDFIK05jdnFmakJiZkpPT25CSGNldkgrTmZKZjhBd1YvK052akw0WS9zYlh2amZ3RHExMXAvaVQ0ZjYzcDNpSUxETXl4MzBFVS9selFUSXBBa2haWmQwaVBsU2lOM0FJL2NxZGFFMHBRZDA5bXRRNVhiUSt3UCtGbjZKUDRydnRDdDlXMDZiWE5OdDRydTcwNk80VnJtMmhsTENPUjQ4N2xWaXJZSkdPS2p2dkdzY1RiZHc2OFYrVFA3Vkg3ZEduZkRiOXVYOW1uOXBiUjc2YUQ0ZC9GSHczL3dpL2lXSXlmdXJTMWxkWmcwdVA0NFduVmlQNzJtc1BXdjBxMURTcmk5Z21pZHRzcWtnNFBROVAwTmJTdWxvRVYzUG1uNHdmOEFCUWJ4Qit6OS93QUZiL0JuZ0x4QmZlZDhNL2l0NFlpdHRPaGtaZktzdFhqbW5WZkxPQVEwcFJZblVrN2pkMjVIQ0FWNDMvd1JWL2FFMUx3VjhWZmpYK3pacjE5SmMzWHc1OFFYdXFlSEdkZG9mVDJ1akZPcURvSTk3Mjg2cU85NUllMWVlLzhBQmUzNEwrSmZFM3c0OEYrS05CZzFLNzhWZUNkZVI5T2F3UnBMa3BjRkFUR2lBczBpencyckRBNHdhOFAwNzR5djhNditDam53aC9hUXROVjhPeDJmamJUZE4vNFNQUkxiV3JlVFZpTGl5ZTN1c1dTdVpsalNGRWRaSkZSR1pZMlVudHBUZk5wOHY4Z3FSVU5mbWZzeDQ3aDFLTFNIdUxWdDN5a3VnL2kvbC9uOVB4MThSWE0zd1A4QStDd1BqendQS2sxeDRaL2FTMHFmVDc2eGlWMk54TmZwSUNkZzVNalhhenFDTzEwM3JpdlRQMmt2K0RuZTFhRzRzZmhMOE9XdkFlSXRXOFczQmpqYnRrV2RzKzQ4WklKdUY1SXl2VVYrZkh4bS93Q0NrZnhZL2FDOFgydC80eThTTGY2YmEzUnZVMGUwc2JlejAxcFBMa2lWbnQ0MVZaaXFUU0ptYmV4U1NSZDJIYks5bmFXNG5WdXJJKzZQK0NVSDdXbW4vd0RCS3dmRVR3ajhYcnFUVHRGdU5MdFBFSXN0TjI2dGNhYnFNZHkrblBITEJiczdXOGwxRWx0SVJjK1h0S3hBN1JKR1diKzF6L3djb3A0OXRiclMvaHI4TGJVV0QvS21wZU1wakpJeW4vcHp0WEFSaDZtNGNIdXBIRmZsbERxc2ZocDlUczdlNEY1cDl5VEFDTXA1NmdueTVTUFk0YmFlK080QkZPRnZNSHQwSFBXdEhVc2tsL21aWGE2bjJSK3dEOFhMUDlvZjlxdlJmK0Z3NlBwT29mQy9VTHl4OE1hMVo2UFpSK0g5UHNvN21TN2tza2FEVGhBVENiNHF6bGd3WXNmTUxNNmsvcHQ0UCtGWDdNZWhmdDcvQUJBK0JQeE8rRnZnKzA4RC9FelE5RThRZUFWMUhTNDdlUFRyZ3MxaGVXZGxld01KYlZaNXpGS2dpbFJTNVkvZWNGL3dUOE4zdW9hVTE5Qll0ZU4vYTFxYldXTzJrS05MaVJKbytuM3RzMFVUN2VwS0RHRGcxOU9mSC84QTRLVi9FVDl2TDR4ZUE1dGM4UTIvaGY4QXNPR2JSNU5TdWJhS0hUOURndm9ZNGJ4c0tqU2JGV0V5cUNYazNxVEdvYmF0VGRXMUtqcHFhUDhBd1dyL0FPQ2JGdC93VEovYkZid2ZvdXBYbXErRFBFK2tSZUkvRGM5NndhN2d0WkpwWVh0cDJBQ3ZKRk5CSXU5UU42R05pRkxGUjhjTk5KcDA2c0drajJrTUpFT0NDT1JnK29yN1ovNExrZjhBQlNYVHYrQ212N2Jzbml6d3haM2RuNEg4SmFWSDRhOE50ZVIrWGMzMXZITk5QSmR5cGtoR21tbmNoZUNzYXhCZ0dEVjhnYWRxdDFwUW0renpQRUxxSm9aZ09raU4xVWc5UlVMUUdkVjQvd0RqN3JYeG8wclZHMTd5OVcxRFVQRVZ6NG11ZFhlMVNDNmx2cjJPUDdXRzJmTHNrZUVQdEFIekRkaGNsYTQzelc4dmtuSGJQWTBwUlE2bFJ0eHh0QXh6U0JQbS9VSDFvSkh6engzVnVrY2tOcnRoRzdlSUVEa2Y3VFlCT1BjL3lGZnEvd0RzUWY4QUJxVjhVUDJrZmhQby9qTDRrZVB0TCtFdHY0aHNvcit3MFgreG4xaldJNEhVR00zTVpsZ2p0MlpDckNQekhkUXdWMWpZRkIrVXR1MzJPYU9ZUkpONUxySjViakt5NE9kcDlqMC9HdjdWdmdwOFl0Ti9hRCtEZmhMeC9vNWhiU2ZHdWpXZXVXM2xUQ1pJMXVZVWw4dmVNQmloWW9UZ2NxUmdISW81ZExsS1ZqK2VYL2dvTi93YkRmRkw5alQ0VTZ0NCs4RytMTkorTFhoZnc5YnZlNnZiMjJteTZYckZqYm9OMGx3dHNaSlVtaVJRV2ZaTDVpcUN3UmxERWZtdHFNNzJ0Mys2L2VSM1FTWlNCbkpPZW5YK0lPUFhISHJYOXVGakZHWkVhNDJmWjl3TWdjWlVyM3lPNHhuaXY1TVAyeWYrQ1hmeGQvWjErRStvZkZqWFBobnIzZ3Y0WjNYaXFYVE5JYlZoRmIzaVcxMDgwbHFIc3kzMmlGRlNIYnVtUkZMU3FGeVRVeGZMS3paby9lamZzZklNcXBEZFNSQmh1VThBbm5IQkIvRUVWTkdoeC9PdjIyLzROMGZoQjhEL0FOdmY5a2p4cDhMZml0OE5QQS9qRFd2QWVwcnFPblh0OXA2THFaMHkvd0J4TWFYY2UyNFVSM1VVN2ZLNHg5cGpHQnhuMno5b1QvZzBxK0EveENXZTQrSGZpeng1OE1iNlQvVndOTW11YVhGMXhpS2ZaY2ZuY25nZXRheWpLRDFXaGxIbGwxUDU0Rmp3b3orZUtSa3dEWDZiZnRDLzhHcVg3U253b2tudVBCTjU0RitLdW54bk1jZGpxSTBqVW1YMWFHODJRZyt5enVmU3ZoUDQrL3NqZkZMOWx5OWFINGxmRGZ4djRHMnY1U1Q2eG84MEZyS2YrbWM1WHlwQjdveEJwYzhkditBWDdObm1aVEQvQU96UnQ0eitPTVZMSEdzaUJrWkdWdWhEVWh0aXA2TlZXSXNSbWhldjZVN3lPQjZIOUtOdVBtL0dnV28zT1A4QWR4MHB4a3ovQUhxQ1AvMSt0TktjZnkvbFFHbzVaZWZ4eFZyVE5ZdU5FMVMzMUN5dUxpenZyVnQ4TnpieUdLYUZoMFpYVWhsUHVDRFZRTDErdEl6VVh0cVB5WjlpZnM0LzhGOHYyc2YyWWt0N2JTUGpCcjNpUFNvQ002ZDR0amoxK0YxSDhBa3VRMXhHdnRGS2xmZmY3T1gvQUFlUDZna01XbmZHTDRNMmQ5YnpmdTd2VWZCbXB0RHVVOVQ5Z3ZDNnY5RGNxUDZmaDVKSndmNVZHOXhRNmw5SHFSeUxwb2YwT0g0OS93REJKLzhBNEtlbmQ0bjBQd1A4UHZGR29aa1o5VzAyWHdQZnBJdysrOTVhTWxuSy93RDEwbWtCSTVCcm1maWovd0FHZy93citMdWpRK0lmZ2g4ZU5lMDdRNzM5NUFkVHRMWHhQcDg2bi9ubGQycjIvd0FvN1pFaDlUM3I4Q1Z1aURYWWZCbjlvTHh4K3p4NGsvdGZ3QjR5OFYrQjlVT04xMTRmMWFmVFpYeDJab1hVc1BZNUh0VTh0UHBwNmY1RmMwK3J2Ni81bjlTR2wvOEFCTmpXUDJML0FQZ2kvd0RFSDRFL0NiVUp2Rm5qalVmQ2Vyd3BxYzBTYWZKcmVwWFZvWUdLSnVLd255VmpoakRPY2VYR1hjc1djL3kvL0VqNGZhMThDTmVrOEsrTlBEZmlYd1hybGdURzlscitseTZkY2dBbkJNVWd5UDFIdWV0ZmNYN09QL0IwcisxYjhFbGh0OWYxendwOFZOT2p3dmxlS3RHVmJrS01aeGMyWmdrTEVmeFMrWnlTU0QwcjdpK0hQL0IyQjhDZjJrZkNhK0dQMmd2Z2JxMW5wbHpoWm80NGJQeGRvejU0WjNndVZoa1FkZUZqbE9PNXJTS2xHWE5CcCtvS2F0eXlUOVYvbC93eCtCdHpaUjNhTjViUnlKd2VEbXErcFBjWGp4dGNUVFR0SEVzS0dTUXVVUlJoVUdjNFZRQUFPZ0F3Sy9vVEg3QkgvQksvL2dwNWVidmg3NHI4T2VBL0ZHcFNmTEI0WjhReWVGOVJkdjdpYVpxU0dMMnhEYjQ5RDByeGo5b2ovZ3pTOFo2VmNQTjhLUGpYNGQxaTNsYmRIWWVOTktuMDJTTlArdm0xRndKRDcrU2crbFJKdGZGRm9wY3N2aGYrWlovNE0zdjJjZnRQamo0cWZGSzhoOHBkUDB5RFFyT2FRZkpJYnFkbVlnOUEwUXNaQWUrMjdIWTErWm43YTM3UXJmdFhmdGpmR1g0cGZhSkxpejhhK0xMMmJUWkR5eTZmRzVqczAraTI2eEwvQU1BRmYwTmZzMGY4RTkvRi93RHdTNi80SXEvRXI0ZitHcnEzOFlmRjIrOE1hNXF6emFIREo1TnhyRXVtbUMzaXRBNnJLNFFRdzdTeXEwa3BkdHFlWnRYK1lPMW50OUhzRjBhZHZzdDlwc2pRVHd6cTBNaVNCaUdCVndDcEJIUWdFWTVBUEZhMG1uVjlFU290UXYzZjVmOEFEa0QzRFdsMnMwTTAwTTBMaVNPU055anhPcHlHVWpsU0NBUVJ5RFcxOFp2akJySHgzOFlmOEpGNGdUVFpOZW10bzROUTFDMnRGdDV0WmxVdG04dXR2eXlYYmdnU1RBQnBTZ2VUZEswa2o2UGdqd3A0UjFQd3I0d3Z2RTNpUy8wblVkTjAxWDhPNlpaYWMxekpydDlKS3FoWGw0aXQ3ZUpOOGtqc1M3WVJJMFlzekp3bHlOZzUvd0RyMXBWdnN3anZjK24vQVBnaS93RHM0ajlxci9ncGQ4TFBDYzF1dHpwemFzbDdxRVRMOGt0cENmTnVrUG9UYkxPUjdyWDNuL3dkdC9IcHZpYiszQjhNL2hsRE9KdE4rSHZoVzQ4UjM4YXVkcTN1b3pGRlJsL3ZMRGEyN2crazV4akpxUDhBNE03djJkLytFci9hTCtJM3hIbnQxbGg4SzZPbW4ycGNjeDNWMi9sd3lvZlh5WTlSalA4QXZWOFYvd0RCU2Y0K3IrMUgvd0FGSVAyZ1BpQkRjUjNWaHFYaXFiUnRLbVE1V2F5c0F0bmJ1dnM4VUViZlZqVVU0ODFTTWZuL0FGK0FvdlNVL1JmMStKOHhhanBQMnpVNFlZbFg3UkpLRWpMeUxIODViQXl6RUt2SkhKSUFIVTRCTmZSbnd3LzRLaGZ0YmY4QUJQbnhmZStGTkwrS2Z4RThNWG5odWRySzY4TzY5SU5TdGJGbDZ4L1pMMVpZby9VRkZHUVF5bkJCcndmVGRlZzhPK0tyUFVMblM5TjE2R3ptRXI2ZnFmbmZaYjBEK0NYeUpZcFNoNDRTUlNjQVp4d2JmN1FYN1EzaUg5b1hVdER1TmVpME8zaDhNNlhIb2VrMjJsNlpGWlJXVmxHenRIQUNvOHlWVUxzRk16eU1xNFFFS29VYlZMclppNVZMZEg2eS9zVy84SGZ2eEd0L2lCb09oL0did0Q0UTFyUmIrN2hzN3JYZkRabjB2VUxSSFlLWjJnWnBZcG1HYzdFRUlQcXZXdjFkL2JuL0FHS2YyUmZpMThPNy93QVpmSHp3VDhIN2ZRNWxqTjE0cjFueWRDdUQ1bVBMQjFHTjRaOXo1RzFmTnlTY0FacitYRC9nbU4renFmMnMvd0J2bjRZZUFwSTNtczlkMXkyaHYxUVprVzBNaXJPNis4Y2JQSjdDTW50WDZtZjhIaFA3UWtuaS93Q09ud1YrRFZqY09sbm9lbTN2amZWYlZXL2RQSk5JYlN6M0RwdWpXM3U4YzlMZytvenpWSXhseXEycllVK1pUbHl1eVNQVFBFUC9BQWF5L3N0L3RiYUxjZUpQMmMvanJybWlXY3JnNTBuVnJQeGxvMXNEa2hBcXVrdy83YVhER3Z1RDlqRC9BSUpqemY4QUJPWC9BSUo1K01QaFg4Ty9GVTNpSHgxcnRqcVYwbmlUVXJaYkZaOVdtcy9zOXM2eElYRUVFUmpod201eUQ1amtsbk5meXErSFBFT3RmRFh4SERybWc2MXFXaDZ0WWpNRi9aWEwyMXhiOThySXBESjY1Qkg4cSsvdkJuL0JhYjl1Yi9nbjdxZWs2WDQ0MXZXOVN0YnEzTjFhYWI4UXRNL3REN1pHckZIM1hMRVhlNUhHeDR4Y0s4YkRES3B5SzFsaFhibFV0KzVTcVR1cE5KMjE3ZjE5NThrZVBmZ3Q0Mi9ZY01IaFA0dWZEN3h2OE83MjJsZUJKOVgwbVNPMHZYVW5MUVRqTVV5L2V3OGJNcEJ5R3h6VkxSZFh0TlJra3VkQjFuOTVORkxDNzJkeVk1VEZMRzBVc1oya050ZU4yUmw2TXJsU0NDUWYyUi9aVS80T3p2RHZ4YTFmVGZCL3hyK0ZOdnBXbjY3S21uM3VxNk5lZmJOUHhLUWhhV3d1Rko4a1p5MzcrUWhmNFdJd2ZzZjlwdjhBNElLL3NjL3RMNk5jYTFySHdyOE0rRVo1SURjalgvQ1Z3ZkR2a0t3M2VmaUFyYk5uSU82V0pnYzVyWDZ4V3BKS2NVMTVhZjVtZkxTbEt5YlQ4OWY2L0UvR2Z3UjRnaytIbjdQWGgzU1h0NW11dEp1TG1DRVNEREJSS1c1SzhaQlpoa1l6dDdkS3IrUC9BTnJMeDE0TFRUWjlEOFJlSXROczNqdy9rVENUeVN1Q0cyT3JJeTRKQlVxZW5HRHpXZjRWOFplSGZIL2gyNDhPMk92SytxYWsvbjJObkt3bWtBalV0SUZjRWtFZ0E3VzVKUTk2UEJ2d3YxVDRzYTVaK0ZiU3lrazFLNXVGaXQvTEo4eUpqMWZQT0F1Y25QR0FlM0ZmeUZYNUlWM1Z4c1U5VzJwTFN6dnJaOUU3bkJHVXRvdlY5dTU5Ty9zRy90Q2VOUDJvWS9FR2wrSmJlSFdyTFNZbzU3VFhyYXhTMFJtYmhvSlkxSnhKM0dNQWl2cC80VlIvMkxldERKdVhncGdIclhNL0Rqd0RwbjdNdnc0MG53bm82d3kzRm1BMTVOREVGYS91bXh2a0lIY25nZWdycVlIdDladHBML1Q1N2Q3aXpsRU43REMrODJzdkRGRGpvY0VjVitKWTdHWVdwbWRYRTRla28wWmFKTFoyc3VhM1MvYlRmYmM5K243MGVTOTVSM2Y5ZGpwL2loRC9BR3Q0SXVGakg3eXorWmNqNWl2Y2YxL0N2bi94Zzl4cEh3bjhYWFZ1cCswUjZSY3lyanFDQW9CL1UxOUtlRW5qMWp5dk54SkhPdXh3dzQ1R1A4L1N2S2ZpNzhPbzVmQnZqYnd4cDgwY09wM0dqWDFyRXhVNWdhU00rVVQ2cm5CNDVHTzljbVM0Wnp6ZU5PWHd4ZC9KUnMybjk1T0lqZWk1ZVZqNTMrQm5ndzZ0NEEwSzRHNW1sc284dXc1SXdEbnA2bWo0b2Z0R2VCL2cxcU5yb3IzeDFmeFBxdDU5anM5TzA5UmMzc2x3RkIyRkZKOHZDNEphUXFxamtzbzVyei85cTc0OVMvc1Mvc0VhSGRRUzQ4UTNtbjJtaWFkUGpHMmN3Z1BOamsvSkhHN0FIK0lLRDFOZlBmOEF3U2c4RzJ2aUQ0WmVKL0dGell6ZmJialdaYlBUcis2ZmZOUEk4Q2ZhcE54NURZY0x1R2NpVnhuclg3emdjbldJd2RYTnNVMzdHRXVTQ1duTzlyM2V5djJWOTlySHk4TUpHWFBPYjkyUDRzOUsvYUMrTVBqTHhSNGF2SlAzbmgyelhDNEUyK1dRbitFYmZseDB5TXNPdUsrS2YyaC9ETXVoYVBZS2x4YnphOTRqRWsxemQzOXlJM2h0UndFVXNlTjdidUIyalBITmZjSDdVTmcwMzluK0g0VkN0Y1NLWGpVNDZrZFB6RmZCL3dDMHJxMXg4VHYyamI3UXRMVmJlNTBPVTZGYnlUN0JHYmUzeUhZUHlSdW0rME5ucmhrSFkxOTV3TEdFcXQ2U1VZeFYzK1N2MTN1OStoMlpmaCthVjRxeHdPZ1hMNkRPMHNkdkhjVzFxWWxlUExKSE8yVjI3Mnhsb3dEbjVzS2Njam5GZWdYbmhkL0Izd1kxUzF1ZjdRdDU5SzFFd1hGcGZ6cExIREx2a2p4RnhqYTZLR0RBQUVxUU1nYmpyZkJ2NEo2V3ZnL1c5UzhTWDJseVdkdkkwdHRGQk5zZjkwQVpSSk5ncUFxc2c4c0RjUzdFbFFPYzM0MWVPWTlTOFRYUGhHMHM3alZoTEJHOHJSVGxUTXNVVFNMNVE2Zk1HbGNBakpWa0FHUUsrK3JZajI5ZFVxU3ZaM2I4bGJ2cDFmNEgxbE9pcVZQbWsvSmVwNUJQNG8wK3pCdDEwK3gzY0Zwb1lRL3pZR2Z2WTZFRDJ5V3h3YXBhbnFGdmYzMFZ4WnF6WEdBMDMyaEFQTllIdjh4SFA0ZlNwSk5IdGRWOEdYbXBSdXNONXA5eEZDYlpTUDNrVDdqNW5UTEVFWUpIVDVlT3BIc0g3Rkg3RGV1ZnRQZUtJTlF1VmZUUENkck1vdUx0enRhNXlmOEFWeGpxYzlNZ2ZTdmZsT2xTaTV5ZHJmbWViNzBta1UvMlIvMk90Yy9hOCtKY05wWXd5MmZodTBsemVYMHdQbHhJR0h5YngxUElISFB0bml2NkdQMkdmZ3ZwdjdQL0FNRC9BQXI0ZjAyM2pzN0szV1crQ2NBNEJHU2NkeUl3ZmI2MTQvOEFzdC9zdTZSOEd2Q1ZqWTZkcHNPbTJzUXhCYWlNQ1YyT2NGeG5CZkJ5U1RnWkl3RGxqOWhXbmh5UFRMQ1ZKQW9hMXRJN0xIWU0yRllqcC90KzJCMHI0RGpTdTUwS2NaZFpYdDVKWGZ6T0hNcktLaDNmNUZEd1pwWG02dnEyb0NSV2tqMDhvQ1c3eUtWNDc3dHhITmN0Y1dGdmFlSkk0ck5ZN05Zc0I1ZWlrRHUzOTcwOWMrbGQvRkYvWWZ3M3ZybU9ObzU5VXVvNEltWWNJTW1SamoyMmpnZHpqalBIbTNpSnJmUi9NdUxxUlJhd3A1MDdjWkNnamFQY2sveXJteWZKY1BpOHBVTVJCUG5iYTdyWFJwN3A5bWpiTDRya2JmYzhULzRLSS9HZTU4Qy9DOCtGZkNiTi93QUpWOFFybGREMHFLTVpsUnBnUkpJQndmM2NJa2srcUtQNGhYMjEreDUrejNhL3MyL3MrZUdmQ05yR3F0cE5taTNCSE82WWdHVG51QWZsQlBPMUZyNHAvd0NDZC93MG4vYlovYTAxTDQzNnRieU40UjhITSttZUVJNU03Ymh6aG51VjltK1J4L3NwYm5rTXdyOU1MS3o4dUpWNHdQd3I3N0QwZlpVNDA3M3QzMytaMXllbnFOdDRjRFBOVzRiZmlud1d1MFZZamo1OTY2NG95WWtjZlA2MUxGRmw2ZWtRYnJUMVhCL1dxTVFCK2IvUEZTb050TTJZWG4rVkNQOEFMajhLQUxVVFlGU28yVDZjMVhWK01pbnh2L1BuTlZFMExTdGovUFdwTTdUVmRINHA0a3dNOXFvQ3dINSs5bjhhWGZuMS9Hb2QrZS82VUY5dmNmbFZhQSt4SXorOVJUVFlKL3hwanpERlViKy9WVk9EUnpBVTlidk5xSG5wejFyejN4UHF1Ymh1Ulc1NHM4U0xiUnY4My8xNjhWK0lYeGUwdnc3ckdtMmVvYWhEWjNXdVhKczdDT1FuTjFNRWFUWXB4amR0UmlNOWNZR1R4WExXbHBZMW94MXV6c2RCdWZ0L2lLUCtKYmRHbGIrUS9VZy9oVzdkYWdwUEJIOUs4RytHbjdUT2s2cDhiZkYvZ05rdUxiWHREMDJ5MWdHVWpaZldjN1N4bVNMdmlPVk5qZjdUSjYxMXVyZVBmSldSOXpMSHp5S3FqN3NFMzFDZDNLeDBsNThTTktrbTFxM3RiMjMxSFVOQUFXL3NiU2RKYnEya2FMelk0M1FIS3U2RUZBMk53SUk0TmNGOEgvMm10Qi9hSitEL0FJZjhiZUdacHBORzhSMnB1WUZtQVNhQXE3UnlSU0twWUxKSElqb3dERUJrT0NSeWZqNzQzL0g2VDltZi9ncHo0VDF2N1RKRDRkK04yZ3Q0YjFESCtyaTFyVDJXV3h1RzVCM3lRU05iZ2QvZkZjcC93VEQrSkMvRGo5cEQ0Ni9BZVpoSFk2RnJqK05QQzBZNFZkTjFFbzhzS0Qvbm5ETTBRNDZ0TzlkaXM0M1JGclBVL1FOL2pQY2FBenFaRWFJY3RITDh5c09meS9Ddkd2Z3Qvd0FGRVBCUHh0OFRmRXJ3MzRxMFM0OEsrSnZoanJUYWZmeDI3bStTN3RKSS9PdEwrTUtva1ZaNGd6Qk5yRlNwR1c0SjdEeFhvOXZmYVo4N2JTQmpKK1hIZXZ6MStPZmdxNC9aMS80S2RhRjRvdnI2MDBYUWZpWDRZdXRQMVNXOW5FYXJOWUFUUTNUS015RlJFUEw4d0tWQVZobk5mRzU5d0hrK2VYamphQ2NuZjNvNk8vbTF2OHh2bFZuYy9SZjRjK0wvQUEzOGN2QWtQaWI0ZWVLTkM4ZGVGN29zSWJ2U2J0YmhOd3h1VWdmTWpya0Fxd0RMMEk3VjVyKzBuOEZmK0ZvL0RyeEJvWldTYXgxeXd1TEM5dENmM2pSeXh0RzRVWStZbFdZZXRmbWorekIvd1VFOEUvOEFCTEs5K0x1bStIOVdiNGtlRE5hOFJSNnQ0ZmZRdHNjVmhlVFJuejREODJHalNOTGRkKytNc0kxd29iS3J1ZkQ3L2c2QjFYVXZpTjVmai80WDJGOTRMbitVeTZWZGxkYnNzbjc2cytJcFZ4L3l6ZkRmOU5UMHI4N2o0ZmNVOEtKMXVGOFg5WW9idkQxdng1SnI0WDJXaWZXNG9WbHMwZlBDZkM2NXMvMkJQR0h3YitMbmlEUy9obnJIdzI4WHczR2hUZUprdW9kOFU2dkwrN3Q0WXBibVZIU1M1a1V4eE1DTGxXSkE1cjNsditEaXJVdmd0K3p0NEg4TWFmNEYvd0NFbzhmMlBodXloMVRXdFgxSUpwOGs2eEt2bUNLSE10d1dVWmNtU0hFaGZHNWRySDNENGgvR245aEgvZ3F6cGNtbjYvNHkwM3d6NGdkeEpGZDY0RzhNYXJHeXF5STMybHMyMCtGZGdFa2QvdmZkQnJqL0FBZi9BTUd4WGhyVmZpcnBsL3JIeFQxcnhSOEtiaUkyeVQ2TzFwYWFwcDR3UEtmN1FVdUxlNGlVOE1Bc1RZZmNDZHV4dnVzaDhSY1BpR3NMbW1HcTRTdTdMbHFSYmkzdDdzMG5GcnRld3BSNW43ci9BRVorZC83U2YvQldUNDlmdE5HOGgxdng3cU9rYVJlQm81Tko4Ty84U216a2lZWU1VbmtrU3pwZzlKNUpLOEwxSDRnVDNtcTZkcWlUeng2cFkycVdqdVFDSmtqUVJJTWpCMitTZkx4MlZGWHAwL1JiL2dzSi93QUc2WGliL2duZDhQTGo0bGVCZkVWNThRUGhiYVNvbXFmYTdaWU5YOE5lWTRSSG5DZnU1NEM3SW5uSUVLczZobzFCREg4eno0ZnVydVZGdC9Ma1oyRVlVdXFzQ1RqK0xISFBYb08rSy9SUGFObWZMWWN0NS9hRjdMSUk0NC9NWXlGRTRWY25vUFlad0t1YWI0V3Z2Rk9xVzlqcGRuZWFocUZ5Y1EyMXJBODAwcDlGUlFXYjZBVlYwblNwclpwRmVNTk80Q3hJSEJ5YyszSFArZTJmN0FmK0NaWC9BQVRXOERmOEV3L2dCcGZoWHd2cGRpZkdFMW5EL3dBSlo0bjhoZjdRMTYrMmd6RXkvZlczV1RjSW9BZHFJQWNNNWQzbDNHcmRUK1FEeE40TTF6d1JxemFYckdqNmpwZW9GZDV0N3kwZUdiYWVoMnNBUjM3Y0VIdUttanRtZ2lqVi9MOHhSaGpIamFmeEhCNmpuMUZmMVUvOEhBMzdGbmhQOXJuL0FJSnYvRVh4QnJPbjJmOEF3bVh3dDBPNjhWZUg5Y01mK21XZjJSRFBjVzNtZmVhR2VGSkVNWkpYZVkzeHVqVWorV0ZMQmlkdTNjNVArZUttTitvTkxkRlpJajlOdkhvYzFOY1hNOXl6TkpKSkswaDNzek1TUzNxVDMrdnZUL0ozQTcxYmQ2SGpGTDVQeTUrWDVldU9menFnc3lBS0Npakh2bjFwNWh4R0dPVzZZSHAvbi9QdGN0ZE9rdmJ5R0ZZMmt1cnFRUndRcUMwazdrZ0JWVWNzeEpBeGpKTmZhbjdKdi9CdmgrMVArMWRIYTN0cjhPNVBBbWdUa0ZkVzhiek5vY1cwak85YmRrYThkVHhncGJsVDYraHNOUmJSOFJ3MkxNY3NyTGpucFdsb0hoVzQxL1ZMZlQ3TzF1THpVTDJSWXJlM3QwTXMwNzlBcUlvTE14ejBVRTErL3dCK3lsL3dhTi9ESHdPbHJmZkdQNGdlSXZpRGZSN1drMHJRVS9zVFM4anFqeWt2Y3lyL0FMU05ibm5wbXYwbi9acC9ZbitFZjdIR2xmWmZoZDhPdkNmZ2pjbmx5WFduV1ErMzNLOU1UWGI3cmlYL0FMYVNOUVAzVWZ6Zy9zcGY4RzVYN1VIN1RJdGJ5VHdPUGh2b2R3b0oxUHh0TTJsTXFrODdiUGExNGM4RVpnQ24rOE90ZnVuL0FNRWxmK0NaZmlYL0FJSm4vQnU0OElhdDhZdGIrSVdrM0VqWE52b3AwdU96MG5RNXBHM3ltMDN0TGNBT3hZc1BNU05tWm44bFhabVAxMEJ5YzA2alVseTB0WWFxaEV4MkhTdkVmK0NrZjdLcS90dC9zSGZGWDRYckRITnFYaWpRSmpvNGZnTHFrR0xteE9jSEgra3d3Z2tjN1N3NzE3aG1oWkdpa1ZsTzFsT1FmUTBOWFZoUmRuYy9sVC80SUIvdFVKK3pGL3dVeDhETHFGMU5wK2grUEMzZzNWZzdtTXA5c1pCYjd1dzh1OGp0bUpQUlEzQTV4L1VBdW4zZHErRnVFa0FPUWs4ZklQMUhmOEsvbG4vNExxL3N5VGZzVWY4QUJWdjRtYVRwYXphVm8vaVMrWHhqb0VrQjhyYmI2Z1RjSHk4ZEZodXZ0RUl4MCt6aXY2U1ArQ2YzN1ZNUDdiWDdGM3czK0tVYlJmYS9GK2l4WEdwSkdNSkJxRVphQzlqQTdLdHpGTmovQUdkcDZHdWhWSEttbjIvci9NaHhVWnRkL3dDdnlQV0UxRzV0aC9wRm14OVdqTzhIOEJ6K2xTL2JMSFdMR2V6bDhxUzN1RktUVzh5aGxsVThGWFE4RUhwZ2lySzhZUEh0bWlXQ081R0pJMWtBNmJobkg1MUYwOTBISzczVFBsZjlvbi9naDcreXIrMUdaTGpYL2czNFYwblU1ZHhPbytGMGJ3L2RibXlTN2ZaREhISTJUMWxSOG5ybXZnLzlvWC9nejQ4UDZndHhjL0NUNHk2MW83NFBrNlg0djB5UFVJbWJzUHRkdDVUb0I3d1NIcDlhL1pVYVJISC9BS21TYUVrOW4zRDhqbjlNVktvdkxZRDVvWjF4My9kbitvcVBaeCt6cC9YM0dudEpkZGY2KzgvbHkvYU4vd0NEY3o5clA5blZKNTErSE1meEUwdTNHZnR2Z3EvWFZHZjZXakNPN0ora0JyNHU4YitCTlkrR1BpZWJRL0UyamF2NFoxcTFiYk5wK3IyTXRqZHhIMGFLVlZjZmlPMWYyeExxYXAvcm9aWS9kbDNMK1lPS3hmaWI4SlBCZngvOE1Oby9qVHd2NFk4YWFQSU1HeTF6VElOU3Qvd1NaV1VIM0FvOTliYS8xL1hRUGFRZTZ0L1g5ZFQrS1g3R1QwL0U1elViV3JENWR2ek4ycitvRDlvci9nMk4vWlIrT3ZuWE9qK0Y5ZStHR3FURm4rMCtFOVdlR0VzZlcxdVJOYnFvL3V4SkgxUHRYd2IrMFA4QThHZ0h4SThMTlBkZkNyNHNlRXZHTnV1NWwwL3hMWnphTGVGZXlMTEQ5b2lrYnRsaEV2UGFqbjdwL21WYUwyYS9JL0c5b1QrUTdDbVBIMS9MTmZVSDdSdi9BQVNBL2FZL1pZV2FieHA4RnZHa1dtMm9MUHFlajJvMXZUMVVmeE5QWnRLa1k3L3ZOcDZjQTE4ME9zVTdzcVNLektjTXZkRDZHbkZ4ZXdTZzF1WnR3bU05YXF5SG4vR3RTZXpZQ3FzMW13YXA1V1psWEhOSFNubTNJTko5bmJQOFg1VWdId3liV3E3SGNaSDN2ZnJWS09JN2hVOGFzdFZFQzV2UzRpMlNLckw2TU0xOVMvOEFCTmYvQUlLR2ZIWDlsdjQrK0RkTytHL2pyeGRMWXphZ2x2RjRRbTFPZTQwVFdIY2JWdG5zM1pvc3lNVWpESW9rVXNOcktjR3ZsQW5ZTy9wWDNSL3dia2ZzK0g5b1gvZ3E1OE9WbWdhZlMvQ055M2ltL0gvUE5MQkRkUU4vNEhSV0tIMmxyYUVyTW1vazRuNysvd0RCWG4vZ3I1NEgvd0NDUjNnZnczZWExNGQxYnhwNG04YVh0eGI2SG9WamRKYUNXSzI4czNFODF3NnVJbzBFMFNqQ016dElBQmdPeS9HQi93Q0M0LzhBd1QzL0FPQ2pVQzJueDkrRmNmaDNXTGlJUlBmK0t2Q2NlcWVWbmpiRHFkZ0h1NDE2Zk1WaUE3NEFyNFQvQU9EcVg5b3MvR1AvQUlLczNYaGUzbmFUVC9oVDRic05DMmhnWXpkWEFOL080LzJzWE1VYmU4R08xZm5DMG5DbXM2Y1l5ajd5dVZLOEhhTGFQNkFOUy80TncvMktQMjhkS3V0Vi9adCtORjFvTjE1WWNXL2h2eExiZUs5UHNTY0VlZFp5djlyUS93Q3pKY0lSNlY4bGZ0R2Y4R2tuN1N2d3p1cmlUd0Q0ZytIdnhXMDFXeENpWHAwTFZHR2VyeFhXSUY0STRXNGJ2MTcvQUpjYWZxbHhvdXFXK29XZHhjV2Q5YU1IaHVZSkdpbWdZZENqcVFWSTdFRVlyNjYvWncvNEw2L3RiZnN3K1JiNlI4WXRlOFRhVkF5NTAzeGVxZUlJSkZYZ0lKTG9OY1JyejBpbFRvUFNqMmY4cmFIelNXNlQvRCt2bWZ1Ri93QUV5ZjJJdmlEL0FNRWdmK0NPM3hJTjlwOXBxSHhqYlJ0WjhWcnBla045dWEzdW9iR1JyS3hXUkFmUGNTcTBoMkFxSHVXUlM0VU0zODBQZ3JYTFdQd3JiV2NjOGNreWhqSW9rQVptSk9UejlhL2Evd0RZdS80UEJibnhUNDUwTHcvOGJQaFhwT20yZW9YSzI5ejRtOEozOHNjZGdEL3kxYXd1UE1abEhWdGx4dUF6dFJqaFQraVA3YjMvQUFTUi9ZOStOMmhheDR0K0wzdzErSFBoOUlTWnRSOFdRM1k4THZISkl3VVRUM2NNa0tTT3pNQUduM2htSUhPY1ZVWlRweTlwdmZUN2hSY0hIa2VuWDcvNjh6K1ZYUk5EMGZXRHJYOXRhOS9ZSnM5TG51OVBDYWRKZWYycGVvVkVWbDhoQWhFbTV5Wm55cUJNRUhJRmNYZmNIdjFJd2V0ZnZGOFh2K0RRVDRlZkZIdzJ2aVA5bi80L2F4YTZYZHh2TmFSNjVEYitJdE11aWVnUzl0REZzUWRNK1hLZnFhK0ZmMmkvK0RaZjlzVDREU3l6V2ZnWFF2aWhwc1M3MnZmQm1zcGN0OUJiWEFodVdQUDhNUjZkZTVxZUlpOTAwQ2cydmRhZjlkajJiL2cwSS9aei93Q0ZnL3R4K0p2aUZjVzVrdGZoL29jN1c4b0dmSnZMaGZzcUtmYVNDNHVpUFV3SDByd2YvZ3NUOGMvK0dtditDdUh4ODhUeHlOTHB2aDdXRjhHNmRsc3FJOU1qVzBrS0hwdGVhR1NRZHYzbWEvWEwvZ2hMK3g3NDEvNEpNLzhBQkxyNG5lUFBpTjRUbjBYeDdmV3Q3NG1iUS9NV2E5V3gwNnpubnRZWmxUSVdkNXBMdHRnTE1xU1FxMkhES1A1Ny9BR3N6K0l2RDczOTVkRzgxUFZicWE4dnAyYmM4azhybDJkdmRzNS96emVIdEtzcmZaWDUvd0JNblZVMjMxZjVmMGgxMVpHYU9RcW8rNmNkczhkL2JwWFkvdEIvR21iNHM2aHBXbldjTnBwL2cvd25BYkR3N3B0cnBWdnBhUXdoVVdTNG1paFpoSmVYQmlTUzRua2tsa2tmR1pDaVJxdXY4R1BDL2hHODF5KzFueHhkUnI0WjhPd0xlUzZSQmQrVHFQaVdVdHRpc0xaaGt4aVJzdE5jQVl0NEVrWWJwakJETHdmakRWanIzaUMrMUZyT3hzV3ZicVM1TnJZUkdHMXRoSTVZeHdvUzJ5TmM3RlVra0tBTW12UmtqTmJYT3IvWXIrQ0YxKzBiKzExOFBQQXRyNW5tK0k5ZXRMQXNnT0lOOHlJSkc5RlZtVmo3QTErdVAvQjJ2KzBKTGFKOEZQZ0ZvMXg5bjBPLyswK0x0ZDA2SS9MTmEydTIyMDZOMS9paTh6N1VkaHlDMFVad1NveDh5ZjhBQnJKOEFqOFRQK0NrVW5pcTVoUnJQNGZhSmQ2a2hLSGE4cmhiZFZIYmNyM01VZ3gvZHJpUCtDNFh4Mlg5b24vZ3NKOFlMNkc1RnhwZmdGTEx3SnAvUStWOWtqRDNpRDZYclhQNEgzSXJocUxtcXdndlUwcC9hbSttaTlYL0FNQy8zSHgxNEsrSjl2OEFFVDRndzZENEQwUFdCNGt2cFZpMGU3a21QbVBJY2JtZU9MbU1CUE1KWVBoVlhKd01pdjJyL1kyK0I5MSt5aDhDckc4OFlhcGErSXZpTnFWaW92TlQ4cEUreHdzTndpVTRCSUFPQ3pIYytNdGpPQjVwK3hQK3dkNEIrQUVEZU5iZnc5WWFUYndRQlV2YmhEOW92MVVBN3lYTEdPRVlCMmcvT1FDeFBHTTc5ckg5cDdSYnJSNWRXOFVhOUQ0ZjhFcklZNDFsa0tYR3Z1T1NpS01zWXgzQ2pMZlRwL0VQRjNFajRweDBNb3lDazFSaS9lazlaTjlsdTB2N3FhdTk3YktmM1dIcDNpdFgvWDlkUzc4Y3YybVpMOTcySHd0cVMyTnVwWkwvQU1RbGQvbDhjeFdZUDNueDFmQkM5czhHdk92MkxQMng3YjRYL0d4ZkIwTmplM0dsZUxKUmF3d2x2T21tdTJkYzNFckhuSlRjU2NuakhYdDh3ZkcvL2dwVDRQTnQ1UGgzdzNxR3JXOEtxcVRYZHhIWXdyMUFFYUFPemRUMUM0NXFqL3dUcC9ha2s4Yy84RkNQaC9IZmVIZExoc2J1OWFDTVc5eDVra2NoZ2ZZZDVJWHQwMmcxOVRMdzdxNFRJOFM1WWZSVTVTMWFUYmpGdGJhNk5kdlN4amw4cTFYRVJhMGplM3lQMjUweUNid3RyWlQ1dkpac3huSFN1bThYZUZJTldhUFd0djd4bzFodU1meEtNNEo5ZXBGY3hEcmtLNmpkV2Q3TXF4cytJWkhiYUVmUFQ4YTYvd0FPU3ZMSEpwOXkzN3VVYk9laDlEWDg1WkZpSHlyR3ErcXMxMDEzWHkwYVBmeE5GYXg2SDQ3L0FQQndUOFBkUWgxcjRUK0c3S082dUhrL3RLV0MxajJoSldCdDBITEVjaFIwd2VDZW1hK2tmMlRmMmZ2K0ZIZkFEd2Y0Wm5nYTN1dkRla0ovYUVMT3JNbDVLVFBPck12Qklsa1pjakl3dkJPT2ZvNzl1RDlpM1JmMmlwdkFPdTZ1dittZkRUWG85ZWg4c0F0TXNRekpDZjhBWmZiRVQvdVo3VnhQampWSTlHOEMzbDB4Qmt1aTdzekRrOTgrL2I2WkZmdGo0c2hpc2x3bVZVZE9SeWN2OFRrN2ZnMzk1ODVqS2FwMHZaTGU3ZjhBbCtaNEZjK0dyZnhsOGZMVzRrUkd0N2ViZklUNkwxWSt3d2Z5cjhvOWU4Ukw0WCtMdmk3VjllMG1XeE41cWQ5YlIyRUpYN1JhTzgrOHA4aENEYUR0ejNCSlhzYS9UWDR2Zkd2UmYyZFBnVjRrOFphNDE4ZjdVQTBTekZtNnJjdFBjaDEzUk80S3E4Y1ltbHlSajkxN2l2ejU4UDhBanp3UDRBOFNYM2lEUjlaaDFqVGJlQzVGbHBXbzZja2Q1SlBJcklqeVNNckNUR1ErN2NXeUFEeml2MXpnR2pLR0hxMUZCdU1yUlZrOWJYdXI5TjF2cHZydWVoZ0tjWXBPOXJmMXNPZzE3VC9HdmdqK3dkQWgxR0dPNnkwOXNiS05ZcmN1cjdubG04eG0zaFFDb1l0amIvQ0ZJSG5majZXSi9pSFphaG85NWM2MXFFWWpNYlJNSkhubWpPMEVoTThuYU9QN3VCOVBTL2hmOEUvaVArMVZxTjFkVytsRFNkQmtuYVYybUhrVzBLdStja1lCa0lPUHZIazg5OFY5emZzY2Y4RTM5RCtGOEthcEhiMjgycE5nU2F0Zlc1NUIvd0NlRU1oRGxUanEyMUNPZm00cjlEb3c5bEp0Yjl0OTk3czlLcFVkUkw4LytBZk4zN0VmL0JMVFd2R21vd2E1NHNpdjdXeHYrWTlHVmNOY3FWeWZPendFQkpQUEF4MUo0cjlSL2duOEN0SCtET20ydTZHMCswV2NBU09LRk5rRnBGbm91ZTR4Z3VldUNCWFcrRmZDVnY0UDhQbzhra3RyYW5DdE5jWWE1dVRuam5qcnhqQTZuaFFLMHg0U3Q5ZHVwbzlhbW10TEczbUVnMCsybFI3eVpzY3lYVEVueWdCamlUQjdIYmdCcjVXNWUwcXU3L0JFeGpweXhPaytIWGlLejhTL0V2U2RIMDAvYkpwbSswWGNpWkNRVzhZM3NmOEFaQjI3UnUrWWxoanVSN1ZxdTZIUXZMWG1TOHV0K2ZaQVFQOEF4NlFuL2dOY2o4SGRKMGx2N1h2ZEswdTJzWTdPd1Myamtpang1dTZUSXkzUnpoV3czSnczcFhZU2FkSnJuaSt5c3gvcTdkVmp3Rkgzc2t0K3JIOHEvTStMc1pLcGpWUlgyWXBMMWwvd0R3OGNyMWxIc3Z6S3Z4UXZvOUY4TmFQWXQ4dmxRUGRGYzRaM2ZDcm5yMlhQL0F2Y0N2aTM5b0RVdkVIN1hueGNzL2dYNER1Ri93Qk1rVi9HT3BJRzJhZGFrYjJ0OXdQRE1wRy9CeUZjS01OSkdhOUkvYk4vYUYxenhKOFpwdmhuOExvMjFuNGdhdzR0SWpBZ2tpOFBXNFhZTGlVZmRNaktwYU5HSUdBenRoRVpoOU4vc0dmc0xhUCt4cjhNUHNZay90YnhWcS8razYzcTByR1NhOG1ZbG1HOXZtSzdpeExIQmRtTEVENVZYOUl5M0NleG93cEw3S1MrN3FlbFJpbzAwdW45YWY1bm9Qd00rQzJqZkFyNFo2VDRYMEcxVzEwdlNJUkRFdUFHZnFXZHNEN3pNU3g3WlBHQUFLN3EydHRncDBVTzBkTVZaUk9NVjdFWTJKbExxTlNLbmhNSDhzODlLa1VaT0JUUi93RFhxak55dU9IV25mZFgvd0N2U0FxRjk2Um4vd0E1b0pBbkgxSEZOTFlwalRZRlJOY2MwQVd2T3hUaFBnRC9BQnFrOXpnVkdiN2pyK3RNbzAxdXNVNzdhUDhBRVpySWZVTm8rOEtyeWEwbzQzZFBlcjZhak9oYTlHT3ZTb1pOUkNjYnE4UDBuOXJMVGZpQjhVUGlsOE85QS9kZkVENGMydHZLTE84SUl2QmQyZ210TGhGQkJhRXlFUnNSMEl3U0N3RllQN0VQN2JHbS90cGZzcGVEL2lOWW90ck5ybG9ZdFN0TTRiVDlRaFl4WFVCQjVYYklyRUE4N1dYUFdoZDJMVm51ZmpqNGhXdmdid2pxMnVhZzB5MkdpMmMxL2NtS015U0xGRkd6dVZVY2s3VlBGZUhmSFg5dmZ3cjhLZkJmd3I4V0c0dDczd1Q4VU5ic3RHaDFyejlzZG45dWdkN1NVakJHMXBGQ3R1WWJCdXprakZkOXEzaXUzdUxXU082U081dFoxS1RRdnlzcUVZWkc5aUNRZnJYNDNlQTlDdjhBNGgvOEU5LzJzLzJQdFdsbnVQRkh3TjF1ODFId2M3c1B0RnpwL3dCb09wYWNZdXAzUE5ESUN3NENhaEd2R2FubVhVcFJQMWgrSS9qWVc4VXlzM3pLU3VDZTlmRFAvQlY3V2RVMWo5a0xXdkVIaDJSbDhVZkRxOHRQR1drc28rNUxZVENXVE9EeVBJODdJNzFIK3k3KzNndjdVUDdHUGdUeG5lWHNjbXRhaHBhV3Vzczc0YiswYmY4QWMzTE42YjVFTW9IVUxNdmJtbmVQTmJpYlFGMUx4aStuK0hmQWwweGp2TlM4UlhjV2w2ZlBDUis4aldTZGtXUXVwSzdZOXpIZHdNMXd5bFVkVktDYmFaMHg1VkM3WjVIOGNmMnVORjA3NHMvczAvdEVhRk1zUGh2V3YrS1A4Uk1TQnMwdlZWV1dMem02N2JTN1ZwRDZPU08rSy9RSXl4UHB6TE1RdlVFTmo1VDN6NmZqWDRNYWorME44S3Zndit3TjRrK0RtdWE1NGkrSVYxZmFucVVmaHU1ME8xamgwMjFnaHV3MXJjU1hOd2Q3aHBvemNlVWx1Q1k1dkxMb1RrVy8ybS8rQzNQeDJudVc4SStGOWUwVHdab3RqYXhXa2VvNkJFTGpVTlVpOHRkc3ozMHhrWlpHSHpGcmNRNFl0d01ZSHJyQys3NzJpWHowZjlkVG05dDJQdkgvQUlMTy9ESmRYL1pwL3RXTFdkRThQYTE0WDFLMzhSK0g1ZFYxT0N4YTR1N1ZpM2wyNG1aZk9sZU5wVlZFenVmYURnY2p4L3d4OFpQRGZqMzl0dnduOFhQaHRxZjlxYWw0VmhzdkJQaklhZ3cwdlJyTCsxbmtoc2xkMkwzMGtVZDQ0VjU0N040VkFpUG1NV1FOK1RmanZ4ZnJYeEk4UlhXdGVJdFgxYnhCckYyUzF6ZmFuZHlYZDFQbnU4c2pNN2ZpVDFxQzY4YjMycFh0MWR5WGMwZDljd3JGSmNSUytTWkFyQmh2Mi9lKzRtQjJLS2VvRmEwNmRPRzJ2ci9YNTNKbEtUM1A2dC9ESDdDdmlyeC9JLzhBd3NiNG5heXFxUXJhRDRCdGo0WnNqMUJTUzlaNTlUa2J0dmd1YlVIL0FKNWpPSy9uby80SzQzWGd2NGIvQVBCVVQ0dFdQdzVzN0p2Q09rWDFyb3pXd3VKYm1LN250ck8xaHZra2xrWnBKU2J5S2ZlN096TXdZN2lUbXRMWGYrQzR2N1YveEo4S1hXazNIeHc4V3BwOXhicEZkUFlRMm1tM2o3MHc0TnpiUVJ6OGxYNURnNFBKT1RuNWtPbVFYV3dTcTIxbTI3UTJEdDZjSHNmZkJxbkxXNlpTMk1TSFVMalM5TGtpaG51RjAyOGRCT3BPMVp5bWR2SFFsU3hPZTJhZlpXLzJpM2pZcjk3ajZIcFRkUStIdHpHa01rRjVaM0N5TzZLdVdTU0pWMmtNeWtZK2JMWUNsdVZicHhuWFhUZnNsckhHdUFzQThzWjQzRUFFdGozSnpqdG5IYXBkeWJHTmQrSGwxQlN2bWVUSmdsZC9DdVIySjdaOVR3TzVBeVIrai84QXdRby80SWgvRjM5cHY0dGZEMzR2NnMybitHL2dqWjZvdXEzRit1c1cxMU40aSt4M09Ic0k3V0dSNUkzYVdMWTd6ckdJMHk2NzJDSTM1NlNXbWZtTE1vWTVBeDMvQU01cjEvOEFaWS80S0ZmRy93RFlkWFVvL2hQOFNQRVBnMjAxZ2lTOXNiY3hYTmpjU1lDK2MxdE9ra1BtaFZWZk1DYjhBRGRnWW81VTl4bjlVbi9CUjM0cytDL2dwK3dqOFhmRUh4Rm10WWZDVng0VjFQVGJtQzRZTC9hc2wxYVN3UjJVUVAzcFpuY1JxbzV5MmVBcEkvanArem1LM2pSOGI5b0RaSFUrdjQxNlY4ZWYyb3ZpVisxZDRtL3RiNGtlUFBGdmpqVVRNMHlQcStxUzNNVnM3NERlVkV4OHVBWUFHMk5WVUtBQUFBSzROSUZNZi9QTmdELzlhanJvS04rcEJGYm1WU2ZtWHNjSEczM3IrbnIvQUlKZS93REJlSDRNL3RQZnN2OEFobGZpUjhUdkNuZ2Y0cDZEcHNGaDRvdGZGR293YVN1cFhVU0JIdnJlU1FwREtrKzN6U2taM1JzN0tWQUNzMzh5VVFLRW56RldUN3FrdGpKL3VqMXp4eCtIcFgxcit5bC93UkEvYWIvYkJOcmNlR2ZoYnJXaCtIYmpheWE3NHBIOWhhY3lIa1N4bWNDV2RQOEFhdDQ1ZnBUVWt2aURrYjJQMFYvNEwxLzhGNy9oNzQ4L1o0OFJmQS80SDY1RDQwdmZHRVkwL3dBVCtKcklPTk5zTEhjR2x0TFdSZ1B0RXN3WFk4aUJvVmhlUUJuZHYzZjRheVc3UGN4UnFkenpFS2loZHp1U2VBQU8vUVlIdDlLL2VMOWxiL2cwSzhNNktzRi84YlBpcHFuaUM2KzlMby9nMjJHbjJpbnVyWHR5cnl5cjIrV0NGaDJOZnBWK3lwL3dUWitCUDdFMFVML0RINFcrRS9ER3BRZ2orMS9zeHZkWWJJd2MzMXdaTG5CL3VpUUx6d0JTNXV4V2kzWi9Obit5bi93UWUvYWcvYStTenZORStHV29lRi9EOTBGWWE1NHhiK3c3UFkzUjBTWWZhWmw5R2hoa0dPL05mcGQreXQvd2FFZUJmQzV0ZFErTkh4TTF6eGhkTHRkOUg4S3dqU2RQVmhqS1BkU2g1NWs2OG9sdTN2WDdHdm1XVGN6Ym1ia2tuSk5KdTVwVzdoejlqeUg5bHY4QVlDK0MzN0ZGbXFmQzM0YWVGZkIxMHFlVzJwVzFyNTJxU3FSZ2g3Mll2Y3VENk5JUnowcjE0OStkemZYcldUNHI4ZTZMNERXM0d0YXBZNmJKZUhiYXd6ekJaNzF2N3NNWDM1V1BaWTFaajJCcklQeEExclh0MzlnK0ZiNW8vd0NHODEyVTZSQTMrN0VVa3VzajBrZ2pCN05Sb2lOWHFkYUNLeWZGUGp6UmZCVThNT3FhbGEyZDFkRE52YUZ0OTNkZjljb0Z6TEtmWkZZMXpQaVhTcHROMFo5UjhiZU9tMDdURVpJNUUwNlFlSDdMZTdCVUhuZVkxMTVqTXlxQWx5b2NzQUVKSUZabWpmRWZ3VDRCOFUyL2h2d25wdW4zR3NhOXBVR3UyVWVtQ0dLUHhIYnlQTm55YnNrUjNOMTVWdmNUQkhmZElrYk52MmlSME5SMk9rUGpYWHRmQi9zUHczSkRDMzNiM1haL3NFYktmNGt0MVdTNEpIOXlaSUNmN3dxSzYrR3VvK0s3YVNQeEQ0cjFwNDdoREcwR2hNMmlXOFdSamVqUnUxMEdBNSthNVpDY2ZJQnhWNzRVZU0yK0kzd3Y4T2VJcExkTFdUWDlNdDlTTUNzVyt6K2RHc2dqSlBKWkEyMG5BNUI0SFFkQm5KeHQvQ25ZUmkvRFhYYnJ4RjRJMCs0MUF4dHFrU3RhYWo1YUJFKzF3TzBGeHRIWmZOamNqL1pJcmVyanZER3FXdWovQUJkOFJhSEhkVzhrbXB3eGE0a0t5cVpJcEFFdHJsU2dPVlViTFI4a0RMM0wxMk5HdlVIb2ZqSC9BTUhpSDdKZzhVZkEzNFkvSERUcmYvVHZCK3B2NFMxbDQ0eVhheXV3ODlwSXpka2l1SXBrNS9pdlJYbnYvQnE5L3dBRkpmQ1B3citDUHhDK0V2eEM4VWFmNGR0ZEoxYUx4SG9FOThKVnQxaXVZL0t2RmVYYVk3ZUdPV0czYmRLeUp2dTJHZHpBSDllLytDZy83S01IN2NmN0VmeFArRThpUXRkZU10Q210OU5hVTdWaDFHUEU5aklUMkMzVVVCUFRnRWQ2L2xxLzRJM2Z0aHovQUxCUC9CUlB3WDRqMVV2cCtpNmhkTjRXOFRSemt3bTFzcnAxaWxlUUhCSDJlVlk1aUQvendJNHprWFIrTGw3L0FOZm1LcDhLbC9YOVdQNjBmQm5pL1NmaUQ0ZGcxanc3cTJsNi9vOTBOME4vcGQ1SGVXc3c5VmxpWmtiOENhMUZQeTVyd3pYdjJaUEEydGVJYmpWRzhOMmVpK0lIYk1tc2FGSkxvMnFsaG5yZVdiUlRIdndYSVBldFRUZkIzamZ3bHhvUHhFdnI2MlhoTEx4WHBzZXJSSVBSWjRUYjNSUCsxTE5MOURUS3N1alBaRjkrbFNBSGQvaFhsOW44WHZHR2diVjE3d0MxOUd2SDJyd3hxc2Q5dTlXYUM1VzNkQi9zbzBwK3ZmWTBUOW96d1hxMS9IWXphOURvbW96SGJIWTY3RExvMTFLeDdSeDNTeHRKNlpqM0QzcWVYc0xsZTUzaTgvOEFBcWpsczRwVDgwYWx2VURCL01jMC9hWTFYc0dHUngxSHRTaHQzOHVLV3FFTVMxa2hYOTNOSVBRT053SDlmMXFSWnBrR0dqV1QzUnY2R25KampINDA3SEZQbTdrOHFZa0Y4cVNLZDBrTGRpUVZOZVQvQUxSdi9CUHo0SS90ZkpLM3hLK0ZmZ2J4amRUTHRhL3ZkTGpYVVZIK3pkeGhiaGYrQXlDdldpMlJnamowUGVnV3FnNVhLZjdweC84QVdvY1l5M0NQTkg0V2ZsZiswVC93YU0vQUg0aXJjM1B3NThXZkVENFczMG5NZHUxd212YVRGLzJ4dU50d2MrOTErRmZBdjdSMy9CcHorMHQ4S1piaTU4RVhuZ1Q0dGFjaHpISHArby8yUHFUTDZ0RGViSVFlK0Z1SEo3WlBYK2t5TnBJLytXZ2IvZUhQNTFLdDFnZnZJengzSE9hT1Y5SC9BRjh5dmF2N1MvcjVIOFhIN1FYN0czeFUvWlR2L3MveE4rRy9qandHMi95MW0xblJwcmUxbFA4QTB6bksrVko5VVlpdk80ZE5XNlZXaWVPUlc2RlRtdjdqcG9yZlZMR2ExbVdPZTJ1RktTd1NnTkhLcDRJWlR3UVJ4Z2l2bEg5cEQvZ2hUK3lqKzFLODF4NGcrREhoWFNOVWxESCswdkM4YmVIcm9NM1Z6OWpNY2NqYzV6S2o4OVFhT2FTM1JYUEI5MS9YOWREK1NGOUdaUjkzcDdWRk5weFRubnAwcjk3ZjJpZitETzNSYmszRjE4SVBqWHJla3NGUGs2VjR6MHVQVW9XYnNEZDIzbE9pOXY4QWoza1BIWHZYd1QrMGgvd2JzZnRkZnM4ZmFMaHZoakQ4Uk5MdHdXKzNlQnRSVFZHY2MvZHMyQ1hiSG5vSWF0VktiMzBLVWY1ZFQ0QmxnNCtsZnVaL3daNmZBUzM4TytIUGpKOFpOWHhiMlZyQmIrR3JXOGs0V0JXUDIzVUFUNkNLSFMzejZPZTJLL0ZueDc0SzFMNForSnJqUmZGR2s2eDRVMXkxSldiVDlic0piQzZpUCsxSEtxc3Y0Z2RLL2ZQUnRHdVArQ1gzL0JxdjRxdnA3V1hTUEZuajdRTGlVeE1wdDdvemE3TkhwOXF4RFlaWm85TWEyZGdjTXBnWWRSaW5LeWc1UlpueTgwbEYvTS9DRDlxYjQrWEg3VVg3VWZ4SCtKVjN1am04ZitKOVIxNVluSnpESFBjUEpIRVBaRVpWQTdCUlhDaDhmNTZWOWtmOEUzZkQvd0FLWi9obHJuaG40aWF4b0Y1TDhRTlpzTkhYUTVkTmxUVWJaTGVhR1l6eFhzYk5Jbm13dmR4cEdsdExtNFczQWRIYmEzenYrMUhEcFovYUU4V1E2SjRmMHJ3dnArbjM1MDlkTjB6VkJxZG5ITGJxc0Uwa1Z3RWpXUkpabzVKaHRSRkFsMnFvVlFLcjJUaEZEOXB6Tm5uL0FOb3h3RCt0Tk12U215cHN6MjJqY1QwMmpPT2Z6QS9FVkczQTdFZGpXWWozei9nbU4rendQMnN2Mjh2aGo4UDVZV3VMTHhKcnR0YWFoR0J5YkZwRlc4WWRzcGFtZVQvdG45YS9UVC9nODAvYWp1dkVIeGgrRWZ3WnRicVJOTjByVGJqeHRxdHFyZnVwcmk0bGt0TFRlUDc4VWNGMFI2TGRIMUZlYi84QUJvWit6aTN4Ry9idjhSZkVDNnR2TnNmaHo0ZnVKcmVVZFliKzZBczRQd2UzbjFIOFloNlY4ai84RjB2MmkvOEFocC8vQUlLMWZHenhERGNOY2Fibyt1SHd4cHgzN2tFR21vdGtXVC9aa2toZVg2eWs5NktuMlkvTUtlOHBmTCt2eFBudjROL0h2eHYremw0bS90bjRlK012RlhnWFZtQURYZmgvVnJqVFpwQURrS3pRc3U1ZlpzajJyN3kvWnMvNE9uLzJ0UGdZWXJmWDllOEsvRlRUbzFWUEs4VmFNb3VWVVl6dHViUXdTc3hHZm1sTW4wTmZtK3paTmRCOEtmRW1qK0QvQUloYVhxZXZhS1BFV2syY3BlNDA4eWhCUDhqQlR5R1Z0akZYMk1DcjdOakFxeHFrM2V4TW9yYy9vVi9ZOS80TzYvaGI4Y1BGbWxlRy9pbDhOdkVYdzN1dFduUzAvdFd3MUdMV3RKaFp1Tjh3WklaNDB6MmpTWTg5K3RlLy90S2Y4RzAzN0pIN1RPbzNPc1dmZzNVdmh0cm1vUDU3YW40RTFVNmNqRTg1VzJkWmJSVlBYOTNDdWEvbjMrR1hoYndQKzI1KzJUOEpmQS93eThFeWVCNC9FT3J4V1Y2eXl2STlySmMzRVVVU2crWTNtUlc3a1NMTXdXVmhjTXI1RVNFLzJDV0dsMjJqV0VOblp4TERaMnNhdzI4Uy9kaWpVYlZVZXdVQWZoUlZweFNUNitYeUNGU1NkbHNmZy84QXRBZjhHam54UThIdFBkZkNINDNlRy9GMXZ1TFI2WDQyMHlYVFoxUVp3b3VyZnpsa1krckpFRG5uRmZEUDdRZi9BQVNZL2FzL1pwM2Y4Smw4QWZHbDVab1cyNnA0VmpUeEZhRlFjYjJObTBoaUIvNmFiRDZpdjZ5aXB4LzlhZ0ZvVHVYY0Q2ZzFNYTFXT2lsOStwcDdyM1gzYWY4QUFQeWYvd0NEYno5bXZXdjJJUDJHL2lqOFhmaUQ0VjhRK0VialhBMm9KcDJzMkRXZC9KcHVtd3p6dE9JWEFralNZeU1xaGdwZjdNcmdGQ2pIOE0vRC9pL1UvaUhQcW5pN1hKV20xenhqcXQzcitveUhLbVNlNm1lV1EvaVRuSnoxOUJYOWt1bzJFT3NXTTF2ZHhSM052Y3h0SE5GS29kSlZZWVpXQjRaU0NRUWVDSy9NRDlwZi9nMDkrQW54VTFUVU5XK0dmaWJ4MThHOVd2R01rZHBwMDZhdG9jVGs1NHM3akVnWFBSRnVGVURnQUFBQzZlSWNhdnRKSytsdENmWnhjT1ZPMnQvNi9FOHIxblhuL2FZK0pXbjZCRThscjRSaHVGams4c2JQdGdUc1BSUU9ucndmU3Z4cC93Q0NzMnRhMDM3ZTN4RTBMV3A1bXN2QityemFabzFtckh5ck95QkRRcWc3RmtaV1k5U1Q3Q3YzQStGZmd5UHdGOFFkSkoyckVzNWlBSTVIYkordWMxaWZ0Yy84RUFmQmY3ZW54VDFyNGtSeWEzYWE1ckNRcmR0YVBibU9TYU9GWXh3ODBSR1VST2ZteWM5Qlg4Y2VCbVk0ZkRadFZ3amg5aDh1MTdwcHQrclRkL1FWT2pPcFBtZTZ2K052K0dQNXptdUVTejJvdmxObGkvOEEwMEJ4MUhiR1AxN1Y5cy84RUJmZ3Ivd3REOXVPMzF5NCt6bXk4QzZmTHFrZ2I3N3V5bU9NTDI3c2VmUVY5aStPUCtEVTF0TDh4clBYUEVra2E1WWY2QTBqWUhiOTAwZzU2NTV4OUs5ZC93Q0NiLzhBd1N3bS93Q0NjcDhaMzF4ZHphcGRlS0lZYmFLZTR0bnQyampqTFoyaDBWdVNUbkdSMDZWKzNlSkhFTlBEY05ZeVVVMUp3YVYxL05wK1RaNm1Fd3RSVlZKOUR1ZmpuOFd0SDA3eHRwUGdPZStodGZFWGlpM252dEtReWJIbmEyS3N5cjZuQkJ3T2VPT2hOZXFmQkQ0bnkvRUh3MUhIY2Z1ZGEwOGJaVi81NmdEaGgrWFN2bi85cTMvZ24xNDUvYUgvQUduUEFQeEIwRzkxRFN2K0ZleEI5UE1PbVR6TGNzN0swcXM2NEJWMUFRZ0hwa2UxZWllTmZEdXNmQi94SkRxbjJXZlQ3bGlKUkZLbmxzVlBWU09jZDhjbml2NVh6SGcycmxXUllPcWsrU3RHODMvTE50dGZmR3kzM1Q4aFlqbmpQMnJXajArWFJuMHhwOGErSjQxOHdyKytReHVEMDNZSTUrbzQvR3Zqajl0VzBYd0xkSFFZNC9ManptSUgrTkdKMmo4TVk5T0srblBobjQzdHZGZWlRMzhEYkk3amlhUFBNRW52WEtmdHUvcyt5ZkZEUWRBOFNXY1lrbjBpY1Izb1VaTWx1M0c3L2dMYy9RdFh6UEQrT2RLczRWOTF2MTE2UDBmZnVjMkt3M3RGR1VUOHpQMjNQMk1QRjM3VjkzOFAvRGxqcVZoNGQ4TTZYYnk2aGRYRjVJUDlKdVpuRWFwSEVNdkl5Um9mdWdnZWNlUnpqcC9nRi93UmI4SS9EdTR0N3FXeHU5VXZvMDNmYmRaamFKQ3dBd1k3WUhmMXoxSzhZeG52K2htaFduaDN3MjBuOWoyTjFxR29Rb2tUeWFicGpxOCtCdEFhZmJ5dm9DMzRVYXBOcjAwOGkyTm5hYU9qTGpaSmllNUxjaklWR0s1NFlITERCeGtqT0svdHJoM0N2QjViUndrNVg1VnJiYm1lc3Z4YjNaMlU4SHlSdGJYelBKZkFIN0sybWVBNGJXYTVWZk1nMkxGSmRLcXFyWTRhS0JSdFE0QTVQejhuRER2MnNVdW0rSGRVWnJlMWt1THFQOTdjUzNFZStTSWROd1FrS3BJQkM3eWlrajcxVzdqd3JkWE5uRE51dU5RbWtPTjZzaTR6Z0ZzaG1JVVpJYjV3dU05ZUZOclMvREs2Z1lMV0d5anVmSmt4NWR0YitZcU9UbkhHUnU5ZW5ITzdPUVBmakoyMnNYS0tYVTVDejFYVU5YMWhSRmROWXpJUkp1aW4zM1hQWU9FOHdSZ0J1SW8xenVPNXl1QXU1cFBoaFlwZFBqdGJlYWFScEEyNEszTXJaeVFwem5IVDc0SFAzZUs5SjhNL0NDU3h0UE92V3RkTGlVay9aNGtqM0FmeGNJZkxHY1p5Y2tFRHJpdVErTC83WW5nSDlub3RZUVhGeHJuaU5nc1M2WHBpZmE3NWllRjh6R0ZoVXNjYnBtalFlNTRxK1ZzeWNrajJ2NFRlRXB2RDNnbWI3UzBmbmFqZUF0dElJQ0lvejBBR2R6UDBIVEdTVG10dXcwalY1dEkxbTY4UFFMTHJ6VzB2OW0rWVFxTGRPQ3NiT1NDQXFNUXpjSENnOEhwVkR3M3FHb0Q0ZGVHLzdSdEcwL1ZyeXdXNXU3Um4zdGFTekRlMFJQR1dRUHNKd0JrZEJYc2Z3aThMcnBHZ3JJeW56SDVKSTduay9waXZ6SExjUC9hR2V5bXZoaks3OUk2TDhUeEpmdks4cjkveVBNLzJLZjJFUER2N0lIaEtUeVpHMXZ4ZHF3OHpXZGR1UVd1TDZWc0Y4RnNzRkxESkpPNWlCbmhVVmZiNUlkcDIrOVhESGltc3UwMSt2UmpiWTdwVHVWeER4ajN4VGxYSFByU2pwVEhtQ2o4SzBNUnpOZ1pwdm1GUjJxTjd2QzFYbHZlZXRBRnA1OFovcFVMM08wR3FjbDd1Kzc4M3NLbzNldEtqZmg2MEQ1V2FjbDBCL0Y5S3JUMzZwMzQ3MTRyKzJkKzBScW43T243S2Z4QThmYUhZV21yYW40TjBlYldFdExsWGFHV09FaDV0d1JsWTdZUkt3d3c1VWU0cjQxL2E3LzRLL3Y4QUQ3d2YreXY4ZlBERjdNM3dkK0lPbzNXa2VNYlNSaVJaQ1lRN3R5cVJ1bnRUYmFrQjFCZTN3T0hKTFVXOWgyUDBudXRiMnIxNDdWNEorMVYrMzVvUDdKZnhqK0VmaHp4UGIrVHBIeFkxYWZRSWRXM25aWVh2N2hiZEhHTUJKR241Y2tCVlJtNkExMnQvNDBURGZ2RmJEWXlyYmdmY2Uzdlh3Si93Y1IvRGFUNDIvd0RCT0xXdFNzZk4vdFQ0YzZ0WitKNFRFZjNwakJhMG5BN2dMRmROS1Q2UVo3VW95VjdNcXg5SGZDLzl1alZvZitDa0h4VitCZml5UTVnMHV4OFhlRExoMFNQN1JwN3d4eDNOdU1BYmpIUDVtTTViOTFNU2NBVjlBWG5qRGMzRDRQWEdhL0V6OXBuOXNTNDhWZUVQMk5mMjFySHpKdGE4TzNCOEsrUHZKWE1seEdSSWwyb1VmY0RlWHFqTG5PQmR3ZGVNL3FIRjhRMzFxeSsyYWZKOXEwOElKQmVvd1cxWkNNaC9OSkNCU01IazlNSHBUZDIxWkJ0dWZNUDdldnhPbC9ZNi93Q0N1djdQM3hxamxlMzhML0VyVHAvaFo0c2RTRWpRdE41dGpQS3g2YlpaNDN6MTJXTERpc3I5aGY0alNmc21mOEZML3dCcEg0SFhSa3RmRGZpN1VWK0ovaEpTdXkzaU40QWI2M2pCOUN5cXE5aHA4cDU1TmVXZjhGamYydVBnSDhadjJldFErSFdyZkVUUk5jOFdSNnBaYWhwZGpvSWZVRnRybU9iWTRtdVVCaGdCZ2x1RUozRmw4d0hCd0FmamI5b0wvZ3NqNGg4Yy9HeGZGWGhIdy9wdmdUeFo0VjBTVFFkTTF6VURIcjJwM3FGMkpta2FXSVc2enNIbEViUndBSXQ1YzhuY2hUcGpoNU5lL3AvV245YUU4eTZIN3RlTlBqRGErR1BDdDFyV3FYOWpwT2gyZy9mYW5xVnpIWldNR2VtK2VWbGpIMDNaUDFyOHBmMmh2MjdmZzc4TWYrQ2llc2ZHcndmNHF1ZkhMZjhBQ0ZuU1BFMm4rRkVLZjJuY3hTaFlGTnpjUmlKby9MUzNkcG9Wa0VZc0ZIemVaWHlsOEovMkhmMnZQK0N0MEVuamJTZkRQano0cFdpU1BERnIydmF4QmEySlpUaDQ3ZWUrbWlpTzF1Q2tCSVVqQkF4aXZGZjJzdjJMUGk5K3duNDBpMEQ0cCtDUEVIZ1hVdFNoYzJwdXdyMjJveGphSE1GekV6UVRxQ3lodkxkZ3U0QTR5S2NLZEtMNy93QmRnYW5hNTYzb3YvQlVieGQ4QWZodkxvdndZc2ZEdncvMDdYOVd2OVZlZjdKRnF1dWFlSlpBa1ZzTG00UXh4ckhBa01heVF3eFNONU84c0MyMWZuYjRvL0ZUeFY4YmZGRW11K012RW11ZUt0Y3VNNzc3VjcrVzl1RDdiNUdZZ0QwQndLNUdXNmpVcnNabStVQi9rQ2dmVGsvbWEycHJYeVpOdTFnU0EzSjNGUVFDQVRqcU1qTmF5bG9LTWRibWUrb3l6d3dXYzBtNjNpWW1OWGI1SXlUbGlPK0R6bkhVNDlxazBrTHFWeEpHc2tQbVozcnRRcnZHMGtoUjA0d09EK0ZYdjdMdDcrMW1qa2p3NzdmTGxUTzZNNTlPakFqdG4zSFRtUFJmREs2ZGNHV1ErYTNJWElJVlQvTW4rWHYyTGo1U1dHQmNlcTUyOGp2VDlXMEcxMUxSN1dHMXQ0YmErU2VTU2U1YVp5TGxHRVlWZHZJWFlWYzVBeTNtSFBSUUw5bHB1KzViYjk3c1QwUDVWYnRyTVNGdHFqTzdHTTkvcDllLy93QmVnb3pmRCtpSm90dXkrZDVza3BWbVlqYW5HY0FENkU4bm5udGc1MkkwaVViZmxERDVqbHV4NUlKNjU0SEkvd0QxVFIyUVptVWhOeFlaQjY4Z2U1K25iM3E5SFlxcW9ubGtzZWo1SzU1QXpWSVpSa3RSQ203SGxLckg3NEJPZnA2Y1pKNlZIZjJLd041Z1Z0eHlTTWNEbm9PK08yZmJtcmx4RVVMYi9sV1BDbkpLcmtkdUFPNS9sem12b0Q5bC93RDRKUi90Q2Z0cEd6dXZBSHdyOFJYbWlYUDNkYTFDSmRLMGtvY0F1dDNkTkhISmp1SWpJM0hDbWgyVzVTVFBtdVcxRnMrN2FveWVlUWNnODl2Ym4vOEFYVmFlQlk0L01rMlJLVC9IOG8vUG9QejdWKzRYN0tQL0FBYUxMSGQyZXFmSEQ0b1J5S3BXU2Z3LzRMZ09IOVViVUxsQmpJNFlKYlo2N1hCd3cvUzM5bWYvQUlKVC9zNS9zZ2F4RHFYdy93RGhENFIwZldvQ0dpMWE3amsxYlVZQ0IxanVidDVaSWllL2xzb05UZnNLNlc3UDVxZjJTZjhBZ2pkKzBmOEF0b0phM25nbjRXYTlINGZ1dHBUWDljQTBYU2loL3dDV2lUWEcwekFmOU1GbGJ2ajEvUzM5bFgvZzBFMDJ6OGkrK09QeFZsMUNUZ3ZvdmdlMjhtSHIwYS91NDk3Zzl3TFZHOUg3MSsxOHNqM01tNlIya2IxWnR4TlJzTng5dnJVNjlXVHpka2VCL3NuL0FQQkxQOW56OWlSN2U0K0cvd0FLdkMraTZ4YjhwcmQzRStwNndEakJLM2wwMGswZWVTVmpaRjU0VVY5QVNGcFhMTXhabTZrbkpOWnZpZnhkcFBnalRWdnRhMVRUdEhzNUhFYVRYMXlsdkc3SG9xbHlOekhzb3lUMkZjKzN4UnZ2RUM0OE0rRjlXMVJXNFc4MVFOb2xpRDZFeklicGgzRHhXMGlIczFHa2RDYnRuWUEvUGlzM3haNDEwZndIYVEzR3Q2cnAra3czVCtYQWJ1ZFlUY3ZqT3lNTVFaSHgvQ29MSDByQlh3bDRrOFNPdjl0ZUtEWXd5TmdXUGg2QVdZazRKS1NYRXBrbWNqSER3RzJQQjRxSDRSandQZVhXcFgvZzBhYmUzTVpqdDc3VnJkbXVwN2d2R2t5cEplUHVlWWhIUmlESTIzZXVjSGlxMTZDMEtuaS80NDNtazZiRGM2VDRTMXE4dEo3MjBzUmZhci94SjdOR3ViaU8zUm1XVld1OW9lVk1rVzIzR1R1QUdhMDI4RmE5NGhiT3VlS0xxR0EvZXNkQmgvczJKeC9kZWNzOTF1SDkrR1dEUDkwZEsydkdmaE8wOGUrRU5XMEsvYVJMTFhMS2JUN2g0emlSSTVvMmpabFBaZ0dKQjdFQTFSK0Z2aXU2OGIvRC9UTlExQlkxMVZrZTExTkl4OGtkOUJJOXZkb3YreXR4RktvUGNBVVcwMUhwdWl6NFE4QWFINEdrbGJTZE50TlBtdk1DNnVrVGRkWFgrMU5NMlpKajd5TXg5NjhhdWZqaDQyOGRhTjRpMHZTOUp1TGZ4RG9xM0ZqcWR0bzMySzhmU251YmU2UzBlR2Y3VTBjMDl2ZDJ5aVJKUmJ0NWR3anZCR29HZmJOVThUNmZvMTB0dmNYS2k2WWJsdG8xYWE0Y2VxeElDNUh1Rk5Rbld0VzFaVlcxc1Bzc1lHRm0xR1hCQTdNc01aWmlQOWwyakk3Z2RLRnBzQzdzOGlzdjJYdkVtcStQZFcxclVQR0YzYjJXcUdlNXQ5TUxIVUpOSnVwSjlPMUNDU0NlVEJWYlRVTGE2OHVBaVNFd3pJRkVSTWl2Mk9oZkM3d1Q0QjFaV2t0YmJWdkVjYUlYdUo3ZGJ6VWppN3ViNVhFY2FmdWg5b3U3aVFlWEdpTHZBR0ZqUUwxYStHSkw0WjFMVWJ5OUo1TVVKK3kyNDlnaUhlVi8yWkhrNm44TkhUZE10dEdzbHRyTzN0N1MzVWtpS0NNUnhnbnFkcWdEbWdPWm1hbC9xdC8vQU1ldW53NmZGMDh5L2NNNDl4REVTQ3YrOUtqZjdORCtGbHZWL3dDSm5mWG1vSzMvQUN5TCtSYmoxSGx4N2Q2bjBsTWxhN1oyOGVuRk1tbWh0TE41NXBJNFlZMUplUjIycW85eWVCUVNjdDQ4dGJmd2hZYUxyRnJERGFXdmh1K1V6eFF4aU9OYk9mOEFjVDlPRlNQekV1RGpyOWxGZGlWWkNkM1k4KzFjOXFXcTJQaTNSYnJUMXNiclc3SFVJWkxXNEVTN0xlV0oxS01QTmNxaktWSkI4c3VlZWxKOEtkV3ZkVzhDV0s2cXl5YXpwd2ZUZFNaVzNDUzZ0Mk1Na2dPQWRzako1aWtnRXJJcHdNNG9LZXgwU3VZMkREcXZJUHBYOG52L0FBY1Nmc2gvOE1uZjhGWVBpSloyVnI5bjBENGlPbmpqU0VCd0RIZnM1dUZVZndxdDhsNUdxam9xTFg5WVI2VitTUDhBd2R0L3NUNmo4Y2YyWXZoNzhWdkRPa1gycmE3OE9kWWswYlVvckMyYWVlVFRiOEFySVFvTEZZcnFHTlFBT0RlTWZXcGx1bXdqcW5FK2xQOEFna2YrMU5KKzJKL3dUNCtHdmpDOHVEZGE5QnBxYUhyek0yNlJ0UXNzVzhzam4rOU1xUnovQUV1QjdWOU5RQU1PTjN0NzErS0gvQnF6KzBkY2VGL0dueEkrQ3V1dGNXZHpxTnZINHAweXl1NDNpbGh1SUF0dmVMdFlBN3BJV3RYd2Y0YlZqNjErMWNMNUdQNS81L3ppdXFwdnpMcVp3MnQyTGlOa2Y3V2V0TnY5T2cxdlQ1TFc4dDdlOHRaaHRraHVJeExFNFBZcXdJUDB4VFVja3J6eDlhbWorYy9oajYxbVVjdkI4RGRGMFY5L2grWFdQQjhpOUJvVi9KYVc2bkhVMnVXdG4vNEhFdzlxdlFUZkVMd3k0K3o2MTRmOFdXNjhtUFZyTTZiZHYvMjhXd01RL0MyN2RhNkJEeG41dXVPVFQ0MjMvbDJvSzV1NWtSZkhhWFJYMitKUEIvaWpSd21OOTNaUURXYk1uL1pOdHV1TUQxZTNUK2RkTjRKK0tQaHY0a1N5UmFEcjJrNnhjUWpNdHRiWFN2Y3dmOWRJcytaR2ZaMUJxckdObnFyZGV0WlhpN3dGb1hqMkZZOWMwZlRkV1ZQdUc3dDFrYU05Y3F4K1plUUR3ZW9CcEMwTyt6bjVTdjZVNy9Kcnl5SDRaWG1nTVA4QWhIZkdIaXpSbEhJdDdpN1hWclErZzJYYXlPaSswVHg0N1lxNUg0eCtJSGh6L2o4MGZ3eDRzZ0hMUzZWY3lhVmRZLzJZTGd5eHVmcmNJS0IyUFNNYmY1VTRaRmVmeGZ0SGVIOVBZUitJSWRiOEd6ZnhmMjVwN1EyeWZXN2o4eTAvOGpaOXE3YlE5YXMvRStsUjMrbTNscHFWak1NeDNOcE1zOExqMmRTVlA0R211NU96MUxSVldIT0RnY1pIU25xREczeXN3L0hOTXp4OWFlRytZMEN0ZmNsanVwQjEydCtPS2tGeEc1K1lGZlhJcUVkYytocDNYSDUwaWVYc1Y5ZThKNlg0dVczL0FMUzAvVHRVV3prRXR1THkyUzQ4aHgwZE40TzFoNmpCRmVaZnR1ZnNWZUQvQU52ejlualh2aHI0Ny90SCt4TmNhS2NYVmhNSXJ5d3VZWkZsaHVJV1pXVU9qcUQ4eXNyQXNyQWhpSzlYVURQU3BCSXlucitkUTBpNHlrbW1mejkvdEgvOEdkZnhOOE1HYTQrRS93QVd2Q1hqUzBYZXk2ZDRxc3BkSHV5bjhNYXl3aWVLUisyNS9LWG5QeTE4Qy90S2Y4RWcvd0JwejlrNkM0bThjZkEveHJiNmJiQXMycWFKYkxybW14b00vTTg5bVpValgvcm9WUHFNMS9ZRWsrZUdYOHFraWNLKzVXWlc5UWNWU25OYk1yblgybDl4L0YzK3pEKzE5ZGZzNTZOcmxqcG1uMmVxUTYxcU9tNm5jUnZleTJ2bk5ZdE9VdGJoVnlsMVpTK2UzblcwcU1rbTFEbFN2UHIxNSswRDhDL2lkNGU4UTY1clh3OTBpMDhjMk9nM1ZucE1VK2xpMmcxQzVlRFVJcmVjTFlDSzFsdWtsT20zTXN0N0VFa0gyMUZVNHQ5djlRUDdUUDhBd1RvK0JmN1lxVE44VHZoUDRHOFlYazY3SDFHNzB0STlUQS8yYnlMWmNyL3dHUWRLK0VQakgvd2FGZnMyZU9kZSsyK0UvRW54UytIY0Vrb01tbldlcVFhblpCTS9NcUM2aWVaV1A5NXBuQS91bXRQYjZXbEg3aWVXTzhaSEIvOEFCdkpvdHY4QThFL2YrQ0tYeGMrUDJxV3ltNnVvOVIxMkIzNCsyMjJrMnNua3dubnI5dmt2b2ZjZ0N2NTNwTGk1MVdhUzh2SnBMaTd2Skd1SjVaRHVlVjNKWm1KN2trazVyK3RQL2dvZi93QUUzTlU4UmY4QUJGM3hKK3pqOERiZVQ3Ulo2UFkyT2xXMTlmUngzR3JyYjM4RjVjSkxjUHRqKzBYSmptWnBIMkkwc3h6c1Vrci9BREEvdEFmc2dmRkw5azIrYXorS0h3MThjK0FaQklZVm0xblJwN2UxblljZnVweXZsU3I2RkdZSDFxT2FNcWpkN2Rpb3hhcGFkMjJlVHRFVmFnS1IxRlh6WnJlUmZ1WFdUY3BPVU9TUGYycjZLdlI4R1BpSDhEbDFxNDB2dzFvL2plMTBPUk5SMGpUZFcxRFFieDlSaW51Vml1YlZaTFM3MDZlM2t0bXMya3R4SkJPODBjL2xsRllHdGZadTF5T1krcXYrRFRuOW5uL2hiSC9CVFdMeFZjUmhyUDRjNkxlYXlDNjdrZVJvL3NpS2ZSaEplUlNyN3dramxhL3BYWDRtK0dXOGZmOEFDS0w0azhQL0FQQ1ZlUUxuK3hmN1NoL3RMeWlNaC9zKzd6ZHBIT2R1TWMxK08vOEF3YXMrQk5OL1pWLzRKNWZHNzQ5ZUpVTm5wOGt6dk8waTQzV0dsV1QzMHN5bnJoeGRpTWorOWEvUTErQ254TCtLbXZmSEg0cGVJUEhuaVM4a3Z2RS9pN1Zialc5UnUyKzlKY3p5dEt6RDB3VzRBKzZNQVl4VXlkNUtQWkNweGJpNTkzK1g5ZmlmM0l1alJOdFpXVStoSE5OeHhYOGZ2N00vL0JiTDlxVDlrNWJlMzhMZkdieGZOcFZ1QWk2YnJkd3V0V1N4aitCSXJ4WlZpWC9ybUZJN0d2MEsvWnIvQU9EeC93QWJhVjVOcjhXUGhMNFg4UXJrSzEvNGF2WjlKbVZSMVl4Uy9hVWtjNEp3cGlYUDkwY1VleXY4TC9UL0FJSDRrNnJkSDc4RkJqLzY5Zms5L3dBSFVYL0JRdnhyK3lsOEd2aGo4T1BoMTRwMW53ZnIvd0FTdFN1NzdWdFQwYTdhMHY0dExza2pEUUpNbUpJaE5OY0lTOGJLeEZzeTUyczZuN08vNEp5ZjhGVi9oVC93VkI4RTZwcW53OW4xaXcxRFFUSC9BR25vdXNReHczMW9yNUN5ZnVwSkkzakxLUmxYM0w4cGRVRHB1L0FML2c2eC9hUGwrSS8vQUFWODFqUVluV1MxK0dIaDNUZkRjU2g5eWw1SXY3UmxiMERiNzN5ejMvYzRQU3M1UjVacU1qYWsxSk9YYjg5ajljdmpsOEpXK0hYeEoxQ0ZWa2J5WnQwRW1NRGFUdVUvaXBHZmZOZlJ2N0tuaU5kUXNtajNmSmZSQitUeUpFNi96TmRUKzBaOElvZmlCNFdsdm9JaC9hZW54bGxJR1dsakhKWDNJNUkvRWQ2OFUrQU9zdjRROFNQWjd2bFp4TkRuZ0E5eCtPSy9pWE04bnJjRjhhVXNZbCs0bks4WC9kbGRPUHFydGZjenNqR051WkgxRk5EdHJ3RDlxZU9YV1BHT2s2YUdMTEp0Q3I3czJQNlY5RDJkeEhxRnBGUEh5c3FoaFhqdmlyUm04V2Z0RWFjTmpHR3dYY2NyakJISS9uWDdkNHFVM2pza3BZS2cvd0RlS3RLQ3QxVXBKdjVXVnpxd2NrcWwzMFRaUHJYd1ZuVFNJMDBmVWxzNUZpVUdDOHR4Y1c4akFjRTRLdXZQY0UxNG44ZnZoRDRzMXpTYnFQVnZEdG45bHMwekRxdHBxUDJoVDAvMWtUeHE4WTNFZ2ZNL2JwbkErdlBzNjVyeVA5dGZYRzBQNE12REMyMmJVcnVPRUVIK0ZjdWYxQzE3M0d1VzRML1YzRTBhMGJRVUxMeWEwamI1Mk9PdFhmSzJ6NC8rRWQzSjRKOFJOYlNlWXR2Y0h5NVk4ZmRQVDlPSytsL0JkMmwzWXZZemJKWTVGekh1SEJCN1Y0THFXa05lMmNON2hSZElnODVWNk1SMGI4YTlFK0d2aVZ0UjB1SExiWnJmZ1k3QWRLL2llaFFsU3Fjc24rOGh0NXgvclZkbVZSa2xhUFIvbUo0ejhIK0h2Q3VxR0hWdFEwR3d0N3RXYUVYdXF0QzdLUHZZUndWNjRERUhuakpyRnZmRy93QU0vRE5uSXQ5OFF2aDdwZHFSODZKYzJqT0ZIUmN1K0ZISFFyMzdWNnhKOExmQlB4M1d4dHZHM2grdzErMHRwZDhQMmt1djJhVWpHNEZXVTRQVHI2VjEyaWY4RS84QTRNYVBjZVpiL0R2dy93Q1pnY3lySk1DTzNEdXdyK3lQRHZpTCszY3BqV24vQUJZZTdQMVcwdHZ0TFh0ZTY2R2s1T0w1V2ZKZmlUOXJqNEhhQmVHZisyYnJ4YmViQjg5ckJjYWhESnR6ajVvMWVQSG9DY2ZoV2ZwbjdVWHhMK01LeDJ2d2wrQ1hpcTh0SkpTSTcrK3Qvd0N5OVBUcU54WWJsL0E3UHFNVitnSGhYNEhlRGZBOG9rMGZ3bjRiMHVSZWtscnBrTVVuL2ZTcUQrdGRTVjNmZUpOZm9FY003YS81L3dDUm02eTlmdy96UHo4OEgvOEFCT0Q0NmZIRFc3ZlV2aW44VExmd25vKzdmSm9IaHROenpMeis3bGwzZlRrU3VweHltT0srbFBoTit4ejhOZjJVZEdiVnRHMEtHODFxemo0MWZVVlM0MUNTVEcwRVB0Q3hzZUZKalZTVkFCeUZHUGFweUY2VjU5OGNOY0ZucGtWdUdPZVpDUFVuNVYvbVRYblo1akk0REFWTVQxaXRMOTNvdFBMYzU2dUljWVBsMFBOclNPVHhQNDAzdTI3TGxtT2ZUbi9QMXIzYlNMVWFicHNVT05wQzVZWjZFOXZ3NmZoWG1md2I4T2JycjdWTXZBQWJwK1EvUCtScjBpUzkydDF4WHpIaC9sOHFlRWxqS254VkhwNmY4Rm5IaGFmTEhtZTdMUm1HS2dsdXZUMDlhcFM2b28vb0t6Ymp4TGFpK2F6VzRnTjRzUW1OdUpCNXF4bHRvY3BuTzBzQ000d1NDTzFmb1oxU05XVysyakphcTB1b0FwMTl1dFlONzRoWGIxL1d2aDM5dDMvZ3FMclg3Q3YvQUFVZCtFZmhyeEl0bWZoRDhTdE5oczU3dVJVak9qMzMyMmFHVzdhVWpMSWhtMDdlcE9GaWVaZ0MyS2NkZGliSDNuZDZ1c2E3Yzg1STYvaC9qV1ZjZUlVV2ZETWNkejdWK1duL0FBVFEvYlQxNzRRLzhGRHZqaCt6QjQzMUs0bWpzTmMxWFZQQ0J1bS9lTHN1NWJpUzNUdVJMWTNGdmNLRHd2MmFjOVhHZnYzVmZIU3JKODBucHhVMUh5dXhVVnBjK0o5Yy93Q0NrL2luOXJQNEVmdGpmQ2VJZjhJejhaUGdtdXIzT210WlNtRnRWczdHOW5aR2hWY1B1VmJXT0p1Zm0rMlFuSjNISHR2L0FBVEQvYi9UOXVuOWpEd3Y0MnVMcUdmeERibVhSZkVPeGRtTlF0aUZhUXFCaGZPaGFDNDJqaGZ0RzBmZHI4MXYyNHZIMG4vQlBUL2d2TG8veGZUSC9DRS9FR3h0THZ4SEZ0L2NTV000VFROU1ZoL3kwWkdqaXU5cC9pWkRrQ3BmK0NPMEhpejlqYjl2ajQ0ZkE2SFM5YzFMd2pOZVR5NmZkVzl2SmN3MjB0bzZ0YlNPeWdyR0o3RzVRbHlRR1pZVjU0STBsSG1qZUs3TmZxQ3RiK3VoK3Zmam5VTk44Y2VFdFUwUFZsODdTTmNzcHRPdjRqejVzRTBiUlNMajNSMkg0MStDZndaMFBVUEUvd0N3QisxUCt5cjRsa2p1dkZYd1QxZVh4eDRkQkJiNXRQbk52cVFqQjZLWTF5aXI5NXIxenpubjlMUDJqUDhBZ3BWOEl2MlpoY3hlTVBpSm9NT3F3Z28yaTZQSi9iR3FoZ1JsSGhneWtMZTAwa2RmbEo4WS93RGdxUjRaMFQ5clR4cDhYUGhYNEJzMjFmeFJaeDJDWEhqRkdsbXNtTUNRVDNDVzF0T0xkek9rYWd4eitjcWxHYkpNaEFxalJxZmEwOWY4dHpQbVgyZFQ5UmYrQ1VIN1dPcGZ0RGZzRStEYmk2RnhjYTM0TnRUNGIxcVFna1J5V0lXT09WNUR4aDdZMjdzN0hCWm01T0t3UDJ1LytDbTN3STBEd25yUGdueEY0dWg4YjMzaWl6bjBXYnc3NExpR3ZYMXl0eWpRTkI1a2JMYkpJZDVVS1pTNGJIeTU0SDRoZkVqOXFMeDE4VHZCV2tlRTlROFhlS0p2Q09pVzZRV25oK1hVWlA3THNzTXpZaXR3ZGdVYnNEY0N3eDFBd0I5a2Y4R3kvd0FCNGZqYi93QUZVOUJ1cml6czd1MzhBK0h0VDhUS2s1SDdxWkkwdFlKa1hCM1NSejNjVHIwMmxBNE9VRmEvVjZjZmUzL0lxUE5KMmJQWHYyV1AyVHZqRjhVdjJQdkVYd2w4QitEZmhyNFdpOFArSzVMZnhRbmpYV3RRYnhOTHJsc0xXNUxXOW1JamIyTTIxSUZDdHZSblJ4dUtscStCZjJsUDJ2OEE0emZ0RFNXYzN4QzhZZU50VTBYVjRHdWRMczc1MnROUG50a21rZzN4VzhZU0Jnc2tNc1JaVklEeE9NNUJyOUV2K0N6WHgxMWIvZ25sL3dBRlAvRzJvemVIYjJUUmZpcDRZMHJWaEdCL285L3FWb3JXaTNNZm1Cb0ZjUkk2TTNseWxTMjRLR1lNUHl6OGMvRUpmR04xcUVOell0YXl0cWx6cWxuRXR5c3lXYVhPR2xpeUFNL09pRURnRGM1d0NhNkZVbDAwVCtRU2pIb2M3TGJib3hzQ3JqZ0tCMC96bXFLaTVuZWFGWUo1cmpkbHdFM09oVTg5c2pCclRoREI4OEZqMkE3VlBxdHQvYjkwbHhjR1h6aEdzVHZFQW01VVVLdTdqazdRQm5xY1pPVGttRXgyUDZWditEV0w5cG5YUDJoZitDYTM5bDY5NU16ZkRUWFpQREdtM0NSaU12WnJid1R4eE1GVURkRjV4VU1PcUZNa3NHSjlXLzRPR3ZoZHBIeEwvd0NDUjN4VXZ0UzBlMzFhKzhFSlkrSmRITWxyOW9henVZYjJCSkhBSElScmFXNGpsUEE4cVNRa2dESS9QZjhBNElwZjhGL2ZnVCt4UCt4MTRjK0VmanZ3WjRqOEgzbmgyNG1lVFh2RCtucnFWaHJobm5MdGQzUU1pM0Vkd0ZaVllLc29LUXJzMkFKQ3Zxbi9BQVYyL3dDRGpUNEYvRWY5alB4OThNL2hCZmExNDY4Ui9FRFNwdkQ4bW95YUxjYWZwZW1XdHdQTHVKV04wc2Nza2hpWjFqVkl5TnhETXdDNGFsSFM0cGZGb2ZnQTJoVzhkekp0a3V2c3ZtNzQ3U1Z3MkJuZ093eHV4d0NRcTU2OGRLMFJHTHFXU1JVLzFtU1FxN1FNazhBRGoyd1BUOHJSczl4QVpXK1lMaysvdC9oL2tYTEd3TEl1M2NXNFhCTzBENkhIdi9ucFU3bEZPUFRaVWx4OHk0YkM4WUgxL0dybjltbU9CbU1ZV01mTVd3ZmwvVGp2aXJuOW5BdHVmSkFYc2VnNmNqcDA3MTlSZjhFMnYyR1BpZCswbCswVjhQZGM4TWZDM3hSNDA4SDZQNHAwdSsxZTh0N1BacE1sbERlUXlYTWJYY3hTMkRORXJqWjVtNDlBRDJOdHlveGJaOXRmOEU5ditEV2VmNHVmQ2ZTdkdYeDA4V2VJUEJzbXZXcVhWcDRWMFNDSk5TczRYQWFOcnVlNFYwaGtLOG0zV0VzZ0toM1Y5OFMrVS84QUJYUC9BSUlBWDMvQlBYNGR5L0V6d0w0b3Z2R2Z3MXQ3aUswMWVQVTRFaDFQdzZaWEVjTXNqeFlpbmhlUmxqOHdMR3lPOGFsV0RieC9SVlBDOXhkU096QnQ3bHQzOTdKNjFEcS9oalQvQUJGcGt0anFWalphblkzQlV5MjE1QWs4RXUxZ3k3a2NGV3d5cXd5T0NvUFVDamw2ayswMTEyUDVQZjJWditDWi93QWR2MnhuZ2srSGZ3djhVYTVwdHdRZzFtYUg3RG82REhYN2JjbU9Cc1p5VlIyZkIrNlRpdjBjL1ppLzROTE5XMVdTSFVmalI4VHJQUjQyWVBKb2ZneUEzYyszSENtK3VWV09OaDBPMjNsQjR3d3h6KzJwWnBOb0xFaEFGVUgrRURvQlEvQS8rdFZhdmNmdE95UG1mOWxyL2dqeit6ait5QWJhNzhKL0MvUkw3WGJVaGsxenhFcDF2VWc0NlNKSmNibGdmM2dTUDB4aml2cHQzZWQ5MGpNN1l4bGprMVIxL1hySHdwb2srcWFyZldXbDZaYTRNOTVlenBiMjhJUEh6U09RcS9pYTVsZmk4dXZ4L3dERk02SHJYaVRkd3QySWY3UDAzbm8vMm00MitiR2V1KzFTZmpvRDBxZEVSN3pPeXdCL2tWUjhUZUo5TDhFNksycWEzcWVtNkxwc2JiV3ZOUXVvN1czVW5vREpJVlVIMnpYTi93QmdlTVBFNHpxWGlDeThPUW5uN0w0ZmdXNG1YMVZydTZSZzZuMVMyaGNkbXp6WE02djhNTkQrRjN4bThIZUxiV3pra3VMdDUvRFY3cUYvY3pYOTFFTG9MTGF5bTV1R2tsR0xpM1cyUlE0R2RReGpwZ3YyRGxYYzZwZmluY2E3R2Y4QWhIUERtdDZ6dSs3ZFhjVGFUWUQwSmt1RkVyb2V6d1FUS1JnOUtxNnJwSGlLNzBtNTFEeEw0dXMvREdrV3NMM0YxSG95SmJwYXhLQ3orZGYzUVppaXFDVExISGJFQUUvTGl1emtiMys4YThkK0ovN091dmZFRHhqNHdXMTEzN0g0ZjhmYUZkYVBxajNrd3ZKYkZKdFBOb3NkbGJHQUNKVmtXSzRPNjRaR1o3a0dMZE1KRU5lb1JzWGRVOGJlQi9nZHIvaUM0aDBIV1o5WjhPYU0ydGFycXNsbE5jWGYyQldBZHhmM2JlWmRLaTcyS3hTU2hBaFVoR0tLMlBxM3g3OGFYM3hlMCt4MHJ3OTlxOE4yOS9mMldyL1lMZjdiUEFsbmVpQ1dYenZNUWI1TGE2MDY2aGhpaWtjZ1hxc1dNS3EzYStGZmhqNFkrRE1PancvYkx0bTBtM3ZMSFJsMUM3TXR4YldkekpESkxhUXFvQmtoRFFRN0VLdDVhb2lKdFJWUWErZ2oreDlKaDAzdzU0YnQ5SjB5MkJFRWNrYTZiYXhxU1NmTGdSUzZuY1NkclJ4ZzVKemsxU1NXd1hYVThYc1AyWVBHWHhOOE1hTG8vakh4RnJtbXcrR2RXc3RTaXZ2N1JqMURWcmkvdHJEVUxPZS90SnBSTUxTT2FTZTB1SWtiYzhXeWNiWWk2aGZZZEUwYlF2aGJxV3J6ZmFJSWRYOFZYYWF0cU1jTVFXVFU3d1cwRnM5d2x2R0MyNTQ3ZUxjRURjcG5ya25TL3dDRWN2TC9BQ2RTMWE2bFZ1c0ZpRFl4ZXgzS1RObi9BTGE0UDkzdFYvU3RFczlBaGVPeXRiZXpTUTVrRU1ZWHpENnNmNGo3bkpvQnliS0oxalV0UlA4QW9lbG1DTS84dkdvU2VTTWYzbGlYYzV4L2RmeWo3anJYSGVFL0RGeHBIeGU4VGFUcVdxWHMxcnIwVVhpT3lodENiRzNFbUV0YjJOQkczbVlWbzdXVmcwckJudjNPT3RlazF4dnhjSDlnemVIdkZTL0wvd0FJM3FLcGZPRGovaVhYZUxhNERIb0k0M2UzdW56MnNRZTFNRjJPbzBuUjdYUXJVd1dOcmEyTUxIY1k3ZUpZbEo5Y0tBTSs5V2NWbGp4YmEzSksyS3o2c3cvNThsRWtmSFVlYVNzV1IvZExnKzFHeldOUSs5Tlo2WEczWHloOXF1TWV6TUFpTU80S3lEMzcwaVRWa2tTR0Y1Sk5xUnhnc3pNUUZVRHVUMnJLSGkyM3ZQOEFrSHczT3FaNlBhb0RDZmNUTVZpYkhjS3hQdG5pbFR3blplY3MxeXI2bGNLZDRrdlhNMjF2N3lJZjNjWi82NXF0YWpBNTNNUzNQV2dETEVHcmFnZjNrOXJwa2ZRcmJKOXBtOWlKSkFFWDNVeE4vdlVXM2hLeHQ3bEpwWTN2Ym1NN2ttdkpEY1NSbjFUZGtSL1JBbzlxMUU1SnFEVk5SdHRGdGhjWGx4YjJzR2Roa21rRWFaUFFaWWdaUHAxb0FsNTNIZHVKOVRYT2FXMzlnZkZmVXJQT0xmeEpacHFrQS82ZUxmWmIzT2ZUTVRXSkE3bFpUMk5hTGVJcE5Rd05QMCs3dWpuaVdkVGFRRDZseDVoQkhRcEc0NlZ6L3dBUm9OUTB2VDdEeEpjWGtNYStGcnhkU21ndG9mayt5bFdodTk3dGxuQ1c4c3NvQ0NQTHdwd2VsQlNYUTdmSEZVdkV1Z3grS1BEdDlwc3dVeDNzSmo1NkszVlQrREFIOEt2TXV4eXY5MDRvemlqeUpQbUxVdmhuNEp0L0UyaytMdGYwM1NiWFd2QnNzbHhwMnN6cXNOenBtNUhobGpXYmh2TGtqZDBhTEpWdHcrVXNGSTlVaWtaaUd6dUJ3ZUR3ZnAvT3Z6Qi80TEsrS0UvWS93RDJvTmUxalZ0VHVyUHdyNGd0by9FMXFIbExScThyTXR4R2lrOHViaUtVcXE0LzFpRHBpdm9uL2dpdCszQzM3ZUg3QzJpK0tOUWtWZkVXZzZqZWVIOVloNC9kUEM1a3R1blhObkxhNWJ1NGs5SzdwVVlxakdTZXIvcjh6Q0VtcWppMS9YL0RIMTlFY3QvZ09sV0ViSjZZMjFYaE9SOTBoVjlhbGlmS3IwNVBidjhBNTRybE55ZFcyK3RTcWQrUHBVTWJBa1piUHJ4MHFWUm43dmY5YUFKbGZQOEFQNlU2TGovNjlSbzM1OU92U25xY0FVQVNwOHBIWUFWSUd3ZmJ2bnZVSTRIZjN6VGw2OWZ5b0FzSStCOHA2OVIvU3VXMVA0SStGZFcxV1RVRjBlTFROV201ZlV0SGxrMHUrYjZ6MnpSeUg2RmlENlYwcXNRUXcvUDFxUURjTTlPTzRvR3BOYkhMdytGZkdYaG8vd0RFbDhjU1hrWEcyMThTYWJIcUVhRDBFMExXOC80eVNTSDYxYWcrSzNpclFjRFhQQXMxMUVvd2JydzVxY1Y4RDZzME00dDVWOWRxZWFSMDU2MTBTdm4rWElwd09SL3RVQ00zUlAyaFBCdXM2aEZZdHIxdnBXcFRZV093MXFLVFNidVkraVJYU3h2SjlVREQzcnRtamFJRGNyTHU1NUhhdVcxYlNyWFhkUGt0TDYxdGI2MW1HMlNHNWlFc2JqMEtzQ0RYS1cvd0cwWHcrZDNocTQxcndaSXB5aTZGcUQyOW9qZXYyTnQxbzMvQW9XbzlRc3Y2L3I5RDFRZm4vV3BGSlA4QTlldk00WmZpSjRYeDluMWJ3MTR3dDE2UjZyYXRwVjQzdWJpM0R3bjZDMVg2aXJVSHgzZlJCdDhTZUQvRm1oK1djUGRXdHFOWnN5ZlZXdEM4KzMvYWtnai9BQXFiQnFlaHFjSC9BT3RUd01uUDg2NTN3SjhVZkRYeFA4NWZEdmlEUjlibXQxM1R3MmQya3M5dG4vbnJFRHZqUHM0QkI0cm9BMUt3dkpraU95YzVQMHpVaVhUZC9tcUZUbW5VaE9OeXdzaVAxK1gzcHQ5cFZ2ckdteldseEhEZFdkeXV5YUNaQkpGS3A2aGxiSVlleEZSS01qK0w2MDRjTnhRTzJ0MGZJbjdTdi9CQW45a3Y5cVR6cDljK0RQaG5RZFVrRFkxUHdtcmVIN2hXYkpNaFcwS1F5UG5uTXNiNVBYTmZDUHhtL3dDRE12d3JxT3VlZDhPUGp4NG84TzZhemZQWmVKdkQ4T3R5S00vdzNFTXR0MEhRR001NHl3NjErMXFYTHgvN1E5NmtGNnArOHRFVmJWYUQ1cGRUOC92MnMvOEFnbmQ0aytBUC9CQkh4bit6MzhGVzFEeFI0bHMvREpzWTVmSWppdk5lYWEranVOVFpJZ1Fva21oZTdXT0VNY0JvNGd4SUJQOEFMZDQyOEU2cDhMdkZOeDRlOFZhTHJYaFBYTEJ2S3VOTTFxeGxzTHEyWWNiWGlsVldVakhjVi9jcXF4eTkxelhNL0Z2NEQrRFBqOTRXT2krT3ZDUGhmeHRvN2Y4QUxqcjJsUWFsYmo2Sk1qS0Q3Z1ZTbkpTNXR5b3VQTHl2b2Z4cGZzdC90RlNmc3o2ejRndlY4Qy9EYngvYitJZEh1Tk04bnhaNGR0ZFhYVFpuamRZYjIwZVZHYUNlR1JnNEtIYSszYTRPRksrV3cyRFc2S295d1VBQWs1eml2NmpmMmovK0RXTDlrdjQ1dmNYV2hlR2ZFdndwMWE0ZHBXdXZDR3R5eHdzeDdHMnV2UGdWQi9kaVdQOEFEclh3cDhjZitET2Y0cGFIcVVaK0dYeG84QmVKckF1ZjNYaTNTN25SYmlGU2M4eTJxWFFsWWYzaUUrZ0hGYlJyUiswckM1ZE5HZW9mOEdobndhdC9oOThFL2pCOFd0YVpiWFM5OXZwQ1R5NVZiVllrZTh2bVBxcGdiVEd6MjJuMXI4ZlBpcjhTZkN2N1p2eHI4ZjhBeEs4YnhhOVo2NThRL0ZHcGErczl1NlNyYXdUek0wVU94aHlzYTRVWVljQURvSy9vZThiL0FMRG5pei9nbnY4QThHOS94SytFL2d0RjhhZkVSdkJlcUxxVTJrV2tnL3RLNnZJL0t1amJ4OHlONU5tVEZGeDVqaTJqSlVPeFd2NXEvREEwdWJUTFcxczc2em1rdDR4RzhaZmJJckx3VHRPRDFCNml0S1BMVXJ0dTIybjlmSWpsY2FLODIvdy80Yy90RzJmTm5BcjVyK1AzdzRtOEMrTVk5UTA5Zkx0Wm44K0ZoL0J5TnlmaHhnZWhGZlRYbCsvRllmeEQ4RlIrT2ZDMDlpeXI1bU44RE1QdXVPblB2MFAxcjhrOFJPRVk4UVpSUERSWDcyUHZRZlcvYjU3ZXRuME82RHMvSTVyNEhlTDE4UitIdktadm5RYjFIb0QxSDUxcmFWNEsvczd4YmZhbzhubWZhUUFpa2NwNjgxNDk4T2RWdXZocjQ0RnBjTEpIR3NtMWtQWWRDTWY1N1Y5REtWbVJYVWhsWUFxUjNIclh6WGhmbUZQTnN1aGc4ZW43ZkJUNjc3TlJkdkpOeDhyRGxlTzNVcHRBVHlLK2V2MjU5VER0NGYwd01DeWw3bGw0N2tLUC9RVFgwZTZZSC8xdXRmS1A3VlV4OFFmR3k2RE4rNDBxMlNNRCs3aEF4UFB1eHIydkZYR2ZWOGlkUHJVbkdQM1BtLzhBYlRtcVh0WStiL0czajI1OE0vRUpKMUFraGlqSW5oQndIUTRHUDhQcCtmb21peUhSWHM5U3Qxa1hUOVFUelVMQTlNLzBPUjlSWGlmakdYL2hJUEY3SnRaL3RGeXNhSC9aVTVQNjRyOUVMMzluNno4VC9BSFFOSDhwSWRSMDdUSXZKa0s4aHlnWmxQc1dKL0d2NTF3ZkJlTHo2cFdsbDd0T2pUVWt2NW5mNGIrYVR0NW9NTC9DZk4zUE9QaDNyQzNqTkV1RyswTGxUbnFmVDYxN3I4TnZGbjlzNmF0dE0vOEFwTnVBT2VzaTlBZnJYeXBva3Q1NEwxMyt6N3RaSVo3ZVhBMzV5Q0s5WDhLK00vc3QzYjNhdnNFaDR3ZWpkMVAxcncrQnVOTVJrR2RLcE85dmhuRGE4YjYvOXZRZXE3M3NkV3ZMeXlQZWpKdEZSVFhXRFdSWStKbzlWMHhKNC9UQkdmdW1xdmlueGZaK0QvRGQvckdxM1VPbjZYcGRyTGUzZDNPZHNWdkJFaGVTUmoyVlZWaVQ2Q3Y3a3dlT280eWhERTRhWE5DYVRUWFZNNWR0elZ1NzViZEN6dHRWUVdMZWdGZUgrSzlaazhaK05XVVphTXNISTlCMFVmbFhRNno4Yk5FOFovRE8xMXp3OXExbnJHazZ4RVh0YnUxazN4eUprZzRQVUVFRlNwd1FRUVFDQ0s0bVh3N3FtcWZESHhLdW4zRTFqcm1xNlZlUTZkY1JuYkpiM0x3T3NNaSs2dVZJUHFCWDVyeGxYbm1lWjBNaHc3MHZ6VDh1MS9scjh6Q3A3MHVYdHFlbFh2akxSUGhWb1duL0FOdGFycCtqL3dCcDNjZW4yNXU1MWgrMFhNZ1l4d3J1SXk1VldJVWM0VmowQnhmdnRaMk8zUDNlT2EvQWp4WisyQjRsL2FZLzRKWFNlRGZpeHIxL2VUZUUyOFBmRTNSTmJzMExYbXArR0pidVRRTlhnNU9XbnNMdTV1bzl6TnVjWU9BcVpyOUx2K0NiWDdVdXZmRmo5bkdidzc0NHZJN3o0bWZDWFZicndINHVtRW0vN2RlV0pDUjN5c2VaRXViY3d5aVhwSTdTa1pBcjlOcFllT0hveHB3MmpaSFRHSmUvNExFL3RIZkVmOW5qOWszU3ZGUHd2dTQ3WHhGQjR4MHV4a1dZanlKNHJuenJlT09Zc1FQSk4zSmFiK1JsUVFUZ212ZzM5c2YvQUlLY2F0NFMrT0g3TWY3Vm5odUxVckx3L3dDTXRBbDBieGo0YmlWekpETnBkM01tcTJFcUhCM1J4YWhkUEdYQStheWhseGpGZmNmL0FBVVUrSFgvQUExTCt4TjhUZkFjSWFiVWRjMEtadExWV3d4MUMzSzNWbUFlMmJpQ0VFam5CTmZsRDR6MXU4K09Id2s4UVgxanBMYXRwL2pheDA3OW9MU3JSSW04aGRXdG0vc3J4aHByTW9KQzNCYTR1Q2dBR3lLTVl5Um5xb3lVa1RZL2MwL0VtejFqU29MeXd2SUw2d3ZJMXVMYTVoY05IY1JPQXlTSWU2c3BCQjdnMThBZjhIQVh3ejBmNHIvczVlRWZHT3JSaVN5K0h1ditUcTh5UmVkTGE2TnFpclkzc3NhODVsamMyY3FaeUEwUU9EaXU2LzRKNTZMNHcrRlg3Q09sMnZqdTR0N1BSL2gzWTNhdzYvZFhVVFFTZUg3Y3M5bmR6TWpHT0hGcnNYeW5aWEFpVVl5UUQ4SWZ0bi84RjlOQitKM2dEeEI0UDhEL0FBMHV0WTB2eEJZejZkYzMvaTY3TUlhS1JHUmlsbmJOdVZobmNyTmNaVWdIWnhSVG96NTc5Z2wyUndlcTYvOEFFSHh6OGRmaHY4VU5BMDJiV3ZqTm9rTUdpYXhhV1phNHVOVzhVZUdaMHNab0daUVRJbDdvc3NUTUZINzJSV0FKQ25QNlcvdEJmOEZGdmhMK3p6QzMvQ2FmRUxROUUxSkYzSFJMZVQrMU5hUTRCRWNscmErWVltN2Z2V1JRZU00cjhLUGkzKzNmOFJQaXBIRG9PcGVKN3ErOEthVmJORHArbVJ4dzJFTUk4a1IrYXdoVk44K3hkcGxmZElWWjF6OHhGZU9hV01SQThLdnBqQVBOZGM2Rk5yM3RmNi9yc1R6UFpINkMvd0RCUUgvZ3IxNEEvYWc4WGVFNWZEZnc3bnZmK0VIdlo3MjExRHhpSXByWFVvNUl3czlwTnAwUklNRXZseEU1dUMyWWtHQmsxOGtmR2Y4QWJwK0pIeDh1dFl1ZGM4UlhWbE40Z1NHMnY3YlJRdWs2ZmVXc01Ramd0NWJhM0NSU0pHZzJxWERISEJKQUdQTTVySDdaS3FLeUlaQ0VET3dWUm4xSjRBQjZuNm1xYzJpVGFaZlhGdHFETnBrOXZGNXF4enhNR2tKQVpGQUEvaVVnaGp3Umc1d1JXa2JSVm82RThwN3g4SS8rQ1pQN1JIeHc4Q3crSlBCL3dMK0t2aUR3L2RSK2RiYWhaZUdycHJXN1EveFF2c0FsQjlVM1Y1SjhVUGhING8rRVBpcSswUHhWNGQxdnd0cjJrcXIzZW1helpTYWZld0FrQWJvWmdzbk9RZUJuR1QwQkkvcXIvd0NEZi9YUEdtdWY4RWd2Z3ZONDdqMXBkWVhUYm1LemZWUTR1WjlNVzhuR252aGh1OHI3S0lSRVR3WWxpS2txVko1Ny9nNGUvWTQ4TC90VGY4RTAvSG5pUFZMR3pYeGg4SjlKbThTK0h0WlpBTG0wU0hEWFZydis4WUo0QklwaUoybVR5bnhsQlVSdTlUU1Zsb2Z5cHd3dEZIQmNiN2VUenBOdmxCaHZHRDNYc0QvbnFLOXIvWWgvYlI4Yi93REJQbjlwTFIvaWQ4UDdpeVhXdEg4MjNlMXZvbW1zZFV0WlZLUzIxd2lzck5HNHdmbFpXVmxWMVlNcWtlVFI2ZkhIY0ZsalVOL3NnNEgwOVB3cWRBQjlHNDVwM0pQMEovNEtkLzhBQmV1SC9ncUo4Qk5QOEhlS3YyZi9BQVRwdXFhUE05eHBuaUJ0ZnZybTUwU2FSUWtyMnFSK1NCdlZWeWt6U3hrb2haR0tLUitmTWNVYk16d1d0dlp4c2QyMkxleWdmVml6WUgxcHNFV0QweitPUnpWcXp0bWtPM0pDc01mNzNOSE1IS1J4UXNPUTNIUUVkcXZXMW9GWTg5UVR1NkhvTVVSMjhpeHN1eHZYb2NqL0FQVml2WHYyWnYyTHZpeCsyRnFjbGo4Sy9oMTR1OGJPSmhEUGNhYnA3dFlXemVrMTIyMkNFYzlaSkU3ZGNWUE5aRnFMZXg1UERHd2NzcXIxd09PdlBYK2Y0MVpTMEV5Nzl5bzJPcWpyMDViUCtmcUsvWEw5bFA4QTROS1BpZDR3UzN2dmk5NCs4TmZEMjBabGR0TjBTTCszZFYyNTVqYVRNZHRDeEdmblI1d0RqNVRYNlNmc3QvOEFCdjcreTMreTM5bnVvdmg3SDhRTmJ0OEVhbjQ0bEdzc1cvdkMxWlZzMVBvUkJ1R0I4eEl6UnE5ZzBXN1A1elAyV3YyQ2ZqSisyVGQ3UGhmOE52RlhqS1B6UEtrdjdTejh2VG9ENlNYa3BTMmpibm84Z3grZGZwTit5cC93YVplUFBFNlc5OThZdmlKb3ZnMnpZaVI5SDhPeGYyeHFXM3VqM0Q3TGVGdjlwUHRBK3RmdXpaMmNXbmFmYjJsdkRGYjJscWdpZ2dpUVJ4UUlPaW9vR0ZBOUFBS2w2Q3E1WDFZdWRkRWZKUDdMMy9CRG45bVg5bEdTMXZOTCtITm40dTE2MElaTmE4Wk91dFhXNEhPNFJ1b3RZMnp6dWpnUnZldnJaVGlHT01jUlFvRWpRY0xHbzRDcU9nQTdBY0NvcjI4aDA2d211cm1hRzN0YlpTODA4cmlPT0pSMVptUENqM0pya28valRwMnVKL3hUTmpxM2pEZDkyNDBtRmY3UFlmM2hlek5IYXlBZHhGSkk0NmJTZUtOSWs4MHBIWXRVR3E2cGE2RHBVOTlmWFZ0WTJOcXUrZTV1WlZoaGhYMWQySVZSN2tpdlAvREd2ZU1QaWJlNjdhM1Y1cC9naHRCMUp0TnVyYlRFR3FYcEpoaHVJcFV1N2lOWUZWNGJpSnRuMlI5cExMNWhLbXVnMDM0UDZCYWFwYjZqYzJiNjNxbHF3ZUMrMWlkOVJ1TFZ2V0ZwaXd0ODlTc0lSU2UxSE0raURsdHVWWS9qTGE2K28vNFJuU2RhOFZodWx6WndDMzA4RHM0dTdneHd6SVQzdGpNdy91K3JqbzNqUHhRK0wzV3ROOE0yN0VmdU5DZ0Y3ZUtldysxM1NlV1ZQT1FMUU42T01aS2Z0QTZ2NG0wYjRSYTVxSGhPT2E1OFFXVWNkekhGSEVKcmllRkpvMnVFaFVwSURjTmJpWVJaamxIbWJNeHlENUQ1djRzL1o2OGZlTGZpWjR1bXVmRmpMNGI4UWFXTE8xdEpiKzR1RTBhNmEzczJpdjdaZDRoZVd6dnJGcFkwRnZiZVl1b094bUJqRVJMUHF4clkwOVQrSW53cCtGK2dhcDQwRjlCNG91dkN0eFp3M3VvdzNMZUlOVzA0M1YydGtqb3p1OHFSZWEwZ0t3WVhFTTZvak1oU3VzK0hIeGZ1dmlEOFN2RVdrdnB0dmE2ZnBlbWFkcXVuNmpEZlIza092Vzk5TGZDRzZ0NUVPRENZclJEOHdEQjVIQTNJcVNTNUVuN1AvaFBRTlF2ci93QVIzaTMrblhkNzlxczdIVW5oaXNkUGM2bXVxN0lnQUdrLzA5RWxWWldjS0VSRUNydkQ5ZHBGOTloc1k3UFFmRHp3MmNRUGxpU0VhWGFSWkpZZ0lWODBaSkp5c0pVa2s1cWtrdGtPVmpvK3BybFBqTnBOdjRoK0crcWFTK3AydWthaHFNUC9BQks3bWR3UEl2b3lKYldaVjZ1MGR3a1VtMEFrbE9sYVowUFVOVVUvYnRVa2hqWVlNR25wOW5HRDJNaExTRWorOGhqejZEcFZyU1BEZGpvRWtrbHBheFF6eWpFaytOMDgzKy9JMlhmNnN4TkJCejN3L3dEaWxKOFZmQStrNi9vdWgza0Z2clZsRmVLTlJZMmEyN09nTFFzckF6QjQySlJnMFFHNVNNMXIvd0JnWDJvbk9vYXJQczZHR3dVMmNaSHUrV20zZTZ5SUQvZHJEK0dvL3dDRWE4YWVNUERmM1lyZTlIaUN5R1ArWGZVWGxra0JQZHZ0MFYrMk95U1JldlBhQUZqZ0RKK2xNYjMwS2VrYURaNkQ1bjJPMWd0V25JTXpvZ0VrNUhkMis4NTkySk5YRHdLeTVQR0ZoNThrTnRJMm9YRVoydkRaSVp6RzNUYTdMOHNaL3dDdWpMMzlLWVpkWTFQSVdLMDBtSTlHbWI3VmNFZWhSU3FJZmZmSVBha0kxOXVSOU9UN1ZrdjR6c1pITWRtMDJxektTdXl4WHpsRERxclNaRVNNUFIzV2svNFJHMnV6L3dBVEJyalZqMUl2WER3K3g4bFFJc2pzMnpJOWExVlRDS3Y4S2pDZ0RBQTlBS0JHWHYxZlVPMW5wY0xjZk5tNXVNZitPcEczL2YwZlhwVlBYL2hkb3ZqalFML1NmRU1FMnZhZnExdkpaM2NkOUo1aXlSU0tVY0NNQVJvMjBrYmtSVDN6WFJZcU81dVk3TzFlYWFTT0dHTVplV1JncW9QY25nZmpRTzc2SFBmQ1R4QmZlSi9BRmpKcTA1dU5hc1dsMHpWSmNCZk92TFdScmVlUUFkRmtlTnBGL3dCaVJUME5kTGpGZWM2SjRzajBMNDJhM3AybjIxN3FOdjR0czQ5ZnRualRaYnRjMjZ4V2QyVm1mYWpSK1YvWmhBajNuYzB4d2VjZGg5bTFiVWY5ZGVRNmVwNngyU2VkSVA4QXRySXUwZytnaUJIWnU5TWIzTks4dm9kS3RXbnVwb2JXM1Q3MHMwZ2pqWDZzVGdmaldlbmlYN1lWR24yVjVmQTgrY1UrejI0OVBua3dXQjlZMWNmcFVsbDRYczdPN1c2K3orZGVSL2R1YmhtdUowOWxkeVdWZjlsU0I3Vm9LdTQ1NjBpVExGanFkK2MzTjdIWng5ZktzWTl6RDFEU3lBN2g3cWtiZTlUYWY0Y3M5SnUvdEVNSCtsNDJtNWxkcHJnajA4eHlYeDdaeFdoZ0R0L0txMnA2eGFhUnRGM2NRMjdTY1JvN0RmS2ZSRjZzZlpRVFFCS3VXWFB2M29tdDRiNjFrdDdpTkpyZVpXaWxqWVpXUkdHR1VqMElPS3pUclY1ZEgvUXRObTI5Zk52SCt5b2ZYQzRhWEk5R1JRZjczZWdhSGRYaHpmYWxQSXJkWTdKVFp4L1hJWXk1K2ttUGFqMUFwL0NpNW1Yd2JIcDEzSTB1b2VINVgwaTVaODc1RENkc1VyZjdVc0JobStrd3JwQWNDdVAwalM3ZndQOEFGS2EzdFlJYlhUL0ZGbjlvMnhxRVg3ZGJiVWRpZjRwSmJkNC9VN2JGanpnMTJBNmRQMDZVRlMzUHlqLzRPNWYyUzIrTVg3QlBobjRxV0Z1Wk5VK0R1dUQ3WTRiR3pTOVNNVnZNeEg4VzI2anNjZjNROGg0R2ErRWYrRFUvOXE3L0FJVnIrMXQ0cytFK29YUVRUZmlkcEgyM1RrSlBHcDZlSGtDanNOOW85MlNlNWdqSHNQNkdQMml2Z1RwUDdVUHdBOGIvQUEyMTVoSG8vanpRcnpRYm1Vb0dOc0xpRm8xbVVOeHZpWXJJcDdNaW5nZ0d2NDQvaFg0NThXL3NCZnRqYVZyRXRySlplTXZoRDRxemUyVE1WSnViSzVNZHhhc1IwVi9Ma2liMVZ5TzlYU2xhZG5zeVozY0xyb2YyRVc1M2pnYmM5ZWMxYWhiUHAxNlZ6ZmdMeHhwWHhLOEdhUDRrMEc2VyswUHhGWXdhcnB0MEQveDgyczhTeXd2K0tPcDY4WnJvSXp4dTl4amcxVFRUc3dUdXJvc3d2dEc3K2VNVktnNHo3ZDZyeHR4K3RUcU1uLzY5SUNSY3NweDI0d2FlR0twOU9jR21SODhidi9yMDROZ1l4eDZIMHFldHdKbGJZdlBLOXFWR0pINWRLalhqcTN6ZDZjcDNmbm42MEFUQTVKL3ZaNitsU0llbjE5YWhIM3NaUDRWSW1UejE5U2FvQ1pPQU9sUDNIUDhBOWZwVVNubnJ0OU04bXBGSi9UTkFpUUhrL3dDY1U1RzRQOURVU3R6OTc4NmVvM04rSFVpZ1pKbkIvd0FhZW5EZGNFZENPTVZGbkovVW1wRkhPT3RCSmkrTlBoajRkK0k0aC90N1E5TDFlUzFPNjNsdUxkV210Vy92UlNZM3hzT3pLd0lwM3dZMUc3czd6eEY0YnZMNjcxUmZEbHhDTFc3dXBUTmNOYnpSNzBqbGtQelNPaEREZXhMRkdUY1MyV08wdkpYcHlldGM3K3psSC9hbmhqWFBFVEE3L0ZtdTNkNmdQOE1FTEN5Z3dlNnZGYUxLUCt1eHFkaXQwZWlLMlNLY2FqaitZMDhWSUNxTnB6K2RQUE5NeWNmMXB3NFAzYUFIVVVaNW9vQVRBcDhVN3huaHFiUlFCWlMrWS9lQWI2R3BSZHhTL2V5djFxbXJjZjhBMTZNNU5CUFV1bTJqbEdWSTlRUjJydzc5cC84QTRKbGZBVDlza1hFbnhOK0VuZ2Z4WnFGME5zbXFUNmFzR3FZOXIySFpjRDhKSzlrQkt0d2ZwVTBkN0pIL0FCYnZyUlpQY3BTYTJNVUx0LzhBcjBwVEl6ajlLbEEyamltc200MTU1MEhtL3dBYi9odC9ibGwvYTlqSC93QVRDMCthUUtPWmtIOVIvS3Jud2E4WEw0aDhOcmJTSC9TTE1BRVo1Szl2eXJ1WlUyL2xYbW5pYlJmK0ZZK05yYldMTmR1blgwbmwzTWEvZGpZOWZ3UFVlLzRWK1Y4UjVZOGp6aUhGT0UwcHl0REVSL3V0cGUwWG5GMmN2Slg3bWtaYzBlUi9JOUF6dWZIdml2aUg0eWVJWk5XOFVlTE5RNnFaNVFwUHB1STQvVDhxKzA5ZDFOZE84UFhsNHJibHQ3ZDVsSU9jNFVrVitmM3huMVgrd3ZDVTNWWmI1bWJkbnIvbitsZUY0eTRwU2hoY090cnlsK1NUL0ZuQmlIYUxPVi9adDhBLzhMVitQR2g2YnNiN1A5cDgrY2dIaEFkejgvN29OZnBtV1ZjNEcxVjZER01WK2QzN0hIN1FYZ0w5bVhYWlBFSGo3V29mRDlycWtSdDdlOXVCL28xa3ZuMjhMenp2L3dBczRSTGRXMFJrUHlxMXdtU0FTUitoVjFLMXV6b3cyc3ZVZWhyMWZCN0s0MGNzcTQ5L0ZXbmIvdDJHaS9IbU40NlVvcGYxL1NQSy93Qm9yNFQyZml4STc2MWVDSFhBanZGQnZBa3ZFakFMbFZ6bGlnSUpJNkFqT01nMTQ3NE4xQjVKSk5QdUcyRnVCdS9oY2REL0FDcnlQL2dxNzhMOVgrTHY3Zkh3RjhQYUg0cDFMd1g0aThjZUR2RitrK0U5ZXRiaG9Sb3ZpQ3dPbmF2WlRNUUNDanRhbU9SV0JEeEdRWXpnamp2MkdmOEFnb0hZZnQ1Nmo0eTArNjBPYndqOFR2aCswRWZpcnc5SkY1WDJTNEk4cTc4b1pQN3FPOWpuakF5U3FtTGNjbm40RHh2OE9wU2E0anlxbmVjZjRzVjFYODJpK1V1K25VMnB2bVZtZlovdzQ4ZXZvOTIxamVOdDUya2VoOWEvT0g0OC9FcjRqZkQzOXY4QS9hSzBWOVkxM1hQaDE0cDE3Uy9CL2luUWxpTTdXMmsrTE5FaHM5TTFheng4MytoYWhDWUpBZ1lzdHpzVmNra2ZmdW4vQUdmeFJvUW1aL0x2cmY1Q3dIVWUvd0RLcU1IaEN4MUh4cTJ1TmJ3Mi9peVBTbTBWTDRmSzF6YU5La3dqWS94QlhUY3VmdWxteDk0NThEdy84UU1ad3psOU5ZK0RxWU90ZDA1cHBxRTFlOEpkcnZwMzFXNHBRdTNidFk4OC9ZbS9adHQvMmRQMmNQQi9nSVEyY2Qxb1dueFhQaVc1dEpIa2h2dFhhSkRlM0FaamtpU1pXSTZER01Lb3dvOVcxTHg2dGxkbzBMZVdzSkJqQVAzY2NqK2xmbmYvQU1GUC93RGdvQjRmOE42UDRxK0g3K0k3ejRaNmw4TmZFdWdhdG8rdFNyY3pEeERxMXJkdGNTMms5dGJSdTR0akRFSkloSUFzaEVVckZVTU8vTCtCWC9CVnJ4aC93VVcvYU8wMzRaL3MvZkQ2eWp2TDZON3k2MS94amRzMW5vMWpFVkUxM05hV2piaXE3MFZCOW9EUEpKR20zTEhINzN3YncvaWFOS1dhWTMrUFhmTS83cWVxaXZ2MXQxTXFNYjNmVm5oUHgvOEFnRHFsakY4VXZoL29taTZycTJyZkIveDFlWDJqNmZwOXE5eFBxZmdieGZDWTd1MHRva0JhWjdhZHhJcEFJams4d2pEQTF1ZnN3ZnRaK0gvMk12R21sK04vaUo0NThQYURONG84QVdYaG54cjRmM3pYbXQzT3ZhSks5amFYMGRyQ2p0dGtzNC9MWjVmS1V2NWpiaVNNZXFmOEZtLzJHSXZnUjhQL0FBYjQ2OGUvRWY0aitKTkcxalZQK0VVK0lHc2FXTFRSUHNsbGRRdWJKNDRMV0FnV01WMmltU0s0YTVadk5VQnk1Qkg0MC90SCtISS9BWHhLdGRBdGRTdU5XMHZUN1JQN04xSzkwK1N3dXJxMWIvVmViQytXVFlvQ0FaMjRYZGtCc0Q5R2pUZzQybC9YOWJqdEpmMTVINlcvdEYvOEhHa0VIMmlINFcrQUxpNGJwRnF2aTJmeTE2ZmVGbGF1VDZITFhQMVh0WHc1ZWY4QUJUMzR2K0R0VHNiandqNDF1dkRsbExMZGFqZGFCYTJrRXVpaTd1Q1JjU05hVEk4VW5tRXRJRmtWMWo4MEttM0ZlR1hFcEJhT1JUdlFrZE1iVDcvaVRXVHFXanRlV0V0eEhKR3pXK0MwV0R1ZFQxWmV4eHhrWnpnNUF3R0kxcHBSVm9xd3BIc1B4Sy9iNCtLM3h2OEFoTG9mdzQxanh2cmNudzU4TVFKYTZiNGJobFdHd2lqamN5UmgxVUEzSGxzeEtOT1pDbUFGS2dLQjVqY1BoV0c1bDNEQllucm50L25pb2RFczRwZE50ZFEwK3p1LytKZm1IVTVwNUZhQ1JwTjNsaE9BUVNvWWJSay9LVG5BT0doK01xZHh4MzdmL1hweWxkM0JiR3A0OCtGc1hobndQNGY4U1I2eGIzR25lSVBrRnVxU2ZhSVo0MmRiaEQ4dmxaanhHK0RJSDh1OHR6dCtadHVYcGxwYngyVi81TTBrMXMwNkxhdkpENWJ5Z0J0eHpuakdWQkFKeVdYc0RpM1o2N2QybG5KYXd6dXR2Y01yeXdrN29wR1hPMWloK1VrYm13U01qY2NFWk5RU3ZKUElaSk43N2pnN2oxNXBzU0lBZHpFbnIvUFBwV3Y0SzhYM0hnN3h6b1d1UTJXajZsZGFEZlFYMEVHcWFkRGYydHkwVEs2eFR3eUtWbmhPeFZhT1RLbGNyakJyTTJ0ODN5aFF2NFlxVkxWZ2VkekVjL2hTdVB6UDZZUDJSdjhBZzV3L1puK1BIdzBzN3o0Z2VJSnZnOTR1aGlDNmpwR3E2ZmVYVm41cXFOeldsMWJ4U0xKQ1Q5MFNDT1FZSUtuQVp2akgvZ3V2L3dBSERYZ3Y5cHo0QmF0OEUvZ1RKcWVyYUw0b2RJdkUvaXU3czVMR0c0dEkzV1FXZG5GSUZtSWtkRjh5V1ZJOEloUlZjU0YxL0hXMjB4cnAyKzhwSHl0M3lQOEFQNFY2RCt6OSt5WjhSdjJwL0ZMYUw4T1BCSGlyeHhxVWJCWll0RzAyVzdXMnowTTBpank0bC8ycEdWZXVUUnpwSU9SdG5tMzJUbGM0K1k0ejc1eGl2ZXRaL3dDQ1Z2N1NQaG40ZUR4WnFId0QrTGxyNGRXQTNUM2IrR0xyOTNFTUh6Skl3bm1JbU9kektCako2Vit1SC9CQ2IvZzN6OGZmc3QvdElXL3hnK091ZytGYkM0MEd3ZHZESGg5ZFNqMU83MC9WR2VNTGZUZVR2dHdZb1JONWUyVjJXU1JId3JScVIreTBNQmlsRW01aElwM0JnY0VIMSt0Slhld1NzdEQrTkQ5bkQ5anY0bi90ZCtJUDdOK0YvZ0h4UjQ3dUZjUnpuUnJGcmkzdFNlaG1uNGhoWC9hbGRBUFd2MG0vWlUvNE5Jdmk3OFFvNGI3NHVlT1BDdnd6MCtZQm0wN1RWL3QvVjE5VmJZeVdzZVIwWlo1Y2QxN1YvUVJZV2tXbVdFZHBhd3hXdHJHek9rRUtDT05HWml6RUt1QUNXSkpPT1NTVHlha3pSeVBxSE11aVBoNzlsUDhBNE4zdjJXZjJXamEza25nYVg0bGE5YjRQOXArTnJrYWt1ZU9sa3FwWll5TWpkQXpEKzhhKzI5TjAyMTBUU2JiVDdHMnQ3SFQ3TkJIYjJ0dEVzTUZ1ZzZLa2FnS29Ib0FCVTRIRE5qaFFXWS8zUjZtdVBiNDJhTHFieVIrSDF2dkdGd2hLN2RDaEZ6YmhnY01yWGJNbG9qRHVyenEzb0NlS3EwWTZrM2xMUTYvQXhTVFNyYlcwazBqTEhEQWhrbGtjN1VpVURKWmllQUFPU1Qwcmt4RDQyOFdzeTc5SDhKMnJkb0ZPcTZpVjlRekJMZUNRZWhTNVQzTmMzNGowbndENFg4dTg4VmFpM2lxOHRROTE1K3RUZjJuOW5FTXNDU3pyYnF2MmEzTVRYTURPMFVVWlJXM0g1VkpCek43TDlBNVRvUjhidEgxZFArS2J0OVU4YU1UaFcwT0ZKclUrdittU3ZIYVpIZGZPM2Y3TkNXdmpqeFFENTkxb25oSzE1M0pZSWRXdml2WWlhWkk0SW05Vk52T3ZveHhrOFA0cC9hdXU5TitLMm1hTXZoKzZUUzVwN3UzdTcyNGptbm10VGFYMHRqZFN0SENyQ09HR1J0TmtETytaWXRUUmdJa2hsa0hLYWg4TnZpcDhWUEMwTnZkWGNzUGlEUTB1dE5qMXE4MU9iVHJlU2E0Z1J2N1V0N2FDMmhQbTJkMWJSZVVraU1ra04zY0lKMlVzeE5lcis0cTNVN2p4ZmY4QXczK0hGc21yK0lyMXZGV3BXdCsybnczR296blZwaHFZQ1l0SVZZL1pyUzhrOHhBa0Vhd0Z5NENyak9QWEpRM210NWpiMnpqZG5PY1Y1ZnAvN09QaGZ3ZHFmakxXZFQxRzhrdHZHVjdOZGFyRmMzZjJXd2JONDExYk50QkFqbnR5eFZaMFpaR3lONVlSMjZ3OXdmRnJhaC95RGJHODFEZno1eFQ3TmJnbm9kOG1DeW4rOUVzZy9TaUtTMkpldXhnYWdGOEpmSGV4dUQ4dG40MDAxdE1rUDhQMit5OHk0dDFBL3ZTV3NsK1diKzdaUmpzSzYzVU5WdGRGc3Z0RjVjVzluYjdncGxua0VhWlBRWllnWlBwWENmR3Z3NTRoMXI0ZTNXb1EzQWkxTHc5SkhybW4yV2xSYjdpNGx0bTgxcllUU0E3dlBpRXNIeXhJMkp6ejJycmZEZWo2SzZXMnI2WDVOOHQ1Q3N0dHFSbGE1bW5oa1VNckxNNVp5aktRUU4yTUVZRlVBSHhSSnFCMjZkcHQ1ZUE4Q2VkZnNsdVBxempleS83VWNiaW0vd0JpNnJxYmY2YnFhMnNSNndhZEhzT0QxVnBueXpmNzBheEgrZGJRR081UDFvL3p4UVNaK2srRjlQMFM1YTR0N1ZGdW1HMXJsMmFhNGNlalN1UzdEMkxHcjZqRlVML3hWWVdGNDFxMXg1dDJuTFcxdkcxeE9udXlSaG1VZTdBRDNxRTMyclgvQVBxYk8zMDFTT0h2bkUwaW4vcmxDMjBqMzgwSDJvR2F3Qlk0QUpKN0NzMjY4VjJOdmN5VzZ6RzZ1NGp0ZTN0VU54TEdmUndtZG4xY3FQZW9mK0VUUy84QW0xQzZ2TlVCNnhUT0k3YyszbFJoVmRmUVNCeVBVMXBXbHBIWTJrZHZESEhCYndydFNLSlFrY1k5QW80QTloUUk4OCtJbDFxK21lUGZCL2lLRzF0ZEx0ZnRUK0hyNTd0L3RFeXczN1JMQ1RGR3dUZDl0aHM0MVBtdHRXNGxPM2tnOWovd2lVTjZ2L0V3bXV0Vy93Qm02WUNFajA4bEFzYkFkaXlsdmMwZVB2QnllUDhBd1JxMmh0TzFtZFV0SkxhTzZVZk5aeWtmdTUxOUhqazJTS1J5R1FFY2lvL2h4NHpieC80QTB2VzVvRnM3cTh0Zzk3Yi9BUFBsY3FTbHpBVDZ4VExKR2ZkRFFWclkySVlGZ2hXTlZXT09NYlZSQnRWUjZBZHZ3cDRVQ3NvZU1iVzg0MDlaOVhiT1A5Q1VQRjcvQUw1aXNJSTdxWDNleE5EUjZ0cVErYVcwMHVOanlJUjlwdUNQWm1DeG8zcUNrZzkrNENUVWxsV0dHU1IyVkk0MUxPN0hDb0IxSlBRQ3N0ZkYwRjR1ZFBodXRXN2g3UkFZU1BVU3VWaWI2SzVQdFNwNFFzbW1qbHVZMjFHZU1oMWx2bSswRkdIOFNLZmtqUDhBdUt0YXBCa3lXWm1QdWFBTW55TlgxQUR6YmkwMHRlNldxL2FaZndra1VJUG9Zajlha3R2Q3RsRmRSM0R4RzZ1b3p1U2U2ZHJpU005eWhZbnk4K2liUjdDdExHYWcxRFViYlNiYnpyeTR0N1NET1BNbWtFYTU5TW5qUHRRQnl2eG8vd0NKSnBPbCtLQzJQK0VRMUZOUnVXSitYN0U2dGIzaGYvWmp0NTVaOGQzdG8vU3V6ZVB5MlpTTU1tUVI2R3NXL3Y0L0VGak5acHBNMnBXZDNHMEU2M2EvWmJlVkdCVmtiZVBNS3NwSXlzYktjOWE1bjRMcHJHcS9EKzMwN1d0V2tiVXZEY2ttaFgzMlZmTGt1WHRqNWF6U1NOdWZkUEVJcmdGUExJRndQYWdyb2R4cUdxMjJqUXBKZVhFRnJISzIyTnBYQytZZlJjOVQ3REpxbi9ibHhkTnRzZE91SkJqSWx1ODJrWDVNRExuMC9kNFBxS20wM1FMUFNaNUpyZTNqanVKVjJTVG41NTVCNk5JMlhiL2dSTlhQTFVjLzFvSk16K3lyeSs1dk5Ra0ViZFliSlBzNmtlNzVhVFArMGpwbjBxenB1aTJ1bEYydGJlS0Y1ZjhBV1NLdjd5WC9BSG4rOHg5MkpOWEFlUDhBNjlVOVQxMnowMmJ5WnJoUmNkZklqRFRUa2VvalFGeVBjQ2dDdzNRYmVPY1pvOHZJOVRXZTJvNmpxSUsyOWl0cWgvNWEzc25Qc1JFaEpQMFpveVByeFRENGRhOTUxQy91N29IckVqZlpyY2V1RVE3bVUvM1pIY1VBWVh4azhRV3VpZUhQN1FWMnVOVDhLM0VldExiVzhiWEZ3STR3d25IbG9Dd0wyc2x3Z0pBR1pBYzEyNjdXNVZsa1U4cTYvTXJqc1FmU3EybDJkdnBOdEhCYXd3MjF2Q2NwRkZHSTQxK2lnWTUrbGM3OElrL3Mzd3pOb0xINS9DbDIranJrL3dETEJGU1MxK3AreXkyKzQvM3QvcFFWME9xYzVQMHIrWXovQUlPb1AyUlIrenYvQU1GTzdyeHBwOXI5bjBENHo2WEQ0alF4cHRqVFVJOFcxOGdQZDJramp1Rzk3ejhCL1Rucy93QTVyOHpmK0RySDlrZ2Z0QWY4RXptOGMyTnFKOWUrQytzeGEycnJIdmtPbTNSVzB2VUhvQXpXa3pIc3RxZnJVeTdoSFhRbC93Q0RlRDR5dDhXZitDWFBnbTFtdkRlWG5ndTh2dkRzbTc3OEVjYzVudDRqei9EYnp3aGVmdUtuTmZkVVp3RjR6bnRqR2Y4QU9LL25SLzROb1AyM2J6NEkvdHUyM3d4MUMva2k4Sy9GaUdTeEVFamp5WWRWaWlhUzBtR2VRNzdHdHNERzc3UW1jN0Z4L1JSYnk3bFg1dXZCK2xkVlRXMGwxTW9kaTdHMmR2QXh6amlwbzIvbG5yVmRPUG02K25lcGtiNWhuNjQ5NnpMSjg3dXc2WjU5UDhtbm9NTHU5TzFRbzI0Ky9YQk9QODlLbVh2OHYxNHFXQTdQUDQrOVBIUS9URk1COUYrdWVhY0J6LzhBWHpSNUFTTDdaL00xSnRJUHk3ZnJVY2YzUjdlMVBEWmYvQTlhb0NYT1ZIVDYwNk1ibTV6VWFqREQ5TWRxa2o0b0FrSTUvd0FSVGg4cHBpbmFPMmZwVDhrTCtIU2dDUmYvQUs0cHdPVDdpbzFHZnVpbkIrZWMwQWM3OFl2RmsvZ2o0VitJTlV0WTFtdnJXeGsreHhkNXJoaHNoUWVwYVJsVUQxTmRsNEQ4SHdmRHZ3VG8zaCsxYnpMZlFyQ0RUbzNJNWRZWTFqREgzTzNKK3RjQjhSVi80U1B4ejREOFBnYmx1OWFHclhRQTVTR3dVM1NzZmI3U3RxaC82NkN2VTFJQTYxTWdlMXY2L3JRZEdNRC9BT3RUaGswM3BTcTI0bXBBVUhqNjA1VDh3cG82ZGFWU1JRQkxSVFJUdXB6UUFVVVVVQUhTbkowNS9sVGNVcGYwb0FkdzFCRkl1ZHRPNlVBWiszL09LQ1BUOGFjR0dNL3JTTzJmeXJ6emE3STVPYXpQRWVodytJdEh1TE80L3dCWE11TW4rRTlRUjlEeldrL1hqclVNbVF0WTRqRDA2OUtWR3N1YU1rMDA5bW5vMTl3NUhuUjF1V0Q0YTY1cGQyY1hlbXdQYm5QOFN0OG9JL1ArVmZFSDdSY0szM2llMjB1TGR0WGFDdnAzUGIvT2ErNFBqRm9LbG83eU4vTE53REJLUDd4SEtuOE9uNVY4WjZkNFl1UGlMKzB5dWwrVE0weHYwdHBGeHl1WEdjREg5M212NUQ4UnNkak1KWGprOVgzcDBVcWROM3U1eGsyNmJmblp4aSs3aTMxSXFVVlZuRmQyZUsvRUg0UjMzZ1gvQUlLaGZzNitHZmlKWjJlcWZCUDQvZkRyeEw0QW5oT1VDMzEyanp6UU0zYVNYeU5MOHBoZzdtNDVqeWZySC9nbGI4WWZFRW53VzhVZkJ2eDNxRXVwZkVmOW0vVzI4QzZyZVRZV2JXdE1SQkpvMnFsY2toYnF3OHZCWWxuYTNrWThrMThOZnRoL3RzZUVYLzRKODJmZ2Y0aGZFdncxcC83VDN3WitMcytwZUNMZUhkZFNhamVhZjRnbU5uS1BKVjFodEpMS2RvVmVaa1hNSXlTVndmbm45cG4vQUlPVXJlMC9iVjhSZkUvNEcvRCtiUkx6WHZDVVhoVFdVOFlUTE5hNmpKYjNSbXRieHJXMWNmdm9FZWVGR053d2FPWTVYb0svcTdJTW4vczNLNkdBaXY0Y1l4Zm0wdFg4M2RsY3llMjM2YnI4MnZtZnBoL3dXdXROWDBYOW5Ud3Q4WFBETnZjWG5pVDluYnhwcHZ4QlMydHdESmY2ZkN6UWFqYTU3STF0TzBqbnVzQkhldmpMNGxheDRSL1orLzRMdVdQeGUrSFBpend4cnZnLzRxNlJGWWVPYkhUTlR0cEpOSm12bWl0a251MFZ5OXVzMXlOTm56SUFXbGVVRXJrWi9NdjlxRC9nck4rMEgrMVplQi9GM3hTOFF5V0lrV1FhUnBqSnBtbG9WWU11YmEzVkVsQ3NCZ3pDUnVPU2E4RDBUNHg2bjRPOFQrSnBORlZMTzM4V1dVMm1YbHBqekk1b0pIamxWZlV2SFBGQk1qZFJMQkczYkZleDdDTTR0VDFXejlDVTdQOEFydGIvQUNQNng5SzBQVlBDbWpRWDJvUnF3a1pvTGtKZ0ZTQ2Nic0VnTVZ4bkJ4blBTdm03L2dvYi93QUZJTk4vNEp5K09maEZENHAwZVMrOE4vRTY2MUJyclY0TGpNbWh3V2d0MEJXRUtTK1d1VlluSXdzVFlERS9MeGZ4bi80S2g2OSt3SCt3WDhLdGErTS9oK1h4TjhUdGJzcmVLNzhOMjkvOWphOXV4R3B1WjdxY3hNSVNpRmZNVlViOS9LMGFmS0dsVmZqbjhQUEF2L0JiVDlnVzN1ZkRWM2F0cUd3Nmg0ZW11U1MyajZnb082MW4yL01FSkpSeDNCeU9jVi9IT095dktjRG16eGRhbk9lU1lpcEtDMTl5RloyaTZxU1g4TnZtVWIvYVYxcFk2dDFlRzhmeUlQOEFncHovQU1FLy9EUC9BQVZiL1owdGZGbncxMWJRcFBHNjJ5WE9rNnRidWpXZmlDQWZQOW5sa1hPMG5qRDlWS2dINVN3UHpKL3diRWVLbC9aTi93Q0NrdmlyNFYvRUxSNS9EZmpEeDM0YmwwalQ0cnlNUlN4WGxyTUxsN1pza0VpV09DWXFWeUhhS1Bia09wcjVCL1pZL2JJK0puL0JJejlwZSswbXhqdk5hOEgvQUcxazF2d3BjWFB6V3BWaUpFSTZRWE1ad1BNMmhaUXFOeXJLUityM3hoK0Uvd0FLZitDMWY3T3RqNDArSGV1UjZOOFRQRENMZWFCcjFsTDluMVRRcjlBc3FXOXlZMkRyaVJVTzRFbFdDdkcyY0UvcFdWNC9OZUJhME1CbVVuaU1ybTE3T3N0WlVyN1JxV3ZlTzFwYmRmSUljclRuSGZxajdVLzRLNC9zUzN2N2UvOEF3VDkrSWZ3ejBHZU8wOFJheGJRWE9rU1NOdGprdXJhNWl1VWlreC9CSVl0aFBPM2Z1d2R1RC9JcHJIaDdWUEQrdTZyb2V2YUxxTmg0aXM3dzI5d3Qra2x0Y2FmUEhJeVR4enhzTjI3Y3JLd2JES3lIdmtIN2IrTW4vQmNMOXRUU2RJMWI0YStLZmpWNG8wMmJSNVpOSTFGYlhUOVBzZFdWNGlVZFcxQ0MzUzczY0VGeEx1Yk9TVG5OZkZielNYRXhhUjVHM0VzU3pISko1ejljblByWDlCUWxHVVZLT3FlcHhwYTNMWGlLVzNtMXE2VzBsYWEyRGxJcG1CVnJoUmhmTUlQSzdzYjhIa2JpRGtnbXFhdjVMTElyc3JLY2hnY0ZUNjU5cWNQbXhsVDh2VUVjVnNlQXZoMXIvd0FVdkZ0bDRlOEw2RHJYaWJYOVFZL1p0TzBxeWx2YnU0SUdUc2hpVm5iQXlUZ2NDcUszMk1PV1I3bVRkSXpTTjB5NTNFLzU0b3hzSTI1RGQ4MTZOOFpmMlN2aWwremhiMmovQUJDK0czajd3SEZmTjVWck40aDhQM2VteDNMWUoySTAwYWgyeGs0VTV3RDZWVytESDdPbmpiOW9MeGt2aDd3TDRQOEFFL2pMV21JUDJEUk5MbXZyaEFlQXpMR2hLTHp5ellVWjY0NXFlWld1VnlzK2svOEFnaHgvd1Mxc2YrQ28zN1Zlb2FGNGwxUFVOSDhCK0M5TUd0ZUlIMDlsVzh2RmFWWW9iT0ZtQkViU3VXWXliVzJwQytCdUttdjZIL0N2L0JJSDlsZndiNEFYd3paL3M5L0NXYlN4RVlUSnFIaDZEVU5RWUVZTE5mWEFlNkw5Zm44M2NNOEVWOE5mOEc1My9CSTc0K2ZzRi9ISHhSNCsrSk9oK0gvQ3ZoL3haNFlmUlcwaWZXVXVOWVdVWFZ2Y1F6ZVZickpDcWdSU0t5dk1yanplRjRJUDY5TGFLT3Z6VlVVbnF5Wis3b2orYS84QTRMRWY4RU1kYS9aeS9iWDBMdy8rei80UDhZK012Qy94RTArVFY5TTBQVGJTZlZicncvSkhNSXJpMmVVQm0rektYaWRKcDJCQ3lsWGRqR1hic1AyV2YrRFVINDZmRmhMZTgrSld1K0ZmaEpwY21HZTNrY2E3ckJIQi93Q1BlMmtXM1hQUERYSVlkMXIraVpXTWNSUldLeHNjbFFlRFNkK3RQbDh3VTdkRDRDL1pWLzROcWYyWC93Qm04Vzk1cm5oM1V2aXpyMFcxbnV2RjF3SkxFc1A3dGhDRXQyVFBPMmNURWYzalgzYjRSOEk2VDhQdkMxcm9maC9TZEwwRFE3RlFsdHAybVdrZG5aMnlqZ0JJWTFWRkhiQUFyU2pqYVp0cUtXUG9CWEpYUHhtMEdTOW5zOUx1TGp4TnFGdTVpbHRkRGhOK1laQWNHT1dWUDNNRGUwOGtkTzBZNms4emtkWlFvWndTQjkwWko5QlhJaTY4YWVKMy93Qkh0ZEg4SzJybkNtOFk2cHFEQTlqRkV5UVF2NkVUWEMrb3JHMWJ3cDRUZlhyZlR2RTJvYWw0MTFhNGhsdkVzOVJWOVFpOHFINzhwc2JlTVdzWVJodEVqUXF4a0tvSFoyVlNjM1pCeTl6Wm4rTldoM1Z3OEdpdGVlTGJ1TmlqUmFEQjl0ampjZFk1TGtFVzBMLzdNMDBab1dUeHQ0b2JDeDZMNFJ0MlBHL09yYWc0UGJhcGpnZ2NldTY1VTU2ZXZtZmlQOXR2VGRQOElhTHJHaDJPbHphTk5aM2MwdHZkNnZiSmVyTkF0dEpEcGtFTnMwOGYyMjV0NXBwSUlXa1ZtYTE4c3FwZmRITmUrRXZpVjhWajRtMDdWNUp0TDArRFg3cDlGdVV1RXRZOVEwNkxVMmprMDI5dHdyRXd6MnNVYnczYUF6ZnZKc21OUXYydWRYdS91SzViSForS3YyYnZEbnhKOE02aHBQaTJYVnZGa09xMjB0cE5KckZ6NTZSQ1JDaGtpdGxDV3NVcWcvTEpGQ2pnZ2MxdGZDSHhYZWVNZmhwcEYzcW5saldZSW0wL1ZVajRqaXY3V1JyYTdWQi96ekZ4Rkx0STRLN1NPRFhRM3QxSEJETmN5eUxEREdDenl5RUtpRHVXUFFENjE1djRVOFhRNkg4WVBFdWthZmEzbXFXdmlLR0x4SllQYnhoTGRwRkNXbDhxU3VWalpFS1dNcmJHWmk5ODV3VGtWYWlsc1RkdFdOMzQ1ZkNheitOdnd1MWp3N2RMYitaZVc3bXlsdUkvT2h0cm9JM2tUUEZuYktzY2hWdGpBcWR2VG9heHRhL1p6OEh6K090VThYYXRhd04vYURtVzRndXBRMWhFSk5PYlRyaUVwSis3K3p6Mi9raVNQYW9kN2FGMnlVVURyalo2MXFUL0FMNjl0ZExqejl5eVQ3Ukwvd0IvWmwyWVBwNU9mZXByTHdqcDl0Y3gzSGtHNnVvdVV1THVScm1hTTk5ak9TVXo2SnRIdFRDN1JqK0VWMHZ3dHBFZG40WDBtOXVyY1NTVEM0QmNwTThqYm5tZTZ1RzNUbDI1YVJXbFpzRE9jQ3RLR3cxalVrWVhGN0JwYWRQS3NFODZSZjhBdHRLdUNEN1FxUi9lN25hd1MyVDM5dXROY2JaaC90REZCTnpQMDd3aHArblhxM2FXL25YcS9kdTdsMnViaEI2TEpJV1pWNVB5cVF2dFdtUG1QWG52elZMVXZFZGpvMDRodUxoVnVHQVpiZU5UTGNNcDZFUklDNUh1RnFyL0FHdHFXb2Y4ZXVuclp4bi9BSmJYOGdVbjBaWWszTTN1SGFJOVBlZ0RZU1ZvWkZaU1F5bktuME5lZC9DRHhGcC9nelQ5VThHeVRyOXE4RjZqSnB0dFp3cTAwNHNIUkxteTJ3b0RKNWNkdFBGQnYyNDNXNzg4R3VzUGgyVy9PZFF2N3k4SGVLRmpaMjZuMkNIZVFmN3NqdUs1MjQwcTM4QS9HUFJiaXp0N2V6c2ZGZGxKb2M4ZHZFc2FtNXRoTmUyaHdBQUI1UjFQSjdzWXhRVWpvanFXcTZnY1c5akhZUnR3SnI2UU13OUNJWXlkdzlta2pZZWxCOE1OZmovaVkzMTdmQTlZUS8yYTM5eHNqd1dVL3dCMlJucldWRkFweXFXNFVFbnNBS0NTdlkyRU9tMnEyOXZERGEyNkhLeFFSaU9OZm9BQUJVeW9Gck1rOFlXTFRORGF5TnFWeEdTclIyU21mWXdPQ3JzdnlSbi9BSzZNdE5NK3I2bDkyTzEwcUp2K2V4KzFYR1BRcXBFYU43aDVCN0dnRFhBejA1NzhWa3Q0d3M1MlpMTXk2cklwMmxiRlBPVlcvdXRKa1JJM3M3cWFSdkNGcmVqL0FJbURUYXV4NmkrWVBFZlQ5eW9XSEl4d2RtZmNubXRVSmhWWCtGUmdEc0I3VUFaT2RZMUwvbjAwcU0rbitsVGtIL3ZtT05oLzIxQi9ueUhnVHdmWmVIdmlSNG8wTzk4N1VvN3FXUHhMcDR2cFBOaWpGd1dTNldPTEFpVnhkeFNUdXlJQ0RxQzlNaXZSc0FDdU0rTEYxSDRQMWJ3MTRza2tqdDdmU2I4YVhxTTBqQlZXeHYyamdPU2VGQzNhMkVqTWZ1cERKMkp5SWZrZGtSdSs4eGI2MHVPS3pCNG1TNzRzTFc3MUQvcHBHbmx3ZXg4eDlxc3Z2SHZQdFNmWmRVdi9BUFhYa09ucDNqc2s4MlFIL3JyS3VDUFlSQWoxcDJFWDc2K2cweTBhNHVwb2JhM1g3MHN6aU9OTTlNc2VCVkZmRTdYZy93Q0pmWlhkNENNaVYxK3oyL3NkNzRMS2V6UnE0cVMwOE9XZG5kTGNMQ3NseW1jWEU3dFBPbzlBN2tzQjdBZ2UxYUczYjEvV2tCbGl4MUxVR3pjM3lXY2JmOHNyR01GaDdHYVFFc1BkVWpJcWZUdkRsbnBkeDlvaXQxTjBSdE54SXpUWEJIb1pISmNqMkp3S3VkS2cxSFdiWFJ4SDlxdUlZR216NWF1UnZseDJWZXJIMlVFMEFXQW1Sbm11UnRFLzRSYjQyM2NQUzE4WTZldDRvSENyZTJXeUdVazkybHRwYlVLUDd0aElhM1gxbTh2UCtQTFQ1TnZhVzliN01oSHN1R2x6N01pajNyalBqam9WMUQ0TGo4UjNGOWRUVGVDN3ROZjhteFUycXRCRXJwZUt1MG1VdTFsTGRvcStadExzbkF3TU1xUFk3dlV0Y3M5SWtTTzR1STQ1cE9ZNEI4MDAzKzVHdVhiNktEVlgrMXI3VWY4QWowMDR4SWVrMTYvbEFqMVdOUVhQKzYvbG4zcTNwbWwydWxJMGRuSGJ4Unk4bG9GR0pmOEFhSkgzczljbkpOV2dvQkZMWWt5LzdDbnZQK1AyL3VweC93QTg3Y20waUgwMm56UHFHa1llMVhOTjBtMjBpRHliVzF0N09ITzR4d1JMR2hQcmhRQlZrTGs4Yyt3RloxMzRxc2JTNWt0MWxhNXVvamg3ZTJRenl4bi9BR3dnT3o2dnRIdlJ1Qm9BYmZiOHFhaTVsd0FXWThqQTVyTE4zcTErZjNOdGE2WkgvZXV6NTh3LzdaeHNFSHNmTlB1dmFrYndqRGZKL3dBVEdhNTFicjhseXc4bkhvWVVDeHNQZDFZKzVvQWRKNHZzUmVORGJTUHFGd3Z5dEZaSjUvbHQ2T3kvSkdUemp6R1hOWWNGM2VhTjhYck81dUxPT3hzdkZGa2RQQ200RWt2MnEyODI0aURLbzJLV2dhN3lWZDhpQ01aR0Juckk0bGhnV09OVlNPTWJWVmZsVlI2QURnVmlmRTNUTGpVUEJkeFBwOExUNnBwYlI2bll4cHc4MDBEQ1VSQTl2TkN0Q1QvZG1ZZDZDbzlqcE4zdi9Lc1A0bi9ESFJmalg4TS9Fbmd6eEpidGRlSGZHR2wzV2lhcENEZ3lXdHpDOE1vQjdIWTV3ZXh4V3BwT3BXdXU2WGEzOW5LTGl5dm9VdWJhVURpV04xREkzNHFRZnhxd1IvbkZVNDZXSnZiVkg4VlhqbndYNHUvWVovYXkxYlFacHZzWGpmNFIrSzVMWkxpTUZRdDlwOTJka3FlcWw0a2RUM1Vqbm5OZjFxL3MzZkhUUy8ybVBnTjRPK0lXaTdWMHZ4dG90cnJVRWFzRyt6ZWRFR2VGaURqZEc1YU5zSGhrWVYrSHYvQjJ6K3lJZmc3KzMzNGYrS21uV216Ui9qRm9hUGRPcDQvdGJUd2x0Y0RHUGwzV3pXTDV6bG1hUSt0ZlZYL0JyRCsxV1BpYit5RjRtK0ZkL2RLK29mRERWaGQ2ZkZuNXY3TjFCbmxBQVBYeTd0TGt0amdmYUl4NlZkSzdoeXZwL1RDb2twWFczK2Y5V1AxVmdjQUQ1czg5Q09CL244S2xYaGYwejYxV2psV1QwK25wVTZOZ0Q2OS9Xa0JZVHB1WG92UEpxVEdUeWU5UWdjZWh3ZHZGU2h0M1BYNmlnQ1VPcGI4aGpIU3BBTU4ySDA3MURHM0hQemZqVDFISngwNjg5Nm5RQ1VjKzJQYnJUMVBJOVA1VXdmTWY1VUtSbi82OUNBblhKUFBUUC82cWVEa2VvejYxQ293eDdkK2xTSTJGOXpWQVM1eU04Y25xTzFQVTRKNkNvMWJQMEl4VGxiSlB2MW9BbEJLakZPTGJoVVM5ZnJ3QlR0KzBNZXdHU2M5cUFPYjhDSC9oSmYyZ1BFVitWM1ErRnRLdDlJdDVBVGp6cnAvdE4waDkxU0d4STlCSWZVVjZXcCtYK2xlY2ZzeVJmYnZodmNlSUhBOHp4bnFsMXIyOGRKWUpIOHEwY2V4czRiVWl2UlZPMFZNZzZrbmVsVmgvZ2FhT0tYN3RTSk81SXB6UzFHSDJvZjBwNWJCb0dQalBIZWxQWDhhWjkzMHB5dmsvclFBNmlrWElITkxRQVVBWlAzcUtNYzBBS3B3ZnZVN3ZUUDhBR25aeWNmMG9BbzlhQU1VWXBwNmUrUFd2UE9nUjF5cHFCeGhUVXhPVDdmV29YUHlVQWVQL0FMVG5pOXZEVmpISXV4dnNjRFQ0WThNeE9CL0wrZGZuYi93Vzc4ZDNta2Y4RTBmaUI0eThKMk04bDU0bnRMYlF0V2xnSE5uYVhFcVF6enllM2xaZ0o1LzF5bm9DUjluZnRyYTdKcVNYRnJBelpra1czRzBuSkNqbjlUWDU4L0ZiL2dwdjRIK0NYN2ZVMzdOUHhLdGRQZjRYK0lQQzF0cEd2WFYwZHNkbHFkOUg1MkoyT0FMZDdXYUZHT2ZrWmcrUUFjZnhweFpVeCtZOGNmWE1CUWRkWVdYdHB4VzhvVTVSamFQZVh1M2l1cjA2MmM0WG1uS2NIdG9sNi84QUIyUHdLOFJlSnJqVWRJMGl6bXh0MGVLU0NESEh5TkkwblB2dWRobjBDanRXaDRLOFA2NThSOVUxdTdzOU8xVFZwZE9zNWRZMUdTMHM1TGhiU0JHVVNUejdBZkxpRE9xbVJzS0M2ZzR6bXZRUDIwUDJXNS8yU1Aybi9IM3d4MWU0a2Vid25xVFFXRjZZOTMydTNiYkpieU5nOExMYnlSdmtadzNBR01tdU8rSDN4TThUZkRXMGtpMGZWVzB5T1MwMUN4bSt5b2lTWE52ZjJ5MnQzRExKdERTUlBFb1h5MlpsVTVaUXJNekgrMGNOaXFlSm9ReEZGM2pOSnA5MDBtbjl4RnJNeVdPV3gvRUJrQ3Z2VC9nalAreUQ0YTB5WFhmMm92aXd5Nlo4TmZoS3NsenA0dUl3eTZwcWtXTnNzYUg3L2tsNHhHb0k4eTZlRlFUc2tXdkN2K0NjL3dEd1Q4OFNmOEZDL2pySDRjMDFyalMvREdsRkxyeE5yeFFlWHBkcVNjS3BZaFd1SmRyQ09Nbm5hN25DUnV5L3B4KzBOL3dUSStOLy9CVFA0VGVGL0Evd0UwUHdyOE9mMlpmQThhRHc1ZjhBaVRWSnJGZkcweUJndC9CSEhETFBKYURjeGhta1JSY0dXUzQzUDVxaFBnK0tzYlh6S3V1Rzh0azFLYVRyelgvTHFrOTBuMHFWVjdzRnVvODAraXZyeXRMbSs3L1ArdXArV1g3YVg3WlBpVDl0WDQvK0p2SEhpRGJZUjZzWUxmVHRHdDdwcExmUzdLMzh3VzhKUDhjaWgyWm1YQ21TV1pzQXVWWDFqL2drTC93VWFrL1lUK094dGRkbWtiNGYrS25XSFY0Z1RpeGx5QWwyb0g5MEFoZ09xK3BBRmViL0FMZFAvQk9ENHVmOEU1L2lGWitIZmlwNFpPa1BxeVBMbytxV2M0dk5LMXBJeXF5RzNuVVlKVGNtK0pnc3FDUkN5QU9wUGh3dHNncnRMYmVvL3BYMGVPNGJ5M0Y1VzhtcTBsN0J4VU9Yb2tsWlc5TkxCVGs0TzhUOWpmOEFnNEIvWUQwMzRxZkRXMS9hSThCd3czRjFhMjhROFMvWkJsZFF0RGdRM294MVpNaFdQL1BNNUp3blA1WC9BQUQvQUdrUEhYN0xQajZIeE40RDhTYWg0ZDFpSGFHa3RuekhPb0pPMlJEOHNpODlHQnhrNHdjMTk2ZjhFaWYrQ3VkbjhOZkR6ZkJ2NHkrZHJIZ0hXSURwMm5haGNEejEwNVhVcjlubFVqbUU1d0NjN2M0UEdNZkQxLzhBcythejQ1K1BtdmVDL2gzb2V1ZU43bTMxZTZ0ZE9zdENzWmRTdkxpM1dWbGpaWW9RenNDZ1U1eGo5YStVNEh5dkg1ZGhhdVE1cis4cFVuYW5OMmZOVGUwWGZySGJYcFlxUzk2OFA2OGprdmk1OFM5YytPSHhMMXJ4ZjRpbmp1dGU4UlhMWHVvVFJ3ckdzMHB3Q1FvNEdjZHZYM3JBVzBacEJqNXVjQWZoL244Ni9USDlsRC9nMXY4QTJqdmpyOWx2ZkdWdm9Id2YwV1RETkpyOTBMM1ZDaHdjcFpXeFloaC9jbmtnSXhYNlYvc3JmOEd0ZjdOM3dMRnRlK04vK0VrK01HdFE0WmpxOXcybTZWdUhkYk8yWU1Wei9ETlBLdnFLL1JLY1ZHS2hUam90RjJTNkdmS2x1ZnpuZkNMNEdlTGZqejR3ajhPZUMvQzNpUHhmcms1R3l3MFhUSjcrNDVQWFpFck1GOXlBQjZpdjZkditDRVgvQUFUYmcvNEo3ZnNVNksydGVIbDBuNHMrTjRqcVhqQzZ1STArMndGcEdOdnArNWNsWW9JUkhtTU1RWm1sWThrQmZzRDRYZkNYd3I4RHZDRWZoN3dUNFk4TytEZEJoKzVwdWhhWkRwMXFQZnk0VlZTZmNqSnJvTnZIU3RveGQ3eUpjMWF5TUQ0Z2ZEYlFmaTE0RTFYd3Q0cTBmVGZFbmhyWFlUYmFocGVwV3kzRm5leDVCMnlSc0NyWUlCQjZnZ0VZSUJwL3c2K0hmaDc0UCtEb1BEdmhIdy9vZmhUdy9hLzZyVE5Hc0lyQ3ppN1pFVVNxbWVPdU1tdHhJeTdoVlVsajBBSEpybDlVK01maDNUOVV1TlB0NzV0YTFXMmJaUHAralFQcVYxYk4yRXlRQnZJejAzVEZGLzJxcDJXckpWM29qcHFJMGFVN1ZWbWJzQUs0ODZ2NDA4U2pGanBXbGVFN2R1ZlAxbVgrMHJ3ZXFtMXRaRmlYT2VIKzF0akhNWjZETDhWK0Z2RE9telEyL2pqeEZkK0liaTg4c1I2YnFsMG90N3BaTGlDMlhHblFLa1UwWW51YmROMHNVcFJwbzl6NUlOVDdTK3lEbE55LytNT2cyK3BUV05uZFRhOXFsdTNseTJXalFOcUVzRW45eVl4Z3gyNVByTzhhOXlRT2F3ZGUrSUhqS1h4Vm9PblI2UG8vaFd4OFFTVDJzVjdxY3gxUzhTNGpoYWRZR3RiZDBoakx3eFhMaVg3VklxbUFLVUpjQWQ1WldzR2thZEZaMmR2RGEybHFvU0czaGpFY1VRSFJWVmVGSDBGY3o4WjlJdnRXK0c5OWRhWmF5WGV0YUc4ZXRhWkJHUDNsMWMycmlkSUZQYnpnalFIMVdaaDNwKzlZTkNMVXZoTnBkMXB0eFA0a3VOYzhhTERFMGpXMm9FWEVFd1VidHEyRnVpVzhqY2ZMbUZwQ2NBRWsxNXpybjdaOWpxR25hMXB2Z1BUZjdRdS9EL2g2NjErMEVzR1liMnl0bDAyWVBaMjZ5Uitla3NGN01zWU1rT0o3WHkzMmh3NDl3MHpXTFBYZEd0OVNzYnFPNjAyOGdTOHRycFQrN2xnZFE2U0Evd0IwcVFjKzljdDRZMDd3cjRYdkxpZnd4b1Z0Y1hWMWQzZDlKUHBWb2pLMDkzSWt0MjMyaGlJbGFXU09ONUZFZ0xNaWtxU0JRb3BiRlgvbVBOL0VQaHZ4aDhidFZtMDMrME5mYndSNHcwZ1d0N2ZRUzIxcGIyVnZOcDkzYTNVVVMvTGNmYUZ1a3Q3bUdlUGNwRnd3RW5sS00zdmgxK3lQL3dBSWxQcCtzNjk0czFDLzFqUmRSbTFhMHVraHQyR25pNnRMS084dGZOdUk1R2tpZTR0R21Gd1JIZEh6VzN5dTdTU1NlcXZGcm1xdis4bXN0SmpQVVFqN1hjTjc3M0N4bzNzVWtIdlN4K0M3RVRKTmRSeWFwY1J0dldXL2Y3UVViKzhpdDhrWi93Q3VhclQ1UTVyYkdUNGEvc1BRYmk2bThPNmZjNmpjWHN2Mm1lNnR5MC9uc0ZLQW03bmJhd1ZTVVZGa094U1ZWUU1pdE5yYlc5VlA3NjVzOUpoUEJTMUgybTQ5aUpaRkNMN2d4UDdOM3JaWWIySkpiOGFhM3luT2Vhb2k1bHdlRUxDRzZqbm1pYlVMcUZ0OGR4ZVNHNGtqYis4bTdJaitrWVVlMVlYeGdtL3NHVHc5NHAzYmYrRWUxT05MeGljWnNic2kydUN4N1J4TkpEY3NmU3pycHRWMTJ6MFY0MXVycUtLYVlmdW9jN3BwL3dEY2pYTHVmWlFUV1Q0anQyOGVlSGRRMGViU0pKTkoxaTFsc2JwcjZYN01zc0VxTkhJRlFCcE1sV1liWFdQNmpyUU5iNm5RdXBTUnNqQkJ3UlZQVlBFZG5vMHl3M0Z4SEhjU0Rja0NneVR5RDFXTmN1My9BQUVHdVA4QWhBZFc4YWZEZlRaUEVXc1hWNXJGbDV1bWFvTExOaERMZTJrcjIwOG8yTVpnSGtpZHhtWGFWZFRqbXUwMG5SYlhSWUdqczdXMnM0bk9YV0NKWXc1OVd4MVB1ZVRRSXBuV05SMUFmNkpwdjJlTnVrOS9KNVFJN0ZZbDNPZjkxL0tQMHBrdmh5YlVFLzRtR3BYZHgzTU5zVFoyK2ZiWWZOeDZocFdCOU1jVnNKQ3ErbjVVdTNzb3l4NDRGQWl2cFdsV3VrV2hoc2JlQ3pnWTd5a0VZalZqL2VJQTVQdWVhc0FZei9Pc3VYeFpZMmQxSmFyTjlxdW9Xdzl2YUkxeExGbnB2VkFkZzkzMmozb04zcTJvZjZ1MXQ5TmpiK0s3Zno1aDdlVkUyMzhmTjQ5RFFCcll6OTBaYnNBT3RjTDhhYjVkYjhDYXBiYUx1MVB4SnBiUmFucHRwYUlabmU5dFpVdVlJWkNvSWlXV1NJUk1YS2paSS9JQk5kRTNoU08rL3dDUCs0dk5VM0RCanVKTnR1UjZHRkFxT1A4QWZWajcxcVd0dXRoQkhEQ3F3d3dqRWFScUVTTWVnQTZmaFFCZytIL0ZOMTQ5OE82ZnEra3JhMmVrNnZheFgxblBkSDdSTkxCS2dlTW1PTmdpNVZsSUlsYnIwcTIvaEczdngveE1KTHJWZ2VxWGJnd24yTUtCWW05aXlFKzlZbndoalh3NmRmOEFDK0ZqWHc3cUx0WklQbEFzTG9tNXR0aS93eHhGNXJWQjBBc3VPQlhZa2hJMmJQeXFDeEpQQUhxVFFOalk0RmppU05SdGpqQVZGVWJWVURvQU93OXFlQmlzc2VLN2U2M2ZZWTdqVkNPOW9nYUkvd0RiVmlzV1IzRy9JOUtialZOUVB6VFd1bXhuakVBKzB6SDMzc0FpSDJLU0Qzb0Vha3NxVzhUeVNNc2NjWXk3c2NLbzlTZTFabzhWUTNmL0FCNFJYR3A1NTMyNkR5Y2VvbFlyRzMwVm1iMnAwSGhleiswTE5QRzE1Y1JuY2t0NC9udEczcWl0OHNmL0FBQUxXZ1J2KzhTMzE1b0F6UEoxYlVEKzh1YlhUbys2V3FlZk4vMzhrQVFaN2d4SDJidlZEeEw4S3RIOGFlSE5TMHJVbzU1bzlXdFpyS1c2bGxNMXpBa3FGR2VGM3o1VEFNU05nQUJBT0s2UTFCcU9wMjJrVzNuWGx6YjJjSk8zeko1VmpUUHBsaUJRQmgvQ254VmVlT2ZoN3Btb2Fvc1M2MXNlMDFkSWh0amoxQzNrYTN1MVVmM1JjUlNoZlZRRHptdWo2Q3ZPL0RIaUNiUS9pNzRpMGV5MCs2bXRmRU1FWGlPeWt1Vk5uQ0pWQ1dsN0dONDM3RktXY3U1WTJ5OTg1SjZHdXcvczNVTDhBM1dvZVN2VXcyVWZsNUg5MXBXM09mOEFlUVJuMkhTZ0hvWE5UMVcxMGVCWkx5NGd0WTVEdFF5eUJONTlGeWVUN0RtcXAxKzR2VGl4MDY0bFhwNXQyVFp4WjdqREF5L2o1ZTA5bXFiVE5BczlJbWVhM2dqanVKT0pKemw1NWgvdHlNUzdmOENKcTJFQVB2NjBBWmk2VGUzMy9INXFNZ1Z2K1dWaWh0bHg3dmxwQ1IvZVJrSHNLdGFYb2xycERTTmEyOE1EVFk4MTFIN3liSGQzUHpNZmRpYXRkLzBxanFQaUt5MG03K3p6WEsvYWlOd3Rvd1piaGw5UkVtWEk5d3VCUUJlVUNuQS9OOTFaQjNWdm1Wdllqdm4wckkvdFhVcjhZdGJGYk9OditXMTlKOHc5MWhqeVcralBHYVErSEpOUTUxQyt2THdIckNqRzN0eDZqWWhETXA3ckk3aW42Z2N6OElQRTluNGE4TXplRTU3cDV0UzhFM1RhRzBFWWU1dVJieHFrbGs3cWdaeVdzcGJWbWNqRzluQjVCcnFUcUdxWDQvYzJVT25yL2Z2WkJMSVBwRkV4QkgxbFVqMHJubHNMZndGOFg3SDdQYncyZW0rTHJCckV4d3hpS0lYMXA1azhLcXE0RytXMmt2Q1RqN3RrZ3owRmRzbUFQeHBsU01rZUdSZGovaVlYVjVxQWJySEk0aXQrZW84cE1CbDlCSnZJOVQxclN0TFNPeHQ0NFlZNDRiZU1ZampqVUpHZzlBbzRINFZJUWRyYlYzTjF4V1dQR05uUDh0bjV1cHpEZ3BaTDV5cTNkV2t5SWxiMloxTkluYzFCaGZUODZIYjl5ek53cWdsajJBOVRXV1RxMm9qL0FKZGRNajlzM1U1SC9qcUl3LzdhQ2hQQ0ZwUEtKTHp6dFRrVTdsYTliemxRL3dCNVk4Q05HOTBSVFNBYVBHRnZjai9pWHgzR3JNTzltb2FMMy9mTVZpeU80Mzd2WTBzUzZ4ZWxkMDFycFVlZWx2OEE2VE9QUWgzQVJUNmd4dU91RDNyVGtWbWZyaytwb3g1WkhOTURtZmhSYi84QUNPYWZxWGhscEhZZUhicG83VXlFYm1zcHYzMXZnQUFCVURQYmpBQS8wVTR4WFdLTUwvOEFYcmxmRUVpK0dmaVBvZXBFaU9EWEZmUTdrNTJocEFHdUxRa24rNlZ1WXdCeVd1MTY4WTZzY2p2VkliUGdML2c1YS9aSWI5cVgvZ2xWNHUxS3l0L3RHdjhBd2x1b3ZHOWlxcU56MjhBYUsrVFBaUlp5elRIR2NtMlFlaEg0Yi84QUJBYjlxeGYyWHY4QWdwWjRKa3ZicjdQb2ZqemQ0TzFRc2ZrSXZHakZzNTdLRXUwdGlUMlhmMHlhL3E3MXZRYkR4Vm9sN3BlcldjT282VHFsdkpaMzFwTW9hTzZnbFFwTEd3N3F5TXlrZWhyK05UOXN6OWxYeEIrd3ArMTE0KytIZDlIcWtKOEIrSUo3R3gxSjRtaE4xYkxKdnRMdFdYaGZOZ01Nb0lKSTNEMHAwWmNzOWR2NlE1TG1oL1h5UDY2b1haRjZ0dTc3amdqNjFZUnNBZEI2MTRsL3dUNi9hamgvYk0vWXorSFB4S1dTSnJ6eFJvNlBxUVVqNU5SaExXOTR1QjBBdUlwU0IvZEtudm12YW9tNDZiYzg5S3FjZVdUUktkMWNzeHQrOCtYR2VtZjhha1I4RHB6a0dvRWJLK25yay95K2xTd3NBdnUzRlJJQ2IrSDczMHp6VWlOam4rdk9halRqdUNjOWFrWEIvR29BZU9TZnBVdmVvVmJCUDhxa1VnTDcvU3RBSkVPQ3RQRDRIcGpvS2lYajBQSUgxcVJjTDdudm1nQ1FmTWUzNTlLY2pjSDV2MHFOTWo2K2xPVS9OK0hlZ0NiN3RjajhlTmZ1dEErRVd0dHB6QmRXdm9sMDNUUVJ3Ynk1WmJlQWZqSklsZFVHeHgyOSs5Y2w0eGpYeFA4QUZyd0xvVER6SVk3dWJ4RGRSSHZGWm9QS1kvN3Q1TmFNUGRhVDEwS2pvN25wSGh6dy9hK0VQRDJuNlBwNitYWWFUYXhXTnN2OTJLSkJHZy83NVVWZlhuQnorTlJvY2ZoVGkzRkc1S1hRa0gzUTM5YWNHTlJnWU5PemcvalVXQWQxUDQ0cDI4ait0UjdzTjA3OVJUKzlBRDBPUlFlbldtcTM1WXB3NUdQZWdDUU9EUzR6aW1kUlNnNFhyMUZBRDZLQTJSUm1nQW9IRkZGQUZIZmswaGJKOTZTZ25GZWVkQTF6Z2ZqVWNnd3VmU3BISDgvV29MeVVRMnp5TjkxRkxIOHFtcE5RaTVQcHFCOHdmR2ZURThZZkdPeDAyRkdlRlp6TE53VDh3T1QrUTRyOEZ2OEFnNHkrSG45by90WTJYeEVqczJ0WS9HRmg5Z3V0aWtabnN3a2FidmMyelFJT2VrQitoL29ZK0ZIZ3F6K0kvanp4SnFHclcvMmpUcDRKYktWQXhYekVtREk2Z2prZnV5UmtjaXY1UGYyMGZndDRyK0EvN2FQajc0V2VKZFMxN3hGclhoUFc3clFiU2E5bGx1N2k4UkpNMnNpQml6TjU4WmpaVlVjaVlZem12eC93aHlsdjY3bjFUZkVWR28rVk9HbjR5NW44a1owOUlwZDlUa3Yyb1AyZ05VL2FoK05Xb2VOZGF0YmV6dmRTdGJPMSt6d1NOSkhGSGJXc05zZ0JiNXVWaERIUGRqWFArQVBEV2tlSmRTbUd0ZUpMSHd6WldzWG1HV2F5dWJ5VzRPY2VYRkhDaEJmdis4ZUpjQS9ObkFQNkNmQlQvZzFZL2F5K01IZ0dIWHI3Uy9BdmdIN1ZFSm9OTDhVNjQ4R3BNaFVNdStLM2huRUxIUDNKbVIxT1F5cVFSWHluOGZQK0Nidnh0L1pqL2FNaitGSGl6NGIrSlQ0NnZJbHVOTzAzU2JSdFdPdFFOa0xQYU5iQ1FUeGtnaktaS3NDamhYVXFQMlNoUnBVYU1hRkgzWXhTUzhrdEZhOTcvTzVXcmxydWZhSDdMLzdVUGdyNDgvRlg0Ry9zZS9BdlNiN3d6OEovRlhpV3l0L0huaURYQkhaYXY4UUk5eXlYOFVpUXZKNU1keEhGSkhzRXJQSXBoaHpIRUdSLzZTUUZVS2thUnd4cUFxUnhxRlNOUU1CUUJ3QUFNQURnQ3Y1dFAySC9BUGcycC9hdThmOEFpM1FmRmw1RHB2d0wvc202dDlSc05WMTNVTWF2YXl3eUxKSE5EYVczbVRSeW82aGdzNWdQeWpwbXY2TnZoaDRlOFFhRjhQTkhzdkYydmFmNHE4UzJkc3NlcGF2WmFUL1pOdnFNd0dETXRyNXN3aExkU3F5RmQyU29VRUtPREtjb3d1QWhLR0ZqOGJjcFNidTVTZThwU2VyYjBYa2trckpKTFNmdzY3bnhOL3djZC9CQnZqMS93UzkxelNkTzhPNnQ0bzhYV2ZpVFJybnd2WTZWWXlYdC9KZkc2V0dRUXhScVhZbTBsdXR3QVB5Z250a2ZrNSt5ci93YTcvdExmSGcydDk0cnNmRC9BTUl0Q3VBSGFUeExlK2ZxZXc5U2xsYmIzRGorNU84QjQ1T2EvcGNqL2M1MnNWNElPRGpJb3dLOWZsYk1vdXgrYVA3S24vQnJKK3p2OERJN2U2OGQzWGliNHZhdkhobVhVSnpwR2xiaHlDdHRhc0pldmFTNGtCNkVZNHI5Qi9oRDhGUEJ2N1B2aEJmRC9nUHduNGI4RmFJdU0yT2hhYkRwOERrZDJXSlYzdC90TmtudWE2ZFJ1YkFCSjdBQ3VhOFFmRm53NzRhMVdUVFp0UysxYXRFQVgwM1Q0Sk5RdjR3ZWhhM3QxZVJGUDk1bEMrcEhXaFJpdFI4emVoMGVNQ25Lck0rMGNuMEFyai8rRWk4WWVJeC94THRCc1BEY0xmOEFMenIxd0xxNFErMXBhdVZaVC90WFViRHV2YW12OEtFMTFTZkVtdGExNGlEZmV0WkpoWjZlTTlWK3oyNFJaWS9SYmd6RWYzajFxbEp2UklseDdsenhCOFd0QjhQYTFOcGJYcjZock1IRXVtYVpieWFoZXdrakk4MktGV2FGVGtmUEtFUVp5V0E1cW9kYzhZK0pUL3hMOUcwdnd6YXR4NSt1VEM5dTEvN2RMVi9MMm5zVGRoaDNUdFZENFFhTlovRGJ4TDRvOEdhYloydW02VFp6eDYvcGRwYVJMQmIyOXZmR1R6VVZGQVVFWHNGNUljQUFDNGpIY1o3dkdSUmFUM1pPaVBOTmUwendySHFNMWo0MDhaU2VJcjJKSW5uMHU5MUNPQ0NHS1dWSWtNbGhiQkZlRnBaRVVOY3BMamQ5L0FOVVI4Y283ZlhHOEcrQzlBc2JhYVBTdFRmU1B0c2MxbHBwdnJPNnVMSnJYYkJBNnh4cGRSd2lSM2FMS1hkdjVJbVp5cTlkcnZ3YzBmeEg0ZzFTNnVJVSt4ZUlORnVORjF1eGlUeTAxV0ozREpKSTZFTUhpRDNTcXdPN0YwNXlDcW1zM1EvQ2ZnM1Izc3ZzR2xyNHAxVFM3cTR1N2U5ZUwrMWJ5RzVtWU5QSjlzbHlzTWo3RXp1bFRpTkZBQVZWQ1ViRkt6V3A1NVplTHZpSjhVTHZROVUwT0hYbGp0cFRaWE11MjEwN1RmUGp1Yk9jM1JpTThwdUxTVzBudXJaOWp5dEhOYUh5bGpreklOLzRjL3Nrd2VHclMvaDFiVlpOV3RianhTL2pLMHRCYlJlWG9tby8ybEplZWRhU0ZOOFlsUmxTZFRrT3pUc3BUejVkL3BSbDF2Vm16L29la3hIcVh6ZDNKSDRGWTQySDFsSDE2VUh3UFkzaS93REV4ODdXV3puL0FJbURpYVBQWWlJQVJLZmRVQnF1WHVIUDJJMThiNmZkNS9zMWJqV3BCeC94TDR4TkhrZFFaaVJDcmV6U0ExSkVkYnZuRGJySFI0MUlaZG1idTR4MUJ5UXNjYkQweEtQYzlhMk9UMU9jREE5aFNIZ1ZaQjVyOEZQQStuNlJwdXFlRzc2TjlVazhINnBKWldodm04MUZzM1ZMcXpNY1BFVVlqZ25TRGNpTGxyVi9RMTZVM3p0eWM3ZU9lMWNKNHgxaXorSGZ4bjBIVkx5NXQ3T3o4WVdVbmgrVnBYQ21TNnRoTmUyWVhQWDkwZFRCQXlTelJqMHJwUjRodWRRSC9FdjB1NmtVOUpyMG15aXozR0dCbXo2SHl0cDdHcFE1WGVwcXV2clZUVnRkczlDRWJYdDFiMjNuRXJFc2pBTk9SMlJmdk1mWlFUVklhTmY2aC94KzZuS3Evd0RQRFQwK3pJUi90U0V0S1cvMmtlUDZWYzByUUxUUTNsZTB0WWJlUzR3SnBWSDcyZkhUZTUrWi9xeEpxaVNxMnZYZC93RDhlT2x6N092blh4Tm5HUjdLUTB1ZlpvMUIvdlVIUkx2VUQvcDJwWERwMGFHeVUyY2JlbnpCak5uL0FIWkFEM0ZhbUZCNjkrOU9OQUZQUzlEdGRGU1JiTzN0N1VTbk1oaVREU24xZHVySDNiSnEwRUdlTzFVdFQ4VWFmcFYxOW5tdU4xMEJ1TnRDalhGeGoxOHFNTStQZmJpb1A3UjFXK0IrejJFV25vZitXdC9JSGNlNGhpWTdoL3ZTSXc5S0FNVFFWLzRScjQxNjlwMy9BQzcrS2JPTFg3WVl5V3VJRmlzcnNleWlNYWFRTzdTU0d1Z3YvRlZqWVhyV3BuOCs4anh2dHJlTnJpNFRQVGNpQXNvNTZzQVBldUcrTkhoZzZicDJpK0tOUXZidTlIaFhVNDdxOFRkOW50L3NFd2EydkFVandXaWppbU55VWxhVEp0RXlUaXZSYlBUSXRJdFZ0YmVHRzFnaEpWWVlVRWNjZnJoUU1EOEtDak4rMzZ0Zm45eloyMm14L3dCKzlrRTB2L2ZtSnRwVStwbUI5VkZPL3dDRVZTK1gvaVkzRjVxWHJISXdqZ1BzWW93cXV2dEp2UHZXcWdWT242VTRESjZVRWtGdGFSYWRERkRCSEhid1JqYWtjYWhJMCtnSEEvQ3ArdFpVbml5enVkeVdUU2FwS3BJMjJTK2FvWWZ3dEp4R2hIbzdyU28rcTZtb2JGcHBzVERQemY2VFBqNkRhaU1QcklQWTBBYWdIWEhUR2ZwV1V2aSt6dXMvWWZOMVZzNC8wSlJKSGtkUVpTUkVEN000TkI4SjJ0M2o3Y3NtcUVFSC9UaUpWeU9oRVlBaVVqMVZBYTFHWGVSdUxISFFFOUtBUE92RkoxWFIvaTM0YzFiZFo2VForSUlaUER0OFUvMG1aM0FlNnNuY2tMSEhzS1hrUUFFZ0wzd0hPUVIyUytFN1NaMWt1MWsxS1pUdUQzcitjQXc2TXNmRWFFZXFJdFUvaWw0WHV2R0hnRFVySFR2TEdyS2lYbWxGemhFdjdlUmJpMFp2OWtYRVVSWWRDb0lQQnEzNGI4YTZmNHI4RmFkNGl0NUJiNlhxdGxEcUVUM0RDUHlvcFVEcUhKKzZRRGdnOUNDS0N1aHBzbTRjODA3RlpROFVyZXIvQU1TKzF1dFJCLzVhSW9qZ3gyUG1TRlE2bjFqM24ycFJhYXBxSnpOZVEyRWZYeTdLUHpKQjlaWlJnZyswU24wWVVFbDYrdm9kTXRHdUxxYUcydDBPR2xtY1J4cm5wbGpnQ3FJOFNmYlYvd0JBc3J1OEI2VE12MmUzSG9TNzRMTC9BTFVhdlV0bDRhczdHOVc1V0h6THBQdTNNek5OT21lRGgzSlpSN0FnZTFYaVBtejM5YUFNdjdCcVdvSC9BRWkrV3pUL0FKNVdNWUxlNGFXUUhJUHFxSVI2MVBwL2h1ejB1NyswUTI2L2FpTnB1WkdhYTRLK25tdVM1SHNUaXIzUVZWMVhXN1BSRmorMlhNTnUwM0VTdXdEeW4wUmVySDJVRTBBY3Q4WHl2aDVkQzhWWjJqd3pxS0c4UFRkWVhQOEFvMXp1YnRIRjVrVjAzcjlpWDYxMmJLWTNLa2JTdkJCN1ZnYTJmK0UyME8rMHVUUjVMblM5VXRwTFM1L3RCamFSend5SVVrWFlRWmVWWWpEUnFENjQ1ckMrRDQxZnhQOEFEK3lUeERyTnhlYXZwTHk2UHFmMlJUWlIzRjFheU5CSlB3VE1QTktlY1AzZ0JTVlBscXVnK2gyR3ErSUxQUTVJNDd1NWpobW1HWW9lV21tLzNJMUJkLzhBZ0lOVlRyRi9mai9ROU5hRmYrZXQrL2tqSHFzYTduSjlWY1JuM3pWelN0RnRORWlrU3p0b0xVU25kSjVTQlRLZlZpT1dQdVNUVm9ERlNJeVQ0Zm52L3dEai93QlF1NWw3dzI3R3poejZqWWZOUDBhUmxPZW5TcjJtYVRiNlJiR0d6dDdlMWhZN2lrTVlqVW4xSUE1UHZWZ1pKOWFvWGZpcXl0THByZnpqY1hVWnc4RnRHOXhMR1QwM3FnSlFIMWZBOTZlb0Y4RmNkS0UrWnNLQ1NheTJ1OVkxQS91YlcxMDJQKzllUDlvbCtubFJOcy9Iemo5S1ErRW9yMlBHb1QzV3JLM1ZMcHg1SkhvWWtDeHQ3YmxZKzlJRG0valZxcTN2Z203bDBlRzQxbnhCNGRtajFld3M5UGpNMDAxeGJONW4yY3N2eXhtWkJKQWQ1VWJabXJlMG5YTHp4ZnBWcmZhYTFsYTZicUVLWFZ0TzdmYXBab1hVTWpCVUlqWEtrRUVQSU1FY1Z0MnNTMmNVU3hCWWxoQUVhcGhWakE2QUFjREh0WEkvQ0JSNGZzdFk4TC9jL3dDRVd2MnQ3TlNjWnNKZ0xpMTJqL25uR2tqV3dQYzJiK2hwbGREYVBoRzN2RnpxRFQ2czJlUmRzR2o0NmZ1bEN4WkhZN04zdWExQkdxSXEvd0FLamFvN0FlMUVreXdRdEpJeXh4eGpjek0yRlVlcFBZVm1ueGRCZUwveEw0YnJWTzRlMVVlU1I2aVp5c2JlbUZabTlxTlNUVkE0OTZqdTd1S3d0WHVMaVNPR0NFWmVXUmdpSVBVc2VCK0pyT01PcTZpZjNseGI2Y2g2cmFMNTh3K2tzaTdPZTQ4byt6ZDZrdFBDOW5iWFVkdzBSdUxxTTdrdUxoek5MR2Y5bG1KMmZSTUQycEFSeWVLRnU4ZjJmWjNtb0h0S3FlVmJqUFErWStBeSs4WWMreHByV1dyYWl1YmkraDArUHI1ZGlna2NleGxsVWhnZmFKU1BXdFljbjFQdlNJbkh6ZGMwd09hOFhmRGEzMXZ3MWVRMk1jYTZ6NVlsc0wyNWRwNVlMcU5oTGJzWkhKZmFzeVJzVnpnZ0VZNXJjOEsrSVlmRjNoblQ5VnQ0NUlvZFN0NDdsWTVCODhXNVFkamVqS1NWSTdFRVV0L3E5cnBHMzdWY1JXL21IOTJydGhwRDZLT3JIMkFKcm5maHZmQ3k4U2VKTkY4cTRodDRybisxckR6b1RFWGd1Mlo1Y0JzTjh0MnQwU0dVRlZraUdOdTBseEgwT3ZiZ1Y4Si84RmpQMmF0SjhRV09uZkVBV051OTB5cnArcE1ZVWI3UWlqWXUvY01INVdWZm15TnNiZlN2dTNmODJLOHIvYmIrRlZ6OFpmMlZ2R3VpYWZEOW8xWmRQZS8wK0lBczAxeGIvdmxqQTQrYVFJMFk3WmtGYVVaOGxSUy9yeklsRnlpNHJxZkpYL0JKanc1b1B3ditHdmlMd3ZvTU1PbTJzbXAvMjB0akRJR2dnZVZFU1V4S09Jd3hpUm1WZmwzRm1BeXpFL1hzYkJzZDhkdjgvblg4KzNnVC9ncmJwL3dPL2JuK0VNZW5hbXN2aERRdGUyK0tybUtiTnUxdmN4eVdiak9kckNHSzVrbUo1QWVOT2NxMlA2Qm8zTU1teG15MGJGVGo3dkhwWFZqVkgybDRiZjhBREdlSDVsRzBpNUc1REU3ZWUyZTlUSVF5OVBmRlY0bXgwUFh0bXBJanZYdUIwei9PdU0yTFVmUWY3UXo4eHA4UkdlLytOUXF3TERQVnUvcFVvYmNhUUVxdDh1RDI0cDZ0anAyNlpxSlRnWS9wVDFZQTByZ1M1MjdoenljWTlhZm41YzRIelZFcTVGUEdCejFIYjJxZ0pNWXdQZjhBT25vM0grYzB6OE52YnJuTktENzRQVFByUUE4SGpqMC9LdVorRmEvOEpOOGJmR21zY05iNkhCYWVHN1lrOHh5N2Z0bDFqMlpaN0g4WXZhdWlrbldCVEkveXh4Z3NUNkFEbXNmOW1LMFovZzNwbXJTai9TUEZVcy9pR1JqOTRyZHl0TkFEN3JibUJQOEFnRkFkRDBKT1B5cC9VVXhldWZ5b0QvUUNnQ1FIUDBwd09lUDVVd0huSi9uUXJkc2RmZXA5UUpGR1I2MDRIK2ZwVFFmOGloUm4xTlNBOGRlOU82OFUwSG42VTVTUUtBSC9BSFJTanRVYWNpbmc3VFFBOERGTys2S2pWdWVhY0h6UUE0SE5GRkZBR2ZRVFRnbkZOd1FLODg2QXh6V0g4UUwzK3pmQnVwVGZkMlc3WStwNHJjSndLNGY0OTZoOWk4QVNRL3gza3lRTCtKei9BRXI1L2l2Ry9WTW14V0ovbHB5dDYyYVg0MkZMYXhEOEROQ0dsZkQyR1QvbHBmTzB6SEh2dEg4aitkZmtiL3djSmY4QUJKTHg3NDMvQUd1OUUvYVkrRCtyNlRZZUtJNE5Qa3VyR1l0YlhNbXE2Y1I5bXU0cDhHUGNZWXJaTnNoUUEyK2Q1Qnd2N05hRnBhNkhvTm5acXVCYlc2UmZpQU0vcm12UGYycmZBUy9FSDRKNnphaFEwOW9ndkllT2R5Y25IL0FjOUsyNFp5Nyt6OHF3K0M2d2hGUDF0NzMzdTQzYTkreDJYd2orSUgvQzNQaFQ0WjhXZllMclNHOFVhVGE2cytuM01aU2JUM25pV1JvSEI2UEd6RkQ3cWE2RGUwVGZLekxsU3BJUFk5UjlPQlhoL3dDd2I4WXJmNGgvQ1dUUVpKbE9xK0RtanRwbzkyV052SnU4bVRIQndXamxYMC9kMTdlM1gvQ3ZvcWVzVTJGV1BMTnBiZEJoRkg4UHlqUHNPOWM3OFZ2RStvZUQvQnozMm1wWWVjdDNhVzhrdDZydkJhUlRYRWNMenVpbFM2eEs1a0s3MHlxdDg2MVJiNFhUNnl6ZjhKSjRpMXpXZzMzck9DVCt5N0JEM0FqdDlzc2lIKzVjVFRDbktkblpFS0plOFFmRlBRZkRHcnlhYmNhZ3MycnFBemFaWXhTWCtvS1A3eHRvRmVVTHlQbUtoUm5raXM5L0V2aTN4TDh1bGVIN1R3L0MzSDJ6eEJPSlprLzJsczdaenZVK2ozTUREdU9NVjBHaGVHYkh3cm95NmJvZGhwdWoycTU4bTJ0cmRiZTFSejBKU01BQVo2NEdhK2YvQUFkOFFQaXI4ZjhBVEZ1TlE4SjNuaGZTTG13MHU1bjAyMzFFMnNzbDFiekkycTJzVi9HeVNCWmt1bzBoSjhvK1pwbDFIS1lsa1pndmU2alM3SHBuaTd3NXB1Z2FKY2FwNDg4WGFwcUZuYXdUM010c0pqcDlnVWhoZWFaVXRiWEVseW9pUjNNVXpYQktxZURYUCtJUDJtdkJQd1kwalFiR3gwOWRIMGErMWVYU2JwSTlPL3M1ZkR6cmJyT1pwck5samRvd3NzRWpiQU1RU05PVDVjYnNNendaK3gzSkw0KzBUeHByV3VhbkY0bHRGc212SWJXNCsxUjZsOW1YVUxkWTcxNVZJdTJhd3ZZN1o1dkxTWW0zTExJRmxsUiswK0hmZ3p3aDhKTFdQVDlEanZOVjFHeHhDMHhsazFPK1JsZ2h0Z3NrekVpSDl6YndKdFpvMXhHQ1J1TEVsdGRGOTQ5Qy93RENMWC9FK3VSZUloNHFzYlBUNzZ3MWY3SmJ4V2U5N1Y3ZGJPMWNTeFNzcW1aSkpIbGNNQjhtL3dBbzVlSnE3QlZMbmFBVDlCV1I1MnRhbC9xb0xQU1lUMGE1SnVwOGVoampaWTFQb1JLNDlWN1VoOEcydDhuL0FCTXBycldleFc5Y05DUjZHQkFzSng2bEMzdWExamN6ZGpqL0FJaytNYkRRUEgzZy9YYk9TVFVtaHZKUERsOHRpbm5pT0svTWF4QjNIN3VOemZRV01ZRWpMeE5KNzEyQWsxclV6OHNWanBNSjVCbUp1N2dqMEtJVmpRanJrUElQYW0rUHZCUytQUEFHcStIMW1Gai9BR2haeVcxdGNJdi9BQjRTbGYzTXlEczBVZ1NSY2RHUUh0UjhPL0dKK0lIZ1hTZGFrZyt5WEdvMnl5WE50bkpzN2dmTE5BZjlxT1VTUm4zUTAxZTRib2NmQkZuZG5Pb3ZjNjBlNHYzRWtKOUQ1Q2hZY2pzd2ozRDFyWFZka2FxdnlxaWhWQUdBb0hRQWRoVU9wYW5iYU5abTR2TGkzdExjRUtaWjVCR2dKNkRMWUdUNlZRLzRTYVcvT05PMDY4dXQzU2FaZnNsdVBjczQzbGY5cU9OeFQwUk9yTmJ0VmJVOVh0ZEV0Uk5lWE52WndzZG9lZVZZMVkrZ0xFWlB0Vkk2YnFlb2Y4ZldvTGF4bi9sallSQUVlcXRMSnVMZjd5TEVSVTJsK0dySFI3dHJpM3RrUzZZWWE1ZGpOY3VQUnBYSmNqMkxHbUJCL3dBSkpjWHdQOW42WmVUL0FQVFc3QnNvUjlkNitiK0t4TVBlay9zblVOUU9ielVuaWpQL0FDd3NJL0s0L3V0SzI1MngvZVR5ajdDdGJ5aGoxUHZUczRvRDBPSCtLbncrOHo0ZDZwTm9Oa3JlSXRQOHJWYkNUSmE1dTdxMGxTNWhoZVpzdXl5dEVJV0pKT3lWaDBPSzZ6UTlac2ZGR2gyT3FhZk1MclR0U3RvN3kwbS81Nnd5SUhqY2ZWV0IvR2pWZkVsbjRmbmhTNnVvb2JpYjVvWWM3cDVzZjNJMXk3NC8yUWE0SDRPNnZmV0Z0cm5oZXowMW9ZdkMrcHl3MnNsKy93Qm1VYWZjZjZUYUNLSUJwTmtVY3B0Z3JpUC9BSTlDTThZQzZqM1I2UUdCSFdxZXErSkxIUmJoWWJpNVZibHhsTFpBWkxpUWVxeElDN0R2d3A0cXIvd2o5eHFIL0lRMUs4blh2RGFFMk1Qc2ZrWXpIcnlES1ZQOTJydWw2TGE2TGFtR3p0YmF6aVk3bVNDTVJoajNKeDFKN2s4bW1TVVRxdXBhai94NjZjdHBHM0huMzdoU1BSbGhUTE4vdXUwUitsS3ZoNmErK2JVTlF2THZQV0tGaloyNCtpeG5lUWU2eVNPSzFsWGJUZ3U0NHgrRkFGYlRkTXQ5SXRSYjJrRnZaMjRPUkZieHJFZ1BydFhBcXdFQTdWblhIaW14Z3VudDQ1R3U3cU50cndXcUdlU052Ujl1Ukg5WEtqM3FNM1dyWDUvZHdXdW1Sbm9iay9hSnZ4ampJUWV4ODF2Y2RxQUx1cmFKWitKZEt1dE0xQzJqdk5QMUdDUzF1N2R4bFo0WkZLU1JzUFJsWWcreHJqUGc3OFF4cW5nQzFzN3U3bjF6WDlEZVhSZFVlMlR6cEpydTFkb0hsa1lmSkdadGduQWtaZmxtV3VsLzRST0M5SC9Fd2t1ZFYzZFZ1M0hra2VoaFFMRTJQVmxMZTlZR2l3RHdsOGFkUzAxY1IyUGluVGsxZTJSUmhWdTdUeTdTNi8zUVlIMDBLbzQvZFNuMW9LUjBCbDFhL1B5eDJtbHg1NnluN1ZNUjZiVktvaDl3OGc5cVUrRkxlNWZONjF4cW5mRjI0ZU1uc2ZKVUxGa2RpRXo3MXBoUW8yMFNPSW9tZGlGU01GbVluQVVEcVNhQ1JWUUpHcWdBS2dBVUFjS0I2VTJJYk53N1p6V2N2aXkzdlZ6cDhkenFvL3YyaWhvVC93QnRXS3hINkJ5ZmFrTU9yWHhHK2UxMDJNOEVXNCswVEgwSWVSUWkrNE1iZldnRFRublMyZ2VXUjFqampHWGR6dFZSNmtuZ1ZtanhURGRxRFlRM0dwcTNTUzNVZVFSNmlWaXNiRC9jWmo3R25RK0Y3TkpsbWxqYTl1RU80VFhibWRsYjFRTjhzZjhBMnpDajJyU1libTNIaytwb0F5dnMrcmFnZjNsMWI2YW45eTBYejVmcjVzaWhPZlR5ampzMWNsOEovQzluNFc4U2VKZEFlSHo1dEcxRCsxTk9tdW1hNG1XMHZ5ODRLczVQbGdYWXZvbFZOb0NRSngzUG9XYTRmNGphamJlQVBpQjRXOFRYVnhCWjJOOUpKNFp2NVpwUkZFb3VNUzJzak1UaG1XNGdFQ0w2Nmc1cGxMc2RzUnVQemZNZmZ2VHVockxYeEhKZmovUWRQdTdoVzZUWEFOcEFQcVhIbUVlaFNOZ2ZYdlRUcHVvYWlmOEFTdFFOdkdUekRZcDVlUWV6U3Rsei92UitXYVJKZTFQVnJYUllWa3ZMcTN0STNPMUdta0NCejZMazhuMkdUVk02OWMzdi9IanBsMUwzOHk4elpSL1FobE11ZisyV1BlcHRNOE8yZWtYRHlXOXVrZHhJdTE1eVRKUElQUnBXeTdmOENKcTRBQjJvQXkvN0h2cjRqN1pxVWlvZXNOaW4yWlNQUXVTMHVSNm95WjdqdFZyUzlEczlGTWpXdHREQkpOL3JaRlg5NU43dTV5em4zWWsxYzZENjlLcDZwNGhzZEd1aGIzRndxM0xMdlMyUU5KY092cXNTZ3V3OXdwRkFGdnFhNDdTLytLVitOdXFXWDNiZnhoWXJyRUdCMXU3UVJXdDFrOXQwRDZkdEhmeVpqMk5icDFQVWIwN2JYVDF0Vjd5M3pnSDJaWW85eGI2TzBacmpQamI0Y2V6OEwyZmlqVUwrOHVtOEYzcWExTWtSK3pRclpoWGh2L2tqK2VRQ3ltdVdFY2p1QzhjZkdSVklma2QxcVBpU3kweTdhM2t1UE11bEFKdG9FYWU0QVBjeG9HY0QvYUl3UFdxLzlvYXBxSnhiMlVPbm9mOEFscmV1SkpGOXhERzJHQjk1VUk5TzFhRm5wVUdqd2ZaYmVDM3Q0SXljUlFJRWpCNzRDOFZLRjJpa0l5ditFWUY3L3dBaEc2dTlSRGRZbmZ5cmNqdXBqVEFkVDZTRi9yV2xaV0VOaGFwREJESEJCSHdrVWFCRVQ2S01BVklxNzI2RnZZVmx2NHlzcFhhT3phVFZKVk8wcllwNXdVK2pQeEdoOW5kVFMxQTFBY3JqN3RPTGVYR3paK1ZCa2trWUFIVW1za1BxMnBqZHR0TkxoUHIvQUtUY0VmaGlOR0gxbEZJUENOcGROdXZ2TzFTUkNEdXZXRXE1SFJoSGdSSXc5VVJUL09tQW84WVd0M2tXSXVOV2JwbXlVU1JFOXg1cElpQkhkUytmYXVQOFNMckdqL0dEdy9xelNXZWxXUGlLRi9EbDZJUjlvbU1paVM2c3BESTRWSXdwRjVFRktPR2U5UUFra0N2Uk1nRGNmb005cXcvaWQ0VHVQRzNnUFV0UHNwSTR0U1pVdWRPa2t6c2h2WUpFdUxWMi93QmxiaUtKaU80VWp2VHVpb2x1SHduWnRNazF4RytvWENIZXNsMjNubU52VkEzeVJuL3JtcTl2UVZwa1pPNDdpZlU5YXgvRG5qclQvRS9nYlN2RVN5TFk2YnExcERlUi9hbUVaZ0VxSzRqY2s0RHJuYVIxREFqcUtrLzRTTnIwZjZCWlhGMXU2U3lxYmVIL0FMNmNiaVBkRWNWSkpxYnVQOGFoMURWTGZSNEZsdXJpM3RZMitVTk5JSXdUNkRQVSt3NXFqOWcxQy94OW92bHQwUFdLeVRhY2Voa1lFbi9lUVJuNlZQcCtnV21sVE5ORENxek1NTk94TWs3ajBhUmlYWWZWcUFJanIwOTMvd0FlT24zRTNvOTFtMGkrbnpLWk0rNGpJOTZhMmwzbDYzK2w2akpISDNoczE4aFQ5WEphVEk5VVpNK2xhYUFkYVZrM2o1ZnZaNHhRQlMwM1JMUFIzWjdhMmpqa2x3SkpnUDNrdnU3bjVuUHV4SnJHOGZFZUh0YjBIeEN2eXJZM1A5bTNweC95NlhiSkdUN2JiaExTUXQvQ2tjblltcGRiK0tXaGFMcTl4cFp2dnQyc1d3ek5wbW5RdmZYME9lUjVrTUlaNHdmNzBnVmZjVm1lSVkvRW54SjBDKzB0ZEgwL1FkTjFLM2t0SjVOWm0rMTNUUnVoVnNXMXJJRXdRM0RHNlZoMUtjWUxSUzh6dVNQbTZjamo2VXNVclFTckl2M2tJWlQ2RVZWMHlDYTIwKzNqdUxsN3llT0pVbHVIUlZhNFlBQXVRb0Nnc1JraFFBTThBQ3B5M1gxK2xXU2Z5T2Y4RncvMk1vLzJGZjhBZ3B6OFNQQ1duNmN1bitFOWN1aDRvOE14SkhzaEduWDJaVmlpQVAzSUp2UHR2KzNjMSs5WC9CRi85cTcvQUliQy93Q0NkWHcvOFJYRjAxeHJ1aDJwOEw2MlMrK1FYbG1xeGhuSnlkOHR1YmVZNTUvZjE4Ky84SGVIN0Z5L0UvOEFaTzhIL0hEU2JQek5ZK0Zlb2pTTmJralFibjBlK2NMRzd0MXhEZUNKVkEvNS9wRHhpdmsvL2cxSS9hcy80UmI0NCtOL2hEcU4xdHMvRzFnTmIwZUV5QVl2N0pUNXlJTTV6SmF1N2s0eGl6SHZWVVBoZFA4QXJUL2dCVTNVdjYvcTUrOE1iNTYvaFU2UGsrdnA2OUtwd3RsQVY1UHJqL1ArVFZoR3poUjE3NXFRTFNFWi93QjN1S21qZmFjbkhZVlhSenozd2V1S2xUN3dQdjF6UUJaUnR4L3ovT25LY2dmenFGR0liNjFJakVMMHFOZ0psZjhBVHZuclRzNEdOMmZURlJwMytsT1JzanIrUHZUaUJMblBmb2VLZnU5OGJ1YWlYNVQzK2xLSk9hb0RqZjJoN3E0UHduMURUYkdWcmZVUEVra0dnV2NxSGE4VTE3S2xxcmcvN0JsM2V3VW50WHJGclpXK20yMFZyWnd4MjlwYm9zTUVTREN4UnFNS29Ib0ZBSDRWNVhyY2YvQ1VmSHZ3UnBQeStYbzhkNzRtdVIvQ3dpakZwRW4rOTV0NkpCbi9BSjl6NlY2eGpBcVJ2dC9YOWJEdWdwVk9HOXMweFR0NC9Dbmc4ZjhBMXFGWVE5T1Y2VTdQUC8xNmo3R2xVNVhuK1ZGZ0pCa0E5OGV0T3p6VVdjRTA4SEo3MHVVQ1FQOEE0OFV1N0k2VXdkZjUwcUhIcjYwZ0pGUE5MdXpuK2ZwVEFkcHB5RGNLQUhjN3ZhbkRpbWcvTjMvS2c5S0FKTitRUDhhZG1vVlhCOWpVaC9MSm9BcjdPT3ROWVpHS2Zpa2NaLzhBMVY1NXVuY2hjYmMxNS84QUdGQnEvaXp3bnBmT0pyM3ozR09xcGpyK3RlaE92UDZWd2R6YS93QnVmSGFOejgwZWk2ZnVBOUhjbitqWi9DdmtPTnFicjRHbmdZLzh2cXRLUHk1MUtYL2tzWkZSMzFPeW5HNC9XcVY0aVRia2tHNk9RYlhIcXA0UDZacTY0eCt0VmJvZk0zNVY5ZElSK0gvL0FBVHIvYlU4VS9DRC9nNWQrSW53djhhUi93Qmo2VDRvVFVQaDVZV0lsUGt3R3llUyswMjR5UVBNYWNMS1ZiQXlkUXdBQmpIN2x2MXIrZlQvQUlPaFBoaHEzN0hmL0JTMzRPL3RKZUVZdnMxNXJrZHBxSG1oY3EydWFKUENRem5vQTlxMWl1UDR2Sms2ODQvZkg0YWZFclNmalA4QURidzM0eTBHWHp0QjhZYVRhYTVwc24vUFMydW9VbmlQL2ZFaTEwd2tUcTRxL1RUK3ZYVXQrSlBEMW40djhQNmhwT29LejJPcTIwdGxjcXB3elJTb1VmQjdIYXg1ckorR0d2M25pbndKcDl4cURMSnJFUWV6MUlvdTFUZVc4alFYQlVmM1RORzVIcUNEMElycEc0SnJnYkR3emFXL3hkOFFXRjU5b3VMUFhJSWRkdGJhV1ovc3JTS0Z0YnBQSkJDT3ErWGFTSGVHK2U3WThjVlV1NExheDBkMzR3c0lMbVMzamxlL3VvenRlQ3lqYTRramJzSDJBaVBQcklWSHVCelRYdk5hMU52M2R0WjZYSC9ldkgrMHpmUXhSc0VIc1JLMys3V3JiV3NkbGF4d1F4eHd3eERha2NhaFVRZWdBNEg0VTRqQXBMeUpNZC9CbHZmRC9pWlhGNXJHZUNsM0lQSUk5RENnV0pzZHQ2c1I2MXBRd3JhVzhjTVN4eFF3S0VqalFiVWpVZEFBT0FCNkNuWHQ3RHB0bzl4Y3pSMjl2SHk4c3JoRVFlN0hBRlpaOFZDK1gvaVcyZDVxWHBLcWVUYm4wWVN5WURyN3hlWjlEV3V3dHpWNjlhaXY5UWcwdTBhNXU1NGJXM1RocFpwQkhHdjFaaUFLenhaYXRxWS8waStnMCtNLzhzckZCTElwL3dDdTBxNFlIMmhRajE3MU5ZK0dMR3h1MHVsdC9PdkkrRnViaG11TGhSNkNTUXN5ai9aQkE5cU9aaXNpQWVLRHFIL0lOc0x5L0gvUFZrK3pXNHowTytUQmRUL2VpV1FmcFhJZUF0UDFUVHZIbml6dy9kYWdsaGEvYUkvRUZqYjZmR0dLUTNwazg5UE9rQjMvQU9tUTNjcmJZMFpmdEtjZ0VDdlJjWlBQUDFyanZpTC9BTVU3NDM4SStJbHlzU1hiK0g3NDlWRnZmbU5ZamorOTl1aHNVQjVBV2FYMXlCcnFFZXgwV20rR2JMU3J6N1ZGYnFiekJYN1ZNN1QzT0QxSG15Rm4yKzJjZTFYdHVTT3A1NzFYMVBXclRSSW8zdkxxM3RWa08yUHpaQWhrUG9vSnl4OWhrbXFiZUlidTk0MC9TN2lSZitldDh4c1l2cGhsYWJQMWl4NzFXd3RUV3pWUFZ0ZXM5Q1dQN1pkUTI3VGY2cFhiRHpIMFJmdk1mWlFUVk5kRnZyNC82ZHFrcFR2RFlSL1pZeVBRdnVhVWtlcU9tZjd0V3RJOFAyZWlHUnJPMmh0NUp2OEFXeXF1WnAvZDVEOHpuM1lrMENLbzhRWG1vai9RZExtOHM5Sjc5amFJUjdKaHBzajBhTkFmNzNlZzZGZWFqL3gvYW5jc3ZlR3hIMk9NL3dEQWdXbXo3aVVBL3dCMnRZSnRIclFyVURLdWthSGE2SEhJdG5hMjltc3hEUytTZ1ZwajZ1ZXJIM09UWE1lSUZYd3I4YWRCMUpSdGc4VVdrdWdYVFp5WHVJQkxlV1dmN3FxbjlwS1QzYWFNZWxkTHFIaVN5MHk3K3p5M0N0ZFl5TGFKV211Q1BYeWtCZkh2akFya2ZqRFphOTR1K0hPb0xvdW14dzZ0cDVpMVhTL3QwZ0xUWGxwS2x6QW5sUmtrcExKRXNiQm5SdHNqY2RpdEJ4M084WG4vQUFyUHUvRTlqWVhUVzVuODY2WEc2M3QwYTRtVFBRc2tZTEtQZGdCNzFtNkJEYStPUEQ5anFxNmxkNnRwMnJXc1Y3YWtOOW50NVlaVURvZkxUQlpXVmdkc3JQd2EzTEt3aDA2MFczdDRZYmVCUHV4d3hpTkYraWpnZmhURVo3WDJxWDMrcHRiZlQxL3YzamlhUWY4QWJLSnRwQjlmTkI5cVJ2Q3kzeWY4VEM0dTlUM2RZNW1DUWU0TVNCVlpmYVFPUjY5NjFnbTAwcWpQdlFJaXRyU08wdFk0WTBTR0dJYlVpalVKR2c5QW80QXA2cnQ3Vm12NHZzNVhaTE15NnBJcHdWc1Y4NVZiKzYwbVJHamV6dXBwcGZWdFIrNkxYVEkvZi9TcDIvTGFrYkQ2eWcvekFOWThLeDdLTWs5Z1BXdk4vamI0eXM5SzhPV0hpaXcrMGFvZkJlb0pxMDdXU0NTSDdIdGUzdmkwcEt4ZnU3U2VlVUtYQkx3eDhIR0QyWC9DSld0MFZhOUVtcHVweURlc0psRGYzaEZnUkszdXFBMW9YdGhiNnJhU1d0NUNsemFYRWJRVFF5REtTUnNOcktSNkVFakhvYUJsR1NEVjd1UmtrYTAwdE1sV0VRKzB6NDlRekFSbzNzVmtIdWFJL0NkbzhpU1hNYmFoTkcyOVpMeC9PMk4vZVZUOGlIM1JWckYrQ0Y5TS93QVBMZlRMeWFTNDFMd3hMSm9GN0xJY3kzRDJyZVVrNytqVHdpRzR4MkZ3T3ZCcnFydTdoMCswa3VMaVdPM3Q0aGw1WldDSW4xWThEOGFBZWpIdnVadHhabWIzTkpJTXFSV1dmRmEzWVgrejdTNzFGVzZUSW9qdDhkbUVzbTFYWDNqMy9TbFd6MVhVT1pyNkhUNDIvd0NXVmxHSkpGK3MwZ3d3UHRFcEhZOTZCRis4djROTXNtdUxxYUcydDErOUxOSUk0MStyTWNEODZvTDRtYSs0MCt4dkwzai9BRnJyOW50eDZIZklBV1UvM29sY2YxZnAzaGl4MDYrKzBMQjV0Mm4zYnE0ZHA3aFFleXlPU3lyMStVRUFlbGFPMzV0M2VnREsrd2FucUovMG0ranM0LzhBbmxZeGdzUFpwWkFkdzkxUkQ3MWwrT1BoVmIrSy9CK3JXRmo1Vm5yRjliRkxMVTV5MDg5cGNxUkpiekdSaVpDSTUwaWt4bkh5Q3VxSnhWWFZOYXRkRWpScnk1aHR2TjRqRWpoV2xQb282c2ZaUVRRTkZMd0w0d2krSVBndlNkZWh0NUxOZFh0STd0cmFRNWt0SFpRWGhiL2JqYmNqZWpLYTF5ZUs4NStIV3ZYV2srTmZGdmh1ejB5ZnlZN3hkZjA5NzBtemlGdGZtUnBWMmxXbDNpK2l2bkttTUFMTkZ5TWl1d09oM2wvL0FNZjJwM0RLM1dLeVUyYUgzM0JtbHo3aVJSN1V4c3RhcHJ0bG9ycEhkWEVjTXNvL2R3bjVwWmY5eU1aWmo3S0NhcS8yemZYNC93QkQwMlNPTnVrMTgva0t3UGRZd0drLzRDNnhuM0ZYTkwwVzEwVlhXenQ0YmJ6RG1ReEp0YVUrcm5xeDkySkpxMEtSSmtuUUxpL0pOOXFWMU5uckZhNXM0VDcvQUNreS9VR1FxZlFkS3VhWnBGdG90czBOcGJ3MnNMTnZaSUkxalZtOVRnY24zUE5XaDh4eDFyT3ZQRk5qWTNiMi9uZmFMdVA3MXRiUnRjVHAvdklnTEtQZGdCNzA5V0JvaGNDbXpXOGQ1RzBNME1keERLcFNTSjEzTElwNEtrZHdSa0VlbFpmMjNWdFMvd0JUWjIrbXAyZThiN1JLTWY4QVRLSnRuUFkrZGtkMVBTa1BoT08vL3dDUWhjWFdwRHZGTzRGdWZZd29GUmg2Ync1OTZBT1UrREhqVzFzUEJ6ZUcydUxqVXRZOEYzTW5oNjZpZ0J1WjhRYmZzcnpNdnlvODFtOXJNUzdLTXpFRWdnNDZ6N1RxMm9MKzdodGROUTk3Zy9hWnZjRkVJUlQ2RVNPUGFzQ08zajhFL0dtQkkxUzMwenhocHZrTEdBRWlqdjdMTHFxZ2NlWk5hU1NrL3dDeHBnOUs3WEhGTmplNWt0NFF0cjFmK0poSmNhdDZyZXVHaVAxaFVMRm4zMlo5NjFFUlVSVi9oUUJWSFpRT2dBNlVTeXJCQzBrakxISEdOek94MnFnOVNlMVpxK0tvYndmNkJGY2FwNlNXNmp5RDdpWmlJMkE3N0dZajB6eFJxeEdwaW83aTVpc3JXU2FhU09HR01aZVNSZ2lKOVNlQitOWjRnMVcvUDcyNHQ5TmovdVdxK2ZMOWZNa0czbjA4bzQvdmVrbHI0WnM3ZTRTZG96YzNNZktUM0xHZVdQOEEzV2NuWm4wVGFNOXFOQUkwOFVKZDRiVDdhNTFBTU9KVVVSd1k3RVNQZ092dkh2OEE1VUN6MVMrUDcrOGhzWS8rZWRtbTkvb1paQnlQcEdwOTYwenljOVQ2bWc4ZjU2MGdPQytGbmh1ejhGK1BQRkdpSkR1a2h1Zjdlc0xpWjJtbSt6Nmc4cnpKNWprdGtYc2Q0eEFJQ3BOQ01jalBmRDVUWG52eGc4V2FiNEM4ZCtFZFVtdWxiVklaNU5PazB5M1JyclVyeXh2REdydERheEJwcFJIY1Eya3JNaU50aWhtUEF5YTJENHM4UmVJbDI2TjRjK3d4TndMN1hwdnM0d2VqcGF4QjVueDNqbU5zeDlSMXA3NmxQdWRZcHovTGlzUHhKOFN0RDhLYXAvWjk1cUVaMVRiNWcwNjFqa3ZOUUtmM3hiUXE4eFgvQUdnbVBlcUkrSFY3clozZUlQRVdyYWlwNU5ycDdOcEZrRDA0V0YvUFlIdXN0eEtwOU1jVnVlRy9DK20rRHRMK3c2UnB1bjZUWTdpeHQ3SzJqdDRTMzk0b2dBejc0elJ5aTBNUC9oSlBGSGlIalRkQnQ5RmdicGRhN2NCNVBabHRiZG0zcWZTU2VCeG5sYzVGQStHTW10RGQ0aDFyVmRjMy9ldEZrK3c2ZUQzVVFRN1RKR2Y3bHhKUDdrMTFuU3NiNGlmRWJ3NzhJUEIxeDRpOFhlSU5COEorSDdQL0FGK3FhMXFNT25XVUgrOU5NeW92NG1xRVh0RDBHeDhMNkxEcHVsMmRwcHVuMm9JaHRMU0ZZSUljOG5haUFLdlBvS3REaXZuRDluRC9BSUt3ZkJQOXNUOW9yVXZocDhLZkVWNTQrMWJRdEttMWpWdFYwMndrVFJ0T2hTV0tFQTNNMnp6bmtrbVFKNUN5S1FIWXNBdGU0ZkVIdzNKOFFQQk9xYUxGcld2ZUcyMVMzZTNYVk5FdVV0OVJzQ3cvMXNFam82cklPb0xJdzlRZWxIUzRGZjR3L0czd1greno0TmJ4RjQvOFhlR2ZBK2dxZHY4QWFHdmFuRHA5dTdmM1ZlVmxEc2V5cmxpZUFDYS9OdjhBYTYvNE8wLzJjL2daOXFzUGh4cDNpajR6YXhFcENUV1VMYUxvMjRjRld1YmxQT09EM1MyZFdIUnNZSi9FWC9nc3YrelQ4U2YyUnYyOXZGZmczNG4rTlBFWHhJMVNKSWIvQUVyeFZyZDdOZDNXdWFiTXBhQ1l0TTdzckREeHVnWXFza1VnVWxRR1B5azBqT2YvQUs5WjgybWhWckg2di9FSC9nNmsrSUg3VFhpRHhGNFQrS1h3KzhJU2ZBdnh4b2QvNGExcnd6b0VMTHFrVUYwbTFMNks5dUdjdGVXeHc2S1ZqaGZCQlJIMlN4L0FmN0VYN1FWNyt5biswMTRMK0lsaGg3M3dacXNPcCtXRHpkUm9jVFc0NUgrdWhNa1I3WWM5dVI0MnBPNnRqUVpoRGR3ek16S053VnNJR3gxeHhrZlRIMXFveXRKU0pscXJNL3M4OEsrSjlQOEFHbmgzVDlZMGU2anZ0SDFpMWh2OU91RVB5M052TkdKSXBBZlJrWld6NkVWckk1QzV6OHZRWVBIZXZoYi9BSU41djJoWlBqei9BTUU0ZEQwdTdrbWx2dmhyZnorRjJlWGtOYktxWEZvUWVCdFdDNFdJY0RpQWNEaXZ1bU5DQUQ5MDQvV3RLbnhhRXhkMFRvZWZtKzkrVlRyMUczOGlLamlRQmNkdTNGV0VUNXZ1L3dDRlNVS2ovTHptcFVHNDlUbk9LYkdkbzlzMDlGQUgwTlNBNlByK09hZWpkZS9mRlJvTSt6VTREYy9VZjRWSUV3YkFwUzRBL1NtRXRnZS9mRlY5VjFLTFI5TnVMeTRaWTdlemllYVZuNFZWUUVrbjZBVld5RGZReGZneEYvYjN4UytJR3VrRHk3ZTRzL0R0dDZiYmFIN1JJdy8zcEwzYWZlQWVsZW5MMDRIdFhCZnMxNlBOby93TzhQeVhVYlEzbXNReWE1ZG80dzBVMTlLOTQ4YmU2R2ZaOUVBN1YzZ09SMXhRRDFZNFVxNEJCL1BpbXJ6VGpTQWVEay8vQUY2VWNkdW5lbzFPRDEvV241eUthQWV6N1I2MFl3UDZVd0hJUFhyMXBkK1dvOHdKRkdDUHAwcCtjSC82MVJqbjFwNTRYK0twQWNyWlBwVGw2Y1o5NmpVYy9YOUtlR0ZBRDFPRGordE9SdUtqNmluQnNSLzU0b0FlT1JTcndlT3ROVTlQY1pvL2k3MEFOMjhVZGFrMjgwMXh4LzhBWHJ6elFnZGNqNi96cmtQQXNYMjN4VDRsMURIK3N1MXRsT095TC84QVhGZGRmVC9aYldTVnZ1eHFXUDRjMXl2d2h0MlR3TGJ6U2Y2eStsa3VXLzRFMkIrZ0ZmTjVsKzl6ZkIwTGZDcWxUN2tvTC8wNC91Tlk3Tm5ST09QeHFyZHJnTWF0U2NBL1dvSndRRDcxOUlJK0VQOEFnNGIvQUdQSWYydmYrQ2FQaVJZeHQxbjRkWDF2NHVzSlFvWmxqaDNRM1lKL3VDMW5ta0k3bUJmWWpXLzRONC9FWGlpLy93Q0NWL2dmUS9GV242dGEzSGdxNnZORDB1OXZyWjRSckdsckw1OW5jeGJoaG9oSFA1QUtsbC8wWWdNY1Y5aGVJTkFzdkZHZzZocFdwV3NOOXB1cVcwbGxkMnM2QjRybUNWQ2trYnFlR1ZsWmxJUEJCSXFUdzBFc1pCYklxeHgrV0lrUlYycW5sakFWUU9BQW9JQUhHTVlxYWNwYzZWOUNrMG9OZHpYTmNoOFZwby9Ea3VoZUpwSkk0WXRCdjFodlpHWUlCWjNXTGVUY3g0VkVrYTNuWW5qYmFtdXVIK2VhcCtKZkQ5cjR1OE42aHBON3UreDZyYXkyVnhzYkRDT1JDallQWTRZNFBZMTIydVkzdHFVeDRyanZCL3hMN1c4MUwwa2lRUndmVVNTRlZaZlV4bHo3R2tOcnErb04rK3ZMZlRVL3VXU0NlWFAvQUYxbFhiajI4a0gzcUQ0YStJYnJ4WDRGMCs2MUlxMnFxajJtcGJmdWk4Z2RvTGtML3MrZEhKZzl4Zzk2M0FNVWtFdEhZenJYd3BZMmwxSGMrUUpycVA3bHhjdTF4TW4rNnprbFI3TGdlMkt2c3ZjNVBybW9kUjFLMTBhMk54ZVhOdlp3YnNHU2VVUnJrOXNuQTU5S28vOEFDU1NYNUgyRFRyeTZYL250T3YyU0VIM01nOHdqdnVTTng3OXF1S0U5VFNKei93RHFxSFZkV3RkRHRsbXZMcTNzNG5iWXJ6eUNOWGIwQlk4bjJITlVtMHZVdFI1dTlTK3pvZjhBbGpwNmJNais2MHI3bWIyWkJFYW4wcnc1WTZIY05OYTJ5SmRTTHNlNVptbHVKRjlHbGNsMkgxWTA3M0VWL3dEaEliaTk0c2ROdXB2U2E3elpRajF6dUJsK2hFUlUrb0hOWTN4QitHOTk4VS9BMnI2SGU2NUxwbzFhMGt0NG4wNkx5ZnNzakQ5M0w1akZwQzBjZ1J3MFppT1VIRmRkdDI0K241VXBIRk8zY1YreHkvd292YlR4TDRKMDNYb05QaDAyKzFlMVNTOVFFeVR3VDR4TkJKSzN6dVk1UTZIY2M1UTEwd1RGY0w0UTF5ejhCZkVEeFY0YnVyaU9IenJsUEVXbXdkWGtodmpKNXlJZ3k3dUwyQzhsWUtEaGJtS3VvT3IzMThmOUQwNW80MjZUWHorUXJEMVdNQnBDZjlseEdmZWt1dzViM05PcWVvK0liUFNMaFliaTRqVzVkZDZXNmd5VHlMNnJHb0x0L3dBQkJxc3VnWEY5ODE5cVYxTUQxaHRNMmNQdGphVEw5UVpTcDlBT0t1NmJwTnRvMXUwTm5idzJzVHR2WklZeEdIYjFPT3A5enpWQ0tYOXJhaHFDL3dDaTZmOEFaWXlQOWJxRDdNNTZGWWszTTN1SE1ab1BoK1crL3dDUDYvdkxvZDRvRDlrZ0I5Z2g4d2ovQUdYa2NlMWFxcnRwZTlBWDdGZlQ5TGcwbTI4bTFndDdXSE83eTRJeEdtZlhDOFo5Nm1VZVdRVjRaZVI3VlF2UEZOamEzVDI0bk54ZFJuRDI5dEcxeEtucHVWQVNnUHEyQjcxRWI3VnI3L1UydHJwcVkrL2R0NThvUHA1Y1RiY0gxODM4S0JHRjhIRi9zSWVJUEMyM2Ivd2pPcVNMYUFmeDJOei9BS1hiYlY3Skg1c2xxdjhBMTVOajByb1p2RnRpazhrTU1qMzExRTJ4NGJSRE84YmVqbGZsalA4QXZsUjcxeFBpYndyRm9meG04UGFwZnpYV3BXdmllMmw4TzNhWERBUk5QR3NsN1pGbzBDeG1ORlhVVUc5V1l2ZFJqTmVpUVcwZHZiUnd4cXNjTVNoWTQwQVZFQTZBQWNBZXdvS2ZjelRjYXRmL0FPcml0Tk1pUGVjL2FaL29VUWhGUG9SSTQ5dTFCOEoyOTJQOVBlZlZTM1VYakJvdmI5eW9XTGoxMmJ2VW10YnRRVzJxekg3cWpMSHNvOTZDUnF4S2thci9BQXFOcWpzbzlBS2NPS3lSNHZ0YndmOEFFdldmVnZRMmFob2o2L3ZtS3c1SHB2ejdVaGoxZlVTQTAxcnBjSjZpQmZ0TnhqdGgzQWpRK29NY2c5RDNvQTFaNTF0cmVTYVJsamhpVXM4anNGVkFPcEpQQUh1YXkxOFhRWGkvOFMrQzYxVWRudGtBaFB1SlhLeHRqdnNaaVBUdFRvZkNGajU4Yzl4RzJvWFVMYjBtdkcrME5FMzk1QTN5eG4vcm1xaXRRamMyNWlXYjFKelFCNXZaV21zYVA4ZEw2R1M4dGRMMC93QWFhYXQra2Rrb3VKRXZyTHk0Sm1Nc3FoZDB0dk5aZ0w1VGNXTG5JNzlyYWVFN0czdTQ3bG9UYzNVZjNMaTZrYTRtalBmYXprN00raWJSN1ZnZkhCam8zaEszOFNLRDVuZ3U5ajF4eU9vdFVWNDc3QS9pYjdGTmRiVjd1RTdnVjFtcFg5dm9sdTAxNWNXOXJicTIzelpwVmpqei92RWdVRlBWRXhYTDdqeTNxVFNFNHJML0FPRWxlOUgvQUJMN0M2dWgwRXN3K3l3QS93Qzg0M3NEMTNSbzRwcDAzVXRUSCtrMy93QmxqNitWWVJoVDdocFgzRnZZb3NaSDhna3U2dHExcm9VS1hGNWRXOW5DN2VXcnpTTEdyc2VpZ25xZlljbXFuL0NRM0YvL0FNZy9UYnFZZHByck5uRCtPNEdYNkVSRUgxeHpVK24rRzdIU2JocHJlM1ZicVJkalhEc1pMaHg2Tkt4THNPbkJZOUJWeER1WE5BR1dkSjFDL3dEK1B6VW1qajd3MktmWjFJUFl5RXRMbi9hamFNK3dxMXBlZzJlalBJMXJieHd5VGNTU2dabWwvd0IrUTVkdnF4TlhEVkxVL0VOam8wNnczRnhISGNTRGNsdW9NazhnOVZpVUYyLzRDcG9BNXI0aWJmRFBqUHdsNGorN0JIZHRvRiszWVFYN1JwQ2NkMiszUldLQS93QUt6U25wbXV3SCtjVnl2anpSN3Y0cGVDZFcwS0sxZlRiZldMU1MxVy91Mzh1UzJaMUlTNGppWGMrK050cmdPWWlHUVZCOE5iMjgrSjNnTFM5WTFxNG5YVUx5RGJxT24yekcxdHJLOWpZeFhWdUFoM3NJcDBsaUllUjFKUTlxWlhRNlhVZkVsanBWMzltbHVGTjRGRGZab2xhYTQybnY1U0F2ajN4aXE1MUxWTC9pMXNZckdQT0RMZlNCM0h1c01aTzVmOTZTTSsxWHRPMHUzMGV6K3oybHZEYXdiaTNsd1JpTk1ucWNLQU1uMTZtckJvSk1rK0dEZkQvaVlYdDNmLzhBVExkNUVBOVJzanh1VStrcGsrdGFGbll3MkZvc0Z2RkRid0o5MktKQWthL1JSZ0NwaHljQUg4QldZZkZsbkxJMGRtMG1wVEt4VXBacjVvVmgxVm56NWFON095MGFnYWRCN25zb3lUMkFySk1tcmFqOTFiWFRZMjlmOUlueDlQbGpSaDlaQjdIcFMvOEFDSTJsemczM25hcElwenV2V0VpZ2pvUkhnUktmZFVCcEFjbjhhTmRYVWZBVXVxYURiM3V2YXQ0WHVJOWNzWTlNakUzMmg3Y2xwYmRKQ1JGdm50elBiNDM3c1hCd00xMDloZlhuaWV3dDd5enZMR0RUcnlKWjdlZTBQMnBwNG5BWkpGZGdJMURLUWZ1U0RCNFBldG9PeXlDUU44NjhxeFBJSXJpZmdxRjhPYWJxM2hNZ1IvOEFDSGFnMWxacjBCMDZWVnVMTFlQK2VjY01uMllIdTFuSjNCcXJqT2lnOEoyZ25qbXVGa3ZyaUk3bGx1Mjg1bGIrOG9iNVl6LzF6VlI3VnBrYzllZW1UV1o0cDhaYVA0RXM0N2pXdFUwL1NZYmh0a0xYYzZ3L2FIL3VSaGptUnoyVkFXUFlHc1lmRVBWTmRCLzRSL3d2cVYxRzMzYnpXUzJqV3BQY2JKRWE4eU94K3pCRzdQam1qVmlzZFpqRlpQaXZ4M28zZ1VXNDFqVXJQVDVMekl0WVpaUDlJdkNNWkVNUXpKTTNJK1dOV1B0V1NmQXV2ZUlQK1E1NG91b29jNE5sb0VSMHVGbDY0ZWZmSmRGZ2Y0NHBvUVFCOGc1enMrRS9BV2krQmpjTnBPbTJkaE5lWU4xUEVuK2tYcEdjR2FVNWtsUEorYVJtUEo1bzVRTWYvaE9kYThRWlhRZkRONHNmVVhtdlNuUzRYSHFrSVdTNjNEUDNaWVlRUm41eHhrWDRlNnRyNEI4UStLTlN1SXo5NnkwWlcwYTFKN0hmRzczZWZVZmFnamQweHhYWEFLQmlvZFcxVzEwRFJyclV0UXVyWFQ5TnNVTXR6ZVhVeXcyOXNnNnM4akVLaWoxWWdDaXdGUHd0NEwwbndSWnkyK2o2Wlk2WERjTnZtVzFoV0w3US93RGZrS2dHUmozWmlTZTVyVEF4WHdwKzFkL3djY2ZzcWZzcnRkV2NQanVYNG5hOWJrci9BR2I0SXRocWNZYm5HYjFtU3p4NjdKbllmM2EvTWY4QWExLzRPN3ZqRjhTVnV0UCtFZmcvd3I4SzlOZkt4NmxlNDhRYTBQUmxNcXBhSm51clc4cEJ4aCs1WStVL29XOFUrSnRNOERlR2J6VzljMUxUOUQwWFQwOHk2MUhVYnBMU3p0Vi92U1N5RlVRZTdFVjhFL3RaL3dEQnpKK3kzK3pMOXBzOUY4U2FyOFhOZWh5aTJuZzYyV2F5RDRPTjE5TTBkdXlFakJlQXo0ejkwOUsvbXY4QTJpdjJ1dmlaKzFwNG5YV1BpWjQrOFYrUE5RalpuZ2ZXdFRsdW83UXQxRU1USHk0Vi93Qm1KVlgycjczL0FPRGNYL2drTjRGLzRLUitKL0hualA0ckRVOVM4RWZENld6c0lOQ3M3eDdOZGN2YmxaWkQ5b21qSW1XR0dPSUhaR1VaM21RN3dzYks0cnZZTHBHLysxai9BTUhhM3g4K0w3M05qOE1kRThLL0I3U0hPSTdpS0pkZDFuSGZOeGNwOW5HZjlpMVZsN1AzcjgyZmpwKzB0NDkvYVg4WW54QjhSUEdmaXJ4eHJXQ3EzbXU2bk5mU3dnODdZL01ZaU5mUlVBVWRnSy9wZitPUC9CdEYreC84WWZCMHVuNlg4TzcvQU9IZXBiZHNHc2VHZGN2QmN3SHNURmRTelFTRDFEUjdpTWdNcE9hL25TLzRLT2ZzSStKditDYnY3VzNpVDRVK0o3eTIxZVRTZkt1OU4xYTJoYUdIV2JDZGQ5dmNxakVsR0s1VjAzTnNrU1JRemhRelRxUFhvZlpuL0JyVCsyOTRKL1piL2JqOFU2RDQrMWpUdkRlbmZGRFFFMHJUOVd2NTFndFlOUWh1Rm1paWxsYkN4cktobFVNeEE4d1JxZnZBaitpajQzL3RDK0FmMlkvQmtIaUw0a2VOZkN2Z1RRcngvTHRyN1h0VWhzWWJ4OWhmWkNaR0huUHNCWUpIdVlnWkFOZnhLK1dXNDlmWHVLZmJhVEpkbkVVTE93eVNGWEovTC9DbnpOcXhKOXAvOEhCZi9CUkR3bi93VWwvNEtBU2VLdkFZdUxqd1g0VDhQMjNoVFNkUm5oZTNrMW1PR2U1dVpMcnluQWVOR211NVZRT0F4alJDeW94S0w4TjlELzhBV3JVT2ovWngrK2tXTTUyN0FkemsvUVp4ajN4WFhlQVBnTDRtK0kxOUZhYUpvTjVlWE53UjVBa0cxcHh6d2tRK2QyejJYZDB4aW91bHVhYXZZNFd6c3BMeTVWSTQybFp2NFVCTEg4QnpYWmVIOUQwM1NmRCtzWE9vM1ZuTGRXOGNhMmRzbHcyNlNWcGsrZjVVWWJWVlpOd2thTTRPQWNrQS9hZjdQSC9CQmo0cmZGT0sxbThSMjgzaDNTNW1XWjRyOWpaZ2pqUDdoVmFYZDErOGtmUWNpdjFaL3dDQ1pQOEF3UzcrRWY3RE45L2FtcWFCSDR2OFFNaUtsN2RhZEJMYjI3SkpIS3NxeHk3Mzh4SGlSbGN1UXBHNVZRbmpuK3VVZWJsNXRUWDZyVXR6TkhxSC9CdjkreGxxZjdLdi9CT1B3OUQ0dDBxVFRmRS9qaThsOFVYZGxjdytWYzZiRE1rVWR0QzR3R1J6REVrcFE0WkduS25sYSsxMjhKdzdoc2ttakFIQ01kNmp2MytZL3dEZlZWdEUrSStpNjh3RWVwUWladWRzK1lXSi93Q0JZeno2WnJvb3h1VU4yUEk1NjExZTA1bmVMT2JsY2RHWVRlSDdpQS9LSTVWLzJXdzM1SEEvVTFCTkcxcWYzcXZEMnpJQ28vQW5nL2hYVUtuR0tjRjV4K2RGMkJ6QWpaVC9BQ0dPVFNoY0g3cDQ2OFZ2dm9kcklmOEFVcW5mTWZ5Wit1T3Y0MVhsOE9GUis2bWJqbkVneitveGdmZ2FRR1ZzeHg2MDVSdVhiN2QveXExTHBGeEQvd0FzOXc5VU80RDhPRCtsUWJmM3BYbmYvZC9pWDZqclFBM2R4ejlhNHI5b0tGdGQrSHc4T296TEo0eXZiYnc4U3ArWklicVZZcmlRZThkdVpwUCsyZGRzVXdQOGUxY3VMUWVLdjJndkQ5dm5mRDRUc0xqV3B3UCtXVTg2dFoyb2IvZWplK0k5NFQ2VTllcFVlNTZqa0YyMnFxcWVpZ1lBSFlVamZlb1g3MUdNbWtUdG9PUTVMZTFPSFAxcHFIbW5CUWVPUHpvQWNhQWZUdDdVbWVLUUdnQ1FIUDFwUnp4VEZPS2NlV1gyNTYwd0pFUFA2aWxQQi9yVEFkd29CNFduWUNVTmswb2Jqb2FqQno3ODA1VGpOS3dFZytZZlNuRG44YWlCRFlGT0IrbmFrSWtEWnFRRVlxRVB1L0tuS2Rwb0dTMGpESXBjWlB5MGRhODgwS1dyeGVmWVRRblA3NVRId1A3M0g5YWlzYkNQVExLRzJpRzJPQkFpZ2VncTY2Qm0rYm5hY2lvWEdEV1BzWSsxOXMxNzFyWDYyM3Q5L3dDUmNkckVEajVUL25OUlQvZC9TcDV1bjU5cWhsUEZiREtVZ3J4NzlxWDR4WDN3V204TzN0dkhtemJVRXVybDFQek9rTG9YaUE5R1U0SjdaRmV4eUx0M1Y4Q2Y4SEkzN01mL0FBMFAvd0FFdlBGT3NXZHUwbXUvQ3U4aDhYMmp4OFNpMmozUTN5Z2pvb3RacEpUMnpicWV3cVkvRUhOYlUvUWdQSEtOMFRySkRJQTBicjBkVHlDUFlqbWtQRmZIZi9CQkg5cDl2MnEvK0NWSHd0MVM2dVJjYTU0UnRKUEJ1ckF0dWRKZFBieVlONTZsbnN6YVNFOXpJZXZXdnNNOC93RDZxN0l1NkpxUjVaTkhFNmZmWEhoVDRuNi9wTnRZelhTYTFISHIxb3hsU0tCSElXMnVVeVR1d3JSUVN0c1JqdXZNa0RPVHZmMmZxZC96YzN5V2FIL2xqWXgvTVA4QVpNc2dPNGU2cEdhei9pUC9BTVNYVXZEdXZMMDAvVUVzYm85emEzaFczSTlsV2Myc3JIc3NCcnBNY2UvdlF0dzZJbzZkNFpzZEt1UHRFTnV2MnJHMDNNck5OY0VlaGxjczVIc1d3S3VtUG1vZFMxZTEwV09Ocnk1Z3R2TmJiSDVyaGZNUG9vUDNqN0RKcWxKcmwxZW4vUWRObmtIL0FEMXZHTnBGOU1FR1hQcG1NQS8zaFZrR200d1B4cXBxbXQybWorWDlydVliZHBmOVdqdCs4bVBvaS9lYyt5Z2sxWE9qM2w4MyttYWxMcy81NFdTZlpVSTkzeVpjKzZPbWZUcUtzYVpvbHJvdm1HMXQ0WUdrL3dCWTZMKzhsOTNmN3pIM1lrMDBJcS8yM2VYZWZzV215N08wdDg1dFVQMFRhMHVmWmtVZTlIOWlYVjZQOU4xSzRrWC9BSjUyYW16alA0aGpLRDlKQVBhdFFKeHhTZEQ3MVJQb2NONHUwVzA4QStOUENuaUN5dGJlMGhhN2ZRZFRlTkFwYUcrMkxDN2tEYzcvQUc2R3lUTEU0RThoUGV1NkhGY3o4VTdLeThWZUVOVzhPemFndG5xR3FXYngyeGpRelhOcktSbUc0U0pBWEpqa0NPQ0IxUVZYOEFmRUxVdmlmNEYwZldyZlNvOUpiVTdWSnJoTDZUTFdjK01Td2lLTWtzWXBBOGJLN3hzR1FqSFdncm9kZDFxaGZlSnJIVDd0clpyZ1NYYTRKdFlFYWU0QVBjeG9DNFgvQUdpQUIzSXFBZUhYdmdEZjMxNWVkekdqRzJnQjc0U01obVUvM1pIY1ZvV1duUWFaYkxCYXd3MnR1cHlJb1l4SEdEL3VxQUtDU2gvYUdwNmdmM0ZsRFl4dC93QXRMeVFTU0Q2UXhrZ2crOHFrZHgycFArRWFGOEQvQUdoZFhXb0syY3h1L2xXNUhkVEdtQTZuMGtML0FGTmF1TUNsVUYyd29MSDBBb0FoczdHSFQ3UkxlM2pqZ3Q0L3VSUm9FUmZvb0dCVTJLeXBQR05qNThrTnJKSnFWeEd4Vm9ySkRPVVlkVmRoOGtaLzY2TXRNYWZXTlNIN3VPejBtTnVjeWszVnhqMEtxVmpSdmNQSU9uQm9Bby9Genc1ZmVKL2gxcVVPbFJmYU5hc3dtcGFWSHVDaVM5dHBGdWJkU2V5dExFaU4yMnN3UEJOU2VIdml2b3ZqZnc5WWF0NGZrdWRjc2RXdG9yeTBheWk4d05GS2drVGU1SWlqY3F3SldSMUlxMy93aDl0ZGtOZk5OcXpBNS8wNXhKR2NkUDNLaFlRUjZoTjN1YXdmZzdHdmg1dkVQaGMvS3ZoM1ZKSHNrSXgvb0YzL0FLVmI3VjdSUnRKUGFwN1dSSGFnclN4dkU2eHFYVDdIcFVmZkFOMWNNUDhBeDJPTmgvMjFCL0RsVjhIMmR3NnZmQ1hWSkZPNE5mdDV5cXcvaVdQQWlSdmRFVTFyQVlGTXVKNDdPM2ttbWtTR0dGZDBranNGU01lcEo0QTl6UVNLUnVQelpZKzlPemlzbi9oTG9idFIvWjl2ZWFvcmRKTGRRc0dQVVN1VlJoNjdDeDlqVFJiNnhxUi9mWGRycHNmOXl5WDdSSUQvQU5kWlZDNDl2Sno3MEFhZDVmUTZkYlBQY1RRMjhFZjM1WlhDUnA5V1BBck9IaXBiNEQrejdPN3ZsYnBNRThtMndlamVZK042bjFpRDFKWmVGYk8wdTB1Zko4KzZqNVM0dVhhNG1qOWRydVNVQjlGd1BhdEFwbHM5VDZrNU5BR1JOcGQ5cmtVa2Q5Y1c5dmF6S1VrdHJXSVNiMUl3eVBMS0NHVmhrSEVhSG5yM3JsdjJldEJ0ZEY4R0pwY3F0Y2ExNE51WmZEczkzZE8wOTQwY0dQc3p2TElTMlpyTjdXY2dIQTgvR0J5SzlCSUJyaE5SMWkxK0hYeHdMWGx6RFoySGpiVGQwZm11STFiVUxFZ0VLRDkrV2Exblg1UnpzMDQ4Y1VEUjNXMEQ1djFOR2Npc2x2RU4xZmZMWTZiY09yZEpyMG16aXgzRzFnWnMrbjdvQS8zaFFOR3ZkUi80L3RTbTJkNGJGVGFvUjd2bHBjajFWMHo2ZHFCRnpWZGRzOUZaRnVyaUdHU1lFeFJsdjNzM3NpRExPZlpRVFZOTmJ2cjVtRmpwY3l4c2R3bXZuK3pLUWY3cVlhWEkvdXVpWjllOVhOSjBHejBUelBzdHRCYm1ZNWtkRXc4cDlYYjd6bjNZazFZY2hYVS9oUUJtblFMcSsvNC90U3VKbDd4MmViR1A2NVZqTG4yODNIdFZ6U3REczlFZ2FPenRiZTBqa081MWdpRVljK3JZKzhmYzVOV2djaitsWjk1NG5zck83ZTI4NHpYY1p3OXZib1o1azlOeXBrcVBkc0Qzb0F2Z2NZeFhIZUNmK0taK0tIaWpRY010dnFSajhSNmV1TUwrKy9kWGNTZXUyNGlXZHoyYlVWOVJXNHQvcW1vNThtMWcwOU00M1hUQ2FYL3YzRzIzSG9mTno2cjJyaXZpNTRiaTBYVXZEUGluVUxtNDFDUFI5UlhUNzRUc0ZoTmhmc2x0S3JScUZqOHRMZzJkdzdTQmlFdFd5MktxSlVleDNOeDRyc281M2hoa2E5dUl6dGFHMFF6dEdmUjl1UkhuMWNxUGVvL3RPcTZnZmtndHROanhuZE8zMmliNkZFSVJUNytZL3dCSzBvTE9PMGdXRkkxamppRzFJd05xb1BRRG9Qb0tmMngrRklreS93RGhFNEx2L2ova3VOVTV6dHUzRFJlMzdwUXNXUjJPemQ3OTYwNDRsaWpWUmdLZ0NxTWNLUFFDcXV2K0lMRHdub2srcDZyZldlbDZaYWpNOTVlVHJiMjhPZUJ1a2NoVi9FMXpKK0xmOXZ4LzhVdm9PdGVJdk00UzhhTCt6dE55ZWpHNHVOclN4ZjdkckhjWS91bnBScXcxT3gzWkZVUEUvaXpTL0JXa2YyaHJXcWFibzFodjh2N1RmM1VkdER1N0RmSVF1VDJHY211Zlh3NTR1OFNqZHF2aUMxOFB3dC95NmVIN2RaWlFPaFZydTZSdDZrZERIYndPT3paNXJROE0vQzNRUENPcWYyaFo2Y0cxWFpzT3BYazh0OXFKWCs2YnFkbm5LLzdPL0E3QVVETTQvRkc4MTV0bmh6d3hyV3FBNC8welVVYlJyRmZxMDZmYUhVamtQRGJ5b2Y3d3JQaitFbXVhNzQwbThRYXQ0bnVOTG11ckNQVHA3RHc5Q0xXS2FHT1dTV05KYm1VU1R5TkcwMHdXU0Q3S2NUUGxlUmowQThBL3JUeEU4cXN5cXpMR056WUgzUU81OXFQUVJnK0VmaHZvZmdlOWx1OU4wMkdIVWJwZGx4cUVoYWZVTHNmOU5ycVV0UE4yL3dCWTdjQURvQUszUUZVLy9xcjVBL2EzL3dDQzd2N0xYN0dvdXJYeEI4VU5OOFVlSWJVTVA3QjhHcU5kdmk2bkJqWjRtRnRDNFBHMmVlTTErWkg3VzMvQjRUNDA4VG02MDc0SC9ESFJ2Q05xeFpJOWI4VnpmMnRxRHJqaVJMV0lwYnd2M3c3M0MwN2pzZnZySS9sd1NUdWRrTUs3cEpHTzFJeDZrOUFQYzA2WGRDNVZsWldVNElQR0RYOFovd0MxVi93VVIrTi83YlY0Ny9GVDRvZUx2R1ZxOGdsWFRyaTcrejZWQ3c2R094aENXMFo5MGpCcnQvZy8vd0FGb3YyclBnVDRmMC9TZkRIeDQrSUVHbDZYQ2JXenM3KzhUVkliYUlydENLdDBrb0NxT0VIOEdCdDI0bzVnMFAyNS93Q0RpTC9ndGQ0dy93Q0NiTS9nbndIOEpiend6SDQvOFZXZHpxdXIzT28yUXY1dENzUVVqdFhqaVpoRUpKcFB0R1BOUnh0Z3p0K1lHdndBL2FjL2JuK0wzN1plc2ZidmlsOFNQRnZqZ3JJWlliYlU5UVpyRzFZOEh5YlJjVzhQVHBIR29yaFBpZjhBRTd4SjhhUGlCcW5pcnhocjJzZUtQRTJ1VEc0djlVMVc2ZTZ1N3lUQVVNOGprazRWVlVET0FxZ0RBQUF3ZG1Eamx1L1dwRDBGZTdiY2Y4YWlrbUo3bnIxb21HMTFVdGpkOTBldFNXbW0zRi9Nc2NFTWswanY1YXFpRmlXUEFYSHJrWXhRSWdkK24wNXlldjhBbitsZnBmOEE4R3lmL0JTL3dYK3diKzAxNHc4TS9Fdld2K0ViOEYvRk93dGJkTlhuWnZzT21hbGF5T2JkcmtESWppa2pubmpNeEJFYkZDeFZDN3IrZHkrQm10TGp5YjY3dDdXNUxiUmJMbWE0TFk1WHkweXl0OVFBZlh2WFYvQnI0UzZuNG4rSXVqMjFuNFB1dkZVaHVvWlcwYVl6ck5xY1lZTTBQbFd1YmtCMUJYZkdRVnprRUhtcWpkTzRjdHoreExSLzJrL2h6NGk4RVhYaWJUZmlCNEgxYncxWXgrYmM2dHAydTJ0OVpXNll6dWFXSjJSUmpCNVBPUlg4dHY4QXdYSi9iTGY5dmY4QTRLSStLUEZRMGZWZkRHaytIN2FEd3RvMmw2dGF0YjZxdHZhbHlYdUlQdlF5eVRTelNlVytDaXlLaEpLa245WS8yU3RKK1AybGZzOFIrRmZoQit6L0FQQ3Y5bFBueTdYVzlYdWJuWE5Vc2tmbVNlMlc0YVdaSjhzU291RVlFa2tsVFVYd0kvNE4xZmhmNGUxcVRYdmlKclhpajRqK0liNmQ3dS9sbHVYMCtDK3VKQ1dsbGxkWGE2bWQyWml6UFA4QU1Ua2dra25PcFZpamRVN0kvQlh3RDhFZGY4ZStJTGZTOUkwRzh1cjY5d3NFVTBNaG1sSkdRWTRJZzBqRWpHQ01qbjBOZmJuN04vOEF3YnRmSFA0MlJ3M0d2YWVQQmVtemJTMzl0dU5QeUNSay9ab3c4NU9PZ2tTUFA5NFlyOTl2Z24reTU0TCtBdWtmMmY0TDhKNkQ0WHRTTU91bTJTVzdTLzc3cU43bjNkaWZldlM5TDhLS2dYNVZIcGdkS3dsV2s5RUhMR081K1lmN01QOEF3Yk8vQ2Y0WFBCZCtMZFUxanhsZXhrTTBOdW45azJlNzZvNzNKeDdUcU04N1JYM3I4SFAyT1BBdndTMHRyWHduNFIwRHc1RklNU3RZV0tSVFQrOGtvRytRKzdzeFByWHRXbStIbFRHRkZhMEdrb2ljMWs0dVh4RDlvMXNlWW40TzJaYi9BRksvbDFxdk44SllZaCs3VHA2VjZ3MWduOTM4NmhrMHhXSFRyV2JveEtWYVhVOGR1ZmgzSkRuQzU3Y3JVZGpEcVhocHMyZDVkV3Z0SElRdjRyMFA0aXZXcm5TbFlmZDkrbFl1cytGVm5qK1ZlVDB4V0VxTGpyRTFqV3ZwSXhmRHZ4ZXY5UHVFajFTTmJxM1lnTktpYlpVSHJnY05qMHdEOWVsZWxXODZYY0Vjc1RMSkhJb2RHVThNcDVCSDFITmVVMy9oV1dOZnUwM1QvRSt0ZUZvMWp0N2h2czYvZGlrUU9vSHB6eVB3TmFVY1pLR2xXN1FxbEJTMWdldUJRUi9qVHR1ZTM0bXZQZE4rTjhrVzFkUTA3Y083Mjc0LzhkYi9BT0tyb3RKK0tlaDZzUW92QmF5Ti9EY3FZLzFQeS9yWGJUeFZLZXpPZVZHY2QwYit6bnQwcEpiZFpsMnZISEl1ZnVzQVJUb3BWbmg4eU5sa1JoOHJLZHluNkduWUpQMHJvTVRQdS9EOE53aktyelc3SCtLTmg4djBEQXFQeXF2NFQ4RWFiNEtodXhZeFNDYlVKL3ROM2N6ek5QY1hjdTBLR2VSeVNjS29WVkdGUlFGVlZBeFcwRngrZmVtc3ZQYnB4UUFnTkdNZjRVNHJ6N1VwWGIwb0FhRncxU2RLUlJ6U25tZ0JDY0h2UzUvejZVblVmanpTcU0wQUFPM3B6N1VLR1BkcWNxZk5Rb3gvK3FnQUI1L3JSak5BL1dncmx2OEE2OVVnSEtkdisxVGxPNDkveXBtY21rNm1oZ1NmNTRwNGt3ZXRSSSswOThldE9EY2Y3d3FRSkZmbi9QTk9WeWFqRCtvNmVsT1ZzSGcva2FBTHg2VXgrb3A5TmtHUitGY0xSb1J5ZjFxdktLc1NIcFVNZ3lQdzY0cVNvbGVYa2ZnZTlRdU53L0dwM09TS2lQREdnb3F6REorbzVySDhYK0U5TStJSGhYVlBEK3QyNjNtaTYvWXo2WnFOdTMzYmkybmphS1ZDT21HamRoK05iTndNR3EweTRQNlZuTGNOOUQ4Y2YrRFpEVzlhL1pQL0FHemYybC8yVi9Fa3MwbHpvTnkrdVdKYjVZM2wwKzZHbjNNcWovcDRpbnNwUmpxc1FOZnM4RC9uTmZqSC93QUZPTlZqL3dDQ1kzL0J3RjhFL3dCbzNDMjNnLzRxVzhXaitKMzMrVkhoVVhTNzZSOERrUldzdW4zSXp3enhIb2VhL2FDZUZyYWVTTnZ2UnNWT1BVVjJVM2RhQk83akdUOVBtdjhBZ1dNM3hSNGJ0L0dmaGpVdEh1MlpMWFZyU1d5bVpEOHlKSWhSaXZ1QTJSN2dWenZ3OHY4QVZ2SG5nblQ5UTFlL0VONjhiUVg5dnA4Zmt4cGRSTzBOekh2WXM1Mnp4eXFHUXg4RHBYWUVacmxQREMvOEkvOEFFVHhKcGYzWU5RTVd1Mmk0MnF2bUR5YmhGSHROQ0ptUDk2OHozclR6SVY5VWJ1bTZEYWFSTEpKYTI4Y00wdzJ5VEFGcHBSL3R5TmxtL3dDQkUxYUtBVlYxUFhMUFJtalc2dUlZWkplWTRpY3l6ZXlJUG1jK3lnbXEzOXQzbDkveDZhYklpWndKYjEvczRZZW9RQnBNajBkVXo2OTZwYU1ub2FlUjZtcWVwNjlaNlJPc054Y0lrN3J1U0JjeVR5RDFXTmN1My9BUWFyblFybStQK202bGR5RC9BSjUybTZ6aitvS01aYy85dE1lMVc5TjBhMjBhRm83TzNndFkzTzUxaGpDQno2dGpxZmM4MHhGSnRUdjc1LzhBUk5QOGxHUCt2dnBQTDQvdkxHdTV6L3V2NVpvR2hUWHZOOXFGMWNaNU1WdVRhUUQ2QkQ1bVBVUEl3UHAyclVLN0tCMDZaYjBwaXVWOU8wMjMwZTE4bTB0NExXRXR1TWNFWWpVdDNKQXh6NzF5L3dBUEF2aDN4dDR1OFA4QTNZa3UwOFFXZzdMRGZtUnBSbnV4dlliMlErZ21UMUZkQmZlS2JDeXZHdC9PODY3ais5YlcwYlhFOGZ1eVJnc28vd0JwZ0I3MXhQeEN2OVcwengzNFIxNjN0TGZUTFZycC9EMTdMZXNKblNPK01ZaFl3eE5nazNrRnBFcE13S2k0Yzdlb3BhRGoyUFJoOHg0NUo3Q3MyNThXV01GMDF2SE0xM2RSbmEwRnJHYmlTTStqaE1pUFBxNVVlOVJEd25IZkoveE1ycTgxVGQxaW1jSmJrZjNUREdGUjE5cEE1OXpXbGFXY2RoYXgyOE1jY01FUTJwRkdvUkVIb0ZIQXBpME16N1hyR3AvNm0yczlMai92WGJmYXB2Y0dPSmdnK29sYi9kb2J3ZERlcHQxS2E3MWpzVXZIVXdrZWhoakN4TjdGa0pIcld4akZBNUI5aGsrMUFoa1VDd3dwR3FoWTQxQ29pamFxRHNBQndCOUtmV1QvQU1KblozSksyQ3o2dklEZ2l4VHpJd2U2bVlrUXF3L3VzNFBUamtVaEdzYW4vRlo2VkhuSHlBM1U3RDF5d1dPTmg2RlpRZjVnR3JKSXNjVHV6QlVRRm1ZbkFVZXBQYXZPUEUzak8xMFA0eWVHOVUwMk81MVdIeEpiemVIcnA3TkFZR2tSWkx5MGN6dVZod2dTK2p3Sk54YTZVWUpyc2s4RzJja2l5WGl5NnBNaDNLOTgvd0JvQ3QvZVNNL3U0MjZjeG92U3FIeGc4TTN2aXo0YzZuQnBxK2RyVnNJdFIwdFdiQWU5dFpVdWJaV1A5MXBvWTFiMVVrZDZDb2w4eGF6cVkrZWEwMHVNOVZ0bCsweit4RWtnQ0tmVUdKeDZIdlRvUENGaWwxSFBORTE1ZFJOdmpudTNOeEpFdzdwdXlzZjBqQ2oycWJ3djRscy9HbmhqVE5hMDEyazAzV2JPRy90SFlZTHd5eHJKR1NQZFdCcXpmMzl2cE5tYmk2bWd0YmRUaHBacEJIR3YxWnVLQkVyRG5jZm1iMUpwZDJCV1MzaWhyd2Y4Uyt4dkx6amlhUmZzMXY3SGRJQXpLZXpSbzROTUduNnBxZVRjNmd0bkdlZkpzSXh1R2Y0V21rQkxEM1JJajlLQkdocWVzV3VpMm4yaTh1YmV6aDNiUkpQSUkxSjdBRTlTZlRxYXBONGtudStMRFRicTRIVHpia0d6aEI5RHZIbUg2ckd5bjE2NGswenczWTZSZGZhSWJmOEEwb3J0TjFJelRYTGowTXpscEdBOUMyQldnRTIvL1dvQXlQN0sxTFV1YnpVVERHZitXRmdua2dqMGFSdDBoeDJaUEtQdDZjcjhZL0Q5cjRQOENTK0o3Q3lYKzBQQ004ZXZ2S2dNbDFjd1FCdnRjWmM1ZVIzc3BMdU5ReFB6U2cxNkMzQy9oVlBVUEVGbG8xMGtOeE5IOW9ZQmx0UXBsbmxIdEVvTHNQWEFJeDdVQVcxMmcvSzBjaS93dWpaVngySVBjSDFwZDJhODIrQXVvNmxhZUJHOE13V1RRdDRKdXBQRDNuWDhtSCt6d3FqMlQrV3VXZG1zWmJOMkR0R2R6c08xZGtmRDgxOFArSmhxRjFjQTlZb1dOckNQYmFoM2tIdXJ1NFBwUUQwTE9vZUpMTFRMZzI4bHdHdWxHNDI4S1BOT0I2K1dnWjhlK01WWGU5MVBVZ2ZzOW5EWXFSZ1MzcmlSaDdpS0ppQ1BySXA5cXZhZnAxdHBWdjVGcmIyOXJiZ2tpS0dNUnhnLzdvQUZURGdkZmVnRExUdzZMN0RYOTVkMzNyRnY4bTNCN2p5MHh1WDJrTDlPcDYxb1dkbkRwdHRIYjI4VWR2YnhjSkhFZ1dOZm9vNEg0Q2ttdUk3TzNubW1rU0czdDBNc2tzakJZNGxIVXN4NEFIcWE1aFBqRHB1dFJodkR0cnFYaTlXT0ZuMGVGWHNuN0VpOWxhTzFiYjNDVE13UEcwbmlnTnpyUWVPUHlySThmYVZwUGlId0RybGg0Z2xpdC9EK3BXRTlscWMwc29oamp0NW8yamt6STJGVDVHYmtrWXJIT25lTnZFNC8walVOSjhJMjdmS1k5TWovQUxUdnZaMXVMaEZnalBZb2JXWURHUTV6eE5wZndYOFAyT3B3YWhlV3MydmF0YXQ1a09vYTFPK28zRnEvZG9ES1dXMnozVzNXSlQvZDRvR2N0OEpmanZlK04vaHJvODBlamE3NG4xOUlEYmFsZFdkbUxUVHJpNGhkb0picUs2dVRIRExieXlSdEtodDNsWXh5SXdVZ2dubzEwTHhuNG56L0FHaHJHbStGYlZ2K1dHaFFpK3ZBUi8wOTNjZmw3VDNVV1lZZnd5REdUMlRibmtabUpabU9TeE9TZnhvQXljQWNuc0JUSGM1blFQZy80ZThQNjFEcXkyTFgrdFcyZksxWFU1NU5RdjRjOWZMbm5aM2lVOC9KR1VUbkFVRGl1bXp1Yk9jdG5KUHJYem4rMXAvd1ZzL1p6L1lqYTZ0ZmlGOFYvREZucmxxV1dUUWRNbE9yYXdyaitCN1cyRWp3azlqTjVhLzdRd2EvTWY4QWF3LzRQRGxScnJUL0FJRi9DUW5IRWV1ZU9ybnR6a2pUN1IrT3hETmRIM1NrSS9jUHZYR2Z0RGZIWFJ2Mlp2Z2g0cCtJSGlDMTF5OTBQd2ZwMG1xYWhEbzFnMS9mZVJHTXlPa0trRmdxNVppU0ZSRlptSVZTUjV6L0FNRTNmamZybjdTWDdBdndsK0lIaVRXN2Z4RjRoOFplSFlOVzFPOXRyZUszaE56S3p0TENzY0toRUVMN29NQVovYy9NUzI0bjI2eHRvNzY4anQ1STQ1NDdoeEc4VW9ESktySEJWZ2VDcEJJSVBZMVhLSS9DMzlyRC9nOFgxaS9tdWRQK0J2d25zTkxnNUVXdWVON2szZHd5a2ZlV3h0WFdPTmdlUVd1Smw5VlBTdnkvL2F6L0FPQ24vd0FmL3dCdVJwWXZpZjhBRlR4UjRpMHVSZzM5akpPTERSMUlPUml4dHhIYjVIOTRvVzl6WG1YeGswYlJORStNL2k2MDhOeXJkZUdiUFhiNkhTSkEyNVpyTkxtUllHQjdneGhUbXVjVzBMSDd2MTk2a29oUmRpY0xnWTRHQi9LbktwVldadUZVWlludFYyTFRXNnNPR3oxN0d1My9BR2ZiaTM4SS9IYndQck45cE0ydmFmby9pUFRyMjYwK0tFelBmd3hYVVVqd0JQNGpJb0toZTVZRHZWUmpkaVAwbS9aSS93Q0RTajRvZkczNFBXSGlqNGovQUJFMHI0VGFuck51dDNhZUhqb1VtcjZoYlJzdVVGNSsvZ1Mza0lJSmlVeXNtY1BzY01pL0pQOEF3VXMvNEkyZkZ6L2dsNXJtbnllTW9OTThRZURkZW5hMjByeFhvcnZKcDl6TUZML1o1VmRWa3Q3allDd2prRzF3cm1ONUJHNVgrcnpXdkdNSmx1SjdlT2E2aDNzeHVKUDNFT09TU1hrd1BxT281NDRyODVmK0RpVDQ2YWpmZnNIcjRWMGE2OEYzbW1lTXRidDdQV1pMK3pudW9MT0NBL2EwbGl1Y0NHT1FTd0loTE1weEo4ckE1b2xaRGpGeWRqK2IydzhOM09weWJMZUdTYVRPQXFxY2s5Z1BYdCtkYVdsL0RlNjFmWG9kTHQ0NUo5U3VwRnRyZXl0b251cnU0bVloVmpXS01GeXhKQUF4a2tpdnR2OEFaMy80Sk8vRkQ5cEMxdHB0QzhMK0pOUzBhNklaYisvaC9zUFJHUmhrT0hjb0xxUG9OOXZMY2tjZkllZy9RSDlrZi9nM3Z0ZmhQcittNjk0bzhkVFdPb2FiTkZkUVdmaEMzVzNhQ1dNN2h1dlprek1oUFkyc2JnRC9BRmhyTjFJSTA5bWV0ZnNsZnM3YVIvd1RtL1pUMDIyOEZ5ZkMvd0NBL2lhNXMwZzFQeFpyMmxKNHM4VWFoY2xSdWE2bWp1N1cwczVOMjdiYUpkWGR2R05vK1p0NWI4NDdQL2dqcjhmZjI3LzJuL0ZIamJ4NUpyV28ydXZhemNUYWg0bjhRMjhHaExyS2c3SXBsc1lIWnpHOFNwZ1FsbzFVQlEyTVYrM0h3MS9aYjhJL0RqVTQ5UzA3UmxtMXRWMmpXTlNubTFQVlF2OEFkRjNjdkpPcWNrN0ZjSUNUZ0N2UnJUdzhpSEpYbXNwVm5lNk5PUkxRL1BEOW12OEE0Ti92aFg4TE5JOHZ4RXR4NGprbGlLVDJ0cURwMW0yNWRycXpSa1R5S3c3UElPcHI3TCtDZjdMSGd2OEFaKzBBYVY0SjhLYUI0VDAvR0hoMHV5UzNNdjhBMTBaUnVrUHU1Sjk2OVh0TktTUEhHUHFLdXcyaThmTCtsWnVUZTR1Wkk1K3k4S1J4ajd2L0FOYXRlejBKWWwrNzcvU3RPTlZROUttamxWZlQwK3RJaHl1UVdlbWhSamI3VnIyVmdxVlRiVmxnVThESFd2SXYyMGYydUxiOW1iOW1MeHY0dVNTTmRTMHZUWGkwd0hCMzMweEVGc01kd0pwRVlqKzZyZWxWb2tFWXR1eVBmSVl2TFdubVFmWEg2Vi9NWDhZZitDOTM3VDN3NytMVjViK0cvakpySDJQVHhCYXlwUFoyV29KTk5EaFpHY1RRTXZ6U0szQ25CVmh6azhmUmY3Sy8vQjN0NHcwYTl0dE4rTW53dzBYeFJaa3BITHJIaFc1YlRMNUFlREkxckw1a016ZXlQQVBUSFN0M2g1VzBKY2JNL2VndWFRTGtmcFh5Uit5dC93QUZ6UDJYZjJ1YjJQVHZEL3hUMGZ3N3IwakZCbzNpMy9pUTNUTnV3RmplY2lDWmoyV0dWMngycjY2RWJJaXN5a0xJQTZFOUdIWWoxSHZXRW90YmdNYTMzQ29aTE5XSi93QUt0S3U2bkxGbi9IRlNCa3o2UXJqa0NzNjk4S1JUZFVycDJnNXBqVys0OU0xbkttbVVwTkhBNmw4UG81TTdWeFdEcVh3K2tRTnRWbXIxZVd5VnY0YWdsMHRaQWVoNzgxenl3c1diUnhFa2VNcnBPbytINWpKWnpYVnEzckU1US9qait0YXVuZkZyeERvd0FtYUcrUURCRThXR0EvM2x3Znp6WG9sMzRlam5CM0x1OWF4OVI4RHczR2ZrSDVWbkduVXAvQXpUMnNKZkVpcnBYeDlzWlNGdjdHNnMyN3ZHUk1uOUQrUU5kVG8zam5SOWZLaTAxRzFrWnY0QzJ5VC9BTDViQi9TdUMxVDRhQi91NS9LdWYxUDRmem9XK1RjUGNWcEhHVm9hVFZ5ZlkwcGZDN0h1aDQ5dnJTWjVyd2F5MVRYL0FBcXdXejFDOGhqQjRqTDdvLzhBdmxzajlLMzlNK1B1cmFmdFhVTEcxdlY3dEdUQy93RDdNUDBGZEVjeXB2U2QwWnl3YzF0cWV0QVVZeUs0elJ2anhvT3BiVnVIdWROa2JyNTBlVXovQUx5NS9YRmRacE9zMmV0UStaWlhsdmVSNDVNTWl5WSt1Q2NmalhaVHJRbjhEdVlTcHlqdWl5b0FvUFhyN0dsQjNmblNubXRDQkNtNWZ4b0krbEtUajJvQXg2L1dnQk9xOWVLQmpINTk2S0FOdEFBcmNjK3RBNllveFR1ZzZVQU5wZTlMM29CNG9BRk9RS2szWk5OQklQRktPRC9YMW9BMGFiSjAvRDBwMUI2VnhtaEM0M0RpbzM2SDlLbTYxRXd4K1hyVURXNVVjL05VYkREVllsWGxxaGs1QTlLUlpYbVg1VG5yVldWY21ya295Zndxck1NSHZVeTJCYm41NS84QUJ6Sit5b1Ayai84QWdsOXIydDJzSmsxcjRVNmxCNG9nS3JtUjdUbTF2WS9VSUlaeE8yT1Q5a1gwd2Zwdi9nbHIrMVN2N2FuL0FBVDErRkh4R2ttYWZWTlYwT094MXBtQ2hqcWRtVGFYakVMd0E4OER5TDArU1JEam12V2ZHL2dqU3ZpWjRNMWp3M3IwSDJyUS9FbGpjYVZxVUgvUFcydUltaWxYOFVkaCtOZmx0L3dhOWVOdFcrQmZpVDlvejlsbnhaY3EzaUg0VytLSDFpMGpJS0daTi84QVo5NjBZUDhBeXlFbHRhU0RISCtsN3Y0cTBveU5IczQvUDd0L3dQMXQ2ZjhBNnE0MzRxV0syZXNlR2RjYVc0aGpzZFFHbVhqUVN0RXoydDZVaEM3bElaUjlyV3hjbFNDRmlibmFXQjdJSEZadmpMd3RENDU4SmFub3R4TkpidzZ0YXkyalRJUG5nM3FWRWkvN1NrN2g2RlJYVWMvTlprMm5hTGE2TXJMYVc4TnY1bitzS0lBMHA5WGJxeDl5U2FzS0FLNW53ZjhBRTIzMS93QUlhVmZhakpEYTZ0ZTIrYnV3aDNTelEzS0V4M0VheEtHZGhITWtpRWdIN2xhSjFmVXRRK1cwMDViV005SnIrUUtjZG1XSk56SC9BSFhNUkZBTldlcHE3Y250K1ZVTlM4VDJPazNmMmVhZFd1OEJ2c3NNYlQzR0QwUGxJR2ZIdnR4NzFCL3dqTXVvQS8yanFGMWVidVREQ3h0YmNmUlVPOHFlNnlTT0QrbFh0TzB1MjBpeit6MmR2YjJ0dmtzSW9JMWpqQlBVN1ZHTW4xclFrb0hVdFUxTC9qMTArR3dYcDV0KzRad2V4RU1STzVmWnBJMkhwU0h3dzE2YzZqZlhsOW4vQUpaQnZzOXVQVWJJOEZsUDkyVnBLMXNMUUZ5MkYrWStnb0ZjaHNkUGcweXpXMnRiZUcxdDArNUZER0k0MStpcndLeXZpTDRPYjRnZUE5WDBXS1piTzYxQzJlTzB1aVArUEs1SHpRWEEvd0JxS1pZNUZQWW9EVmk1OFcyTWM3d1F5UGZYTWJiR2dzME53Nk4vZGZibFkvcklWSHFSVWYybldOUkI4cUMxMHBleHVEOXFtSHNZNDJDTDlSSy8wb0RYY1g0ZmVMMStJbmdqU05janQydFcxYTBqdVh0ajkrMGtaUjVrTGY3VWI3a1lkbVEwc25qR3hra2FPMGFUVTVvMjJ0SFlwNTJ4aDFWMy93QlhHZjhBcm95MXhudzM4SVcybGVNUEdIaHJVbnVOVmh0cjFkZHNvN3dob1RiYWdaSlpOMFNLc0xOOXVqMUEvYzNLclJqUFRQb3lSckhHcUtBRmpBVlZBNFVEb0FLQnl0ZlF5aStzYW1QbFd6MHVKdjcrYnE0d2V4QUt4eHNQVU5LUHJTandiWjNSM2FnWnRZZnJtK2NTUmtqb1JDQUlWSTlWUUgzSnJXcGs5eEhhMjhrMHJwSERHTnp1N0JWUWVwSjRGQXJpN1BxY0RBeWVncDNTc2crTVlidGYrSmJiM1dyWjVEMnlnUUVlb21jckd3OWtabTlxVDdOck9vdCsrdXJYUzR1NjJhL2FKaDZZbGxVSUI2anlUN04zb0VhVjdmUTZiWnlYRnpMRmIyMEkzU1RTdUk0NHg2bGlRQitOWnc4WHJlRU5wdG5lYWg2VG9uazI0OUQ1c20wT3Z2RnYraDZVK3o4SldOdGR4M1RRL2FieUU3bzdtNWtOeE5FZlZHY2twMzRUYU9UeFdpUmxzK3ZKSjYwQWViZkJxeTFYVDV2RW5oZTV2TGZUWS9EdXF5eTJjRmtubU45aHZDYnVEYkpLdVBLUnBKN1pBSWtJRm1RRGdDdTQwN3dyWWFiZXJjUjIvbVhhQXF0ek83M0Z3by91aVNRczRIc0NCN1Z6dmlZLzhJcjhhUERlcUw4bHY0bXRadkR0NGMvZm1pV1M4c21iMFZWWFVVSHE5MGc1NHJxdFUxeXowUkVhOHVvTGZ6U1JHc2o0YVUraUwxWSt5Z21ncDl5d2RxSC9BRG1sT0ZCcktiWGJ1OTIvWWRObVplMHQ2eHRZejYvS1EwdVI2TkdvUDk3dlFORnZMMWliN1VwbVhQOEFxckpUYVJrZHNzR2FYUHVKRkIvdWlna3RhcHJ0bm9UeHBkWEVVTTB3SmlpSnpMTjY3RUdXZjZLRFZVNjFmWHh4WjZiSkd2OEF6MnZXOGxTUFZZMURTWi8yWFdQNjFhMHZSclhSVmtXMXQ0YmZ6anVsTWFiVEtSM2M5V1B1eEpxMHZDNG9BeWpvZHpmai9UdFNubUhlSzF6WnhaOVJzSmwvQXlrSDBxM3AyazJ1andORGEyOEZyR3gzTXNVWVFPZlVnZFQ3bmsxYVVHUS9LRHdDVDdldGNqY2ZHalE3dVNTMzBWN3J4WmVSc1VNT2hRL2JFUndjRkpMakl0WUdIUEU4MGZTZ0NDNGYvaEUvajNidDkyeThhYVViWThZUmI2eExTUmozZWExbm5KUDkzVGxIWVYyb2ozS3h4OHFnc3gvdWdja24wRmVjK0xQQ2ZpNzRxZjJXenZwdmdxUFNkU2cxTzF1STIvdFRWRVpOeXN2OEZ0QVpJWkpvWDV1bE1jOGdHQ1FSc240SmFKcXNpeTY4THp4ZE9wRGh0ZG1GM0NyRG95Mm9DMmtiRCs5SEFqZTlBRFI4Yk5GMWNNdmg5ZFE4WXlLY2Y4U0dKYm0zM2QxTjQ3cFpxNDdvODZ0N1U4UStNL0UzK3NtMGZ3bmF0L0RiZzZwcUJVOUR2ZFVnaGNkQ1BMdVY2NFk5YTY1bDNZM01mbEcwWk9jRDArbnRRUG5ZS3E3aTNUSGVnTG5LV3Z3YTBTVzhpdk5WanVQRXVvUXNKRXVOYm1ONzVVZzZTUlF0aTN0MjZjMjhVWTlxNnhzdTI1aXpIMUp5YThhL2FuLzRLRmZBL3dEWW1oYi9BSVdwOFVQQ1hnKzhSUE1HbVRYUnVkV2tYc1ZzWUJKY3NQY1JZOTYvTTc5ckwvZzc5OEcrRjB1dFArQ2Z3eDFieFZkTHVTUFcvRjA0MDJ4VTluV3pnWjU1azc0ZVczYjJGTWVwK3kwVWJUTUZWU3pFNEFVWk5lRGZ0WmY4Rk8vZ0QreEF0eEQ4VHZpcDRWOFBhdGJqNXRGaG1iVU5aempJQnNyWVNUcm4rODZLdnF3SE5melUvdGQvOEY0UDJvUDJ4dnRkbnIzeE8xUHd6NGR1OGc2RjRSem9kajVaNnh1WVQ1ODZlMDgwbjlhK092UFZHYmFvVGR5Y0RyU0RRL3EyL1pOLzRPRy8yVy8ydU5TMVN4dFBIaS9EdlVOUG5NY050NC9Odm9QOXB4QURFOEV4bWUzWlNTUjViU3JNTVpNWUhOZVNmOEZhZitEaWo0Ty9zM2ZCYnhONFIrRm5pelMvaVo4VVBFV2t6Mk9ueitIYnFLKzBmUUdtVXhmYXJtOFJqRThrYXM3cERFWkdMb29rOHBUdVA4MFpsM0RubjYrbE9VOGdmcFREUWtqaldHRlZYNVVVZEFPdE9UcnhqZG4xcU9QTzRHck5ucDgyb1RMRkRISk5JM1JJMTNNZndITklSOWdmOEU2ZitDNDN4My80SnIrRTV2Qy9nMis4UCtKUEE4bHc5MUg0YjhUV1VsM1oyVTBoQmtlMmVLU0thSGNSdUtMSjVaWWxpbTRzeDlmL0FHcC8rRG5qOXBEOXAzNFlhdDRSc2Jid0w4Tk5MMXkyYXl2N3J3elkzSTFLV0NSQ2tzUzNGeFBMNUlkU1FXaVJKQUR3NHI0QjBQNGUzbDNxVFdwK1c2UUFtMmlqZTR1QU91VEhHR1pmK0JZQXIyYjRTL3NvM09zZUgyMXk5czlOc2RFeVkvN1MxeS9TRzFWMUEzcmlOMWpEamtoSnJxRThkT09hdXVwcENMYlBDdEU4UDNHcjNzZHJhV2sxemNTOFJ3d1JsMmYyQUE5dTNwVy9EOE1iNjMxZE5QdWR0dmZNTS9aVVZyaTUvd0MvVVlaeDBQM2dQZnFUWDF4OEVQMmM5TitNTngvWXZ3LzBMeDM4YWJxRnRrOXA0VDB4N0xRb1dQVkxxNkl0NElmVGZMTmVJZU01SEZmWG53SC9BT0RmejRsZU9ybjdWNHkxZndiOEhkQm5ZTWRFMEczaThRYXVVd055U3piWWRQamtIQVdTR0dUR0Ixd0RXY3FrVVY3TnA2bjVmK0d2Z2ZlM1ZuTGVMWWZaN08xWXJMZWFwTUlvWVNwK1lPc1pLUnR4bkVzeWREWDFEL3dUYStCUHhFaytQdmd2NGdmQy93QUhlT1BpQS9oTFdJdFN0N3ZTMFRSTkUzeE1jeFMzMHdTMjY3Z1NKYnJjQ1JzSkpyOWZQMmQvK0NLL3dHK0FXcFd1cUh3ak40ODhTV29VSnJmamE2L3R5OFRhY3JzamtVVzBSQkhCaGhRakFHZUsrc3JYdzZDa1kyNTh0UWlEKzZvR0FCN0RwaW9sWGZRdmxzZktJK0IzN1JIN1FONEovSHZ4RzhQL0FBMzB5WWduUy9COXNkYzFZTHh3ZFMxR01XOExBY2Z1YkZnT29jbkREMFA0V2ZzQmZEWDRiZUtJZkVTK0hwUEVuaTZFNzA4UitLYjZmeEJxMFQ5MmludkhrTnZ6L0RiaUpQUlJYdmx0b2lyL0FBcitWWG9OTFZBZUt5bEp2Y2JsYll3WWREM3R1ZjVtUE9XSkpKcTliNktxRDd1SzJJN0VmM2Z4cWRiVEg4TlNTNW1aRnA0VWRLc0phY2RLdkxiVTR3YlJ6elFUek1wcEJ0SGI4YWN5N2Y1MVlNUFBQV281VngvV2drZzh6OC9wVVQzT3hNbmlpNm1XTmZ3ckQxalZjQmdyZmwycFNkalNNYmtYaVhYbThwbzR6dHozcnhuNDYvc2JlRy8yMXZEdWxhRDR1OFFhOXBHbTZmcmNPcFF3Nlhkd1c3MzAwYVNEYko1c2NtNUZTVmlBb0h6WVk1MmdWMytzNnBzM2JpdUt2ZkJtYlVDMnE2dEZvdWc2eERZUkFRUzI4MGNOeFBIS3lzNmVZMjVDUkVxWkxzaXVWVlRzQ2doVW84OHRUYVh1eHVqOG9mMnV2K0RQN1dyU1c3MUg0SS9GYTIxWE9YR2llT1lUYjNCNzRXL3RrWkhZOWc5dkdNOVhIVWZsL3dEdFgvOEFCTTc0Ky9zSENTNytKM3d4OFUrR2ROaGNLbXR4UmkrMGhtSjJwaTl0bWtnREU5RloxYnB4bXY2K1BEZWwyRm5ZVzUwcUg3QlpvcmVYYlFnSmI0WWxzcWkvSUFTeElLZGNqa2pGYkVQTU1pNStTWlRHNFAzWFhvUVIzQjU0UEZlanpOSEpkSDhOTXR6NXlNMytzVjg1WW5PNnZkdjJTdjhBZ3FmKzBCK3d5WVlmaGw4VlBGSGg3UzRTU05GbW1YVU5IYlBYL1FybFpMY0Uvd0I1VUREc1FlYS9wVS9hMi80Ti9QMlUvd0JzV2E2dmRYK0d0cjRMOFFYUU83V3ZCRW8wTzR5ZVN4Z1JXdEpHSjVMU1FNeDlldWZ6Ri9hby93Q0RPTDRoZUY1cnErK0RQeFM4TmVNTEVicEk5TDhVVzc2UHFDam5FYXp4aVdDVnVuelA1Q25uZ1k1aVR2dUk2ajlrbi9nOGkxQ3creTZmOGN2aFBiNmxHTUxMcm5naTQrejNHQi9FYkM2Y3h1eC8yYmlKZlJSMi9VajlqMy9nc2wrelgrM0cxclorQS9pcG9LK0lMb2hWOFA2NlRvMnJNNTZJa054dEU3ZFA5UTBnOTYvbGcvYXUvd0NDYS94Ni9ZZGxrYjRxZkN2eGQ0UnNWZFl4cXN0cUxyU1pYUFJWdm9ESmJPM3NzaE5lSmI5NDUyc3ZVWkdjMUxweFlYZlUvdXNhRm9aZHNpc3JEc3d3YVR5c0d2NC8vd0JrUC9ndGIrMDEreExCWjJYZ240cmVJSi9EOW15ckhvR3ZsZGEwcFVIL0FDeVNLNURtQmY4QXJnMFo5Ni9VVDlrbi9nOGowZlVUYjZmOGRQaFBjNmJNeDJ5YTM0R24rMFFaSnhrMkYxSUhSUm5KSzNNaDlGUFNzblJmUXE1KzNiUkEvd0JLYTF2bXZEZjJSdjhBZ3FGK3ovOEF0eVEyOGZ3dytLbmhYeEJxbHdEdDBXYWM2ZnJJSTYvNkZjaU9kZ1A3eUl5ZWpFYzE3MUlteVREWlZsT0NDT1FheWFhM0FwdEJpbzVMY0VkT0t1YkJtaGt6L3dEcm9zQm15YWVyQThWVnVOSFZ4OTFUeFcxNUFCcGpRWXFlVkR1emxyM3dwRFA5Nk5mcldKcVh3NmhuVnRxL3BYb0xXM05RdmFoaDkxUldjcU1XWEdySkhrZXFmREZrM2JGK2xZTno0SnV0T2w4eU1TUnlMMGRDVllmUThZcjNLWFRWWU54Vk81MEZKZXFxZmZ2WE5MQ0xkRzhjVTltZVU2YjhSdkZIaHlUYXQ5SmRSci9CZEtKaC93QjlINXYvQUI2dWowajlvNHg0WFU5SmIza3RKTS8rT04vOFZXL2YrQ29iazh4OC9TdWYxVDRZUnlCdkxVTHgycTR5cjA5cGZxTzlLZTZPczBYNHhlRzlkS3F1cHgyMGpmOEFMTzZCaGI4MitYOGlhNmFPVlpvbGtRaVNOaGtPcHlwK2hyd25WdmhoTkNyYlZPMzZWaXc2VnEzaEtZdllYTjVZdDFQa1NzZ1AxQTRQNDVyYU9PbXZqajl4UDFXTXZoa2ZTQjRwUXVhOEcwejQrZUt0QStXNUZycWNZNC8waUxaSmoyWk1EOFNEWFU2SisxVHBFcnFtcWFmcUdudVJ5OGVMaVA2OFliOGxOZE1NWlNsMXQ2bWNzSlVYUzU2Z0JuRklQOG1zWHc1OFI5QjhXRlYwL1dMRzVrYkdJdk04dVUvOEFiRGZwVzhFS0U4WTlLNlUwOVVjMG90YU1ZRHpTcXVUVGpudC9PazJybi82OUFnN0NsenlmNTBBZE0rbk5HM0RaSDUwQWFWQjZVTnc5RmNab1J0OTZveU1WTTY4RTFISU85VElDdktNZm5WZDErWDZmclZxVk1qakZWNVJnZm5VbWhDNHl2Ni9XcThxNC9IOUt0RWRxaG5UbjYwbUJTa0hIZXZ5UC9hb2ovNGQ0ZjhBQnpmOEhmaWZINWxuNFA4QTJrOU1Yd3pyVHI4c0wzc2lycHpxYzhBTE11ajNMSHVYZjNOZnJsS09hK1JQK0N2UC9CTi9UZjhBZ294OEtQQXRyYzYxZCtHdFErSHZpZVB4QkZxZGttYjBXdmxPczl2QXg0UjVKRnRXRG5JUXdCc01WQ21JNk0waTF6TDhmVFpuMll5R05pcHpsVGcwMWh1RlpuZzN4VWZHM2c3UzlZY0FTNmphcE5Nby9nbHhpUmZ3Y01Qd3JUYjVSLzhBV3IwRTc2blBLTFdoeUhnaTNqOE1lUDhBeFpvOGNNZHZIZXp4ZUlZUExRSXJyY2hvNWdmN3ppNHQ1cFdQL1QwbmMxMVlHSzVQNGxYaWVFL0VuaG54RklKUEp0N3B0RXZHaWhlWmhEZkdOSXNJZ0xFbTlqc2x5Qjhva2NuQXlhMkRmNnBmL3dDb3NZckJPZ2t2bkVrbjFFVVpJSy9XVkc5cXFPZ3BhNm1wMUo5YzhEMXJOdjhBeFpZMmQ0MXFKemNYa1p3OXRiSTF4TkgvQUw2UmdsQi90TmdlOVIvOEl6OXRUL2lZM2w1cUFZZjZwbjhtM0dlbzh1UEFkVDZTbVQ2MWZzN09IVDdSSUxlR0szdDQrRWlpUVJ4cDlGWGdWUWpPTjNxK29qOXhhMittS2Y4QWxwZU1MaVVmOXNvbTI4K3ZuWkg5MDlLRDRUanZEblVMcTgxVFBXTzRjTEFSNkdGQXNiajA4d09mYzFyVUFGejhvSitsQkpIYjIwZHBicERGR3NjTVl3aUlBcW9QUUFjQ3BPbFpJOGFXTjBXV3g4N1ZuVTRJc1ZFcUE5d1pjaUpUN000Tk5EYXhxWVBObnBVUjZZemRYQkgxK1dPTmgvMjFYNjBETVB4NnkrR1BpUDRUOFE1VkxhNGtuOE9YN2s3VWpqdWdzdHZLeDlSZFcwVUtnLzhBUDgvclc2UEdscmRwdTArTzQxalBSckZROEo5UjV6RlljanVOK1I2VmdmRkg0T3gvRVQ0ZjZ0cDZzTDNXcG9QTjB5NTFKL09pdGIrSWlXMG5FZVBLUXBQSEUyWTBYN3Z1YzlCNEw4WFd2eEQ4SDZSNGdzNDVZYlhYTEtHL2hpbFA3eUZKWXc0UnZSbDNiU094QkZBK2cxVTFuVXY5Wk5hYVZIMDJ3RDdWTjlkN2hVVS83SmprSCsxVG9mQjlpYnBaN2lOcis0ak81SnIxamNORzNxZ2JLeG4xOHRWRmFtRnhVT282bmJhUmErZmVYRUZyQnVDK1pQSUkweWVneXhBejdVRWs3RExaT1diMVBKcERXV2ZFa2w0ZjlBMCs3dVEzQWxtVTJzSStwY2J5UFFwRzROTk9tNmxxSy82VmYvWm96MWhzWXdtUi9kYVZ0ekgvQUhrRVJvQXZhcHExcm90dXN0NWMyOXJHNTJxMDBpeGh6NkRQVSt3NXFuSjRndUxzbGJIVGJxWHY1bDBUWnhFK256S1pmeEVSSHZVMm02Qlo2VE8wMEZ1cXpzTVBPeE1remowYVJpWFlleFkxYUFWRDJCb0E0UDQxZUJkYzhiZkMvVkV0NzJTVFdkUEVlcmFUYTJTZlowbXZyU1JicTJpZHlXazJ2TkVpTXlOR1NqdHdNNEhUZUM1TkgxYncvWjYxb2NjYldPdVdzTjdCYzRQbTNVTXFDU05uYy9PNUtzcHl4SnJZaTNDVmRtZDJjcnQ2NXJ5ZjRXL0U3UlBBa25pTHdPczgrcGFqNFAxbWUwZ3NOTHRwTDY0anRad3Q1YkkwY0t0NUVjU1hJdFEweFJBYlVrc0FSUVV0ZEQxY0RDMHFJWldDcXJNM29veWE1RWFuNHo4U2Jmc09sYVg0VnRXLzVhNnpKL2FGOHA3ZzJ0dElJUUQyYjdXeDlZK3hKUGd6WTYvRmp4TmZhcjR1M2NOQnFjeXJZbGY3aldjS3gyMGdCNkdhT1J4L2ZOQkpKZGZHVFFQN1Ftc2RQdXBmRVdvMnpHT2ExMFNGdFFlMmZQM0ozanpGYnNlM252R0RnODhHb2Z0dmpieFEyTGV4MGZ3amFua1NYNy8ydGZzUDdwZ2hkSUltN2h4Y1hDOVBrTmRaWTZmQnBtbncydHRERmIydHFvU0dDSk5rY0tqb3FxTUJSN0FBVklTcEdmVGlnRGtmK0ZLNlZyS2crSTdqVXZHTGRkbXR5ck5aazlqOWpqU096M0RIRCtSdkg5N09TZXNFQ3dReFJvcXJIQ29TTkZHRmpVZEFCMEE5aFhuUDdTUDdZbndxL1k5MEwrMHZpbDhRL0NmZ09DU016UXhhcnFDUlhsMmd6ekJiRE04LzBpalkxK2EvN1Z2L0FBZDEvQ0g0ZGk2MC93Q0VQZ1h4UjhUTlFqSlZOVDFkdjdCMGoyZEZaWkxxVWVxdkZBZjlvZGFCNnMvVzd2WGx2N1RuN2Mzd2QvWXUwbzNIeFUrSmZoSHdSSjVabGpzYisvVnRTdUU5WXJLUGRjeTl2OVhHM1VWL05wKzFSL3djVC90Vi90WHp6YWV2anh2aDNvMTh3amowandKYnRwTE1TY0JmdFFaNzV5YzRLK2Z0UDkydmxyNHFmczYvRmI0YTZPM2l2eHg4UHZpUjRmc05VbEVqYTE0ZzBDK3RZYnVSemtFM0U4YWgyYnJrc1MyZTlBN0xxZnZwOFEvK0R1ZjluVHduNHh1ZE8wWHdmOFd2RldtVzZOczFXM3NMT3pqdXBBZUFrVTl3c3Zsa2Z4T3FNT25sOTYvTXYvZ281L3djWmZIVDl0bnhiZDJmZzdYZGErRGZ3NlZQSnQ5QzhQNnE4TjlkcmpEUGUzMFFqbG1aK2N4SnNoVmNMc2M3cEgvUHVTNExqYTM5NG5QYzV4L244YWpJNC9oN2MwQ3YySnJtK2t1cmlXYVIyZVdaekpLN0hMU01lckU5eWU1TldMWHczcW1xYVBQcVZ0cHVwWFdtMjMrdXZJYlo1SUljZjNwQU5xL2lhKzF2K0RlMzloZndyKzNoL3dBRkZOUDBQeDFadzZ0NFA4RzZKZGVMTlMwdVVueTlYTUV0dkJEYnlZSVBsbWU1aWQxL2pTSmtQREd2Nm5QQ3VtMjNnM3cxYTZUbzF0YmFScEZqRUliYXhzWWx0clcyakhBalNKQUVSQU9BcWdBZWxNUi9EeVJ2anlHQkJIWFBGRWNSM2RLL1hQOEE0T1hmMklQaGo0WS9iSzByWFBoYi93QUl6b2VzYXRvMGw3OFFkRTBpTm1oMGk1RHh0YlhzME1DTWxySmR3eXRrUDVhUDVDeUhEVGI1UGdEUlAyWVA3TTB0ZFMxamJwdW43Qkt0MXFreTJxRmV1NUY4eEVtQkJYSGwzRE56OTA1QUpZdFUyenhXejB1YStuV0tLS1NhU1RvcUtXSi9MNjEwbmhINFI2cDRyMWRiS0dGamNLTjhrVU1MM1U4U2prczBjUVowVWRTWENnRG5PT2E5aThLZUhmRE41NGt0ZkRYaC9TL0V2ajdYcjBBVyttNkZZdXNkMjJGeHN6RXJ6REg4TDJrdWNuNXlEbXZ2My9nblgvd1NQK1BHdWZHUHczNG04WWZEcndYOE4vaDlwN3lQZGFicTF3emE1Y3EwWkN5UW9GbWEzbVZ5akZTdHFwQVB5NU9ham5paTFTN253eDhPZitDZld2ZUpkTCsyYWJvR29heUdqMzI4dHl5bU81eVArV2NjTCtUSXc2N0RlQnhqbU05RDlNZnM4LzhBQkQ3eDU4UUxpMmoxeGhvT20zRGhabFZUaGtiSHpMQkY1ZTVnRDl5UVRjajcyTTErMi93NS9aTjhOK0JnR3Q3R0pwOFlhVWdtUi84QWVrSkxubm43MlBiZ1Y2YnBIZzIzMDJIWkJCSEV1T2lLQm1zdmJQb2JSakJINGcvQVQvZzMvd0RqcDhTcnhvZkVWNzRFK0MvaFdPNGZ5NG9ZVjhSYXZjS3JFTEtJRktXc2U4QUVGV2drR1JsQVJ0cjduL1o3L3dDQ0Jud0krRTkvYTZ0NHEwbldQakI0bWhBTGFsNDV2anFVWVlZeUV0TUxiN2VCaFpFa0k2YnNWOTMyK2hxZys2TWRLdVE2WXExazVON2s4eTZIS2VIUEFkajRiMGExMDdUN08xc2RQczA4dTN0TFdGWWJlM1VkRlNOUUZWUjZBQVZ0MjJoS25PMzlLMllySC9acWVLeXlhTEV1WmwyK2xLblJjY2VsV283SUFqaXRDT3l3ZW41MU5IWjRIK0ZQbElidVVZN0w1ZnUrMVNwYWZuVjBXNFBHS2tTREZWWVJURm1BYzhmbFRoYllQU3JaaDI1cERGazlSUllDcjVGQnQ4anB4VnBvdG82RHB6VFhRRWRCU2FBcHZHTVZSdXBSR252VjY3a3duMXJJMUdmYXRTVkZYME1uV0wzR2E1TFdiOHIzL3dEcjEwR3J1Y056L1N1UjhRTVlvMzdWakpuWEJIZ1AvQlFUOXFXSDlsWDltWHhKNHVhMlhVTHVMeXJDd3NqY05BMTdjM0VnaVZBNi9NcENtU1FsZVFzVEVkSytLLzJVL3dEZzRjK0NkNHkrSC9pMzRiOFRlRTc3UjcwblRmRWxxQnIxdEEwY3BaSkM0VVhjZTFWVlJsTHJIOE8wRWl1Si93Q0RqWDlwTDdONGc4SStBYk9mNWRBdEpmRkdvb0RrZmFwdDFyWUQyS0FYVGtIcXNxbm9DYS9IZDVpVzY3dnJYWmhGYVBNWllpcGEwVWYxcC9zZWZ0bCtGdjJnb1pyZjRLL0VMd3o4WHRIMCtCYmk4c1lMeG9kV3RYZHpzYVY3cmJOR3p1c2hMVGVZN2hUdFVGY3Q5ZDI5MUkyMVpMZVNFNVlENWd3SUhRNUI0ejZZNFBGZnhCK0RmR21xL0R6eEZaNjVvV3E2bG9ldGFiSjVsbnFHbjNVbHJkV3NuVGRITEd5dWg5MUlyOUR2MkwvK0RvajlwRDltTFR0UDBYeFplYVQ4WmZEZG5LdVY4VUZ4ckN3WSthTk5RalBtTXg0SWU0V2NyakdDTUFkVHRJNVhxZjA3RW4zcHhiY09QMXI4dWYyVGYrRHIzOW52NDdlSTAwbng1cFBpYjRPM1Z5OFVjTjVxWlhWTkxkMkdEdnVJRkRSQlc0M3lSS20zNWl5OGdmb3g4UGZqeDRIK0xuaHYrMmZDWGpEd3I0czBmemt0bXY4QVJOV3Q5U3RZNVhBS1J2TEM3b3J0dUdGSkJPUmpPUlU4ckZZNmJVcnFPSFM3aGJtRnJpMW1ReFhFWGwrYXNzYmNNR1RveTRQSUlJeG5nMThQL3RkLzhHOFg3S0g3WituM2VvVy9nV3orSGZpSzZRaUxXL0FqSnBpcS9abnMxQnM1QnU1YjkwcnR6ODRKelgzS20xdHJCbTl1YXcvRWVzWG1udjUzOWczV29LcktqTmFYQ3JjTXVlQ21Tb09EaklkMEFHNDVPTUdiRGoyUDUzUDIyZjhBZzBoK04zd050TG5WdmcvNGcwbjQwYVBHV2M2Y0kxMGJYb1VDbHNpR1dSb1o4WTIvdTV2TWM3ZHNYT0IrWVh4VytEdmpENEIrTlpmRGZqcndwNG04RmVJb1kwbWwwdlh0TG4wMitqUnhsSE1NeXE0Vmh5Q1JnanBYOXRlamFaY1FSaGsxUy9tUm0zQ0s4amlZeEE1K1hLcXJmUWxqK05jUiswWit6dDhOZjJ1L0RVdmcvd0NLbnc1MHZ4dG9rVVptaE9yYVdMbU8zTFpVdGIzQ2Z2WUpjRTh4c2o0SjV4bWpVTkQrSzYyblpKRllmZWpZTXJEcXBIUWo2ZXZ0WDJ2K3lEL3dYMy9haS9aQVcwczlIK0p1cGVMdkQxcVFGMFB4aW45dTJZUUtGRWFTU3Q5cGhRQURDUXpvbzlPVG45Sy8yMy8rRFFqd0w4UUV1dGEvWjM4Y1NlQ3Ivd0NZL3dEQ09lS0pwZFMwbVIrQ0VpdkVEWE51QjB4SWx3VHh5dmY4bVAyMi93RGdrTiswSC93VHRzMjFMNG5lQUx5eDhNdFA5bmo4U2FaY1I2bm8waExsVTNYRUpieVMrTXFrNGpjNUh5NTRxb3RiTU5laCt3LzdKLzhBd2Q1ZkRyeHFMZXcrTW53NzE3d05lTVFqNnY0Ym0vdGpUbTlaSGdjUjNFS2pCTzFEY043bmtEOUxQMlovMjZ2ZzcrMlhaTEw4TC9pVjRSOGFUZVY1ejJGbGZCZFN0MC92UzJVbTI1aUh1OFlGZnhoVzEwT3VRZHc0SXdmOCt0YWVrZUpadEd2NGJxMnVKYlc2czVCTmJ6UXlOSExieUE4T2pEbFdIWWluS2pUbHRvVWYzQkE0UFQ5S08xZnl0L3NvL3dEQnhyKzFKK3kwYld5UGp4ZmlOb05zQW8wenh2Yi9BTnJjY0RDM2U1THdZQTRIbjdCL2Q2MSttWDdKL3dEd2QxL0I3NGp2YjZmOFhQQmZpZjRZNmcrMUpOVTBzLzI5b3dQZDNDcWwxRU9tRldLYkF6bGpqSndsaDVMYlVEOWNkZzlCK1ZOMlpGZWVmczVmdGMvQy93RGE5OE90cW53djhmOEFoVHg1YXhvSkoxMGZVRW51TE5UMDgrREltaFB0S2luMnIwUlhybnMxdUJHWWMrdjBxTXdjK3RXYzRvS2hqUUJVYTM1NmZwVU1saXJkcXZHUDVxVHk5eDZVQVpVK2tyS09nck52ZkM4ZHlEdWpWdndycFdpNXFJd2NmL1dxZVZNcFNhT0ExYjRiMjExdXhIajZDdVUxdjRPcTRZb3Y0VjdMSmJxM1gxcUNYVEZjZEJXYzhPbnViUXhFa2ZPbXNmQ3E0aDUybDE5R0ZNMG54TjRzOERZV3cxWFVvWVkvdXd0SjVzSS80QStWL0lWOUFYWGg5WEhLZzU5YXg5UzhEVzEwTU5DdjVWajlYYWQ0T3gwUnhpYXROWFBQOUMvYXcxelMyQ2F0cE5ucUNEaG5nWnJlVEhyajVsUDBBRmR0NGIvYWg4SjZ6dFM2bXZOSG1ZNDIzY0dWei92cHVING5GWWV0ZkNPM3VRMjFRcCtsY2pydndUYU1zMGEvaFd2dHE4Zk1mczhOUGJRK2g5RjEyeDhSMnhtMCs5dE5RaS92MjB5ekJmcVZKcXllbitlSytRNzc0YzMyaVhRbnQvT2htUS9MSkU1U1JUN0VZSS9DdGZSUGpkNDY4SGxVL3RPUytnWGdSMzhRbi84QUg4Q1Qvd0FmcldPT1gyMDBaeXk5ditISk0rdVN1NGYvQUY2YU9sU1ZHdzJWcEk0Z1BOUmxkcC8rdlVsTmRkMVNCQTNVL2pWYVZmbStncTVJdjhxaGxUSS9IMHFaRlJLYmNOVVVxZmUvem1wMkh5NHFPVDdocVNpbk92ei9BSTFVMUMyVzd0NUlXKzdLcFEvanhWNlpLclNqZCtQV3M1YU1xUFk1WDRDek5wMm5hMW9jbjN0SnZUTEVDZWtVMldBL0IwbHo5YTd3OGY4QTY2K09maUIrM0JlZkFQOEE0SysvRGY0TmF2NFl0WXZDL3dBWXZERnhMcFBpUVh6SzM5b3hHZVJyVm9pbTA4MnlLTVBuTjNIMTNCYSt4dTNldXltN29tb3RiOS8wME1meDc0V1BqandicW1reHpDM252N1o0cmVmdmJUNHpGS1BkSkFqajNVVWVDL0ZTK052QitsYXdzUDJiKzByU081ZUFubTJkbEJlSS93QzBqYmtJN0ZTSzF1Mk9UWERlRDMxTFRmRmZpancvYnRZMnNGbmZEVmJhV1lQUEkwRjl2bWI5Mk5nSCtsTGVnTnZQQ0Q1SzJSbWxkV08zQjNkTW42Vmt6ZUxySXl0SGJOSnFWd2hLR0t5VHo5ckQrRjNIN3VNLzlkR1VVMCtFcmU4Si90Q2E2MVhKKzVkc0REN0R5VkN4SEhZc2hJOWExSTQxaGlTTkZWWTR4dFZBTUtvOUFPMVVSb1pZbTFqVWg4c2RucGNaNmVhZnRVNUhjRlZLeG93N0VQSVBidFRXOEYyZDh2OEF4TVRQckh0ZnNKWXo3K1NBc0lQdUVCOTYyS2p1cnFPeXQzbW1rU0dHTVpkM1lLcUQxSlBBb0VQSzVDNTUyakF6MkZLT0t5UjRyanV4L3dBUyszdXRTQjZTUXFFdHo3aVZ5cU1QOXdzZlkwbjJYVnRSL3dCZGRRNmRHZXNkbXZuU0QvdHJJdU1IMDhvRWVwNjBBYU45ZXc2YmF0Y1hFMFZ2Q2h3MHNyaU5GK3JIZ1Y1NThKdkZBMHpWZkZYaG14c3JxNlhSOVdlL3MzWmZzOExXZCtUZEpJSGZHNk1YTFgwS21KWHd0cjA2WjdlejhNV1ZsZExjZVQ1OTJuM1o3aHpQT25xRmR5V1VmN0trRG5wWE0rS00rR2ZqajRYMUplSWZFMXJjK0hicjFrbWpSNzYwWmo2SWtPb0tQVnJsYUNvOWpvV3N0VTFML2o0dkk3S052K1dWa21XK2hsa0IzRC9kalE1NzFMcDNoeXoweTdGekREdXU5cFg3Ukt6UzNHMzA4MXlYeDdaeFY0blBhc0h4TDhTOUQ4SjZsL1o5NXFDdHF1emV1bTJjVWw3cUxxZjRsdFlGZWNyNnNFSUhjaWduVTNNY2ZXbEhKNDZucGp2WEpmOEFDVGVLdkUzeTZUNGRoMFczWTRGN3Ixd0drQTdPbG5ic3hrSGJaTFBiT080R01FUHdzbTEvNXZFZXY2MXJTdDk2emlsT202ZU05VjhtQXE4a1o2RkxtV2RTT09hQmx6WGZpcG9IaDdXWDAyYlVCZGF0Q0EwbW1hZkJKcUYvR3A2TTl2YnE4cUtmN3pLRjk2cC8yOTR3OFNmTHAraDZmNGJoN1hHdVhDM2x3cDdZdExXUW95bmpscnVOaDNTdWkwSHc1cC9oUFNJOVAwdXhzZEwwK0VrcGFXZHVsdkJHVDF4R2dDalBzS3VGd1A4QTlWQWprbitFa2V1TG54SnJHc2VKRklPNjFubUZycDV6OTVEYlc0UkpZL1Jibnp5Qi9FVGtucE5HMGF6OE82UGI2ZHA5cmJXR24yWTIyOXBiUXJEYndEcmhJMUFWUjdBQ3VjK05meDc4RC9zMytGVjEzNGllTXZDM2dYUjJ5STd2WHRVaDArT2NqbmJINXJLWkg5RlFNeDdBbXZnMzQwZjhIVG43SzN3eG4xUzEwTzY4ZmZFQzhzWWliZDlIMEg3TlpYMHZPSTFtdkhoZFJuR1hNUkFCeXUvcFFWWnMvUjRzQU1EMTV6WERmdEEvdFA4QXc0L1pTOExmMjE4VFBIWGhYd0hwam9YaWsxdlVvN1NTNkE2aUdKajVremY3TVNzM3RYODhIN2ZIL0IwWDhkdjJuYm4remZoaXpmQXJ3b0ltaWxqMGErRjdyVjh4NnUrb3RERzhJR1BsVzJTSWpjMjU1T052NXZlTi9IbXRmRWZ4WmVhNTRnMWZWZkVPdWFnNWt1dFMxSzhrdkx1Nlk5V2VhUm1keWZjbWdXaC9RNysxai93ZHVmQXo0VS9hYkg0VStGZkZYeGMxTkRpTytuVStIOUdPZjRnODZOZFBqajVUYklEMmNkYS9NajlySC9nNVIvYXEvYWhTNHNiRHhqWi9DblFiZ0ZEWWVCN2R0T21LOWliNTNrdk4yT0Q1YzBhbnJzSFFmQWdZa1ordWVPbENyNWh3ckt4OUFjbjlLQUwydmVJYjd4VHI5MXFtcDN0NXFXcVgwaGx1cjI3bmFlNHVYYnE3eU1TenNmVmlUVlJ5elAxUHpkZmVueDJiTVAxcTVZNlc4ODZ4ckd6eVNFQkZVY3NUMkZBYXMvb0cvd0NEVlA4QVlEOEgrQnYyUzR2ajlxbWkyK29mRVR4ZnF0OWFhTnFkM2JaZlE5TnQzTnRpMTNENUpKWlZ1REpNbkxKc2pCQVZ3MzZ4YTVwMXI0bTBTKzB2VkxXMzFUUzlXdDVMUytzYnlKYmkydm9IVXE4VXNiQXJJaktTckt3SUlKQkJyOGtmK0Rjai9ncExxVC9zdWFUOEVmRVhnSFhwditGY2k0U3c4UVdGMVplV2JPYWVXNUVkeGF6VHgzUG1KSk02aG9JNXR5YkN5b1FTM3UzL0FBVlovd0NDbW5qTDRIZkFpNy80VnBEWmFIUGVib05TOFhYcmViYmVHclpzUmlWV1J0MGQwOGpxa2U2SnpHM3plVzUyaWxkTGN2MmNuc2Z6MmZ0K2ZCenczOEYvMjgvako0SjhFeGx2Q3ZobnhwcXVrNlBFam1ieVlJcnVSRmhERWt0NWVESGtrazdNbkpyaE5FK0ZPb2FpanlTZVZZd3dzcXl5WEJJQ01SbmF4R2ZMT0R3Wk5pLzdRcjFTL3dER1BnYndnczBscmI2dDR1bm0vZVRlVkdMSzNsSitadk5sbVI1TGdFL041aGdqWVp6dnp6WHVIN092N0FYN1dYN1dSdExqd1A0Qlg0YytINWdFZzF1NmhiVFZTQTQrYU8rdXk5NUxIMy8wWXVNazRVRGlsN1NKcDdFOWgvNElZYVo0Si9ZWitKbml2NHcvRUg0aU40QnZOTDBsdEgwMngxT1dEVFlkZXRyb0ZweVZsamtNb2lhRzNaUHMvbUt6bGNzdTNhLzZGK09mK0RsNzluM1J0Q1dId1BkK0pQaUZxbUJIR2lhZGNXSzNFN2RJMTg2TXpPNUp3UEtpS2Y3UUF6WHpyK3pML3dBR3RYaG16MU5kZStOWHhDMXJ4eHJVMkh1TFRTVmFDRGRnZ3E5M2NiNXBnYy9lV09Cd1FNRUhtdjBhL1p0L1lSK0ZuN0tGaEhEOFBQQWZoend2TXNma3ZmVzFyNW1vekovZGt1NUMxdzY5OXJTRURzQldVcXZZcFJXN1IrVXZ4Si9aMi9iRi93Q0NxUHgxMVh4eFovRC9BRVA0QjZEcmpxMGVvZUlOMzlwZ0NNUmI5MXo1MTlDelJxcTRzNFlJY0tQNGl6dDcxK3paL3dBR3ozd3o4STNFZXEvRlR4VjRtK0ttdFNPc3R4SDVyYVpZeXVEa2J5cnZkU1lKSkJFOFlPZm1ROFkvVUMxMEJZaDkzbXI4R21oRDByUG1iM0s1b25tWHdPL1pnOEVmczUrR1RvL2dQd2w0ZjhINmJJb1dXSFNiSkxZM0dPQVpYVWI1V0dCODBqTTN2WGYydWhyR3YzYTE0cklBZmRxd2xsaWxZbm5ablFhWUU3Vlpoc3ZhdENPejQ2Vk1scmpvS3EycG56RkdLeHhVOGRuN1ZkUzMvd0E0NlZJa1BQSDQwY29ybFZiVEhhcEV0OFZhV1BCOWZiRkFUQTcvQUpWVmhFS3c0cVFRZi9xcVFKeC85YWwySC9Jb0FaNWYrYzBnajVxUXg1cE1ZTksydHdHRk1IMXBqYzFLUm1vKzNlbGJXNEVaK1ROUVR0aXBaVGsxVHVac1pva0JXdTVjZi9XckYxQ1RkV2hlU2NaeVB4ckl1Wk54L3dBOFZKdFQzTTY5ZzgxbTY3cTV2eExwYlR4NFhBM0hHVDBHY2MxMWhYZFRkTTAxZFExbUpXWE1jSjgxdnc2ZnJpdWQ2eXNqYm10cWZ6RWY4Rmg5RStKbXUvSFB4UjQ3OFhmRDN4LzRWMGJ4VHJzejJsM3JtZ1hWamJ4MmtBK3pXRVBtU0lGV1Q3T29abHprczRPUFg0cWtIejQveVRYOXg0MHFIVXZEczJuMzF2RGVXTjlFMGR6YTNNU3l3M0NNTU1qb3dLc3BCSUlJSUk2MThJL3RsLzhBQnRoK3kzKzFwYVBjYVY0UmI0UWVKR2ZldXBlQ0JIWTI3OFkyU1dES2JVcDN4RWtUNUgzOFpCOUtLdEZJNDZrdWVWMmZ5dVBONWUwZmpRcytmMHI5Y1Ayc3YrRFFINDFmRFMxdWRTK0V2amp3cjhXTE9GTjQwNjlqL3dDRWQxaVE1KzRpeXZKYXZnZnhOY3hrbm90Zm1YKzBiK3laOFQvMlF2Rm8wUDRvZUFmRm5nUFVwR1lRSnJPblNXMGQ0Rk9HYUNVank1a0IvamlabFBZMVJtY1BIYzdQeXhYV2ZCYjQ2K012MmN2SHR2NG84QWVMUEVIZ254SmFxVWkxUFJMK1d4dXRoeHVRdkdRV1JzY28yVmJvUVJYRXFlUGJ0VWdkajNJL0dxNWdQMVMvWmIvNE96UDJoL2c0ME5wOFFORjhHL0ZyU1ZSSTNlNnR2N0YxUTdlQ3d1YlllV1dZZFM4RGtrQThjN3YwYy9aay93Q0RwcjluRDQrM0duV2ZpS1RXZmhIcmpvNXVFOFRXclhPblpDcWZMaXY3VVBobU9TRExDaXQ1WkIyc1VEZnpKcklhZUxobEdhT1pkU3VidWYyMy9EdjRwK0QvQUl6K0NMVHhKNFgxelI5ZDhQWGczV3VyYVRmeFhOcE11Unl0eEE3SUFUaktzd09lQ09vcnFOUHVvcjJ6am10cmlPNnQ1RitXVkhEcko3aGw0citKbjRJZnREZU92MmFQR2ErSlBoMzR5OFRlQnRlUUFHKzBMVXBiR1dSYzUyT1kySG1JU0JsSHlwN2cxK3BIN0MzL0FBZG4vRUQ0U1dXbjZIOGJQQnRuOFF0TFcrM3orSU5BTU9pNnhEQTc3bkxXc2FMYVhUcjFBSWhMaklhVEpMMFdUMkRRL29tQndlbE51RUYxYlRXOHNjYzF2Y1J0Rk5ISXU5SlVZWUtzcHlHVWpJSVBCcjUvL1l5LzRLbWZBWDl2blNiZVQ0Wi9FYlE5VTFpZE43K0hiMlFXR3ZXNUM3bVUyVXVKWDJqT1hpRWtmQnc1SE5lK1dXb1FhakFzdHZQRGNSdHlIaWNPcDVJNmozQkg0R3BKUGlYOXRUL2czbi9aaC9iVDg2L204R044TlBFOGc0MW53TUl0S01weHg1MXI1Yldzdk9Nbnlsa09QOVlEelg1VWZ0Zy84R2szeDArRGNWMXFmd2w4U2VIUGpEcE1QenBZTVJvV3VBZDhRek9iZVRBL3UzQWRzY1I1SUZmMGIwWW8yMks1aitKWDQ0L0FMeDUrek40MmJ3MzhSUEIzaWZ3TDRnVWIvc091YWRMWXpTTG5BZEJJbzNvZXpvU3A3RTF4eTNCamJQOEFkempOZjIrZkV2NFcrRi9qVjRVazBIeHA0WThPZU1kQ2xPNTlOMTNUSU5TczJQcVlwbFpNKytNMStjbjdYLzhBd2FsL3MzZnRCdmRhaDRCbThSZkJYWHJnTXlqU0gvdFBSakllZHpXTncyOERQOE1NOFNnY0FVK1pnZnpZK0dmR3VvZUVQRUZwckdsWDk1cE9yYWZJSmJXL3NwMnQ3cTJjZEdqbFFoMFB1cEJyNzYvWkkvNE9aZjJwUDJaMXQ3SFZQRlduL0ZiUWJmNWZzWGpXM2E5dVZYajd0OUcwZDBXd09ETEpJby91bXN2OXRQOEE0TnFQMm9mMlI3aS92OUg4S3A4WFBDVnI4NjZ0NE5KdTdrSm5qek5QT0x0V0E1Ynkwa1JlZm5JNXI0TDFUU3J6d3pyZHpwMnBXbDNwdW9XVWhpdUxXNmhhR2UzY2RWZEd3eXNQUWdHbnpYMFlhbjlKWDdJMy9CMlY4QlBqTkhCWS9GSFJmRVh3ZDFsOXF0Y01yYTdvN0U4Wjg2M2pFNmM5UTl2dFVIbHlBU1AwZStCMzdRM2dQOXBmd2d1di9EdnhsNFg4Y2FLd0JOM29lcFJYcVJmN01nall0R3c3cTRWZ2VDQWEvaVZpMUlxblhQdG50Vzk4T1BpNTRrK0VuaXUzMTd3bjRpMXp3cnIxbWN3YWxvK29UV0Y1RC91elFzcnIyNkVWRXFNSHRvRjBmMitsOXc2OWFBZHAvU3Y1amYyUy93RGc2VS9hWC9aN052WitMZFEwUDR4YUREdFJvUEVzQWgxSUwzMlgwQVdRc2VtNmRadTNGZnAzK3lYL0FNSFZ2N09QeDNpdGJQeDlENGsrRE91VEZVY2FyQ2RWMGpjZjd0NWJKdkMrclN3UktPNXJLVkdTMjFLUDA0emc1bys3WE4vQ3Y0dCtGL2poNEx0L0UzZ3J4TG9Iakh3N2RjUmFub21vdzZoWnVlNitiRXpMdUhkU2NqdUJYUWVaZzRyS3p2WUJ6amQrVlI3UmpwK3RPTFpOR2Fld0VaanlmU212QnVxYlBIM2FEakhwUjZnVVpiRlg3VlZuMFZYN1ZyTXU2Z3habzVialRzY3RmZUZZNXQyNk5UNjFnNnI4TjdhN0RmdTl2NFY2SThQNC9oVVVsa3JqN3Y2VkxwcDdseHF5UjAxTWtHYWZUWEh5bjZldGFHWTNvYUtDTWlqTlJJQ09SZWZyVUxyMUZXSkJrWjlLams2MUxBcHlMdGIycUVyamlyVXk5ZjFxdS9RR29OQ3ZNdnlrZmxWT1VFdGoxcTlJT2FxenI4MzZpcGt1b1IzUHozLzRPRi9BR3BlSHYyY2ZoNThldkRkdVp2RmY3Ti9qYXc4VDIyMWR4ZTBsdUlFbGp4M0RYRU5oa2YzVlk4VitnbmhYeGRwdnhBOEs2VDRnMGFaYmpSL0VGakJxZGhLQ0NKYmVlTlpZbXo3bzZuOGE0MzlvTDRMV0g3UnZ3TDhhZkQvVnRxNmY0MjBPODBPV1J4bnlQdEVMeHJLUDlwR1pYQjdGQWUxZURmOEFCRGo0bmFsNDgvNEp2ZUVkQjE5V2k4VWZDNjl2L0Ftc3dQOEFldHBiQ2RsaWpJUEkyMnNsc3VEM1UxcGgzclkwbXJ3Zms3L2ZvL3h0OTU5Y2RULzlhdVU4Vkgrd1BpaDRiMUlFTERxOGR4b1Z5UDd6bFRkV3p0N0lZTGlOZjlxN3gzcnFsK3RjdjhhTkl2TmErR0dzRFRkNTFhd2lHcDZjRXdXZTd0WFc0Z1g1Z1I4MGtTcWNnZ2hpQ0RuRmR4eko2blNPNGlpWjJJVkl3V1ppY0JRT3BKN1ZtanhaYlhhYnJHTzQxUWYzclJRMFIra3JGWXo5QTVQdFVPajZUby9pR3dzOVVpWnRXZ3ZJNDd1MXVicC9PM0k2aDBrUlQ4a2VWSVB5S3RiREhMYnM3ajF5VFFUc1paaTFiVWY5WmNXdW14K2xxUHRFdjRQSW9RZlF4dDlhV0R3dlpRWE1jOGtadkxtTTdsbXVYTThpSDFUY1NJL29nVWUxYUxOK1gxckg4VmZFSFJQQXNrRU9xNnBaMlYxZGdtMXRYazNYVjVqcUlZRnpKS2ZhTldOQWE5RFlaczljazlDVFFHd0NQNlZ5UThiNjk0aC81QWZoZTRpdDIrN2ZhL01kTmpaZjd5MjRXUzYzRCs1TkZCbkgzaGtHZ2ZEclZQRUxidkVIaWpWTHFNOEd5MGJPaldmc2QwYnRkNTlRYm9vMzl3RGlnZkwzTlB4VDhSZEQ4RTM4Tm5xbXBXOEdvM1NlWkJZSXJUMzF5dWNaaXRvdzAwZy8zRU5jcDQ4ajhSZkZyUW9yTFI5RU9pZVRmMldvUTZucnNnaU1UMjExRmNJMGRyQ1hsa0JNVzE0NW10V0tzd3p5YTdQd240SjBmd0pZeld1aTZYcCtrdzNEK2JPbG5Ba0gyaDhZM3liUU43LzdUWlkrdGFXNEt2eTBDT1RiNFkzbXY3ajRpOFNheHFjYjgvWTlQWnRIc2tQc0lHKzBNcEhCU2E0bFEvM2EzUERQaFRTZkJlbWZZZEgwM1Q5SnN0eGMyOW5iSmJ4TXg2c1ZRQUZqM0pHVDF6VlA0a2ZFcncxOEhmQ1UzaUR4ZjRpMEh3cG9Odm56TlIxclVJYkMwUWpuSG15c3E1OXM1cjRHL2FtLzRPYy8yYi9nS0xpeThIemVJdmk5cmNPVkNhSGFOWTZXcitqM2x5cTdsUEh6d1JUcnpRUFZuNkxrN1A4QTlWUlhkMUhaVFdzYzBrY01sNFdGdWpzRmE0S3J1YllEeTJGQkp4bkFCSnIrY3o5cXIvZzZJL2FFK05DM05qNEsvd0NFYitFT2p6RXFoMFcxRi9xd1RwaDd5NURMbi9hZ2hoWVk2OUsrV1AyYVArQ212eEYvWnQvYlo4Ti9ITzgxalV2aUI0cjBPYVNPOFBpTFVwcnlYVjdLYU5vYmkyZTRrWnBFRHh5UHNia0k0UjlyYmNGY3cxRS9yYkxZem44YS9MWC9BSU9ZZjIrdmk5K3hQNEsrRmR2OE1QSDgzZ3UzOGVOcTl0cXEyTm5idHFFbjJVV2JSeVJYRG8wc0tqN1F5c1lpaloybmQxQng3LzhBNE83ZmdTZkJIMnFENGIvRnk0OFJlVVcvc3Q0OU9qdEZsQ2s3VGVmYVNkbmJlSUN4L3VaNHI4YWYrQ21QL0JTdnh4L3dVNi9hQ0hqZnhoRlo2UFo2YmEvMlpvT2cyTHMxcG9sbUhaOWdadVpablk3cFptQU1qWUFWSTBqalIzRnl0TThnK0pYeGQ4UWZGZnhkY2E3NG0xM1d2RW10WFpMVDZqcTEvTGUzVTJTU2Q4c3JNN2ZpVGoycmtMcThhVS9OemppaG1NdnpkL1Vtby9zelA2YzhDZ1dySTJMU045MDlhZEZHMGhyYzhQZkR6VnRidjRiU0d4bTg2NjRoUjBZUEllUHVMOTVqejBBUEJyMS93NSt4bnFtbjZIRHJIaWFhMThNNlBjUHNpdnRZdm85TGdtSU9HVmZNeTVrWG41R1Zja2RUemllWkZ4cHRuN0UvOEcvZi9CRVg0TTZ0K3hyNFArTlh4TjhKYVQ4U2ZGL3hBam0xR3dzOWNnRjNwT2cyUzNFc01TTGFObUthV1JZL01lU1pYMjcxUkZUYXpTZmFmN1NmN0czN0pQaUQ0Y2F2WitNUGd4OEtyN1RkUHNKYmk0VFF2QzF2YmFqYndvaFpqRFBZcEhQRXdWU1FVa1U1RmZsTmIvOEFCZW40UWZzZi9BRFEvaGY4RmZEUGpIeFY0ZDhOd09MTzIxRFVab2JHMk1zanpTdDVzMjZRa3l5TzdSbUI0c3NRakJhOSsrSFg3TGY3VTM3YlhnQ3gxajRoZkU4L0EzVGRXalc3dHZDdmcvU0NkVnRZMkh5dGNYVHlDUzJtSUlKU0hiZ1lEYkdES3N5cXFLTlk0ZFBkbjVVL0YzOWwvd0FDK0VmaUxyZXFhVHFHc2VIZmg3YzMwa3ZoNlB4eGN3NmJxc2RzV3lzTjFGRVhsYVpBZHUrR04wY0FOa1pJSEhqNHQvRDN3UzdRZUg5SjFqeGRkSU51QkV1bldjcURxSkdjU1RTWUpQektzTFl4elg2bU4vd2FvV0hpMzRreGF0ckh4aTF1KzAyNWN6YWcxNW9nbTFXNWM0NlRmYVNwTGZNUzdoaURqNVc1cjdlL1pjLzRJai9zOS9zdld0bzJsK0FiYnhKcVZyaGwxTHhRdzFXWXVBbzh3UXNxMnNiL0FDcjgwY0tOd09jODFuN1lmczlkRDhYL0FOaVhSLzJyZjJoTHhwdmhMOE9WMC9STHNyRExxTmpIY2FmWk9GVXFCTnFVMHdFcFFNVGhwV2tHNDdSbml2MEc4TC84RU1maWQrMHZvV2oyZjdRM3hra3VQRG1tTXR6RDRWOEp3bVNPS2JHTjczdDJHTHVveW9MUlM0RHVFWkF6YnYxUXRmRGFnUjdzc0kxQ0tEL0NCMEE5QVBUcFdoRG82b09GL0NzNVNjaXVheXNmTlg3TTMvQkxiNEkvc3BtM244Ry9EblFiWFZvU0dYVnIrTTZscVc4WitkWjV5N1JNY25QbGJGNTRBSEZmUXR2NGNVeWJueXpNY2xpY2svalcxRnArQjkyckVWanpRUzZqTXVEU1ZYamFLdFE2ZW81eFdrdGx6OTJwa3RjSHBUc1p1UlFUVHNpcDBzQUIvbmlyc2R0ai93RFhVaVFZL3dEMTA3V0ZjcVIyWUgwcVlXd3pWanljK2xPQ0FHcUVRckFxMC95Z0QwcVhibnQrdENyemdjVUFNRVo5cVh5aFRzWituclM3UDg1b0FZRXhUcUNDTzFGQUJSUlJRQW1NZi9xcEhISC9BTmFuWnhVYjlmOEE2OUFDTTIwVkU1K1hGU1NkYWdsUDhxQUlwMzJoajdWUXVXL1BrMWJ1SHhuNlpyUHU1T1BjVm05eW9tZmZ6WUI1eDdWaTNWeHRKK2xhT295NERmM2NkYXdOUXVNQmo5VFV5TnFjUjB1cENOYy9rUFd1bStIZWpUWDlwOXE4aVh5N2xzcXdRNDJMd1RuMDNaSDVWNUw0MThZMmZoalJyelVOU3VsczlOMCtDUzZ1N2h6OGx2REdwZVNSdlpWVmlmWVYvTVQrMXgrMlo0djhiL0gvQUZENGs2UHJ1dmVGZkZIaUhXSi9FVVY1cG1vUzJkN3BpU3U4ZHJBczBUQjE4cUJDbnl0MEMvaVVZdHpLcUpjbDJmMkRkUHc0cHFuY2Z3d1B4cithWDlpei9nNjcvYUIvWjBzN1hSL2lUWTZMOGJ2RDl1QXZuNnJJMm42OGlESEF2b2xaSk8rV25obGNuSHpqSFA2dC9zZC84SEx2N0svN1ZzVU5scS9peTQrRVBpU1FmTnAvalJGdExWMnh6NWQraGExMmpwbVo0V1BaT3VPNDQ3ZGo5QXR3VWZyV1Y0ODhDYUQ4VS9CMTU0ZjhVYUhvM2lmdy9xSzdiclM5WHNJcjZ4dVI2U1F5aGtiOFFhdCtIdkVPbitMdkQxbnErazM5anEyazZsR0pyUy9zYmxMbTF1MFBSNDVVSlIxUHFwSXF5TURwMzk2Q1Q4eC8yM2YrRFZQOW5mOEFhVVc0MVQ0Y3ZxZndQOFR5RXRuU0ZPbzZIT3hiSkwyRTBnTWZvQmJ6UklvNTh0alg0eS84RkNmK0NDdjdRdjhBd1RqMGU2OFFlSk5Bc2ZGL2dLMVA3M3hUNFZra3ZiR3pVa0FHNmpaRW10UmtxTjBxQ1BjZHF1eHhuK3RJTHVvZUpYaVpXNVdRRlhCNURxUmdxUjNCR1FSNkdnWi9EQXFoaHVWc3I2ZzV6Uy93WTllOWYxdGZ0bi84RUh2MmFmMjU1YmpVZkZQZ3VUUWZGbHdYZHZFdmhlU1BTZFNsWmdCdW1DUm1DNVlZQjMzRVVqOXQrQ1JYNDhmdDlmOEFCcVo4YVAyY1JjYTU4SXRRaStObmhuelFvc2JXMit4ZUpMUld6eTFxV01jNnI4b0x3eUZ6blBsS29KQUZqOHJBZjVkS2NHeDE1NXJiK0kvd3g4UmZCL3h2ZmVHZkZ1ZzYxNFg4U2FVd1M5MHZWN0dTeXZiUmlBd0VrTWdWMXlwQkdSeUNEME5ZVExnOGZpZlducUlzMmVvVGFYZlEzTnZOTGIzVnJJSllab25LU1F1T1E2c09WWUVBZ2prRVYraWYvQlBmL2c1aC9hQS9ZNHYyc1BHK3BYdnh5OEczRHF6MkhpalU1RzFhek9GVXRiYWl3ZVVaVlFQTG1Fc2ZjS3BMTWZ6akhDNHpUbGY1ZVQ5YWZNQi9WOSt4Ti93Y01mc3gvdHJSMjlqRDQwWDRhZUtwTnF0b2ZqZG90TGFSemdZZ3V0N1dzd0xIQ2dTckszVXhyMHI3ZzM3b1k1RithT1ZRNk1QdXVwR1FRZTRJN2pnMS9ERVp0NmJXd3k5TUhwWDBMK3g5L3dBRlVQai9BUHNLQ0dENFpmRkR4Sm9lalJ0dS9zSzVrWFVkRmJKeTMraDNBZUZTZWNzaXEvUDNnZWFOR1BRL3NYWitQeDVwZCtBSy9CbjltdjhBNFBIZkVlblNXTm44WXZnN28ycjIrL2JkYXQ0TzFHU3d1RWovQUw0c3JreXBJL3FvdUlsSjZiZUJYNmpmc2lmOEZsUDJhZjI0TG1PeDhCL0ZUUTExOWxVLzJGcml2b3VxYmp6dFNLNUNDY2p2OW5hVUQxcGNySFkrb1EyRHVHYThqL2FzL1lLK0RQN2NPay9aZml4OE5mQ3ZqWjFoTUVWOWUybmw2bmFvU0R0aHZZaWx6RU1nSDVKQUs5WmtWbE8xZ1Izd1JSU0EvR245cVA4QTRNNHZoMzRyUzZ2dmc3OFZQRTNnMjhZdkpIcGZpaTFUV0xFazhyR3M4UWhtaVFIamN5enRqMU5mbTMrMC93RDhHNHY3WEg3THJYTnkzdzNrK0l1alcyUCtKbDRFdWY3YUVudUxVS2w2QVBWcmNDdjZ1c2UxQ3R0UCtlS0JIOE5lczZWZitGZGR1dEwxU3p2Tk4xT3hrTU54WjNjTFFYRnU2bmxIUndHVmg2RUExSEhlTXJkK2VsZjJyZnRGL3NtL0MvOEFhODBEK3kvaWo4UHZDUGoyelNObzRXMXJUWTdpNHRRM1h5WnlQT2hQKzFFNm4zcjg0ZjJwZitEUkw0Qi9GSzJudXZoWjRvOFpmQ2JWbTVqdDU1ZitFZzBqdWNHT1psdVZ6d04zMmxzQWZkSm91MEZqK2Y3NEpmdEkrT3YyYnZGeWE3OFAvR1BpandScmE4ZmJkRDFLYXhtY2NmSzVpWmQ2bkF5clpCN2cxK2tQN0pQL0FBZG4vSDc0UFRXMWo4VHRIOEwvQUJnMFdNaFh1YmlKZEQxZ0pnamk0dG96Q3g2RWw3Wm1PT1d5YzE0cisySC9BTUczbjdWSDdKTnpkM1ZwNEpIeFU4TTIvd0F5NnY0SWR0U2JieWZuc2lxM2lFQVpZaUZrR2NCMjZuNFh1TGVmVE5TbXRiaUtXMXVyYVJvcG9aa0tTUXV2QlZsT0NyQWpCQkFJTlZ6YzI0OVQrcmYvQUlKNy93REJmMzRCZjhGRFBGOWo0UjBxODF2d0g0LzFFN0xUdy80bWdqai9BTFNsQzdtanRMbUozaWxZWU9FY3hTdmo1WXp6ajdiTG12NGcvRFdxM0dqNmhiM1ZuY1RXMXhiU3JOQkxFNWprZ2tVaGtkSEdDcksyQ0dCQkJHUnlLL3NJL3dDQ1ozN1F1cS90VmY4QUJQejRRL0VMWDNrazE3eEo0YmdmVkpwRTJOZFhrSmEybm14Z0Q5NUpDMG5BMm5ma1pHRFVWYU1WSG5RYzN2V1BkZytUaW5WSDI2VTBqL1pybnVpaVVIbWxCelVRNDdVb2M1bzBBa294azlLYUpCVGdOeHBnYmxOYzRGT3FObTNINlVBSFNrNk5Tbm1tNTkvMHFYMkdPUElxTmwrYnA5T0tlcHpTU2NmblVpS3NpNVgvQUhxcnlybjI0cTFJdmFxOHcveG9ManNWNU9SK05WNTQ4L1NyVEREVkRLTUQvUFNzMk1vc09LK2Uvd0JsVDRJK0lQZ0orMjc4ZkJEcGN5L0RyNG1TNmY0ejAyOEVzZmsyK3JNaGgxR0FwdjNoNUpENTJkZ1hhQU1rclgwUk1QbTdWVjNpMXY3ZVJqOHJ0NVRmajAvWFA1MG82U1JTZWx1Nk5RdGovQ2hKbVNSV1g3eWtFWU5JL3dCNzhCU1lyMFVjcDV6NEQ4ZGFKOE5QQ2srZzZ4cXVuNmJKNGQxTzQwYTFobW5WWkpvaHRuczRvVSsvSzRzN2kxR3hBemJzZ0FtdGdlTzlZMXg5dWcrRjc5b3p5THZXNURvOXVmVUNOa2U3M0QwZTNSVDJldWt0dENzYkxXYm5Vb2JPemgxQzhqV0s0dTQ0VldlZEYrNnJ5QWJtVWRnU1FLc2hRb3BGTnB1NXlROEI2MXI3SzJ1K0tyNW8vd0NLMDBPSTZQYnQ2WmtWNUx2Y1BWTGhGUGRPMWEvaGJ3Tm8vZ1dPWmRIMDJ4MDFyczV1WklJUXN0MjM5NmFUNzhyZHkwaFppZVNUVmp4VjRuMHp3SjRhdTlhMXpVdE8wUFJiQlBNdXRSMUc2UzB0TFpmV1NXUXFpRDNZaXZqenhYL3dYbS9aOXVmamo0ZCtHSHczMXkrK01ueEM4V2FwRG8rbTJQaE8zOHpUbHVKVGhXbTFDWGJiaUJlV2VTQXpsRVZtMkhhUlJvZ1Yzb2o3UFlLRi91MWxlTi9IbWgvQzd3bGRhLzRuMXZSZkRPZzJTN3JqVTlYdjRiQ3l0eDZ2Tkt5b3Y0dFV1cHd5YXBwMXhiK2ZMYW1lTXhHZTFmYkpGa1kzSXhIQkhVRWo4Sy9uYy80T1EvOEFnbXA4UWYyWC9GZWsvRmU0K0puajc0c2ZEdnhKZnRwc2R4NHUxUjlRMVB3cGV1clNwYkYyd2h0NVZqa01ieHBHRk1SUjF6c2VSazZkVDlLUDJxUCtEbW45bVg5bnByaXg4TjZ2clh4YzF5SUZSRDRZdHZMMDVYN2I3NjQyUnNwL3YyNnpqMnI4Mi8ycFArRHFMNCtmR1Y3aXkrSCtuK0dQaEhvOGdKVnJDSWF0cTIwOEZXdTdwUEw5Zm1pdG9tNDROZmxldXJTTXhCTzRZeC9kSDZmNTYxN0Yvd0FFOWZnZnBQN1V2N2RId2grSE92WEU5cm9Qakx4WllhWHFMUnlHS1I3WjVsODZOR0hLeU9tNUZZY2huRlMyeldLVGRrZTMvQ0Q5aVQ5ckwvZ3Jack0zalhTOUY4Yi9BQk1nVjNnLzRTL3hUclhsMmJFTVEwVUYzZnpLSk5wQlZrdHkzbG5DbFY0RmVWZnRzZnNFL0dQOWdMeE5wdW0vRmZ3VGZlR2Y3WVZuMHk4V2VHOTAvVUJIamVJcm0zWjRtZFF3TFI3aElvWlNWQVpTZjY2dkMvaGpTL0JIaGZUZEUwVFRiSFJkRDBXMWlzZE8wK3loRU50WVcwU2hZNFlrWGhVUlFBRkhBQXI0TS80T2M0UERVbi9CSVB4aC9ieTJ2OXBMcitpdDRhTXVQTUdwZmJGREdML2Ird20vemovbG41bmFqbElsSjMwUDVrSnI1OEJXUHAxK25wL1dvWkxrc2ZtemdEa0RQdlhZZkQzNEYrSnZpdHI2YWRvV2szbC9mTU4va1FRdk5jYlA3NGhqVnBXWHFkeW9RTytCWHZIZ1gvZ2xONC8xZlE1TmM4UVEydmhQdzNic0V1dFkxeTdpMHpUNG01d0JQS3doeWNmY25sdG5JNkRwVTh5Tkl4azlqNVg1Qzg5U2V2Y1YxbmdMNERlS1BpVHIwR242WnBjNzNkMEZhS0YwYjdUT3B6ODBWdW9NODRHRG55WTNQdFgzbCt6Wit3cjhKOVZWWmRLOFdYM3hNdW9wZnM3dytDWVpFaFNWYzVWNzV6SEpDM3NqM3NUREJBS2tWM0h4TStMa1A3SytvM2ZnSDRUK0R0THNmaWpxa0lTejhPYUZZTnJXcVBOSWZsZThQbC9aNDNUNytJYmVLY2d4OElyaVFEZHRXYnh3L1dUUG5UNGZmOEVodFpzdEJUeEo0ODFMVC9DL2hWSkRHMnA2NXFVUGgvVFpIQis1SFBjWlpwT1IrNG5TMWtPZG9JUE5ZZmp6VVAyWi9nVmZ4eDZUcm10ZkZUVUxXTExXM2h2UzVkSjArV1VFcVFiKzVrYTVqT09kMFF1b2pnNDROZTkvQ1QvZzN4L2FrL2JiOFZSK0tQaXhyRjU0ZE4waWw5VThjNnJMZmF1MGZHRlMxVnBKbFlBbjkzTTBBSFFHdjBPL1pZLzRObS9nRjhFVXQ3dnhkRHJQeFExaUVpUW5VNVdzTk9Sd09xVzBEaHlPKzJXYVZUbnBqZ1p1b2hjcTJTdCtaK0x2Z1A0b2ZHRDQ5K0kyOEsvQlQ0WXJvY3Q4TnpXdmhmUW4xVFZaNCtWRTAwcksrMWx3Y3p4eHc4cnlSZzE5V2ZzOWY4R3lueDAvYUsxeUh4TDhZZkZGcjRQYThLU1hFbXIzYmE5cmNvLzJvbzVTbm9NUGRLd3p5dmF2M3grR1h3UjhOL0NMd3ZEb2ZoWHcvb2ZoblJZVGxMRFNiQ0t5dGxQSFBseHFxNTk4WnJyTFhRbGovaCttYWwxR3cwNjZud0YreWY4QThHOUg3UEg3Tk1scmZYSGh1NytJT3VXcFdSYjN4TktzMENPRGtGYlNNSkFSbmtlYXNwSDk2dnVheDhKeDI1LzFhakp5UUIxSjZtdWtoMHhWUFRtcktXSVU5S2oxSmxVTWExMFZZd1BscTVGcDJCeFdrdHBqSEdLbVMweXRQbEk1ak9qMDdwd2VQYXA0N0hBNlkvRHBWNFFMUUl3UDhLcmxKdVYwc3MvM3FlbHRrOGZ5cXlJK09uNWlnTDlQenArb2lKWU1VOVlzRC82MVNDTDlhY0k5bzdVd0l3djEvS2xDWi84QXJDcGZJNXB3ajQ3VUFRK1hnZEQrVk9FVzMvNjlTN09ldjZVdXpBNG9Bajh2My9TazJIUDlhbENBMEZNRDJvQWlFZVI3MGdYSDk2cEh3RDcxRzN5bnQrVkFCbW8yWGFha0ZJNStYbWdCbEZBNlVVQURkS2o2K3RPZHUzOUtqYzRIL3dCYWdCc2grYXE4aHdvcVoyei9BUHFxQ2JnL3lwZExnVkxsOEEvU3MrOWZnL3pxN2RuSUo5di9BTlZaMTQyZHc5YWd0ZVJrNmsyYy9OWE82dVNxSHR4WFNYYWVheDlEV1JxdGp2aGJBL1dzNVNPbGFId1Avd0FGd2ZqMjN3ay9ZczFYUTdXNSt6Nng4Ujd1UHd6YkVOaG83YVFOTGV5SDBUN05ISkVXN0c0VDFyK2Mvd0NJZml0dkZmaWE2dVZlVDdPOHpOYnhrLzZwTUtpakhZK1drWVArN1g3eGY4RnUvd0RnbnArMEorMlQ0eXROVThCK0VYMWp3ajRTOFB2QnBxUlhzWG4zZDFkVEFYMDZ4QWw4SkNrS2dFYmlZbTJxUWNuOFJmMmh2MlZQaUYrekhyMGxsNDA4TTZscFMrZThFTjc1VFBaM2JLTng4dVhHMC9MaHNIREFISkFycXc5TnFEa1lZaVcwVWViTkovWDhhcnRKdU5Pa2ZiRTJPL0ZRaC9YbXRqbVBZUDJWUDI4dmpKK3hIck0xOThKL2lSNHE4RHRkU0NXNnRkUHZEOWd2WEF3RFBhdnVnbUlIVHpJMnhtdjFZL1kyL3dDRHhYeFY0YmhzdEsrUEh3MXNmRmtFWldPVHhENFJtWFR0UTJnZk04bGxMbTNta0o3UnlXNmorN1g0a283SG9lUHBVMGNtQitIRkE3bjloMzdGUC9CWWo5blQ5djJXMXMvaDU4U05MLzRTYTZBQThNNjMvd0FTblc5NUdkaVFURUM0WUFISnRtbFVldGZUa3dhQ2J5M1ZsYk9DRGdiZnFEL25tdjRYWVp5aks2dHRaRHVVamdxUjBJUHJYMnQrd2ovd1g0L2FRL1lRMUtHMzAveHBkZkVEd2lvRWNuaG54bFBOcWxtcWpnZVJLemllMUk1d0lwQW1UbGtmcFRIb2YxbGxNOVA1MUZkMmNOMG0yYUtPWlZPNEIwRFlQcU05K2UzTmZsZit4My93ZHEvQWY0NVg5dnBQeFI4TytJdmd4cWx3MjFiNldUKzNORXprQUJwNFkwbmpKem5MVzVSUUNXY0FjL3BsOFA4QTRoYVQ4WFBCZGo0bzhGK0pQRC9pL3dBTTZubDdiVXROdklyMnluWGtFUjNFQktIQjRJTzQ1QkJ3ZWlDeDUvOEF0US9zR2ZDejlzM1QydGZpUjRMOE5lTUxOclA3R1A3VTB5T1M2aFVOdVI0YjFObDVDeTdtQTJUQlJ2YjVjbk5mbUgrMkovd2FFK0NQRThWN3Fud1Y4ZGE5NE52bTh5ZVBSdkVFWTFqU3gxSWlTZVBaZFJEc04wZHdlTUU4NXI5aE5PdmJ5L3RKL3dDM05MaDBsb1paTmtrRi93Q2RHMFFIeXkrWUZqYU5pQ2NyajVTQ056REJOMjZGMVkydm13ZWRlSUNyTEdxSXpzdm9HWmxCeU9oSnp6bjV1bE1EK1REOXFmOEE0SVVmdE9mc3JIVXIyKytHK3BlTXZET21NRmZYdkNCL3RxMEM3U3haNDR2OUlnMjRJY1RSSnNQWGdxVDhldEg1THRHM0R4a2gxUEJRanNSMi9HdjdlZkRueEQwL1ZMdVNUeTdqVExvWVNTSzZzNUxhNFZobkJiY0ErM2JqQlpWR0R3VG5qelA5cW4vZ214OEJmMjNyV1IvaWg4Sy9CL2l5K2taWE9yTmJHeTFZN2Z1LzZkYkdPNUsvN0prS251RFFEUDQwT2g5S04rMGRmeHpYNzFmdHZmOEFCb1Q0ZDhSNmhKcVB3QjhiYWg0WXVMcG1rR2grTFNielNJQ1NQM2FYMFFOMUVvR2Rva2d1TThicEY2bjhzZjJ3ZitDTVg3UzM3QzNoZVRYL0FJaWZDM1ZMUHd6QzVXWFd0S3VyZldMQzNBejgwc2xxOGhnVTRPRE1FejA2OFVoV1BtTVRranJVYmxaQjh3RGQ4SG1tN3M5R0IraG9mSnhpZ1I5YmZzVy84RnhQMm1mMkViVFQ5TDhHL0VqVU5XOEo2YXF4UmVHUEVxLzJ4cE1VU2pBaGlTVStaYko3VzBrWDg4L3FaK3lML3dBSGluZzN4aHF1bTZUOGJQaGZmZUMydUdTRzY4UWVHYnh0U3NJbVBXVnJPUlJjUnhqaklTU2Q4WndHUEIvbjdIQkdRZXZQRk9BWFA4UUk2VXgzUDdUZjJYUDI3UGczKzJ2cHh1UGhQOFRQQ1BqcVNPSVR6V1duWHdYVXJhTTlHbHM1TnR6RU8yWGpVWnlLOVpJS3NRYzVVNFAxcitHR3d2N2pTcjJPNnRacHJXNGliTWMwTG1PUkNRUnd3d1IrRmZlUDdKWC9BQWNuL3RYZnNvYVpiYVZKNHkwLzRtZUg3T0lRd2FmNDRzanFUUXFDTWJidU40cnc0QTJnUE95Z0g3dkFvSG9mMVcwVitRdjdJSC9CM3Q4SXZpYTJuYWI4WlBCdmlENFk2bE52UzUxYlMxYld0RmpJQ2xYS0lQdFNCanYrVVJ5N2NMOHpaSlg5Ty8yZC93QnFqNGFmdGMrRnBOYStGL2p6d3I0KzAyM1ZUY1NhTHFFZHpKWjdobFJQRUQ1a0RIKzdLcW4ycFdCSGV5SVg2TVZQWE5lR2Z0ZWY4RTBmZ1A4QXQzd3UzeFYrR2ZoenhOcWpSK1dtdHBFMWpyTVFBd29GN0FVbklYcUVkMlQvQUdUMHIzUkRrVW1keDlxUlIrRy83WWYvQUFhQjNGaUxyVnZnRjhTL3RTN3QwZmgzeHFnamtRZHhIcU1DYldJL2hXUzNYL2FrUFd2MmkrRG53cDBmNEVmQ0x3cjRIOFB3cmE2RjRQMGkxMFd3aUJQeXcyOFN4TG5KeVNRdVNUeVNTVHlhNlorUi93RFdwdFpWYWp0eUU4cXZjZHY1L3JTYjZTaXNTaDIvMy9sUzUzQ21VZERRQS92VDFiUDFxTlQwOTZjRzJtdEVCMEJPQlViSHBqdDcwNXpnVXdkYVV0Z0ZIU2lpaW9BS2E1eDAvblRxUThVQVF2d2Z3cUNVY2ZyVmhoOGxSU1VGUktrcTQvQSt0UXVPZi9yMWFrR0dxdXcrU3BrVVU3aGNuOGFwYWxaTmZXVHhSaG1ta1g5MkIxTDl2MXhXbk91NGZoMXFtK1ViY0NjcWV0Wnk3bFJJL0NYaS9UZkgvaGJUOWMwZTl0ZFMwdlZZRnViYTZ0cEJKRE9qZnhLdzRJeUNNajBxWFg5ZXNmQ2ZoKzgxYlZiNngwdlNkUGpNdDNmWHR3bHZhMnFEcTBrcmtJaWoxWWdWK0hQL0FBV1Mvd0NDdjM3Ui93RHdTaC9hajhRZkNYNGQzL2hIU2ZCbXAyc3V1K0hMbTkwRkwyL3RZOVF1NUwyYWFONVNZeUk3bVc2dFkxZEdqVklEOHU0QmgrUFA3VG43YnZ4ZS9iTjExZFIrS254RzhZZU9wWVpXbXQ0ZFYxR1NTMHNpMzN2czl0a1F3QTRIRVNLUGF1K25LOFV6Q1ZyNkg5TVA3V0gvQUFjb2Zzb2ZzdS9hTE96OGIzWHhTMTYzTzMrenZBOXFOUWhCeGtFM3p0SFpsZlV4eXlNUDd0Zm1iKzFUL3dBSGRmeG4rSjZYTmo4Si9CM2hQNFU2Yko4cVg5My9BTVZCcksrNnZLcVdpWkhWVGJPUjJmMS9JR0tiSDAvT3JDeWwvZXJKUFZQMmh2MnUvaVYrMW40blhXdmlaNDg4VitPdFNqZG5oZldkUmt1bzdNbnFJSW1QbHdyL0FMTVNxdkhBcnV2K0NXdjdXT2svc1ovOEZDdmhQOFN2RWZuTjRjOE1hNFA3VmFPSnBaTGF6dUlaYldlWlVVRm1hT09kM0NqSkpUQUdUWHpxanRqOE0waWxpZS9JL09wNVNsTjN1ZjI2Nk44UVBEL2lMNGFSZU10TjEvUk5ROEczRm45dmk4UVc5OUZKcGNsdGpkNTR1UTNsZVhqa3NXd01IT0svR2Y4QTRPWi8rQ3ZQd2wrTFA3TDhmd0orR1hpbncvOEFFVFdkZTFhMDFMWGRVMFc1UyswelI3YTJielk0a3VveVlwYmlXWFp4RXpCRVNRTVF6cUsvRUh3YjRVOFRlUHJXVFN0RXM5YTFTMTNpU1cydFZrbGdSdXp1aTVWZTN6TitkZlVIN0x2L0FBUmsrTWY3U01VRjlEb04xcDJoc0E4bXBQR0JacEh4OC8ycDJTMVlZUDNSUHVIUEhCRkhOMDZseG91WHdvK1RJVUtucGtWMmZ3ajhOZUtMcnhucDk1NFd0ZFZrMXJScmlLL3RwYkMzZWFhemxpZFhqbUFVRWphNmdnNHhrZWxmc0Y4Ri93RGdqQit6NzhJTkRTUHhKck9xZU5QRU1pN0doMEFHL2xTVGdrcGNzc1ZxRk9DcFJ4Y0FqSXkzSUorM3JwSGliOWlUOWwyRHhSOERmaGo0UDhJNmJwZW9RV2w5cS9pQzBUeEJxV21SelA1Y1Z4YkpjS3VuMnVaV1NNaU8xSjNUSnRmMW5jMmpoK1YzYis0L1JMOW4vd0Q0S0wrSi9IUDdMZWorTXZHbWcrRE5NMWcyWWsxblY3UFdIaDhPeFNoUnZkcExxT0h5Q1dEYm9pN3JHUmp6WDZqOHcvOEFncFYrM1o4SXYyanZpU0xyNGwvRnpXUGpOWStIYmlXYlFmQ0hnUFRQSzBqUldrMnFUOXNZdzI4amxRaUdaMzFBbjV3RWpVK1dQQWZoMy93VFcvYkEvd0NDbmZpclQvRW5qSzM4ZmVKTEZnc3RyclBqYlVaYlBUYmFKdjhBbjJGeGo5Mk93czRYVVk0WHBYNkNmc3pmOEd3bmhIdzFIWjNmeFM4WlhuaUNhTmZuMGp3NUQ5aXN3UnhnM01vTXNpa2Rkc1VMWlBCN25LVlcyaTFObEdDMXNmbTc0ai80SzEvRU9Ld2k4SC9CSDRkK0QvaFBvK1FMWHlyR0hXdFh1WkR3TWI0a3Mwa1k0QU52WlJ1R0orWW11bCtHMy9CRWI5cjMvZ29oNG5YeE44UkI0bXRmT1JmSzF6NGs2dE5GS0ZKenRqZ2s4eTdWUU9RRmhWTVl3dzRGZjBDL3M0ZnNPZkMzOWxDd1NINGQrQXZEdmhXUlUyTmUydHI1bW9TcmpHSkx1UXZjT01jWWFRZ2RnSzlZdHREVmUxUjdTVnJJems0M3U5VDhyLzJSZitEWFg0VS9CbWFMVWZIbmlqeE40KzFiYnRsdHJDUnREMHgxUFdOeEU3WE1nNjhpZU1IUEtDdjBJK0FuN0tmZ0g5bWJ3dzJqZkQzd1g0YjhGYWJJQUpvdElzSTdacnJIUXpTQWI1bS8ycEdadmV2VllkTVZUMC9Tck1WbHRQOEFoVTI2c3pkUmRERnRkQ1dOZnU5S3ZRNmFvRmFDMndVZi9XcVFSWkZYRkdmT3lwSFo3TzFTcmEvNXpWbmJuLzhBVlRnbkhwK0ZVa1Rka0N3WU5TTEhnVklJcyt2OHFjSWY4bm1uWUNJSnQ2RHJUL0wrdFNDTWNmNXpUbGo5c2ZoUUJFc1hzVFQxanlPLzUxSUUvSDhLZGlnQ0pZYy8vWHB5eFlwKzAvNUZPRWVQZWdDTXgrNXBRdnBVZ1hhYVdnQ05Zc1VxcGsvTUtmUlFBMFJnR2dKdEhGS3grVS9TazNjMEFCR2Uvd0N0TnBUSlNNY2R2eW9BYTV5dE1icFQ4NEhlbzNQWG1nQnBPVFRTM0gvMTZjYWEvd0IzdlFBMmlpZzBBUms1Tk1rYlA5YWVPYWliZ21oZ01kc0dxOHpjZjRWTk0yMzg2cDNMYlI2Vk1nS3QzSmpQNDFtM1V2UFdyVjVObjhxeTdxNHczclVNMmlyc0dHYXIzdHMxd3l4Sjk1eUVYNmswRzcycjErdkZXdkM0L3RMV0dreHVXMlhQMVk4QWZ6Tlo3dXhvNVdWenIvRDFpdHBicXFBN1kxQ0tmWVZTOFkvRG5RL2lDR09zYVhhM3N6UmVSNTVCUzRXUE9kZ2xVaHd1ZWRvT004NHpXeGJ3K1JBcS93QXFreHlQcml2UmpvdERpdnFmbTMrMEQvd2ExL3N4L0Z1TzR1TkMwUFd2Q21wWHBacGJtMDFxNDNLekZtTWlDVHpJZ1FXeVZNUkRiVkdWNUovTC93RDRLRGY4R3RmeFgvWmowelVQRW53MTFCL2lONFp0NTFDYWRKQ0lkWGdqWWdidHlaZ2tSTTh1eGhZNHlJaG5GZjB6TU9PbjRVRm1qWWJkeTQ2RVZYTmZjUi9EOThVUGdCNDYrQ0dwR3o4WmVEZkUvaGE0WFo4bXE2Yk5hN3QyNExndW9CenRiR0R5VmIwT09VQTQ0SDA1cisyajQ1L3NyZUFmMmtQQitzNkQ0dzhPMmVxYWI0aHRoYWFsR014L2JvMVlPaXpCZmxsMk1BVTh3TnNPZHVNblA1Zi9BTGFuL0JwYjRCK0tlcDZscS93bDhRd2VDYm00aUp0dEx1SUgreTI4aW9xcW9ZRmc2c1FTMlZSZ3hKM2tIYXI1VTltTS9uZFU4ZS9lbkkyNy93RFZYMkYrMVovd1FoL2FZL1pSMTM3UGYvRFh4RjRvMDUyWVJhajRjc1pkVGdmYW5tWUpoVnNIYUQ5U3BIM3NBL0pHczZGZStITlRtc3RRdExteHZMWnpITEJjUkdPU05oMUJWZ0NLVW90YmlLeVNZTmVnZnM4ZnRVL0VqOWt2eHIvd2tId3k4YytLUEF1c1B0ODY0MFhVSkxVWFNxY2hKa1U3Smt6L0FBU0t5bko0cno0cnovOEFXcTc0YThNNmg0MThTNmRvdWwyOGwxcW1zWFVWalp3S2ZtbW1sY1J4cVBjc3dINDFON2FzYXZmUS9aajlpci9nOEE4YWVEclMyMG40OGZEK3g4Y1FxOGNaOFJlR0hUU3RTamo2Tzh0b3dOdk8vY0NOclplQ01jZ2o5WHYyTy84QWdvdCt6Yi93VUVndHB2aGo0ODBqL2hJUE9jLzJETmN2b2V1bytkekUyUlpIbURkUzhZa1E1d1d5Q0IrRnY3Wlg3QzN3ZXMvRHNmakxRN2U0c2ZBUHdxOEU2NTRmMXk5MGFPS3hrMXJ4RnBWMURwOXFabkt1cG11THE2UXMrd21SSVNjNUpJK2J0SS80SnFlUDVORnV2c2V1ZUNidngvb1doSjRydlBBdHZxTW84UzZmWTdGbUVubG1NUkc0V04wa051a3BuVU92eWJpRlBtNFhPY0xYaHozNWZYK3ZSdnRkZHowSzJYMXFjdVZxL3A4ditHK1RQNjk1WUx5eUJYelB0SGxsc3hUTGgrK0FEeGowNUJxT3cxUnIrU1JKTGU2czVvV3d5eUpsV0J6aGxjWlZnY1o0T1IzQTRGZnk3ZnN2ZjhGc1Aydi9BUGduajRhOE5RWFd0YTVyWGdlK3M0cmpSdEsrSUdsVDN1bjN0cTZob210THFUeTdqeXRtTmdobjhzRCtIdFg2Y2ZzZi93REIyWDhIdmlzdHZwdnhnOEs2NThLOVdZaEgxUFR5MnZhSTNBK2R2TFFYVUlKNktJWlFveG1ROG12VVVicThkVGljV2o5WFJrZTlPallwOHkvSzN0WERmQVA5cGY0Yy90VWVHVzFqNForT3ZDZmp6VDQxVnBwTkMxT0s4ZTB5TWdUUm94ZUZzSDdzaXF3N2l1NFUxSkdxUGxyOXBML2dpdCt5MysxZStzVGVMdmd6NFRoMWpXcG11cmpXdEVqYlI5U2VkaDgwNWx0aW05eWVUNWl1ck5rc3JFblA1YS90bWY4QUJubHJtZzZWUHEzN1AveEtoOFVHRm0vNHAzeGVJN083ZFJuQ3hYMFE4bDVPZ0lsamdYT1R1SDNhL2UvclZTNzBhM3ZmdkNSZm4zbnlwbmkzbmo3d1VqY09Ca05rSHVLQm44WTM3V0g3QVh4bS9ZYjF0ckg0cmZEcnhGNE5VM0gyU0srdUlWbjB5Nm0yZVlZNGIyRm50cG1DOGxZNUdJd1FRQ0NCNUNVSWI3MmEvc3IrS3Y3Tmw3NGd0Rmg4MjM4WWFEQVpFbjBMeGZicHJVVnlTNElLTGNSdUdIbHRLZ2lSb2hnb0MyQXdQd3grMDUvd1JVL1pUL2FQaGttMUQ0ZnY4RS9GR3FwY0xwMTE0WXVScGR0ZFN4SDdxMjVEMkw0QkJJaWpSUXU0dE44cEsxeTMySzVMN0g4M21CK2xPSnlnL3BYMjcrM0ovd0FFSXZpcCt5TDR5bXROQnZ0TitKR2x2QkplMllzd05QMXE0dGtNWWFSZFBsY201dzBxS1RZU1hhS1dVTXlzUXRmR1hpendocTNnVHhKY2FQcnVsNm5vbXIybTN6N0xVTFdTMXVZTnlobDNSeUFNdVZaU01qa0VIb2FWbWlYRm9vSjErbnBXdjRKOGFheDhPZkV0cnJuaDNXTlU4UDY1WVA1bHJxT20zY2xwZVd6ZjNrbGpLdXBIcUNLeDE0WmFtakdGL0gwNjBJay9UTDlpYi9nNlgvYUkvWnBhMzB6NGdTYWQ4YnZEVVJWU3V2T2JYVzRrQXdSSHFFU2t1VDFMWE1jNTl4WDYvZnNXZjhIRlg3TWY3Wkl0YkNUeGJKOEwvRlZ3d2pHamVOQWxna2o4ZjZxOUROYU9DVGhRMGtjakVmNnNWL0tyR3ZHNzBQQTI4RWQvNmZuWFhmQnY0WDZ4OGJmaXA0WjhGK0hiZjdUcjNqRFZiYlJOT2l3U0h1TG1WWVl3ZjluYzR5ZXd5YXVNYmxjeTNaL2JCQmN4M2tLU3hTUnl4U0tIUjBiY3JxZVFRUndRZlVVNnVaK0N2d2cwZjluejRPZUUvQVBoMVBMMEx3VG8xcG9WZ0NNTTBOdENzS00zcXpCTnpIdVdKNzEwMWNNdmlkaHgydXdvelJSVWpEZFJUV08zdHpUcUFCRDh6ZmhVblExSEdmbWI4S2txbzdETjZYN3VhYlRuNlV4amhhSmJpRkp3S2FIeWYvclUwblBXak5TQkpuL09Lalk1YitkQTZmV2p0UUExMkFQNFZHNDQvQTFKSWVLYTNLMEFWNVU1L1dxNTRQNFZha1dvSlJRYUZhUmY1MVdsWEI2ZTlYSk9EbXEweVlPYXpBL0dQL2c4Ry9aWFh4UjhCdmhqOFpMSzNCdXZDdXB2NFYxV1JWK1pyVzdEVDJ4SjZoWTVvNXgyR2JrZGNqSDgrc3NlMC8wcit4bi9BSUt1ZnNwWGY3YmYvQlBINHEvRFhTN2VTNTF6WE5LVzYwYUtNUitaTGYybHhGZVc4YUdSa1FOSkpBSXNzNkxpVTVZREpyK2M3NEovOEVSdkdYeDErTkNlRWJIeEJvN2FrMW0ycHRadmMyOWxkUTJxQ016VHkvYUpWQ3hvWHdYaEU2K2hhdHFkYU1WeXlDTkNkUnZrUjhMeGorZGRUNEYrRm5pTDRqR1QrdzlGdjlTaGh4NXM4Y1JFRUFKd0M4cHdpalBHV0lyOUs1LzJLdjJML3dCZzlKRytLdnhzc1BpRDRrc3d6eWVIZmhsWkR4UGVxdzdOcUU2alQ0aU9keU5HamdrWU9BVFJmLzhBQlVqV05JOEpUYXIreS84QXNteGFMb3RoSThNZmpyeFRwZDM0eDFLMUs0ek5HMndXZG13N3ArOGpISXdNY2FlMGIyTlBxOEkvRy91L3I5RHduOW1mL2doeDhaUGovcGE2dTJrWEZob1N4bWE0dndpcGEyMFkvd0NXajNVN1JXMndkVzJTT1FPMmVLOUFiOW1iOWp2OWpoa2Y0bWZGMjErSW5pSzFINzNRdmgxRWZFMHBiakgrblMrUnBxWUlJWldFcEFQR1NNbml2K0ZaZnRoZjhGZ2ZGSC9Fd3VQaWg4V1ZobEhtUkZpbWlhZk55TUJCNVZoYWtCZ2VkZzc1eG5IMmoreWovd0FHaS9pcldGdGRRK0x2anJSL0N0dVZHL1NkQ2ovdFhVQU82Tk1TbHZFMk1nTWhuVVo2SEZSekxxMnpSV2o4TVV2WFZueWI0ai80TEIyZmcrd2gwdjREZkE3d1o0QnQ3UGMxdnJ2aWtqeFZxMFRad0pyZUtkVnNiWnVjbEV0M0dUd2NkZjBDL3dDQ0RHcGZGWDlzVFFmaWw0aStOVjk0NThheTNWNXAwdWlhbnJNTXphVzhlMjdXYUd5M0t0dkdxdDVUTkhFRkg3eFNSaXZ1Yjlsci9naWgremwreVk5dmQrSC9BSWRhYnJ1dVdwTExyUGliYnExNFgzRnZNQ3VxMjhiZ25BYUtGQ0ZDak9GQUgxVkhwUlpWVnVSR29SY243b0hBQTlBQjJyS1hOTFJhSUZYYTFidWVNZUVQMmF0TTBGeTBkbGEyNnNNRk51NXNjY2RsSFQvYUhGZDFZL0RMVFl2TEVsbkJjZVM2dW5uSUpOcnFRVllBakNzQ0FRUUJnakk1cnRJdE5DRE5TcmFLbzZVY3JaazZ4a1JhUnVjczJXWnVTVDFOWElkTVZWenRxK3NRVWVsT0VlUHJWcUptNXRsZU96VlI3MUtzSHRVb0h0UzdPS2ZLUVJpUEgvMXFjcTQrdFBDYmgxTk9BMjFWZ0k5cHB3VEErYW5kcUZOQURWVWJxY3EvTnpUd00venBhQURGQ2pkOUtEelJ1TkFEd0FCLzlhbEl6VE4vSHZpbEQ0RkFEcUtidnlLVU54elFBNVRsdi9yVUNUMi9TbWI4bW5icUFIQnlhQStXeFViTUJSdkdQL3JVQVNiK2NmMG9MNC8vQUZWR0dCR1A1Q2dPb0gvMXFBSEZ5ZS80VUFZcGhrUHRSdmIyb0FmMEZOWnR2LzZxWXhKTkp1QW9BY1RuNlV4L3U4OWZwU21UdFVaTGZwUUFic3ZqSDQwMG5kVG5iSC82NmFPS0FDbVNISC82cWN4eFViSG5QdlFBak50UFNvM3B4NU5SU04zOUtTQWlsZmcxUnU1UDhPYXQzRGNWblhUNExVcGJsZVpuMzh2SDg4MWphaGMvT2ZwV25meVp6L09zSFVuMmpyMzcxbkpuUlRSbDZ2cmYyV051Y1lIUEZmbkwrMVIvd2NPdCt4WisxQjRpOE9Ed3F2aUh3aDRZMVNMUzd1YTFtSDIyNXV4YmhwMFZYS3B0aGszeG41czdrSFRuZDltZnRTZkcreC9aNCtCL2l6eHhxU2lXejhKNlZjYW1ZU2NmYVhqUW1PQUgrOUpKc2pIdTRyK1czOXBieDVmZUx2RkVYOW8zc2w3cWtobDFMVkpuVGFaNys2ZnpwNWZmZGxPdU1FTngzT21IaGVkM3NoemtsQzdQNld2MldQOEFnNHIvQUdjLzJtTld0ZFBrOFZhZjRVdkxoWTFNT3FTelF5ZWZKSUVqaVZYZ1FNdU1sNUF4VkNWemxTWFg3czBMV0xUeEhwa2Q5cDkxYjMxbElTRW50NUJKR3hERldBWmNqSVpXVWpzVkk2ZzEvRFRQKzhCemhoN2pyWHRuN0ozL0FBVWorTkg3RHZpMjMxYjRjK09OUzBscmFKTFkydHlGdkxTUzNXWXorUjVjb08yTXlNN0ZZeXVTNy8zbXoyZTZ6anVtZjJhWS93QTRvSXovQVBxcjhBZjJYLzhBZzhROFhhUEhhMlB4WitHMmg2eGhuZVhVOUV1WkxSbnlaU2llU3dmWXZNUzc4eWtCR08xaXcyL3FCK3hML3dBRndQMmV2MjVkTnM0ZEQ4Y2FUb1BpYTU4cU50QjFhNSt6M1psa3dBa1FrQ0dYREhibFZBSnhqZ2drNWV3Y25ZK3V3YUFjMUJwV3IydXZhZkZlV04xYlgxcFBueXJpMm1XYUtUQklPMTFKVTRJSTRQVUdwODhWSkFra2F5eE5HeXEwYnJ0WldHVllkd1IzRmZNdjdUUC9BQVIxL1p3L2F5MVM0MVR4WjhMZkRhNjVjUWZaenFsaGJMYTNHQUR0SkMvSVN1Y2o1Y25nRWtBQWZUZlVVakt4a0hQeWpxTWRhYWsxc0IrQW43WkgvQm81NHU4TjNHcWF4OEkvRlduK0lMUExQWjZJYlpvTGtBOUFXbnVDQW9KMi9LOGpZWGNGTzdhdjVsZUpmMlJ2ajUreUY0cm04VDNuZ0g0aWVEOVE4Q2FrcGZXUDdHdVlrMGk1UnZra01oVENBbkJWbXdHeU1FMS9aZ0YrYnA3VlQ4UitITlA4WWFhMWxxMWphYW5ac01HRzZpRXFZK2pBNC9DcWJqTFNTS1R0c2Z4bDZWKzJUNHl0djJlUCtGWnpOcDJvK0dianhVdml5N2U0V1ZydlVaL2xMVzhzbS9EUU82TElSdDNieG5kMnI2SThlZnR2ZkNtdytQOEE4UnZqajRKYngwZmlGNDgwdTRzOUswRFZOTmdqdFBDOTFkV3kyODkwOTRzNy9hVlJBNWlSWVVCTERjcUFZSDdWZnRuL0FQQnRCK3p6KzFYZlhHcmFEYTN2d3Q4UVRJVkVtaDIwTDZjU2Y0bXRjSVMyZTRsVWNuam12elIvYWsvNE5RZmoxOEdZcHIvNGQ2cDRhK0tXbHdybnlMZWM2ZnFqRWNjUXlnUm5kbk9CSWR2VExkVHhWTXJ3MDNkYVh2ZTJsNzJ1bjYyVzJwMVU4WlZqdTc3V3YwdGUxdlM3UG51eC9hRDhYL3NYL3dEQlA3NFk2TnAyb0xjYW44U2RVdmZGYzJuYTFaeGF4WVJhSkJtenRiWnJPNldTTHlyaVZacHVFQmJ5MUlPUld6KzFoK3lINEYrQW53djhQNlBlZkR2eGRjZUxQN0tzOUxuOFZlSGZFdHJjMjkxNHJ1SUhtT25YbW51WE1LaGlvQmo4cG1SY3FqZmVQeTk0MytGWGpyOW1mNGoydHI0bThNNjE0VDhRNkhkcFBGYmF4cHJSbUtXT1RldVk1azJ1dS9Cd1FWWU1NZ2h1ZlM3MzlxL3dmOFp2amw0YzhWZkZqNFc2RHFNbjlweVhYaXkvOE5YTjVwbC80aWhraktoMlFYSGxDZU9VK2Z1ak1YbXRHcUVvR1pqakxBVktkUlRwN055bEsyamIreXQxZEphYnZXenNkRWNSQ1VHcGRFa3I2cnplejY2OU5PcHMvRVQ5Z2I0by9zc2FQNGk4Y2FMNHEwQzkxUDRYM05uQjRyazhJNnpjUTZ0NEt1TGtxTGNUbG80WHc3TnRXUzNNaWxsZm5Dc3c5cy9aUC80T1cvMm92MmFFdGJQV3ZFMm4vRnZ3L2I0UTJYaksyKzBYZ1hPVHR2NGlsMFhJNk5NOHdISHk5cThoL2JqL0FHbC9BbnhzK0VmaHJUN2ZXTlErSlh4RzAzVTJrbjhlYW5vSDlqNnBMcEt4T2tOamVrU3Q5dXVON0t4dVdHUXNRd3hMeUZ2bHRsM2JtQWJhcEF3VDE3NC96NzEyNWZVclZLUE5pUGl2MnQvWGxvbmJ2dThjVkdFSjh0UGIxdWYwYy9zamY4SFcvd0FBL2phMXJwL3hNMGZ4TDhHOVltTzFybTRVNjFvZVR3UDlKdDBFNlpQWHpMWlVYdS9ldjBmK0UveGY4SS9IcndYRjRqOEMrS1BEdmpMdy9NY0xxV2g2akRxRnJucnRNa1RNRmJubFRnanVCWDhVcko5T0IxcnB2Zy84YlBHWDdQbmpPUHhKNEI4V2VKUEJPdnhEQTFIUk5TbHNMaGgvZFo0MlVzcDdxMlFlNE5kTHByb2N1blUvdE0xSzkrd2JBMXJkVHd5RWgyaGo4elo2WlVIZWM1L2hVNHdTY1Z6ZWpSdHFtcTMxMTRiOFJhWGYyTWF2WlgybnZISGNMRmRMd0MwMFpFcU1PRmRKZk15cXJ0RVpCTGZ6Ni9zbGY4SFhueCsrQ3EydW4vRTdSdkRIeGkwV0xDeVhGd2cwWFd3dnRjMjZHQnNEaytaYk16ZDNyOVF2MlNmK0RpbjlsWDlydlVMT0RVUEU4bnd0OFdTb3NTMmZqZUJMQkR6bmJIcUNNOXFWM0hnU1N4czM5enFCSEswRmo2VStPMzdLZHA4YmZDMTFIcGVzNjU4UGRlWVlpdnRMbS9jaDFJS08wQ3VFZFEzSTJtTmpraGpna0g1dCtObi9BQVRtOE8rTy9nVmRhVDhiTks4Ry9FaE5JdGxXWFdMelNVaGswbUlxaXVMZTlhU0dhRUFreWNYSG11eE9PR1ZGKzJ0UnVOUzE3U3ROMUx3enFtaHpXTjBQT0UwMFRYbHZmUWtmS1laWXBWQUhPZHczZ2pISHI1RCsyTDhOZkRQai93QUlXc1hpYnhuNG4rRTk1UHVzcmJ4TG9PcHkyc05xSlJ0a2lrblpCQkZ2d0Fza2dqa0J4NWJxMmFjWlBabHdiYnN6OFovMnVQOEFnMjYwSzVpMWErK0hDK0p2QnQxYjJuMisxdFdOOTRvMHVTQUtHTDNGdWxrbXQ2Yyt4WGJ5VGFYdTU4SUpRVGdmQ1h4cC93Q0NRM3grK0JQaGIvaElwL0FkejR1OEhTYjJ0dkVuZys1ajEvVGJoRmNLV0p0eTBzSkJLNVNlT09SYzRaRk9RUDZRZjJSdjJGTDc5bS80ZGFYb0dqL0UrNCtObnc2MFYyanRMTFg0SWRRMVBTdytUdHM5Ulc0UmJZUmtvVlRad2dZRERGU08wOFMvQlQ0ZitOL2liRHJMemFoby9qSFRGTVVsK0x1NWp2cGtqK1FmYTVkN05jUnBqQ05kbVJGSitUQUpCclMrZ25GZEQrUDFMZkV6eGxXVjQzS09yRDVrWWRRUWVoSHAxcjlNZitEV0w5azRmSFgvQUlLVHA0MnZyWHp0RitEdWp6YTRXSzdvMjFDZk5wWktmY2I1NTFQWnJVSHRYNkgvQVBCVkQ5aGJ3ajQ2L3N2V3ZpSjhKZkQvQUk3dGI2NGcwcFBGOFBpR1hTOWNFTHVxb3FYc1c4M0Z3bVN5cGRXb2dDK1lCSndFZjNiL0FJSWJmc0srRGYyTVAyVnRVMUR3cmErSzRYK0ptck5yTXA4U1hXbjNtb1Iyc0lNRnJCNTlnejI4c1F4Tk1raUVGaGRFc3FINUZtVWxHRGtSVXA2SmQvNi80QjlwZjVORkZCYXZQR05jNEgvMXFhRzYvcHhRVzlLVHZRQTVjNTlxZlRZejh0TzcwQU9qSC8xNmQxTklvd0tjaDVxMEJ1UDk2bU9EVWovZXFPVHFLbVc0REMyS2FyYmY0cy9qU1A4QWVvcEFQRGJxWHJVZlEwL3Ivd0Rxb0FTVGtkNmJVbU0wMHBtZ0NObDQrbFY1bHhWcDEyaW8zaUJIYWdwU0tiRGdpb1pZeVZxM0xGeTFSTXVPS1hLVVUydHZteno2aXZ6ei93Q0NpSC9CdlQ0Sy9hLytJR3ErT1BBL2lDUDRkK0s5Yk1rK3FXTTJuZmJORjFhNFppN1RHTldWN2FTUnlXbFpQTVYyWXQ1WWRuZHYwV0tmNXpSNVlxSEJQY0l6YTFpejhsLzJGLzhBZzJHMEg0Ui9GZjhBNFNMNDAzbmd2eDdwZW4yeS93Qm5hRHBVZDB0bTEyR1VpYTRMckVYalZRMklPVVptQmZJWGEzNm9hTDRNc2ZEMWxhMnRsQ3RyYVdNYXcydHRicUlJTFpGQUNva2NlMVZVQVlDZ1lBNkFWcm1MUHArVk9FT0I3ZGFxTk9NU3BWSlBjcTJlbncyRmpIYTI4TWR2YlFaOHVHSkFrY2VUazdWQUFIUFBBcVZiWlI3VllFSUg0MG9pNTZmenJUUXoxS3l3RHIwcVJZVDIvbFUzbDVIOUtVSmlxRVFDSG4vNjFIbDRPTWMxTjVlVFJ0NW9IWWhFZi82cWNGMi93NHp4VDJPS1J2NUhOQkkzYWNpbDJIL0lwZWNVbWVmL0FLMUsrb0NFWS9pb1Zjbm1nNC9XZ3R6eDErbEZ3SENtNDNNZVAwbzV4bmpwNlVBODByNkFTQmhpZ05tb2xHUlM0UE5VQS9PN3YrVkx1NHFQTkJYQW9BZnZIcUtYUEZSai9QdlIwTkFEOXcvdmZyUnV5T3Y2MUZUc1pvQWR1eU0wN2R4OTc5YWo3VVlvQWZ2SDk3OWFONDlSVEtUdlFCSVdHS1F2eHgrV0tiU0dnQi9tZTFCa0pwb09hTTBBQkpORkdmOEFPS1k3RTBBTGpnL3cwTStlbjg2YVRtaWdBb29velFBMTJ4VWJIajBwNzlmL0FLMU1rNEg0MHBYNkFSNS80RFVVaDQvVSsxUGJuNmRLcjNVYVRiZDZodkxiY3ZzUmtaL25TMkFqdUd6V2Jjdm5tcmwxSVA4QUNzKzZmMHFUVGNvWGczYnUvSGVzalU3VGZHZVBjY1Z1UEh2TlFYc0lTQS9UbXNibXNXdGo4dFArRGlMNDVRK0R2Z1o0YStIWXVQS2J4cGZ2cXVxb3JBTU5NMDdiT3dJLzJyZzI3RHNmczdpdjUrL0ZPdFRlSXRldkw2NC8xMTVLOHpnRWtBc1NTQjdET0JYOWszeDMvWXQrSFg3Wkh3UHV2QXZ4TThOVy9pRFE5Uy9mdCs4ZTJ2TEtRa0VTVzl4R1ZsaGZDcURzWUIxQlJ3eU15bjhpL3dCdFAvZ3p5MUt5ZVRWUDJmZmlSRHFVSkxNZkQzamMvWjdoUjJFVjlieCtYSWUyMldHSURITWpaNDdzT3VXSmhXcVhzajhQQmhaTXR1MnFjbkZWbWs1ejAvbFh2LzdYWC9CTWo0Ky9zTUNSdmlsOExmRkhoblRWSUIxZFlWdnRIY2tnS0JlMjdTVys0NUEybVFOeU1nVjgvT0F3RzA4Vm9ZaUYrUDYwK0djbzZzR1pYak81V0I1QjdFZHdhaGR0dEFPUlFCOVIvc21mOEZnLzJpUDJOTlRzbThJZkV6eEZOcFZuTDVoMGJWN3VXKzA2Ykp5VmFOMnlGSjV3ckx5U2VwT2YwNy9ZNS80UEJHanROTjByNDRmRHVTZVhiSEhkZUlQRGM2RGN3eUhsTm95Z0RPRndxdmdFc2NnWVVmaExISmh2NVZJcy9Uci9BSVZYTStwWE8rdXAvWlgreTUvd1UxK0JuN1pWanBzbmdINGtlSHRVdk5VdDQ1MDB5VzVXM3Y0V2NFaUdTSmlDc3cydUNuSitSc1pBelh2SmJiL092NFo5TTFlNDBtL2h1cldhZTF1cmRoSkZQQTVqbGlZRUVGV1VnZ2dnY2c5cSs5UDJTdjhBZzVJL2FnL1pndE5GMHU5OFkvOEFDeFBER2p5U09kUDhTUkpjWFYwR0RrSTk4Vk55VlYyRFlMRTRHMEVER0QzWHNHalA2cHMwamY1elg1amZzVC84SFV2N1B2N1IwMm42TjhSRjFMNFBlSnJvd1FlYnFpRzUwV2FaNHh2SzNVZVRER0pkeWhwMVFiU2pNd3l3WDlHdmh2OEFGUHd6OFpQREs2MTRSOFJhSDRvMGt2NVp2Tkt2b3J5RlcyaHRwZU5pQTJDRGc4NElQUTBPTFFjcDBGSGVpakdLa0xIQi90QS9zd2ZEdjlxcndsL1lmeEc4RzZENHcwMGNvbW9XKzZXMzk0cGxJa2pQcVVZWkhCeU9LL01yOXJmL0FJTksvaG44UTdTN3Z2aEg0MjFyd05xekZwWXJIV1l4cUdudXgzSFp2UUpKR21Tb0IydXlnWk8vZ1YrdDY1SXB4R2FxTTJ0aFhQNVFmMm5mK0NFLzdVbjdLVmlsOXJud3UxbnhCbzZ4SkpMcUhoVC9BSW4wTnNXRG5iS3R1R2tqMmhEdVprMkFzZzNrc29QeUNpckpFSFJrZm5hY01Hd2ZmRmYyK0srd3F5bGxJNUJIYXZuWDlyNy9BSUpQL3M5L3QxekplZkViNGFhTnFHdVF4TkRCcmVuU3phVHFjUUpMY3oyenhtWERFa0NiZW9KUEhKem9xdmREdWZ5RnpqRzdDL2R3Q1IyL3ovV2cvTXdYcDJQUFd2Mm0vYksvNE5EOWRzcjZiVXZnTDhSTkwxYXprbFp2K0VmOFpocks1dFl6OTFZcjJGSFNjanBpU0tIZ1ozRThIOHUvMnEvMkFQakYreEQ0Z2xzZmluOFBQRW5oTUt5S2wvTkI5bzB1Y3VOeStYZXhiN2Q4NFB5cklXQkRBZ0ZTQlVaSnZRbzhiQ01XNkhIWGptaUtCbVhIVU5uaXBVZ2Jrc1c2RVpCeDM0RlN4RldneHRBYjd3NzhIL1B0V2lRSHAzN0wzN2N2eGkvWXMxcGJ6NFdmRWp4WDRKM1NDV1d6c2J3dHB0MjMvVGF6azNXMHZmOEExa2JZcjlWUDJMLytEdkxWUERtbng2VCswQjhQMjF5U01iUjRqOEYrWGJYRXE0QS9mV0V6ckV6SGtsNHBvMXdjZVYzcjhYVnNpekxqbkdTY3RqL1Avd0JlbTNGcDVUcnh5d3l1VDE3WnhVeXBwN2g2bjlWMzdFUDdZZjdIZjdhbmoxZFYrRCtzZUQ5TStJbC9ZL1o1dExqc3o0YzhRbUk1ZG9saHhHWnRwM0ZtdGpJb0pKTEVOay9WVi80SXRacDVKSm9WdkxneGlITncyMDdSeHlRTTVJNEpJSnh4MHIrS2FNdEZMSEpFeFNTR1FTeHNwdzBUS2NxVkk1QkJ3UVI3Vjl1L3NmZjhIQkg3VVg3SkVWdFpKNDhiNGllSFlRRi9zanh1cjZ1cXFNREVkeVdXN2p3TUFLSnRnSE93MURwdm94N3MvZlQ0OGZBSmZpanFNT2c2ZDhTdml4OEg5ZXY3Z1BZU3gyY04vWTNjbytZSjV6eHZGY1I4QWZaYm1Vb1FQOVRuYXcrbTlHMHVMUTlJczdHSC9VMlVDUUpoUXZDS0ZIQzhEcDBBQTlPSytKditDUEgvQUFXV2kvNEt0dDRzMDZmNGE2ajRLMWp3UGIyOTNlM01Pb3BxT2xUTFBJNlFvc2hXT1dPWnZMbFlJVVpkc2Juek9pbjdpcmt4RjArVmhLVjM2QlRHYmowUDFwN0hpbzg1SnJuRUZIZjhhQ2FQOGFBSGdZcFYvclFPQlRrNmZqUUE0ZEtjcThmUTAybmpnZjhBMXEwQTJXT1cvQ215SGtVNXo4MU5rcUpiZ1FuN3hvQnpUcEJ6VER3YVFDLzQwNWFiVGxPUlFBNVFHUDhBbm1uZVhSR09LY1RRQkdRUWFheWZuOWFtelRYR0JUc3dLN3BuL3dEWFVicC9uTldHWEovVDZVMGlrVmNwbVBpaFlSVmpaL25GQmozSHYrVkJWeUZVMit0T0VlTzJLazhvbWxLSGQvV2dseTdFWmovR2dSODFJeVlYOEtaVFFyc1lCaWdVcm5CL0NtOURUNXV3Z05NSnlhZTQ0cHJIRkxtQVRPRFNiczBZeWFCOGdwQU5UT1BXbkFZLy9YVFZPUi9nYUNlUC9yMVZnQWhkMUpqUDBveGdVb09SUlpBTjZIL1BOS1Z5S1dpcUFRYzB2U2lpZ0E3MFlvSm9vQUNjVUNreGtVaW5ISFdnQUgzZXY2MERqdjhBclMvblNFNG9BWGRuMC9Pa3huK0w5YVg4NkNjZXRBQnV4NmZuUnUrbjUwaWdqMW93ZDNlZ0F6bi9BUFhRZW4vMTZOL3YvS201UE5BRGs0SC9BTmVnbkEvK3ZUVk9EM28vSGRRQU0yYUtPbEZBQlJSUlFBVWpOZ1V0TmtPRm9BWXg2MHdubW50d3ArbFJPZHBxTDNBWVc3MVdtYmFQdzVxWjJxcGN2OG52OWFjaHgzSzExTGt0MjdWblhNMjRubk9hczNrbUQvbm1zbTl1TUgvNjFaeUxpcnNtODhiL0FOS0lveHFWOURBUDQyK2IyWHFmMHJGdXRVRUl6bmJXTDREL0FHaGZCcC9hQWorSFZ6NGgweTE4ZGFocFM2cHAya1R5aU9lL3QybGtqWm9RY2VZd2FGeVVYTEJWWnNiUVRVMnV6UzFsb2UwV0tiVVp1bTQ0SDBxY25QNENrVlBLRzNCRzNqQnB4NUZkNjBWampISXpKREluemVYSXBXUmMvSzRQVUVkeDdHdmlIOXNUL2czaS9aVi9iSXVyelVyNzRmcDRCOFMza2UwNng0Sm1YUjIzYmkyOXJWVmF6a1lrbmN6UWIyQjViSUJIMjR4M0NqT1JqL0lwZ2Z6Y2Z0dGY4R2tYeHgrQ0gyalZ2Zy9ybWsvR2pRMUxQOWhBVFJ0ZWdYNWovcUpwREROZ0FEOTFONWprOFJEcFg1YmZFTDRhZUl2aEw0enZ2RHZpelFkWjhNK0lOTGtNVjVwbXJXVWxuZVdyanFyeFNCWFUvVVYvY2xnQWYvV3J5LzhBYWsvWXcrRS83YlBoTmRFK0svdy84TStPcktHSm9iYVRVclgvQUUzVDFiRzc3TmRKdG50eWNESmhrUW5Bem1nRCtLTUp0b0ovTHJYNzRmdHYvd0RCbmhwR3ZYTStyL3M4L0VQK3c1SlpBVDRhOGFsNTdTTUZ2bThtL2dScFZDakcyT1dDUW5ITW9yOGtmMjBQK0NYWHgyL1lCMU82aitLSHc1MTdSZEp0NXhieGVJSUlEZWFIZHNmdStYZXhneFpiakNNeXYyS2dnZ0FIejd2Mm1oSmNkNmMwV1IvWEZSNW9BazgvYlhxWDdOUDdhbnhXL1k4OFNSNnI4TWZpQjRuOEYzVVprSlRUN3dpMW0zcUZiekxkc3d5WjJyOTlHNVJEMVVFZVVZOXFYT1A4OWFCcDJQM0EvWTMvQU9EdzNYOVAxWFQ5TCtPM3c3c05VMDB2NWR6ci9oUDl4ZW9oNlNQYVNONVVqQTlSRzhRSVBDNUdEK3RIN0lQL0FBVlQrQVA3Y3VoNlpjZkQ3NG1lR3J6VmRVQVZOQXY3cGRQMXVHVWtBeE5hVEZaR1lNd0FNWWRHNnF6RG12NDJrazRyUjBQVzV0QnZyVyswKzVtc2RXc0xtTzV0THVDWm9aN2FSRHVWNDNVZ295c0ZZTURrRURHT2MxelgzSGZ1ZjNNWjVwcEc5ZTNXdjVhdjJMLytEbWo5cHo5azFuc1BFV3Z4L0dMUWZKS0paK01wSkxpN3Rud05zaVh5a1hCeGo3c2p1cEJKd0dPNnYxYy9Zdy80T3JQMmRmMmlYajAzNGhmMnY4R05la2tXS050WFZyN1Nibkk2aTdnUStWeURuem8wVVpIem5uQ3NITDJQMDVWZHBwMjZzWHdEOFJQRC93QVU5QkdyZUdkZTBmeEpwYllBdTlNdlk3dUVaNUFMUmtnWkhPRDJyWUw4MHRoVzdnMkdxSFViU0hWdEp1dFB1b1lielQ3NkY3ZTZ0cmlNU3dYTVRqYTZTSXdLdXJLU0NwQkJCSUlxVGc5UGwvcFFEdG9HejRXL2ExLzROelAyWFAycGhlWHRsNFBtK0Z2aU82QUs2bDRLbVhUNEZjZEMxZ3l2WmtIK0xaRWpNUDR3ZVIrWTM3Vm4vQnB2OGJQaFR2MUQ0VytKUERQeGEwOEYyYXpiWm9PcklPd0VjOGpXOG1WNmtUcWM4Qk9hL29pRDhVR3FVMmd1ZnhxZkdiOW1mNGhmczFlSUl0SjhmK0NmRnZnblZKTStSQnJlbHpXTFRiY0hNWmtVQ1JRTzZGZ1BXdUV1N0krVXB6eXVEdEhjWTU0OWorWEhYclg5cGZ4RitHbmh2NHcrRXB0QThYZUhkQjhXYURjRU5McHV0YWZGZjJraEhRbUtWV1hJN0hHUjJyNEcvYVovNE5pdjJiZmpmTnFWL3dDRTRmRW53bTFpOGpQbHJvTjB0eHBNVXUwQldObk9Hd293TXBETEVEempCT2EzVmRQY3BTVFA1b0JHd2RkMkZ6eGsvd0FQcjA3Y2tWZHRsY09PaDI5Um4wOWNqMnI5SnYydXYrRFcvd0RhQStCY2Q5cW5nV2JSZmpCb3RzUTJ6VFI5ZzFkbC92Q3prY2g4Y0FpT1ZuSnpoQ0J1UHhuNEwvWXkrSUd0L3RSK0dQZy9yWGh2eEQ0VDhaZUxOZXROQ2pzdFcwNlcwdWJkN2k0U0R6OXNpcVRHb2N2dkdWMm9XempKR3NaTG9EZGxkbjcvQVA4QXdiTC9BTExuL0NnLytDYVduZUtyeTJXSFd2aTdxVXZpS1VsY1NDeWpKdHJKU2U0S1J5emoydXEvUTJzajRmZUFkSitGSGdEUWZDdWcyNHRkQjhMNmJiYVBwc0kvNVpXMXZFc01TL2dpTFdxelpIZXZJcTFPYWJrVFRUVWRScmtINjAwbkJwMmVLakRuQTZtb0tIa2M1b1RvTS9TbUFlK2FrVmNuNlVBU0FZL25UbEhBcHEvZXFRY0NxaUFEdFVtS1lneWFmVkFiQk9UVEhQTlB4elRIKzkrZmVzd0lpY3RRUm1uT2NnZnJUZW9vQUtkRzNPS2FCaWxVNFB0UUEvSkZPQXo5YWJUbFB5RDhLRUE2aWlnOGl0QUk1Qmh2clRXVUUxSmppbTdjR3BhdUF3cnpTZjBxVEZKdDVvNVFHZFRSVHVuL0FPdW1Md0tuWUJUMHFNajVxa0p3S2hZMEFOWmc1cHI5S2NlbE4rNzJ4K05BRFFjMDFqaW5PMlJ4VGNnZlQ2MEFOWmlQbHBBTTBwT1IvS205YXIwQUFlS2RubWtwQjEvblJxQXZlbEhTazdVdEVRQ2lnSElvSnhWQUZHY0gvd0N0U0J2cFFUbnZRQXRGSm5QL0FPdWt6ei85ZWdBL3owb0M4LzhBMXFOK2FDY2Yvcm9BTWNmL0FGcUN1ZjhBOVZHLy9QTk4yanIrUFdnQnpIYVAvclUwS1QxL2xRUU90QUZBQUR0UDh1S2NXd2VuNlUwY1VBYnFBRGpIRkZHYzBVQUZGRkZBQlJSUlFBVVVVWm9BRFVaTzQwNW14LzhBcnFNOFVtQVNkUlVNcHg5S2tKeTFReU5tcFFFVXpZNXFsZE55ZnlxMVBKV2ZjdDh2NEdrTkZHOWZCSTk2eGRTZkg2VnJYWjNEYldYZDIrK01nWnFaR3NIWTVYWGJwOGJWNVovbFVDdjVzUDhBZ3JUKzFsSjhjUDJsL0hQaXpUYjZZVzJvYTJkSTBLNGdrWmZLMDdUTnNVY2tUQTVYelpWRStSeURNL3JYN3VmOEZSdmpwTCt6WCt4ZDQ4OFJXYzdXK3RYVmdkRzBWbGJhNDFDOHpid092KzFFWGFiSDkyRmoycitZRDQrNnBESjQxR2wydk5yb2NDMkNsVHd6TGt1Y1k0K2RuSGNIQU9jWXJURC9BQlhMbExsaDVzK3JQMlNmK0RpdjlxejlrZExPeWgrSVRmRVR3N1o4ZjJQNDJnL3RoQ29BQVZib3N0NGlnZEZTY0tQN3ZhdjAzL1pLL3dDRHdQNFYvRUcrMC9TdmpOOFAvRUh3MXZKMUNUNjNvMDM5dDZURyszSmtlSGFsMUZHVDBWRnVHR1IxR1dIODhXM2NmcjcxWG1sM3lkZmF1bzVPYnVmMjFmczYvdFhmREg5cm53ci9BRzM4TC9IM2hUeDVwNGpXYVZ0SDFHTzRtdEZicDU4R2ZOZ2IvWmxSR0hjQ3ZRTzlmdzQvRGo0bGVJdmhGNHlzL0VYaFBYdGI4TCtJTlBmZmE2bnBGOUxZM2xzMk1aU1dKbGRUajBOZnBSK3hiL3dkYWZ0RmZzOEMxMHY0aVE2SDhiUERzY243eHRaellhNUhIdHdFanZvUnRiNXZtTFhFTTdIa2JoMUFHajJQNlpoUWErQWYyTC8rRGxMOW1IOXJoYkRUOVc4VFQvQ1B4WGVBS2RNOFlCYmV6YVR1STlSWE5xVjlESzBMTmtBSm5pdnZxMHU0Nyt4Z3VvSllyaTF1b3hMQlBFNGtpbVE4aGtZRWhsSTZFRWcwQTR0RHp5YWgxWFRMWFhOSXZOUHZyVzJ2dFAxQ0ZyYTZ0Ym1KWm9McUpoaG81STJCVjBZRWdxd0lJT0RVdTRHZ3Y5S0NUODQvMnEvK0RhNzluSDQyVFgydGVFZkIrbWZEL1hMb3pUU1cwTnRkTnBrbTRiZ2lXOXRQRVlNT01ob3QyME1WQ0ZjSVB5Ry9heS80Tm0vMm12Z1RyRnpmZUgvQnRqNDQ4THNobWl1L0RPb1NhbEpIMVBsdGJQREZlS1FPTXRDVlgrS1R2WDlTd09mL0FLMVJHSUM0M2hRSk1kUjE3LzRtcTV1NEg4VFh4OC9aYThjZnN6YWhaUStMOUN1dE5oMUtNU1dsNEFaTE81T1BualNZRFkwa1pPMTFCeXBIb1FUNTRSdTkvd0FhL3Q5K0tQd0E4RC9HdTB1b2ZHSGhQUWZFa2VvUkNDOFcvczBsRjlDT2tNL0g3NkVmODg1TnlmN1BGZkpIN1NQL0FBYmtmc2svdEgrRy9zZi9BQXJqL2hBZFFpWFpiNnI0UHZEcHQxYnJ4aFRHd2t0NVJ4MWxpZGdPRlpSZ0FkdWdIOG51M2I5ZnJTZy81eFg3Ri90amY4R2UzeFErSHkzT3AvQkh4MW9YeEtzVUJkTkYxc0xvZXNleUpJek5hU24vQUdua2c3ZkwzcjhzdjJqUDJVL2lWK3lMNDIvNFI3NG5lQmZGSGdYVjh0NVVPczJFbHN0MHFuQmVHUWp5NWsvMjQyWlQySnFRT0ZFL0h6OGoxejBwVkdHNTcxWDIvTmsvV3BONS9wUUIzM3dDL2FnK0kzN0xmaWxOYitHM2pyeFo0SDFRTWpQTm91cHkyZ24yRWxWbFZTRmtUSk9VY01wQklJSUpyOU9QMlUvK0R2SDQyZkRPTzNzZml4NFI4TGZGU3k4eFJMcUZxcTZEcXFwbjV2OEFVb2JaeUIwSGtwbkF5dzVOZmtTcjRQUDhxbWpPYWR5dVpuOWFIN0lIL0JmcjlsMzlzWFM0L3NQeEZzZkFtdStWSEpjYUw0MGROSG5oWjJDYkVta2I3Tk1keEFIbHlzU0dVNEdTQjludEU4YXFXVmdzaWhsT09HQjZFSHVQZXY0Wm92bUcxZ0dIY0d2b2o5aS8vZ3FGOGRQMkI5UlJ2aG44UTlaMGpTRGRSM0Yxb1Z5d3ZkSXZ5bUJ0ZTJrRElOeWpZV1RZKzBBQmh0WER0Y2VqUDdEKzlIM3Yvckd2eFEvWTcvNE8rdEwxUTIrbC9IajRheTZiS1NWYlgvQmorZEFjbmd5V053KzlRQjFhT1orUnhHTTRINngvczNmdG1mQ2o5cjdSNHI3NFovRUx3bjR5OHkxUzdrdGRPMUdPUyt0VWNBano3YlBuUXNNNEt5SXBVOEhCb2xCajVXZWw1dzFLVGsrOUllRzcrOUwwcVNReFdacVhoRFI5ZTF2VHRRdk5KMDI4MURSM2FheHVwN1ZKSjdKMkJVdEU1QlpDUVNDVkl5Q2EwV3o2MGlmS3JIamNldk5aMUpXUVc3anQzT1A2VkdXMmluTXh4NjFHVHpYSmNvQzM0VWdPQmo4YVRkaysyS1VkYWV0Z0ZRYy9TcFVHU2FZaDdmblVrZjNhb0I2RFBGUHBxZjU1cDFWSFlBQngvbnBSbi9PS0tLb0RjSndLanprMDVnVFRDMk0rMVpnSTdVMmd0elJRQVVHaWduaWdCeW5OT0g0MUdEOHcvd0FLa0JvQWtYZ1VFNEZSNXBkMjRkUDBxMDdnS1R1bzJnL3cwSjlQMG94L25GTUJvNEhlaWxaY24vNjFKUUExaG4xcHRFalkvd0QxVVpxWkFOZHM4VkhJK0IvOWVnOEROTkkzSE5TQWc2VTFtT1A4ODBqa2ppZ0RGQUNEcHpTRDBwV0dSUVJrMEFOMjVQV2tJNTZpblk1Lyt0VFhBSFA5S3F3QVR4ak5JUnpTbmlrSXhSRzRDZzgwVWc1TkMwMEF2UVVuNTBvT2FLWURWVWdkVFRxVGtmOEE2cVRPNzhQYWdCeHBQenBNZk43ZlNqSCtjVUFBR0tUR1g3MHYrZWxHZWY4QTYxQUNCUXZXamY4QWxRNDQvd0RyVW1PTTBBQi8vVlJSUlFBVVVVVUFGRkZGQUJSUlJRQVVVVVVBRkI2VVpwcnRqLzhBVlFBMXp1NHBydDh2NDA0OENtT2UzNDFNZ0dNMlAvMTFDNTQ2Z1ZKSTNINFpxdkszdFIwdUJEY3R0OXVLejdwOHJWcTZrclB1SmM1L3BVZ2l2Sjg3WS9wVWJXK1U1L2xVbThFLy9Xb3VHMnhrNHo2Q3M1R2g1djhBdFEvQ1RTL2k5K3pYNHc4TzZ0SHB4aThTVzQweTFsdklGblcxdVdZZVRNaU4xa2psMk9tQ0R2akdHWDd3L254L2F5LzROdVBqNThDOUJmeE5wOTE0WjhWYWJkWElUeXA3NkhTZFNqWmdTQkxISkkxcXAzRGFBbDFKdUxLQVNUaXYzUS9iSytPSHhxK0FYeFc4SHQ4T3ZnM2UvR2Z3dkxZWFUydDZmQnF5YVBKcGswSlhZWUxqQkU4dHhITklQc3M2bU4vczhldzdtSk94OEJQK0NwZnd2K1BPcHI0ZjFEVGZHbndwOFpibFNYdzc4UmZEbHpvTW01MUxLcTNESTlxeGJCd25tQ1E3V3pHQ0NCNkdIaDd0MmlLbXVpUDVPZmp6K3paNCsvWmo4VXlhSjQ5OEo2OTRWMVJJWUpudDlTc0pyVmtFeUYwQjh4VitZN1hHTzVqZkdRQ2E4K0hISHRYOWwzN1NQN0hYZ3I5c2o0RDZ0NFQxYTNqMVR3enJVWWFDU0Mxc05TVzNsaklDejJqM0NTd21SV1FnbDl6WUxqNWNnajRIL2FyL0FPRFR6NExmRW16c2Izd1BxM2lqd0ZyaUlxM0syYUpmYWRmbGNaLzBWeWpReVNESUxyT2thTno1WnpnYU9LZXNUTFZPelA1eWxPMDFhaU9mei9PdnZMOW9UL2cyOS9hUStDOXRaemFINGRYeDZ0MU8wY2tlbHZIRmMyaWtLMFFhR1NRU1NTRWJ0NGdXV05Db0N5eTd1UGpYNHEvQlh4VDhCL0hPcitHZkYyaTNtaDYzb055dHBmMjB1MlFXMHpKNWlvWFFzaExKOHd3eHlPUnhVdUxXNFhSaDJyN2xDdDkwOFpOZlFYN0huL0JTdjQ2ZnNKYXBheWZESDRsZUpmRCtsMjhoa2ZRcExrM21oM0c0amQ1bGpOdXR5V3h5NFFPT3pBODE4LzI4WkEyLzAvS3JzTW9NT3phdnlzV0J4aHVRQVJuMDRIMDlzbk54MTNLakpvL2NmOWxIL2c4RzgrVzEwLzQzL0NkRWpZZ1RhNTRJdXorN0hxYkM2WTd2ZmJkRHZoTzFmcEoreXgvd1dLL1puL2JJZTN0L0JmeGM4TXJyVStBdWlhN0tkRTFRdWMvSWtOMXM4NXVQK1dKa0h2WDhpdTdIRzdqMlBhbzdtWHpFS3Nxc3A1d1J4L242VXBSUlYxMVIvY1RJalJPQXlzdkc0WjdnMG00Wi92Vi9JWit4Yi93V0svYUcvWUZuc29QQWZ4RTFXVHcxWm5IL0FBakd1TWRVME4wSnlWVzNrUDdqUFhkYnRFLysxeWMvcnY4QXNlZjhIZUh3cCtJc1ZycHZ4czhGNjk4TmRXWmdrbXNhSXJhem9oNDVkNHhpN2hIK3lxWEIvd0JxcDViQzViN0g2K3QwcGhZbis5WG0zN09IN1pYd24vYS8wcjdaOExmaVA0TzhkeG9na2xoMGpVbzVydTNYcis5dGlSUEYvd0J0RVUxNlhuSTUvbFVpczF1TnljZXZ2V1A0ODhCK0gvaXY0UnVmRC9pclFkRDhVZUg3ei9qNDB6V0xDTFVMR2Y4QTM0WmxaRy9GVFd6NVdPOUpMQ3N5WTdIdU1nL21LQ1Q4cVAyM3YrRFRQNEdmSCs3dXRaK0Uyc2FwOEY5Y21Vc0xDS050VzBHYVRPYytUSklKb04zVDkzS1VYSUlpNDJuOGlQMnovd0RnM3kvYWcvWXFrdWIzVXZBamVPUEM5dWNueEI0T2tPcVdhTHo4OHNXMWJtM1VZR1htaVJCa2ZNYS9yRHU3SzYrMFJ0YjNFU3hML3JJNUl5ZDN6RG93STJuRzdxRG5qcGc1YnFGNWZhZVlaTGUxYTlEVElqaU9aWXBJa1lnR1Fic0JndjNpTWdrQTdkekFLd00vaHV1dE9tMDZieTdpR2FDVEc3YkpHVU9NNHpnalBiOUtFT2V0ZjF4ZjhGSHYrQ1Ivd24vYis4SDZsSjRuOEw2WTNpYVpmM1BpR3lzNExUWGJZOXNYZ0E4eU5PdXlZUG5HTTRKQi9Dejlzai9nM0ErTW43TnQzcUZ4NFJ1OVArS1dqMnFSM0NOcFcyTzlpdHlKQVpMaUxlVlJta1FMSEhFOHhmTFpLc2hVMXk5aDh1bDBmbnRGeDE3L0FLVmFnNjkrdU90ZWdlUC9BTmtENG9mQ1R3NWVhMTRrOEFlTE5IMGpUYmhiUzl2YmpUcEZ0N09ac2JZNW54aUptREtRcjRKRHJ4eUs0R0JGbFhjaDNEMUhOVnl0YmtyY3NRN2xiSU5iSGhUeEhxbmdmWHJYVnRIMUcvMGZWYk50OXRmV003Mjl4QVR4bFpFS3N2QlBROUQ2R3NtRmZtcTBnSmJjUDRlQjcxcEEwMjFQMFcvWTYvNE9adjJqZjJaSWJMVGZGV29XSHhnOE9XNnJFTGJ4TmxkU1ZCL2MxQ01lYXpZNkdjVEg4Qml2MXEvWXEvNE9NdjJjdjJ1YmUzMC9YUEVDL0NIeFpJQUcwenhkY1IyMW5LZU9ZZFE0dDJCSklDeU5GSWNjSlg4d1VVbTFPdjhBNDdVNkQ3dnNNZmo3L24rbE9VRklxOTl6KzEzUlBFTm40bzBLeTFUU3J5MTFUU3RTaFc1czcyMG5XNHRydUpobFpJNUVKVjBZRUVNcElJUFdyWVBiOE90ZmduL3dhVmVEL0cvaW45cER4NXE4ZmlUeEZhL0Ryd2JvditsNk1tb3pSNmJlNm5leUZMZG50Zy9sc3l4UTNiN3l1UXlwM1BINzFzMmE0TVV1V1ZpRkpOdXdydGcxR3g0eG1qZmsvcWFqelhLWFllcEtqMXBRY3RuL0FDYWFXK1g4QjJwVUdSNzFhQjJKVkh5Vk1CeFVhY3QrTlNVeVI2akZMVFVPVnAxYUlBb29wck5qL3dEVlFCdE1kelUxazNVNmlzd0dBN0Q3ZldrSFNuTXVSVGFBRWJKSEZLT0tLS0FBY1U0UFRjMFVBU0E1TklSVFB6L09nTmovQVBYUUJJRzRwUTNOTVZxWE9hdm1RQzlldE5ZNG9ZNEh2VFMyYVhNQUU1cU4yRENuTytPMVJuaitLcEFhM3pta0oyaWdIclRQMStsQUNZMjBvNEZJVG1rSm84d0ZJM1VnYmp0aWdkZjZVQUVqdlRzQWpIT2NlaHBCOHA0b2I1VDllOUptbXV6QVVERkZGRlVBWW9vUElvQnlLQUNpZ0hOR09LQUdubjYvV2ovUFduSHIzcFB6b0FSK1IyUDQwWi96bWpCM2Q2Qy9IclFBQTgvL0FGNkdPUDhBOWROTFpJb0p5YUFETzdnMFlvb29BS0tLS0FDaWlpZ0Fvb29vQUtLS0tBQ2lpaWdBSndhWS9YLzY5S1d3S2FUUUFGc1ZHVG1uTXVlL2Z0VWJuNWZTcGtCQ3h3UHd6VUV6Yy84QTE2bmtPRCtGVTdoc0RyMzlhR0JVdVplZTFadDNOMS94cTNkUGtWbFgwdUExU1V1NGZhd0R5M1RtcHRPdVRQZlpXS2E0K3lvMDVpajI3cE5veUZYY1F1U2NBWklHVHlRS3dOU3Z6RkcyRGpqbml2emwvd0NDa3Y4QXdXZzhRZnNWZnRHM25oclFiZXgxand0cFBod0R4VFpqeTQ3MmE2dk4za3gyOXc2U0NDYUtCNHBWTFJ5eG56U0hpY0tNRVl1VXJJMGpHNTl5K0RmR3ZpQzN2NWJIVHZoenAvanJ3QnFkOUplcWRIMW1LUFZOTGE2a2VhUnJyVE5TV0h5OWp5ZGJlN2ZoemlJQlJuM1BTYi9UOWF0Y0ttb1F5UXF5dkZjZWFrcTU0Y0hjY1AweGxTd3gwT0svSFg5ZzMvZ3YzOEVJN25UZE44U2E5WitEMHVKOHZKcnZoMlN4bXRabkRCWFdXM04xQkxHUDNTbHZPMDVZbERzc1RBaFUvVFQ0VGZ0TzZiOFdWaTFMUi9FdWc2dm9NeitYYWF0WXl4YXBwTitvUU01aHU0WkNpTU9ubHRNNzdneDJsY0VlankyVm9tTW90dTVRMEQvZ25yNFgrRUhqTHhONGcrRmQ5cXZ3cDFUeGRjUno2a3ZoaWFLMTAyYVZkKzY0azB5YUthd2xtYmNBemlDS1JsVUFTb2ZtcjFmd1hINHc4TytHN2UzOFRYR2orS2RRZ2pQbmFocFZxZE0rMXRuakZwTEpJc2ZISC9IdzNTcjYrTW9aOUdqMVMxamsxVFI3cUFYTUY3cG4rbkxOR2NZS3BIbDVNOGtlV0h5QWUvRmE5dkw5b2lWdXFzTWdZSzhlNFBJUHNlYWptSjFTc3lqTC9adXNlU2wxRkg1ckhFY1YxSHNjc0JuNVEzVWpubGMvV3ZLLzJrUDJCdmhWKzFob2tPbitPdkNPazY1YjI0alZCUEF1NVVqWm5qVHpPSlZSV1ppRVIxSHpFZENRZlpKVVdWTnNpS3lucUdHUWFxeWFYSkM4a2xyZFNRc3c0amx6TkNQVDVjZ2o2S3lqMm9VbXRpVDhqZjJvZitEU2I0WCtMN0lOOEtmRTJxZUNwcmZ6V1dHL2FUVUZ1TXFkaVBJekVZVjhBYlVSaXBPOTNiNTYvTTc5cTcvZzM4L2FhL1pWYlVycVR3SGRlT1BEMm4zSGtwcWZobkY4MDZsUVZmN0twTStDV0lPeEhDbFdCUFFuK3E2SU1VRzhMdndOeEhUUGZGTXVyU082dFpJWlk0NW9aa2FPU09SUXlTS3d3VllIZ2dqSUlQQkZWR3AzRnNmeEM2dnBGMW9tcFhGamZXOTFaWDFvNVNlMnVJMmluZ1lmd3NqQU1wOWlCVk9jNStYZzdoWDltSDdSbjdDdndaL2E2MGQ3SDRsZkRQd2I0d1RZWTQ3bTkwNVZ2clZTU1NJTHVQYmNRY2tuOTFJdkpQcWEvTmY5cm4vZzBPK0d2ajFMclVQZ3I4UU5lK0grb01HWk5IOFF4bld0SmRzZktpVGdwZFFMbnF6bTVPTzFQbVRIelBxZnozdUNqZjB6VmVWdWV2MXI3Ri9iTi80SVdmdE5mc1JRWG1vZUpQaHpmZUpQQzlrR2QvRWZoSW5XZE5TTURKbGtFYWllM1FmM3JpS0laNzlLK1BHdzZibElaZW1SelVTRGNrMGpWN3Z3N3JGdnFXbjNWeFlhaFl5TE5iM1Z0SzBNOXU2bkt1anJobFlIa0VFVjk2ZnNpZjhBQnk5KzFYK3l5dG5wK3BlTHJQNHNlSGJZaFRZZU40V3Y3amJubmJmb3lYZTdHUXZtU3lLdkh5RWNINEJZZi9XcE9vOWFrYWswZjBlL3NyLzhIZG53RitLa2R0Wi9GSHd0NHcrRXVxU0hiTGR4Ui8yL282RGo1ekxBcVhLOS9sRnMyQVB2R3YwZi9aMi9hdjhBaGorMTE0ZmJWdmhkNC84QUNmajZ6akFNMzlpNmxIY3pXdWVRSm9RZk5oT08waUtmYXY0b2dQN3g5eWF1K0gvRWVvK0VOY3Q5VjBpK3Z0SjFPemJmYjNkbE84RnhidDZySWhES2ZjRVVEdkhxais1SEc3OGFRcGhxL2xvL1l5LzRPWlAyb3YyVTdtM3ROZThVUi9HSHd6R1ZXVFQvQUJvWHU3eFZIWHk5UVVpNkRFZERLOHFqQStRODErcmY3SVAvQUFkZGZzNS90QTNXbjZaNC9zZkVud1oxNitmeTNiVkFOVTBTTmo5My9Ub1ZWd0R4ODB0dkdxOTJBeTFBY3Q5ajlPVHV6ajVXSHYxcnh2NHYvc1JlSGZpVjhTOUU4ZGFGNGg4YWZEWHg5NGQ4MUxQWFBDMm9yQ0o0cFR1a3RycXpuU1d6dW9IYkRNa2tKYmNOeXVqZk5YcDN3NStKWGh2NHhlRTRmRUhnL3dBUmVIL0Z1ZzNBQmkxUFJOU2gxR3prL3dCMmFGbVEvbld6bmpORnd1MGVkWFh3T1BpbjRYMitpK0xyaXoxblZHdGZJMURVTkR0WDBKYnB6bmRKRkI1MG9nWnMvd0RQUmlDVGhnRHgrYm43WDMvQnRsNEIvYW44VGFwNGk4STZ4cm5odlhabWxXN2gxTlo3ZVlUZVVJNFZVekI0M2dSbzFKZU11c2lHUVJ1TXF5L3JPK2VuTk1QSXgrbFVwdEIwUDVQdjIwZitDTGZ4eC9ZeThRU0xlK0Q5YzhSYURIQjUwbXI2WlppYUdMQS9lbGxqZDVGZ1FrS0pwVmpEWkIyaklyNWhPalNXTFJlZEZKQzF4RWs4UmxCVXZFNHlycjZxdzVCNkVkRDNIOXJONVl3M3R2NU0wTU04SklZeHlJSFFuc2RwNHJ4YjQ3ZjhFNVBnciswWDRhdk5MOFVmRC93N2RRWDBnbWVXTFRyZFoxa3h0TWl1MGJmdkNweDVoQmNjRUVNcWtheHFwYm9aL0lTYmRWYjV2dmJ0b3p4dCt2SDhxY3RrZklMS3dZbi9BTWRPZjg5Ni9iajlyci9nMDgvdHZ4WXVvZkJ6eG5wbWk2R3dKZlNkVlM0bm1WeTN5N0hra2I1UXBHOTJrendTc2VRRWI0czhTZjhBQnZ4KzBYNEIvYUg4SCtCZkVQaEcrbThQZUxOY3M5R2J4aDRkUnRVMHV3Z25tV09TNGxZS3NrQWpYYy8ra0pHcDI0QlBmVlRpOWhTa2x1ZnNQL3diZGZzd2Y4TTVmOEV1dkN1cjNkb3R0cm54VXU1dkY5NHhIN3hyZVhFTmlwUDkzN0xGSEtCMk53L2N0bjd5WjhkUFdxUGhud3JwZmdMd3JwbWc2Slp4NmZvdWgyY09uYWRhUjhKYTIwS0xGRkd2c3FLcWo2VmJKeDNyeDZzK2Via09uRnBhaU43bWdldE5KeTJmNjBLMmVPbFptbXc5VG1ub005YWpWY21wZ01uOWEwRklrUVlPS2twcXJqNjArSWMvNTVweEpIamlqT0tLRDBxd0dzNEZNYmx1bjYwci9NYU9sUzJCdVVVRVlORlNBbVBwK1ZOSUNpbnQvbm1vK1Y2ZnpvQUtLQlJRQWhHQlFwb1BXanRRTzF4YU0wM2VBYU9vL3dEcjBENVIxR2Y4NHBqSEI0cE43ZjdOQXVWajJPQlRIY2p2aWd0bi93RFZUUzJQU2dFRE5oZi9BSzFSNXlhY1R6NzAzZFFNUndWWGo4YVowcHg1Tk5QU2dCeEdCU1kzVWZ4VXVhcUpJblEwbmIvNjFOSEp6K3VhWGRWQUtlYWIwTkRIY2FBTVVBR0tLS0NNMEFGRkZIV2dBcEQvQUo0b1BILzY2VFArYzBBR09mOEE2MUdQODRvYmxmOEE2OU5VRG1nQjJmbXgvU20wRDVXbzZDZ0Fvb29vQUtLS0tBQ2lpaWdBb296UlFBVWc2MHRGQUJSUlFUUUFacHJISC82cU0vNXpRV0ZBRFdPZTNOTkp4U25rVTA0WDYwQjVDRnY1K2xSdFQ5MldOUk0yUitsQUVVNTYvU3FWeTJXL0gwcTNNYy9oV2ZkdHlmenFHQlR1VHgxck51bzk2NTYrdGFVdys4UHlxSVErY004Z25QV29rVW5iYzRINGhhM1orRWRBdjlVMU80V3owdlRiZVc4dkozKzdid3hxWGtjK3lxcGI2Q3Y1ZC84QWdvWjhmOVQrTVhqclZOYTFEellkUThjYXJjZUlMbUJqbjdQQ3pGYmVESVBJaWp5Zy93QmxVK2cvcUEvYWYvWnR1UDJxZjJmL0FCeDRCc3RYazBHNjhUYU5OWlFYeXFDc2NqWTJwSm4vQUpaU1lNY21NSHkza3dRY0VmeU0vSFh4dEg0OStKbXFYbHMrYkdHVDdKYWdFOFJSallwUG9TQnVJOVdOZEdIV3JreW5LMExJNGk5bnl4LzJhNlA0TmZ0RStQUDJadkdpNi84QURueHA0bzhDNjRxaFh2ZEIxT2F3bWxVTm5ZN1JzdTlNamxXeXA3ZzF5OHJZZmQvZCtZMVFra3k1ejNPYTNrYzkyajlOL3dEZ21sL3djMmVQZjJJSTljMGp4aDhQL0MveEMwUHhacjl6NGwxdStzY2FKclYxcUZ5VTgrNWFTSld0cEdLb3VRWUZMRlJsd1NUWDY0ZnNZZjhBQnh4K3pQOEF0YjN5V2QxNDZoK0dXdFNzcVJhZDQxVWFhSldPTTdiZ0Y3VUxrNEJhNURIL0FKNUowcitWTUhQcFFHSHQvalJkdlZsYzNkSDkxTnBleDZuWVcxM2JUUTNWbmVSaWEzdUlXRWtNNkVaRG80eXJLUnlDQ1FhbUM0UG9QUTEvRjEreVQvd1VPK05uN0RXc2ZhL2hUOFN2RkhnK05uTHpXRUZ3SjlNdW1QZVd6bUQyOGg5M2pKSFlpdjFXL1lrLzRQQmRhMFc2dDlKK1BudzlnMWl3a2tBZnhCNFJjeFhjQzRVWmV5bmNwTHlDeDJUUmdaK1ZjQUxTRGxYUm43NEthTVpQL3dCYXZtdjlsWC9ncnY4QXM2L3RvZUxORjhQL0FBNitKbWs2NTRoOFF3eXkyT2t0RE5iWDhoaEFNeVBCSWl5UnNnSU9YVUk0eVkya0N1VitreWRxRGIwTkFPTFc0aEdEU0htaGh5T2xLRHRvSkNPUjRYRElXVmw2RlRnajhhK1Yvd0J0TC9naTUremQrM290NWVlTmZoeHAybStKNzNMTjRuOE40MGZXUkllc2tra2ErWGNOeGpOekhLUFFBODE5VFlBSGFnMFhBL25sL2JlLzROR3ZpaDhMUmNheDhEZkZtbi9GTFNWWm1HaDZ2NVdqYTVDcFB5cWtqTjlsdU1EcXhlQmljYll6emo4ci9qaCt6NzQzL1pwOGV6ZUZ2aUY0VDhSZUNmRVZ2bG4wL1diQ1N6blpkeFhlZ2NBU1JrcWNPbVViSEJJcisyWnR1ZW8zRHBubXVMK09Qd0s4SGZ0RmVDSlBEZmp6d3Q0ZDhZYURMSnVPbjYxWVJYbHVHSXh2VlpBUXJnRTRZWVlaeURtcTBEVS9pZEpKL3dCMGRxUDg5YS9vRS9hbi93Q0RTRDRkK09iM1VOUytGdmpiV1BBZHhJNWEzMHJVSVA3VDA5TUtjRGVXRXczUGdaREVJcHlBeEdHL0l2OEFidS80SlQvR2IvZ25mZVcwbnhFOFB4TG8xN0pKSGI2enBzLzJ1d0xJeURhOGlqRWJIekVJRGRjc0FTVWNLY3ZZRDV1elJuQno2VkxDQWt5eWJGbVVFRXEyZHJlb09DRCtSRk1DY0RHZlRpcEE3TDRHZnRBK09mMlpmSEVQaVg0ZStNUEVuZ25YNENDdDlvbW9TMlVyZGZsY29RSFVna0ZYQlVna0VFRTErbTM3SEgvQjJ4OGIvaEhMRHAveGU4TzZCOFlOSEFDbStoV1BRZGFpRzRjK1pCR2JhVUJjL0swQ3N4eG1RYzUvSmxGd1YrdFR4UnQ2KzFVaWxKN0g5WGY3RzMvQndKK3pEKzJkNWRsWmVPMStIL2lTUjFpWFJQSEFoMGVlZG14anlaL01lMWx5eDJoVm04d2tmY0dSbjdVa2laTWJsSURnTXA3TUR5Q1BVSDFyK0hxQUtCenp1R0NNWkZmU1A3R1gvQlYzOW9EOWhPZTFoK0hQeEkxcXg4UDI3aGo0ZDFGdjdTME9WYzVLaTBtM0xGdTZGb2ZMZkhSaHdhcmt2c1VySDllSlVPT25lbHpnYzErUlg3RS8vQjJaOE92aUxhMnVsZkhqd25lZkR2V0NNTnIzaCtHYlZORW5QY3RiL05kMitleXFMZ2VyQ3YxSytEM3hyOEcvdENlQ0xmeE40RDhWZUgvR2ZoKzZIeWFobzE5SGVRQTlDckZDZGpEa0ZYd3dQQkFQRlRLTFc0K1YydWRNVHpUU2N5NC9FOGY1L3dBaW5aNDUvd0QxVkdUOHpIMy9BRXJHckswUkJJOU1MNTVOSVR6VFMyYTR4cDZqaS9HYVVldnZpbVozSC82OU9VWWFxc01tVGcvaFV5b2VsUnhKK3Z2VTZqaXFKSHFOOVBWZHRJcTdhZFdtd0JUWkQ4dE9wcjlLQUdqclRINGFsSjVwcDVOWnZjRG9tVGRUU3UzL0FEMHArMzZmbFRYSEg4K0tBRVBJcFB6cGFSdUJRQXovQUJvby9yelJRQW5VVUUwZncwMHQ3ZnBRYWJDRS9NYUI3Y1VFODBkcUFFWnZVOXZTazMrOUQ5RC9BSVUyZ0J4ZnB6K3ROMzgrdElPRFF4eC8rcWdCc2pkZldrQXlEUVBtZlA4QVNnZ2dVRXNROWY2MEU0b3BDTTlxQXNoMk9hVEZBcGFDUm1OditOSTNCNlU4cmtVM2JrVlNZQ1orWHAyNjBVQVlwQUtGTHVBdEZBT2FNMVZ3Q2pQTkFPYVFZOVAwb0FQem8vT2tJNjlQeW9BNC93RHJVQUtSa1VoK1R0UmovT0thVC9uRkFBZVRSUWVCbWpHS0FDaWlpZ0Fvb29vQUtLS0tBQURtaWlpZ0Fvb296UUFVWjlxYWV2OEE5YWovQUQwb0FheEpQY2Yxb29KNW9QSm9BQ2NWRHV5Zjhha2NjVkdhbTREWGZCLyt2VUx2OHRTRnVQclVNcllEZTNTaHNDR2VYQSt1ZTlVSjN6VTkxTG1zKzVsNEI5ZXRTT3d4NWVmclNyTXFKejJxbmNUODF4UHhwK01lbi9CbjRZK0l2RldydVUwenczcHR4cWQyVnh2TWNNYlNNRnpnYmp0MnFNOHNRTzlSSmw4dDlEMTd3cGE3TEx6ancwemJ2K0FqZ2Zyay9qWHkvd0Q4RkRmK0NKZndGLzRLUVdGMWVlS3ZERWZoangxTVF5ZU1mRGtTV2VxbHR5ay9hQUI1VjJDRjIvdjFkbEJPeGtQTmZTM3duOGZhUDhWL2hqNGU4VWVIN2tYbWcrSWROZzFDd21Bd1hnbGpWMXlPekFFQXFlVllFSGtWMGhHQi9pSzdhYTVVYzh0OVQrWi85dWovQUlOVmZqNSt6M2Y2dHFmd3ZheStNSGcrSE0xdXRrd3R0ZWpqNHlrbG8zRWpBa2pNTHR1Qzd0cUU3UitZbmo3d0hyWHd4OFgzM2gveEpvK3BlSDlkMHVUeWJ6VHRRdFh0cm0yZkFPSGpjQmw0SUl5T1FRZWhyKzVXYU5uSHl0dE80SE9NNUFQVDhhOHMvYWkvWWY4QWhIKzJyNFN1dEcrS1h3LzhQZUxyZThpV0ZyaTRnTU4vR3FFbEJIZHhGTGlQYVNTQXNnQXllT1NEcGRNblZIOFVvR2ZYbWpZdzlhL29QL2JRL3dDRFBUd1A0dDBkcjc0RGVQTDd3anJFTVlDNlY0c2tlKzA2NklYR2Z0TVNHYUZtUEpQbHlMNktCd1B5di9hKy93Q0NGdjdUbjdGbDFleStKdmhucTJ2YURZMi8ycVhYL0RDUHErbHJIbkRGcEkxM1JsZTRrUlNCODJOdk5MbDdCN1R2b2ZJYUtSbXBGYkp6MDk2bWtzSGhka2tSa2tVbFdWZ1F5bnVDUFgycU13N2Y1MGlpV3oxR2JUNzZHNHQ1cFlMaTNrV1dLV0p5a2tUcWNxeWtjcVFSa0VjaXZ2bjloZjhBNE9QL0FOb2o5amJYbFhWdFdpK0svaDE0SXJTYlRmRk54TTg0ampaaUdqdWtZT0pzTVU4MlpaaVVDcVFSSEdGL1ArUVl4OWFRRDV1aG9LakpyWS9wOC9ZeC93Q0RwejltejlwUzNzTlA4ZFhHcmZCZnhSY0JVbGgxMURkNk8wcDdSMzhLNEMvN1Z4SEFCNjk2L1Jmd1Y0MjBYNGsrRkxMeEI0YjFyUi9FbWdha2dsczlUMHE5aXZiSzdROGhvNW9tWkhHQ0RsU2EvaHRXWG4xQnIxWDlsNzl0ZjR0ZnNYK0ovd0MyUGhYOFF2RlBnZTZlUVN6eDZiZWxiUzhJeGp6N1pzd1Ryd1BsbFJod09LQTBaL2FjeUZoMS9NWnFOdzZENWYwcjhEUDJMUDhBZzhHOFllRnphNlQ4ZlBoL1krTUxKY0kvaUR3a0UwN1ZBTzd5V2NqZlpwbVBwRzFzUFkxK3JuN0czL0JaRDluRDl1MkMyaDhDL0V6UjdmeERjYlIvd2ptdnNOSDFnT2Y0RWdtSUU1OVRidktvL3ZVQnlQcHFmUm1wNnBIcCtuVFhGd3BhT0ZTeEl3TVk5eVFxOXVXS2dkU1FNa2MvYzYxY2VKdEErM2FCTkswanZ0RnJkS0lsa0tuNTFVeUt5ays2a29jY0h2WFZYVnBGZnd0SEo5MlJTcEt1VmJudUdHQ3A5d2NpdU90ZmhCRG9pU0xZYW5xdTEzTEtOUW5lOGtqQkhLaTUzTGRrYnNuNTVuSTNFRENoVldvMjZncldNcnc1cWZpcXd0a1hYb0xXdzFLUjJlUjdKNWIyeVlLd0grcGM3MTNLZWtjbTBaeVFjWUxmaUg0QThJL0hEd3pjYWI0bjBlejFpemxCam1paVUzS3QwUDNBQkp1NzRWU1J6enp6MGVuU2F4cFU1anZMV1M2dDJiaDRKRXVGalh0L0RISUQweUNzbkErOW1sMTN3M3BQaVR5L3RWdnRrd2NHTjJpa0FJUFFyaHNEUFR0OWFybVNCK1orYy83Y2YvQnR2OEhmMnFkUHZOVjhBMitrK0IvRWZscEhGUHBjQ1dWc0dYZ0xKREN2bEtBdlhNSmtjNHk2bkxWK2ZQeHovd0NEVWY0MGVCclc0dWZCZmk3d240dVNFS0k3WFU0MzBXNnVXUGFNN3BvT1BXU1dQUG9DUUsvb1d0UENHcGFROFBrYW8xL0RHaFUvYmgvcEhCSkdKVUs4YzQyN2VjQTU0SU94SGRzRUszS1BHMkJuZDM3ZFIvaFRsUHZxVHk5aitOdjlvejloNzR2ZnNqVEVmRXI0YitNUEI5cjUza1IzOTlwNy93Qm0zRW5YYkRlSnV0NWYrMmNqVjVpc1hIcFg5cjNpZjRiNk40MjBtYTF1b1I1TjBwV1FST1ZFZ1BCREFmSzQvd0Jsd1ZJNElJT0svT1A5cm4vZzE4K0JueG92L3dDMHZCZHJxUHcydXk4a2t5YUhQbTNuM0NWaGlDYmRHdUhrVTRUeXhzakNBcjk0RWVWZ2Z6aHhybkhzUlZxSmd2SE9UZ1lyOUVmMnZmOEFnMmMrUDM3T3RtZFE4R3cyZnhjMG1QZDV5NlBDYlBVcmNCdmxQMmFaejV1NVNDZkpkeXAzREIyN2orZjNpcndYcTNnRHhOZWFQcjJrNnJvdXNhZklZYnV3MUcwa3RMcTFrSDhNa2NnVjBiMklGV3RDdENwRk4vZCs4VG5pdXIrRG54dThZZnMvK000L0VYZ1h4VjRqOEYrSUlPRjFMUTlTbTArNDJuSHlNOFRLV1U0R1ZiS25vUWVsY2NEdFRQZnRpcG94a2NLcDc5T2xVaWxvZnRmL0FNRWdQK0RqVDR5L0duNC9lQS9nejhTdkMrbi9BQk11UEdlcFcralduaUxUd3VsNnJZQmorOHVycEVWb0xtT0tJTkkrMUlYQ3h1eFp6d2YyNkw4ZmozcjhBZjhBZzB1L1pXYngvd0R0VWVOL2k5cUZydTA3NGI2T05KMHlSMU8zKzA5UjNLekllaE1kcEZPckRxdjJxTTl4WDc5TWM4VjUrS3R6SklVWmMxMk5MOGU5QVBGTlp0M29hTTdTTUg2MXpGMkpFT1RVa1F5UlVhREJxYUhyL3dEV3FrTG9UeERBeCtHYXNJblNvb2g5MnBrR0JWUjNFT28ybkgrZUtGNWFuN2NpckFaU09jTFQ5Z3ovQVBycU51VW9Bakl5UDBwcDRQU25uN3BxTXJrODFtQi8vOWs9XCIiLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3R5bGUtbG9hZGVyQDEuMi4xX3dlYnBhY2tANC40My4wL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nzcy1sb2FkZXJAMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS01LTEhLi9zdHlsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIi8vIHN0YXJ0Li5cbmNvbnN0IGFjdGl2ZVNlc3Npb24gPSAkKGAjbWFpbkNvbnRlbnRDb250YWluZXJgKS5kYXRhKGByZWNlaXZlZC1zZXNzaW9uYClcbmltcG9ydCAkIGZyb20gXCJqcXVlcnlcIlxuaW1wb3J0IFwiLi4vX2Nzcy9zdHlsZS5jc3NcIlxuXG5pZiAoYWN0aXZlU2Vzc2lvbikge1xuXHQvLyBoaWRlIHdoZW4gc2lnbmVkIGluXG5cdCQoYCNuYXYtc2lnbnVwLWxpbmtgKS5oaWRlKClcblx0JChgI25hdi1sb2dpbi1saW5rYCkuaGlkZSgpXG5cblx0Ly8gc2hvdyB3aGVuIHNpZ25lZCBpblxuXHQkKGAjbmF2LWxvZ291dC1saW5rYCkuc2hvdygpXG5cdCQoYCNuYXYtZGFzaGJvYXJkLWxpbmtgKS5zaG93KClcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=

/******/ ;(function (modules) {
	// webpackBootstrap
	/******/ // The module cache
	/******/ var installedModules = {} // The require function
	/******/
	/******/ /******/ function __webpack_require__(moduleId) {
		/******/
		/******/ // Check if module is in cache
		/******/ if (installedModules[moduleId]) {
			/******/ return installedModules[moduleId].exports
			/******/
		} // Create a new module (and put it into the cache)
		/******/ /******/ var module = (installedModules[moduleId] = {
			/******/ i: moduleId,
			/******/ l: false,
			/******/ exports: {},
			/******/
		}) // Execute the module function
		/******/
		/******/ /******/ modules[moduleId].call(
			module.exports,
			module,
			module.exports,
			__webpack_require__,
		) // Flag the module as loaded
		/******/
		/******/ /******/ module.l = true // Return the exports of the module
		/******/
		/******/ /******/ return module.exports
		/******/
	} // expose the modules object (__webpack_modules__)
	/******/
	/******/
	/******/ /******/ __webpack_require__.m = modules // expose the module cache
	/******/
	/******/ /******/ __webpack_require__.c = installedModules // define getter function for harmony exports
	/******/
	/******/ /******/ __webpack_require__.d = function (exports, name, getter) {
		/******/ if (!__webpack_require__.o(exports, name)) {
			/******/ Object.defineProperty(exports, name, {
				enumerable: true,
				get: getter,
			})
			/******/
		}
		/******/
	} // define __esModule on exports
	/******/
	/******/ /******/ __webpack_require__.r = function (exports) {
		/******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
			/******/ Object.defineProperty(exports, Symbol.toStringTag, {
				value: "Module",
			})
			/******/
		}
		/******/ Object.defineProperty(exports, "__esModule", { value: true })
		/******/
	} // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
	/******/
	/******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function (
		value,
		mode,
	) {
		/******/ if (mode & 1) value = __webpack_require__(value)
		/******/ if (mode & 8) return value
		/******/ if (
			mode & 4 &&
			typeof value === "object" &&
			value &&
			value.__esModule
		)
			return value
		/******/ var ns = Object.create(null)
		/******/ __webpack_require__.r(ns)
		/******/ Object.defineProperty(ns, "default", {
			enumerable: true,
			value: value,
		})
		/******/ if (mode & 2 && typeof value != "string")
			for (var key in value)
				__webpack_require__.d(
					ns,
					key,
					function (key) {
						return value[key]
					}.bind(null, key),
				)
		/******/ return ns
		/******/
	} // getDefaultExport function for compatibility with non-harmony modules
	/******/
	/******/ /******/ __webpack_require__.n = function (module) {
		/******/ var getter =
			module && module.__esModule
				? /******/ function getDefault() {
						return module["default"]
				  }
				: /******/ function getModuleExports() {
						return module
				  }
		/******/ __webpack_require__.d(getter, "a", getter)
		/******/ return getter
		/******/
	} // Object.prototype.hasOwnProperty.call
	/******/
	/******/ /******/ __webpack_require__.o = function (object, property) {
		return Object.prototype.hasOwnProperty.call(object, property)
	} // __webpack_public_path__
	/******/
	/******/ /******/ __webpack_require__.p = "/" // Load entry module and return exports
	/******/
	/******/
	/******/ /******/ return __webpack_require__(
		(__webpack_require__.s = "./src/_js/index.js"),
	)
	/******/
})(
	/************************************************************************/
	/******/ {
		/***/ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/index.js?!./src/_css/planner.css":
			/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader??ref--5-1!./src/_css/planner.css ***!
  \********************************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				exports = module.exports = __webpack_require__(
					/*! ../../node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js",
				)(false)
				// imports

				// module
				exports.push([
					module.i,
					".planner-header {\r\n\tdisplay: flex !important;\r\n\ttext-align: center;\r\n}\r\n\r\n.planner-header .lead {\r\n\ttext-align: center;\r\n}\r\n\r\ntextarea {\r\n\tposition: relative;\r\n}\r\n\r\ntextarea.note-slots:nth-of-type(2n) {\r\n\tbackground: #c0232350;\r\n}\r\n\r\n.planner-header h2 {\r\n\tfont-weight: 800;\r\n\tline-height: 1.2;\r\n\ttext-align: center;\r\n}\r\n\r\n.time-slot-row {\r\n\theight: 9.234894vh;\r\n\tmargin-bottom: 0.15rem;\r\n\twidth: 100%;\r\n}\r\n\r\n.save-btn,\r\n.note-slots {\r\n\tz-index: 99;\r\n}\r\n\r\n.hour-display {\r\n\tborder-top: 1px solid #0000001c;\r\n\tfont-size: 1.23rem;\r\n\tfont-weight: 600;\r\n\tline-height: 1;\r\n\tpadding: 0.25rem 1rem;\r\n\ttext-align: right;\r\n}\r\n\r\n.hour-display > span {\r\n\tposition: relative;\r\n\ttop: -15px;\r\n\tz-index: 97;\r\n}\r\n\r\n.note-slots {\r\n\tborder: none;\r\n\tborder-top: 1px inset #000;\r\n\theight: 50px;\r\n\theight: 100%;\r\n\tpadding-left: 0.25rem;\r\n\tresize: none;\r\n}\r\n\r\n#containerRow {\r\n\tmargin: 2rem 0;\r\n\tpadding: 0 !important;\r\n}\r\n\r\n#dateRow p {\r\n\talign-self: center;\r\n\tmargin: 0;\r\n\ttext-align: center;\r\n}\r\n\r\n#dateRow i {\r\n\tfont-size: 2.5rem;\r\n}\r\n\r\n#dateRow .chevrons {\r\n\tcolor: var(--black);\r\n\tpadding: 1rem 0;\r\n}\r\n\r\n#current-time-line {\r\n\tborder-bottom: 3px dashed #e7000050 !important;\r\n\tposition: relative;\r\n\twidth: 100%;\r\n\tz-index: 59;\r\n}\r\n\r\n@media screen and (max-width: 768px) {\r\n\r\n\t.planner-header .lead,\r\n\t.planner-header h2 {\r\n\t\ttext-align: left;\r\n\t}\r\n\r\n\t.planner-header h2 {\r\n\t\tdisplay: none;\r\n\t}\r\n\r\n\t.planner-header .lead {\r\n\t\tfont-size: 1rem !important;\r\n\t\tpadding-bottom: 0;\r\n\t}\r\n\r\n\t#currentDay {\r\n\t\tfont-size: 1.5rem;\r\n\t}\r\n}\r\n",
					"",
				])

				// exports

				/***/
			},

		/***/ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/index.js?!./src/_css/style.css":
			/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader??ref--5-1!./src/_css/style.css ***!
  \******************************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				var escape = __webpack_require__(
					/*! ../../node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/url/escape.js */ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/url/escape.js",
				)
				exports = module.exports = __webpack_require__(
					/*! ../../node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js */ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js",
				)(false)
				// imports
				exports.i(
					__webpack_require__(
						/*! -!../../node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader??ref--5-1!./planner.css */ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/index.js?!./src/_css/planner.css",
					),
					"",
				)

				// module
				exports.push([
					module.i,
					'* {\n\tfont-family:\n\t\t-apple-system,\n\t\tBlinkMacSystemFont,\n\t\t"Segoe UI",\n\t\tRoboto,\n\t\tOxygen,\n\t\tUbuntu,\n\t\tCantarell,\n\t\t"Open Sans",\n\t\t"Helvetica Neue",\n\t\tsans-serif;\n}\n\n:root {\n\t--orange: #ff783a;\n\t--charcoal: #2f4858 !important;\n\t--platinum: #e7e7e7 !important;\n\t--goldcrayola: #f9c784 !important;\n\t--black: #070707 !important;\n\t--black-faded-1: #070707c7 !important;\n\t--white: #f4f4f4 !important;\n\t--white-faded-1: #f4f4f4e0 !important;\n\t--white-faded-2: #f4f4f49d !important;\n\t--gray: #a7a7a7 !important;\n\t--link-blue: #007bff !important;\n\t--color-past: #2f4858 !important; /* charcoal */\n\t--color-current: #b7b7b7 !important;\n\t--color-future: #91b18b !important;\n}\n\nhtml {\n\tmargin: 0;\n}\n\nheader {\n\tbackground: url(' +
						escape(
							__webpack_require__(
								/*! ./images/workdayplanner1.jpg */ "./src/_css/images/workdayplanner1.jpg",
							),
						) +
						");\n\tbackground-position: 0% 40%;\n\tbackground-size: cover;\n\tmin-height: 128px;\n}\n\nheader > .container-md {\n\talign-self: center;\n\tbackground: var(--white-faded-2);\n\tcolor: var(--black);\n}\n\nheader h1,\nheader p {\n\tmargin-bottom: 1rem;\n}\n\n\nmain {\n\tbackground: var(--platinum);\n}\n\nblockquote {\n\tmargin-bottom: 0.5rem;\n\tpadding-top: 1rem;\n\ttext-align: center;\n}\n\nform#signup,\nform#login {\n\tmargin: auto;\n}\n\nform#demo-login {\n\tbackground-color: var(--goldcrayola);\n\tfont-size: 1rem;\n\tmargin: auto;\n\tmargin-top: 3rem;\n}\n\n#navbar-user {\n\tborder: none;\n\tcolor: var(--goldcrayola);\n\tfloat: left;\n}\n\n#signup-err-toast {\n\tbackground-color: var(--platinum);\n\tborder: 1px solid #000;\n\tbox-shadow: 1px 1px 2px 1px #000;\n\tcolor: var(--link-blue);\n\tfont-size: 0.89rem;\n\tpadding: 0.5rem;\n}\n\n.bg-charcoal {\n\tbackground-color: var(--charcoal);\n}\n\n.form-group > label {\n\tfloat: left;\n\ttext-align: left;\n}\n\n#blockquoteBody {\n\ttext-align: justify;\n}\n\n#profile-header-row {\n\tline-height: 32px;\n\tpadding: 6rem 1rem;\n}\n\n.grid-container {\n\tbackground-color: var(--charcoal);\n\tdisplay: grid;\n\tgrid-template-rows: auto 1fr auto;\n\theight: 100vh;\n\tmargin: 0;\n\tpadding: 0;\n}\n\n.login-container,\n.signup-container {\n\tmargin: 2.65rem auto;\n\tmax-width: 425px;\n\ttext-align: center;\n\twidth: 70%;\n}\n\n.login-container input,\n.signup-container input {\n\tbox-shadow: inset 1px 1px #0004;\n}\n\n.text-date {\n\tcolor: var(--orange);\n\tfont-size: 1.7rem;\n\tfont-weight: 700;\n\tword-wrap: break-word;\n}\n\n.text-goldcrayola {\n\tcolor: var(--goldcrayola);\n}\n\n.bg-past {\n\tbackground: var(--color-past);\n\tcolor: var(--white-faded-1);\n}\n\n.bg-current {\n\tbackground: var(--color-current);\n}\n\n.bg-future {\n\tbackground: var(--color-future);\n}\n\n.bg-gray {\n\tbackground: #dbdbdb;\n}\n\n.footer {\n\n\t/* Vertically center the text there */\n\tbackground-color: var(--charcoal);\n\tborder-top: 1px transparent #000;\n\tbox-shadow: 0 -2px -2px 2px #0004;\n\theight: auto;\n\tpadding: 0.5rem 0;\n\twidth: 100%;\n}\n\n.footer .wrapper {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\tmargin: auto 0 !important;\n\tpadding: 0 1rem !important;\n}\n\n.footer span {\n\tletter-spacing: 1px;\n}\n\n.link-button {\n\tbackground: none;\n\tborder: none;\n\tcolor: var(--link-blue);\n\tcursor: pointer;\n\tpadding: 0.25rem;\n\ttext-decoration: none;\n}\n\n.link-button:hover {\n\ttext-decoration: underline;\n}\n\n.disable-click {\n\tpointer-events: none;\n}\n\n.fa-save {\n\tfont-size: 18px;\n}\n\n.chevrons:hover {\n\tbackground: #292b2c34;\n\n\t/* opacity: .2; */\n}\n\n/* The Modal (background) */\n\n.modal {\n\n\t/* Enable scroll if needed */\n\tbackground-color: var(--black);\n\n\t/* Fallback color */\n\tbackground-color: var(--black-faded-1);\n\tdisplay: none;\n\n\t/* Full width */\n\theight: 100%;\n\n\t/* Location of the box */\n\tleft: 0;\n\n\t/* Full height */\n\toverflow: auto;\n\n\t/* Sit on top */\n\tpadding-top: 100px;\n\n\t/* Hidden by default */\n\tposition: fixed;\n\ttop: 0;\n\twidth: 100%;\n\n\t/* Stay in place */\n\tz-index: 1;\n\n\t/* Black w/ opacity */\n}\n\n/* Modal Content */\n\n.settings-modal-content {\n\tbackground-color: var(--color-future);\n\tborder: 1px solid #888;\n\tmargin: auto;\n\tpadding: 20px;\n\ttext-align: center;\n\twidth: 68%;\n}\n\n@media screen and (max-width: 576px) {\n\n\t.modal-content {\n\t\tfont-size: small;\n\t\tpadding: 20px;\n\t\twidth: 100%;\n\t}\n\n\t.signup-container,\n\t.login-container {\n\t\twidth: 90%;\n\t}\n}\n\n/* anything above 1200px */\n@media screen and (min-width: 1200px) {\n\n\t/* \n\t.signup-container,\n\t.login-container {\n\t\twidth: 800px;\n\t} */\n}\n\n/* The Close Button */\n\n.close {\n\tcolor: var(--gray);\n\tfloat: right;\n\tfont-size: 8px;\n\tfont-weight: 600;\n}\n\n.modal-save-button {\n\tbackground: #0084ffda;\n\tmargin-top: 0.25em;\n\n\t/* float: right; */\n\tpadding: 0.5em 1em;\n}\n",
					"",
				])

				// exports

				/***/
			},

		/***/ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js":
			/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/css-base.js ***!
  \***************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports) {
				/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
				// css base code, injected by the css-loader
				module.exports = function (useSourceMap) {
					var list = []

					// return the list of modules as css string
					list.toString = function toString() {
						return this.map(function (item) {
							var content = cssWithMappingToString(item, useSourceMap)
							if (item[2]) {
								return "@media " + item[2] + "{" + content + "}"
							} else {
								return content
							}
						}).join("")
					}

					// import a list of modules into the list
					list.i = function (modules, mediaQuery) {
						if (typeof modules === "string") modules = [[null, modules, ""]]
						var alreadyImportedModules = {}
						for (var i = 0; i < this.length; i++) {
							var id = this[i][0]
							if (typeof id === "number") alreadyImportedModules[id] = true
						}
						for (i = 0; i < modules.length; i++) {
							var item = modules[i]
							// skip already imported module
							// this implementation is not 100% perfect for weird media query combinations
							//  when a module is imported multiple times with different media queries.
							//  I hope this will never occur (Hey this way we have smaller bundles)
							if (
								typeof item[0] !== "number" ||
								!alreadyImportedModules[item[0]]
							) {
								if (mediaQuery && !item[2]) {
									item[2] = mediaQuery
								} else if (mediaQuery) {
									item[2] = "(" + item[2] + ") and (" + mediaQuery + ")"
								}
								list.push(item)
							}
						}
					}
					return list
				}

				function cssWithMappingToString(item, useSourceMap) {
					var content = item[1] || ""
					var cssMapping = item[3]
					if (!cssMapping) {
						return content
					}

					if (useSourceMap && typeof btoa === "function") {
						var sourceMapping = toComment(cssMapping)
						var sourceURLs = cssMapping.sources.map(function (source) {
							return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */"
						})

						return [content]
							.concat(sourceURLs)
							.concat([sourceMapping])
							.join("\n")
					}

					return [content].join("\n")
				}

				// Adapted from convert-source-map (MIT)
				function toComment(sourceMap) {
					// eslint-disable-next-line no-undef
					var base64 = btoa(
						unescape(encodeURIComponent(JSON.stringify(sourceMap))),
					)
					var data =
						"sourceMappingURL=data:application/json;charset=utf-8;base64," +
						base64

					return "/*# " + data + " */"
				}

				/***/
			},

		/***/ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/url/escape.js":
			/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/lib/url/escape.js ***!
  \*****************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports) {
				module.exports = function escape(url) {
					if (typeof url !== "string") {
						return url
					}
					// If url is already wrapped in quotes, remove them
					if (/^['"].*['"]$/.test(url)) {
						url = url.slice(1, -1)
					}
					// Should url be wrapped?
					// See https://drafts.csswg.org/css-values-3/#urls
					if (/["'() \t\n]/.test(url)) {
						return '"' + url.replace(/"/g, '\\"').replace(/\n/g, "\\n") + '"'
					}

					return url
				}

				/***/
			},

		/***/ "./node_modules/.pnpm/jquery@3.5.1/node_modules/jquery/dist/jquery.js":
			/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/jquery@3.5.1/node_modules/jquery/dist/jquery.js ***!
  \****************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__
				/*!
				 * jQuery JavaScript Library v3.5.1
				 * https://jquery.com/
				 *
				 * Includes Sizzle.js
				 * https://sizzlejs.com/
				 *
				 * Copyright JS Foundation and other contributors
				 * Released under the MIT license
				 * https://jquery.org/license
				 *
				 * Date: 2020-05-04T22:49Z
				 */
				;(function (global, factory) {
					"use strict"

					if (true && typeof module.exports === "object") {
						// For CommonJS and CommonJS-like environments where a proper `window`
						// is present, execute the factory and get jQuery.
						// For environments that do not have a `window` with a `document`
						// (such as Node.js), expose a factory as module.exports.
						// This accentuates the need for the creation of a real `window`.
						// e.g. var jQuery = require("jquery")(window);
						// See ticket #14549 for more info.
						module.exports = global.document
							? factory(global, true)
							: function (w) {
									if (!w.document) {
										throw new Error("jQuery requires a window with a document")
									}
									return factory(w)
							  }
					} else {
						factory(global)
					}

					// Pass this if window is not defined yet
				})(typeof window !== "undefined" ? window : this, function (
					window,
					noGlobal,
				) {
					// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
					// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
					// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
					// enough that all such attempts are guarded in a try block.
					"use strict"

					var arr = []

					var getProto = Object.getPrototypeOf

					var slice = arr.slice

					var flat = arr.flat
						? function (array) {
								return arr.flat.call(array)
						  }
						: function (array) {
								return arr.concat.apply([], array)
						  }

					var push = arr.push

					var indexOf = arr.indexOf

					var class2type = {}

					var toString = class2type.toString

					var hasOwn = class2type.hasOwnProperty

					var fnToString = hasOwn.toString

					var ObjectFunctionString = fnToString.call(Object)

					var support = {}

					var isFunction = function isFunction(obj) {
						// Support: Chrome <=57, Firefox <=52
						// In some browsers, typeof returns "function" for HTML <object> elements
						// (i.e., `typeof document.createElement( "object" ) === "function"`).
						// We don't want to classify *any* DOM node as a function.
						return typeof obj === "function" && typeof obj.nodeType !== "number"
					}

					var isWindow = function isWindow(obj) {
						return obj != null && obj === obj.window
					}

					var document = window.document

					var preservedScriptAttributes = {
						type: true,
						src: true,
						nonce: true,
						noModule: true,
					}

					function DOMEval(code, node, doc) {
						doc = doc || document

						var i,
							val,
							script = doc.createElement("script")

						script.text = code
						if (node) {
							for (i in preservedScriptAttributes) {
								// Support: Firefox 64+, Edge 18+
								// Some browsers don't support the "nonce" property on scripts.
								// On the other hand, just using `getAttribute` is not enough as
								// the `nonce` attribute is reset to an empty string whenever it
								// becomes browsing-context connected.
								// See https://github.com/whatwg/html/issues/2369
								// See https://html.spec.whatwg.org/#nonce-attributes
								// The `node.getAttribute` check was added for the sake of
								// `jQuery.globalEval` so that it can fake a nonce-containing node
								// via an object.
								val = node[i] || (node.getAttribute && node.getAttribute(i))
								if (val) {
									script.setAttribute(i, val)
								}
							}
						}
						doc.head.appendChild(script).parentNode.removeChild(script)
					}

					function toType(obj) {
						if (obj == null) {
							return obj + ""
						}

						// Support: Android <=2.3 only (functionish RegExp)
						return typeof obj === "object" || typeof obj === "function"
							? class2type[toString.call(obj)] || "object"
							: typeof obj
					}
					/* global Symbol */
					// Defining this global in .eslintrc.json would create a danger of using the global
					// unguarded in another place, it seems safer to define global only for this module

					var version = "3.5.1",
						// Define a local copy of jQuery
						jQuery = function (selector, context) {
							// The jQuery object is actually just the init constructor 'enhanced'
							// Need init if jQuery is called (just allow error to be thrown if not included)
							return new jQuery.fn.init(selector, context)
						}

					jQuery.fn = jQuery.prototype = {
						// The current version of jQuery being used
						jquery: version,

						constructor: jQuery,

						// The default length of a jQuery object is 0
						length: 0,

						toArray: function () {
							return slice.call(this)
						},

						// Get the Nth element in the matched element set OR
						// Get the whole matched element set as a clean array
						get: function (num) {
							// Return all the elements in a clean array
							if (num == null) {
								return slice.call(this)
							}

							// Return just the one element from the set
							return num < 0 ? this[num + this.length] : this[num]
						},

						// Take an array of elements and push it onto the stack
						// (returning the new matched element set)
						pushStack: function (elems) {
							// Build a new jQuery matched element set
							var ret = jQuery.merge(this.constructor(), elems)

							// Add the old object onto the stack (as a reference)
							ret.prevObject = this

							// Return the newly-formed element set
							return ret
						},

						// Execute a callback for every element in the matched set.
						each: function (callback) {
							return jQuery.each(this, callback)
						},

						map: function (callback) {
							return this.pushStack(
								jQuery.map(this, function (elem, i) {
									return callback.call(elem, i, elem)
								}),
							)
						},

						slice: function () {
							return this.pushStack(slice.apply(this, arguments))
						},

						first: function () {
							return this.eq(0)
						},

						last: function () {
							return this.eq(-1)
						},

						even: function () {
							return this.pushStack(
								jQuery.grep(this, function (_elem, i) {
									return (i + 1) % 2
								}),
							)
						},

						odd: function () {
							return this.pushStack(
								jQuery.grep(this, function (_elem, i) {
									return i % 2
								}),
							)
						},

						eq: function (i) {
							var len = this.length,
								j = +i + (i < 0 ? len : 0)
							return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
						},

						end: function () {
							return this.prevObject || this.constructor()
						},

						// For internal use only.
						// Behaves like an Array's method, not like a jQuery method.
						push: push,
						sort: arr.sort,
						splice: arr.splice,
					}

					jQuery.extend = jQuery.fn.extend = function () {
						var options,
							name,
							src,
							copy,
							copyIsArray,
							clone,
							target = arguments[0] || {},
							i = 1,
							length = arguments.length,
							deep = false

						// Handle a deep copy situation
						if (typeof target === "boolean") {
							deep = target

							// Skip the boolean and the target
							target = arguments[i] || {}
							i++
						}

						// Handle case when target is a string or something (possible in deep copy)
						if (typeof target !== "object" && !isFunction(target)) {
							target = {}
						}

						// Extend jQuery itself if only one argument is passed
						if (i === length) {
							target = this
							i--
						}

						for (; i < length; i++) {
							// Only deal with non-null/undefined values
							if ((options = arguments[i]) != null) {
								// Extend the base object
								for (name in options) {
									copy = options[name]

									// Prevent Object.prototype pollution
									// Prevent never-ending loop
									if (name === "__proto__" || target === copy) {
										continue
									}

									// Recurse if we're merging plain objects or arrays
									if (
										deep &&
										copy &&
										(jQuery.isPlainObject(copy) ||
											(copyIsArray = Array.isArray(copy)))
									) {
										src = target[name]

										// Ensure proper type for the source value
										if (copyIsArray && !Array.isArray(src)) {
											clone = []
										} else if (!copyIsArray && !jQuery.isPlainObject(src)) {
											clone = {}
										} else {
											clone = src
										}
										copyIsArray = false

										// Never move original objects, clone them
										target[name] = jQuery.extend(deep, clone, copy)

										// Don't bring in undefined values
									} else if (copy !== undefined) {
										target[name] = copy
									}
								}
							}
						}

						// Return the modified object
						return target
					}

					jQuery.extend({
						// Unique for each copy of jQuery on the page
						expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

						// Assume jQuery is ready without the ready module
						isReady: true,

						error: function (msg) {
							throw new Error(msg)
						},

						noop: function () {},

						isPlainObject: function (obj) {
							var proto, Ctor

							// Detect obvious negatives
							// Use toString instead of jQuery.type to catch host objects
							if (!obj || toString.call(obj) !== "[object Object]") {
								return false
							}

							proto = getProto(obj)

							// Objects with no prototype (e.g., `Object.create( null )`) are plain
							if (!proto) {
								return true
							}

							// Objects with prototype are plain iff they were constructed by a global Object function
							Ctor = hasOwn.call(proto, "constructor") && proto.constructor
							return (
								typeof Ctor === "function" &&
								fnToString.call(Ctor) === ObjectFunctionString
							)
						},

						isEmptyObject: function (obj) {
							var name

							for (name in obj) {
								return false
							}
							return true
						},

						// Evaluates a script in a provided context; falls back to the global one
						// if not specified.
						globalEval: function (code, options, doc) {
							DOMEval(code, { nonce: options && options.nonce }, doc)
						},

						each: function (obj, callback) {
							var length,
								i = 0

							if (isArrayLike(obj)) {
								length = obj.length
								for (; i < length; i++) {
									if (callback.call(obj[i], i, obj[i]) === false) {
										break
									}
								}
							} else {
								for (i in obj) {
									if (callback.call(obj[i], i, obj[i]) === false) {
										break
									}
								}
							}

							return obj
						},

						// results is for internal usage only
						makeArray: function (arr, results) {
							var ret = results || []

							if (arr != null) {
								if (isArrayLike(Object(arr))) {
									jQuery.merge(ret, typeof arr === "string" ? [arr] : arr)
								} else {
									push.call(ret, arr)
								}
							}

							return ret
						},

						inArray: function (elem, arr, i) {
							return arr == null ? -1 : indexOf.call(arr, elem, i)
						},

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						merge: function (first, second) {
							var len = +second.length,
								j = 0,
								i = first.length

							for (; j < len; j++) {
								first[i++] = second[j]
							}

							first.length = i

							return first
						},

						grep: function (elems, callback, invert) {
							var callbackInverse,
								matches = [],
								i = 0,
								length = elems.length,
								callbackExpect = !invert

							// Go through the array, only saving the items
							// that pass the validator function
							for (; i < length; i++) {
								callbackInverse = !callback(elems[i], i)
								if (callbackInverse !== callbackExpect) {
									matches.push(elems[i])
								}
							}

							return matches
						},

						// arg is for internal usage only
						map: function (elems, callback, arg) {
							var length,
								value,
								i = 0,
								ret = []

							// Go through the array, translating each of the items to their new values
							if (isArrayLike(elems)) {
								length = elems.length
								for (; i < length; i++) {
									value = callback(elems[i], i, arg)

									if (value != null) {
										ret.push(value)
									}
								}

								// Go through every key on the object,
							} else {
								for (i in elems) {
									value = callback(elems[i], i, arg)

									if (value != null) {
										ret.push(value)
									}
								}
							}

							// Flatten any nested arrays
							return flat(ret)
						},

						// A global GUID counter for objects
						guid: 1,

						// jQuery.support is not used in Core but other projects attach their
						// properties to it so it needs to exist.
						support: support,
					})

					if (typeof Symbol === "function") {
						jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]
					}

					// Populate the class2type map
					jQuery.each(
						"Boolean Number String Function Array Date RegExp Object Error Symbol".split(
							" ",
						),
						function (_i, name) {
							class2type["[object " + name + "]"] = name.toLowerCase()
						},
					)

					function isArrayLike(obj) {
						// Support: real iOS 8.2 only (not reproducible in simulator)
						// `in` check used to prevent JIT error (gh-2145)
						// hasOwn isn't used here due to false negatives
						// regarding Nodelist length in IE
						var length = !!obj && "length" in obj && obj.length,
							type = toType(obj)

						if (isFunction(obj) || isWindow(obj)) {
							return false
						}

						return (
							type === "array" ||
							length === 0 ||
							(typeof length === "number" && length > 0 && length - 1 in obj)
						)
					}
					var Sizzle =
						/*!
						 * Sizzle CSS Selector Engine v2.3.5
						 * https://sizzlejs.com/
						 *
						 * Copyright JS Foundation and other contributors
						 * Released under the MIT license
						 * https://js.foundation/
						 *
						 * Date: 2020-03-14
						 */
						(function (window) {
							var i,
								support,
								Expr,
								getText,
								isXML,
								tokenize,
								compile,
								select,
								outermostContext,
								sortInput,
								hasDuplicate,
								// Local document vars
								setDocument,
								document,
								docElem,
								documentIsHTML,
								rbuggyQSA,
								rbuggyMatches,
								matches,
								contains,
								// Instance-specific data
								expando = "sizzle" + 1 * new Date(),
								preferredDoc = window.document,
								dirruns = 0,
								done = 0,
								classCache = createCache(),
								tokenCache = createCache(),
								compilerCache = createCache(),
								nonnativeSelectorCache = createCache(),
								sortOrder = function (a, b) {
									if (a === b) {
										hasDuplicate = true
									}
									return 0
								},
								// Instance methods
								hasOwn = {}.hasOwnProperty,
								arr = [],
								pop = arr.pop,
								pushNative = arr.push,
								push = arr.push,
								slice = arr.slice,
								// Use a stripped-down indexOf as it's faster than native
								// https://jsperf.com/thor-indexof-vs-for/5
								indexOf = function (list, elem) {
									var i = 0,
										len = list.length
									for (; i < len; i++) {
										if (list[i] === elem) {
											return i
										}
									}
									return -1
								},
								booleans =
									"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
									"ismap|loop|multiple|open|readonly|required|scoped",
								// Regular expressions

								// http://www.w3.org/TR/css3-selectors/#whitespace
								whitespace = "[\\x20\\t\\r\\n\\f]",
								// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
								identifier =
									"(?:\\\\[\\da-fA-F]{1,6}" +
									whitespace +
									"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
								// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
								attributes =
									"\\[" +
									whitespace +
									"*(" +
									identifier +
									")(?:" +
									whitespace +
									// Operator (capture 2)
									"*([*^$|!~]?=)" +
									whitespace +
									// "Attribute values must be CSS identifiers [capture 5]
									// or strings [capture 3 or capture 4]"
									"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
									identifier +
									"))|)" +
									whitespace +
									"*\\]",
								pseudos =
									":(" +
									identifier +
									")(?:\\((" +
									// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
									// 1. quoted (capture 3; capture 4 or capture 5)
									"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
									// 2. simple (capture 6)
									"((?:\\\\.|[^\\\\()[\\]]|" +
									attributes +
									")*)|" +
									// 3. anything else (capture 2)
									".*" +
									")\\)|)",
								// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
								rwhitespace = new RegExp(whitespace + "+", "g"),
								rtrim = new RegExp(
									"^" +
										whitespace +
										"+|((?:^|[^\\\\])(?:\\\\.)*)" +
										whitespace +
										"+$",
									"g",
								),
								rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
								rcombinators = new RegExp(
									"^" +
										whitespace +
										"*([>+~]|" +
										whitespace +
										")" +
										whitespace +
										"*",
								),
								rdescend = new RegExp(whitespace + "|>"),
								rpseudo = new RegExp(pseudos),
								ridentifier = new RegExp("^" + identifier + "$"),
								matchExpr = {
									ID: new RegExp("^#(" + identifier + ")"),
									CLASS: new RegExp("^\\.(" + identifier + ")"),
									TAG: new RegExp("^(" + identifier + "|[*])"),
									ATTR: new RegExp("^" + attributes),
									PSEUDO: new RegExp("^" + pseudos),
									CHILD: new RegExp(
										"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
											whitespace +
											"*(even|odd|(([+-]|)(\\d*)n|)" +
											whitespace +
											"*(?:([+-]|)" +
											whitespace +
											"*(\\d+)|))" +
											whitespace +
											"*\\)|)",
										"i",
									),
									bool: new RegExp("^(?:" + booleans + ")$", "i"),

									// For use in libraries implementing .is()
									// We use this for POS matching in `select`
									needsContext: new RegExp(
										"^" +
											whitespace +
											"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
											whitespace +
											"*((?:-\\d)?\\d*)" +
											whitespace +
											"*\\)|)(?=[^-]|$)",
										"i",
									),
								},
								rhtml = /HTML$/i,
								rinputs = /^(?:input|select|textarea|button)$/i,
								rheader = /^h\d$/i,
								rnative = /^[^{]+\{\s*\[native \w/,
								// Easily-parseable/retrievable ID or TAG or CLASS selectors
								rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
								rsibling = /[+~]/,
								// CSS escapes
								// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
								runescape = new RegExp(
									"\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])",
									"g",
								),
								funescape = function (escape, nonHex) {
									var high = "0x" + escape.slice(1) - 0x10000

									return nonHex
										? // Strip the backslash prefix from a non-hex escape sequence
										  nonHex
										: // Replace a hexadecimal escape sequence with the encoded Unicode code point
										// Support: IE <=11+
										// For values outside the Basic Multilingual Plane (BMP), manually construct a
										// surrogate pair
										high < 0
										? String.fromCharCode(high + 0x10000)
										: String.fromCharCode(
												(high >> 10) | 0xd800,
												(high & 0x3ff) | 0xdc00,
										  )
								},
								// CSS string/identifier serialization
								// https://drafts.csswg.org/cssom/#common-serializing-idioms
								rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
								fcssescape = function (ch, asCodePoint) {
									if (asCodePoint) {
										// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
										if (ch === "\0") {
											return "\uFFFD"
										}

										// Control characters and (dependent upon position) numbers get escaped as code points
										return (
											ch.slice(0, -1) +
											"\\" +
											ch.charCodeAt(ch.length - 1).toString(16) +
											" "
										)
									}

									// Other potentially-special ASCII characters get backslash-escaped
									return "\\" + ch
								},
								// Used for iframes
								// See setDocument()
								// Removing the function wrapper causes a "Permission Denied"
								// error in IE
								unloadHandler = function () {
									setDocument()
								},
								inDisabledFieldset = addCombinator(
									function (elem) {
										return (
											elem.disabled === true &&
											elem.nodeName.toLowerCase() === "fieldset"
										)
									},
									{ dir: "parentNode", next: "legend" },
								)

							// Optimize for push.apply( _, NodeList )
							try {
								push.apply(
									(arr = slice.call(preferredDoc.childNodes)),
									preferredDoc.childNodes,
								)

								// Support: Android<4.0
								// Detect silently failing push.apply
								// eslint-disable-next-line no-unused-expressions
								arr[preferredDoc.childNodes.length].nodeType
							} catch (e) {
								push = {
									apply: arr.length
										? // Leverage slice if possible
										  function (target, els) {
												pushNative.apply(target, slice.call(els))
										  }
										: // Support: IE<9
										  // Otherwise append directly
										  function (target, els) {
												var j = target.length,
													i = 0

												// Can't trust NodeList.length
												while ((target[j++] = els[i++])) {}
												target.length = j - 1
										  },
								}
							}

							function Sizzle(selector, context, results, seed) {
								var m,
									i,
									elem,
									nid,
									match,
									groups,
									newSelector,
									newContext = context && context.ownerDocument,
									// nodeType defaults to 9, since context defaults to document
									nodeType = context ? context.nodeType : 9

								results = results || []

								// Return early from calls with invalid selector or context
								if (
									typeof selector !== "string" ||
									!selector ||
									(nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
								) {
									return results
								}

								// Try to shortcut find operations (as opposed to filters) in HTML documents
								if (!seed) {
									setDocument(context)
									context = context || document

									if (documentIsHTML) {
										// If the selector is sufficiently simple, try using a "get*By*" DOM method
										// (excepting DocumentFragment context, where the methods don't exist)
										if (
											nodeType !== 11 &&
											(match = rquickExpr.exec(selector))
										) {
											// ID selector
											if ((m = match[1])) {
												// Document context
												if (nodeType === 9) {
													if ((elem = context.getElementById(m))) {
														// Support: IE, Opera, Webkit
														// TODO: identify versions
														// getElementById can match elements by name instead of ID
														if (elem.id === m) {
															results.push(elem)
															return results
														}
													} else {
														return results
													}

													// Element context
												} else {
													// Support: IE, Opera, Webkit
													// TODO: identify versions
													// getElementById can match elements by name instead of ID
													if (
														newContext &&
														(elem = newContext.getElementById(m)) &&
														contains(context, elem) &&
														elem.id === m
													) {
														results.push(elem)
														return results
													}
												}

												// Type selector
											} else if (match[2]) {
												push.apply(
													results,
													context.getElementsByTagName(selector),
												)
												return results

												// Class selector
											} else if (
												(m = match[3]) &&
												support.getElementsByClassName &&
												context.getElementsByClassName
											) {
												push.apply(results, context.getElementsByClassName(m))
												return results
											}
										}

										// Take advantage of querySelectorAll
										if (
											support.qsa &&
											!nonnativeSelectorCache[selector + " "] &&
											(!rbuggyQSA || !rbuggyQSA.test(selector)) &&
											// Support: IE 8 only
											// Exclude object elements
											(nodeType !== 1 ||
												context.nodeName.toLowerCase() !== "object")
										) {
											newSelector = selector
											newContext = context

											// qSA considers elements outside a scoping root when evaluating child or
											// descendant combinators, which is not what we want.
											// In such cases, we work around the behavior by prefixing every selector in the
											// list with an ID selector referencing the scope context.
											// The technique has to be used as well when a leading combinator is used
											// as such selectors are not recognized by querySelectorAll.
											// Thanks to Andrew Dupont for this technique.
											if (
												nodeType === 1 &&
												(rdescend.test(selector) || rcombinators.test(selector))
											) {
												// Expand context for sibling selectors
												newContext =
													(rsibling.test(selector) &&
														testContext(context.parentNode)) ||
													context

												// We can use :scope instead of the ID hack if the browser
												// supports it & if we're not changing the context.
												if (newContext !== context || !support.scope) {
													// Capture the context ID, setting it first if necessary
													if ((nid = context.getAttribute("id"))) {
														nid = nid.replace(rcssescape, fcssescape)
													} else {
														context.setAttribute("id", (nid = expando))
													}
												}

												// Prefix every selector in the list
												groups = tokenize(selector)
												i = groups.length
												while (i--) {
													groups[i] =
														(nid ? "#" + nid : ":scope") +
														" " +
														toSelector(groups[i])
												}
												newSelector = groups.join(",")
											}

											try {
												push.apply(
													results,
													newContext.querySelectorAll(newSelector),
												)
												return results
											} catch (qsaError) {
												nonnativeSelectorCache(selector, true)
											} finally {
												if (nid === expando) {
													context.removeAttribute("id")
												}
											}
										}
									}
								}

								// All others
								return select(
									selector.replace(rtrim, "$1"),
									context,
									results,
									seed,
								)
							}

							/**
							 * Create key-value caches of limited size
							 * @returns {function(string, object)} Returns the Object data after storing it on itself with
							 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
							 *	deleting the oldest entry
							 */
							function createCache() {
								var keys = []

								function cache(key, value) {
									// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
									if (keys.push(key + " ") > Expr.cacheLength) {
										// Only keep the most recent entries
										delete cache[keys.shift()]
									}
									return (cache[key + " "] = value)
								}
								return cache
							}

							/**
							 * Mark a function for special use by Sizzle
							 * @param {Function} fn The function to mark
							 */
							function markFunction(fn) {
								fn[expando] = true
								return fn
							}

							/**
							 * Support testing using an element
							 * @param {Function} fn Passed the created element and returns a boolean result
							 */
							function assert(fn) {
								var el = document.createElement("fieldset")

								try {
									return !!fn(el)
								} catch (e) {
									return false
								} finally {
									// Remove from its parent by default
									if (el.parentNode) {
										el.parentNode.removeChild(el)
									}

									// release memory in IE
									el = null
								}
							}

							/**
							 * Adds the same handler for all of the specified attrs
							 * @param {String} attrs Pipe-separated list of attributes
							 * @param {Function} handler The method that will be applied
							 */
							function addHandle(attrs, handler) {
								var arr = attrs.split("|"),
									i = arr.length

								while (i--) {
									Expr.attrHandle[arr[i]] = handler
								}
							}

							/**
							 * Checks document order of two siblings
							 * @param {Element} a
							 * @param {Element} b
							 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
							 */
							function siblingCheck(a, b) {
								var cur = b && a,
									diff =
										cur &&
										a.nodeType === 1 &&
										b.nodeType === 1 &&
										a.sourceIndex - b.sourceIndex

								// Use IE sourceIndex if available on both nodes
								if (diff) {
									return diff
								}

								// Check if b follows a
								if (cur) {
									while ((cur = cur.nextSibling)) {
										if (cur === b) {
											return -1
										}
									}
								}

								return a ? 1 : -1
							}

							/**
							 * Returns a function to use in pseudos for input types
							 * @param {String} type
							 */
							function createInputPseudo(type) {
								return function (elem) {
									var name = elem.nodeName.toLowerCase()
									return name === "input" && elem.type === type
								}
							}

							/**
							 * Returns a function to use in pseudos for buttons
							 * @param {String} type
							 */
							function createButtonPseudo(type) {
								return function (elem) {
									var name = elem.nodeName.toLowerCase()
									return (
										(name === "input" || name === "button") &&
										elem.type === type
									)
								}
							}

							/**
							 * Returns a function to use in pseudos for :enabled/:disabled
							 * @param {Boolean} disabled true for :disabled; false for :enabled
							 */
							function createDisabledPseudo(disabled) {
								// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
								return function (elem) {
									// Only certain elements can match :enabled or :disabled
									// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
									// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
									if ("form" in elem) {
										// Check for inherited disabledness on relevant non-disabled elements:
										// * listed form-associated elements in a disabled fieldset
										//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
										//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
										// * option elements in a disabled optgroup
										//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
										// All such elements have a "form" property.
										if (elem.parentNode && elem.disabled === false) {
											// Option elements defer to a parent optgroup if present
											if ("label" in elem) {
												if ("label" in elem.parentNode) {
													return elem.parentNode.disabled === disabled
												} else {
													return elem.disabled === disabled
												}
											}

											// Support: IE 6 - 11
											// Use the isDisabled shortcut property to check for disabled fieldset ancestors
											return (
												elem.isDisabled === disabled ||
												// Where there is no isDisabled, check manually
												/* jshint -W018 */
												(elem.isDisabled !== !disabled &&
													inDisabledFieldset(elem) === disabled)
											)
										}

										return elem.disabled === disabled

										// Try to winnow out elements that can't be disabled before trusting the disabled property.
										// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
										// even exist on them, let alone have a boolean value.
									} else if ("label" in elem) {
										return elem.disabled === disabled
									}

									// Remaining elements are neither :enabled nor :disabled
									return false
								}
							}

							/**
							 * Returns a function to use in pseudos for positionals
							 * @param {Function} fn
							 */
							function createPositionalPseudo(fn) {
								return markFunction(function (argument) {
									argument = +argument
									return markFunction(function (seed, matches) {
										var j,
											matchIndexes = fn([], seed.length, argument),
											i = matchIndexes.length

										// Match elements found at the specified indexes
										while (i--) {
											if (seed[(j = matchIndexes[i])]) {
												seed[j] = !(matches[j] = seed[j])
											}
										}
									})
								})
							}

							/**
							 * Checks a node for validity as a Sizzle context
							 * @param {Element|Object=} context
							 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
							 */
							function testContext(context) {
								return (
									context &&
									typeof context.getElementsByTagName !== "undefined" &&
									context
								)
							}

							// Expose support vars for convenience
							support = Sizzle.support = {}

							/**
							 * Detects XML nodes
							 * @param {Element|Object} elem An element or a document
							 * @returns {Boolean} True iff elem is a non-HTML XML node
							 */
							isXML = Sizzle.isXML = function (elem) {
								var namespace = elem.namespaceURI,
									docElem = (elem.ownerDocument || elem).documentElement

								// Support: IE <=8
								// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
								// https://bugs.jquery.com/ticket/4833
								return !rhtml.test(
									namespace || (docElem && docElem.nodeName) || "HTML",
								)
							}

							/**
							 * Sets document-related variables once based on the current document
							 * @param {Element|Object} [doc] An element or document object to use to set the document
							 * @returns {Object} Returns the current document
							 */
							setDocument = Sizzle.setDocument = function (node) {
								var hasCompare,
									subWindow,
									doc = node ? node.ownerDocument || node : preferredDoc

								// Return early if doc is invalid or already selected
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if (
									doc == document ||
									doc.nodeType !== 9 ||
									!doc.documentElement
								) {
									return document
								}

								// Update global variables
								document = doc
								docElem = document.documentElement
								documentIsHTML = !isXML(document)

								// Support: IE 9 - 11+, Edge 12 - 18+
								// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if (
									preferredDoc != document &&
									(subWindow = document.defaultView) &&
									subWindow.top !== subWindow
								) {
									// Support: IE 11, Edge
									if (subWindow.addEventListener) {
										subWindow.addEventListener("unload", unloadHandler, false)

										// Support: IE 9 - 10 only
									} else if (subWindow.attachEvent) {
										subWindow.attachEvent("onunload", unloadHandler)
									}
								}

								// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
								// Safari 4 - 5 only, Opera <=11.6 - 12.x only
								// IE/Edge & older browsers don't support the :scope pseudo-class.
								// Support: Safari 6.0 only
								// Safari 6.0 supports :scope but it's an alias of :root there.
								support.scope = assert(function (el) {
									docElem
										.appendChild(el)
										.appendChild(document.createElement("div"))
									return (
										typeof el.querySelectorAll !== "undefined" &&
										!el.querySelectorAll(":scope fieldset div").length
									)
								})

								/* Attributes
	---------------------------------------------------------------------- */

								// Support: IE<8
								// Verify that getAttribute really returns attributes and not properties
								// (excepting IE8 booleans)
								support.attributes = assert(function (el) {
									el.className = "i"
									return !el.getAttribute("className")
								})

								/* getElement(s)By*
	---------------------------------------------------------------------- */

								// Check if getElementsByTagName("*") returns only elements
								support.getElementsByTagName = assert(function (el) {
									el.appendChild(document.createComment(""))
									return !el.getElementsByTagName("*").length
								})

								// Support: IE<9
								support.getElementsByClassName = rnative.test(
									document.getElementsByClassName,
								)

								// Support: IE<10
								// Check if getElementById returns elements by name
								// The broken getElementById methods don't pick up programmatically-set names,
								// so use a roundabout getElementsByName test
								support.getById = assert(function (el) {
									docElem.appendChild(el).id = expando
									return (
										!document.getElementsByName ||
										!document.getElementsByName(expando).length
									)
								})

								// ID filter and find
								if (support.getById) {
									Expr.filter["ID"] = function (id) {
										var attrId = id.replace(runescape, funescape)
										return function (elem) {
											return elem.getAttribute("id") === attrId
										}
									}
									Expr.find["ID"] = function (id, context) {
										if (
											typeof context.getElementById !== "undefined" &&
											documentIsHTML
										) {
											var elem = context.getElementById(id)
											return elem ? [elem] : []
										}
									}
								} else {
									Expr.filter["ID"] = function (id) {
										var attrId = id.replace(runescape, funescape)
										return function (elem) {
											var node =
												typeof elem.getAttributeNode !== "undefined" &&
												elem.getAttributeNode("id")
											return node && node.value === attrId
										}
									}

									// Support: IE 6 - 7 only
									// getElementById is not reliable as a find shortcut
									Expr.find["ID"] = function (id, context) {
										if (
											typeof context.getElementById !== "undefined" &&
											documentIsHTML
										) {
											var node,
												i,
												elems,
												elem = context.getElementById(id)

											if (elem) {
												// Verify the id attribute
												node = elem.getAttributeNode("id")
												if (node && node.value === id) {
													return [elem]
												}

												// Fall back on getElementsByName
												elems = context.getElementsByName(id)
												i = 0
												while ((elem = elems[i++])) {
													node = elem.getAttributeNode("id")
													if (node && node.value === id) {
														return [elem]
													}
												}
											}

											return []
										}
									}
								}

								// Tag
								Expr.find["TAG"] = support.getElementsByTagName
									? function (tag, context) {
											if (typeof context.getElementsByTagName !== "undefined") {
												return context.getElementsByTagName(tag)

												// DocumentFragment nodes don't have gEBTN
											} else if (support.qsa) {
												return context.querySelectorAll(tag)
											}
									  }
									: function (tag, context) {
											var elem,
												tmp = [],
												i = 0,
												// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
												results = context.getElementsByTagName(tag)

											// Filter out possible comments
											if (tag === "*") {
												while ((elem = results[i++])) {
													if (elem.nodeType === 1) {
														tmp.push(elem)
													}
												}

												return tmp
											}
											return results
									  }

								// Class
								Expr.find["CLASS"] =
									support.getElementsByClassName &&
									function (className, context) {
										if (
											typeof context.getElementsByClassName !== "undefined" &&
											documentIsHTML
										) {
											return context.getElementsByClassName(className)
										}
									}

								/* QSA/matchesSelector
	---------------------------------------------------------------------- */

								// QSA and matchesSelector support

								// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
								rbuggyMatches = []

								// qSa(:focus) reports false when true (Chrome 21)
								// We allow this because of a bug in IE8/9 that throws an error
								// whenever `document.activeElement` is accessed on an iframe
								// So, we allow :focus to pass through QSA all the time to avoid the IE error
								// See https://bugs.jquery.com/ticket/13378
								rbuggyQSA = []

								if ((support.qsa = rnative.test(document.querySelectorAll))) {
									// Build QSA regex
									// Regex strategy adopted from Diego Perini
									assert(function (el) {
										var input

										// Select is set to empty string on purpose
										// This is to test IE's treatment of not explicitly
										// setting a boolean content attribute,
										// since its presence should be enough
										// https://bugs.jquery.com/ticket/12359
										docElem.appendChild(el).innerHTML =
											"<a id='" +
											expando +
											"'></a>" +
											"<select id='" +
											expando +
											"-\r\\' msallowcapture=''>" +
											"<option selected=''></option></select>"

										// Support: IE8, Opera 11-12.16
										// Nothing should be selected when empty strings follow ^= or $= or *=
										// The test attribute must be unknown in Opera but "safe" for WinRT
										// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
										if (el.querySelectorAll("[msallowcapture^='']").length) {
											rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")")
										}

										// Support: IE8
										// Boolean attributes and "value" are not treated correctly
										if (!el.querySelectorAll("[selected]").length) {
											rbuggyQSA.push(
												"\\[" + whitespace + "*(?:value|" + booleans + ")",
											)
										}

										// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
										if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
											rbuggyQSA.push("~=")
										}

										// Support: IE 11+, Edge 15 - 18+
										// IE 11/Edge don't find elements on a `[name='']` query in some cases.
										// Adding a temporary attribute to the document before the selection works
										// around the issue.
										// Interestingly, IE 10 & older don't seem to have the issue.
										input = document.createElement("input")
										input.setAttribute("name", "")
										el.appendChild(input)
										if (!el.querySelectorAll("[name='']").length) {
											rbuggyQSA.push(
												"\\[" +
													whitespace +
													"*name" +
													whitespace +
													"*=" +
													whitespace +
													"*(?:''|\"\")",
											)
										}

										// Webkit/Opera - :checked should return selected option elements
										// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
										// IE8 throws error here and will not see later tests
										if (!el.querySelectorAll(":checked").length) {
											rbuggyQSA.push(":checked")
										}

										// Support: Safari 8+, iOS 8+
										// https://bugs.webkit.org/show_bug.cgi?id=136851
										// In-page `selector#id sibling-combinator selector` fails
										if (!el.querySelectorAll("a#" + expando + "+*").length) {
											rbuggyQSA.push(".#.+[+~]")
										}

										// Support: Firefox <=3.6 - 5 only
										// Old Firefox doesn't throw on a badly-escaped identifier.
										el.querySelectorAll("\\\f")
										rbuggyQSA.push("[\\r\\n\\f]")
									})

									assert(function (el) {
										el.innerHTML =
											"<a href='' disabled='disabled'></a>" +
											"<select disabled='disabled'><option/></select>"

										// Support: Windows 8 Native Apps
										// The type and name attributes are restricted during .innerHTML assignment
										var input = document.createElement("input")
										input.setAttribute("type", "hidden")
										el.appendChild(input).setAttribute("name", "D")

										// Support: IE8
										// Enforce case-sensitivity of name attribute
										if (el.querySelectorAll("[name=d]").length) {
											rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=")
										}

										// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
										// IE8 throws error here and will not see later tests
										if (el.querySelectorAll(":enabled").length !== 2) {
											rbuggyQSA.push(":enabled", ":disabled")
										}

										// Support: IE9-11+
										// IE's :disabled selector does not pick up the children of disabled fieldsets
										docElem.appendChild(el).disabled = true
										if (el.querySelectorAll(":disabled").length !== 2) {
											rbuggyQSA.push(":enabled", ":disabled")
										}

										// Support: Opera 10 - 11 only
										// Opera 10-11 does not throw on post-comma invalid pseudos
										el.querySelectorAll("*,:x")
										rbuggyQSA.push(",.*:")
									})
								}

								if (
									(support.matchesSelector = rnative.test(
										(matches =
											docElem.matches ||
											docElem.webkitMatchesSelector ||
											docElem.mozMatchesSelector ||
											docElem.oMatchesSelector ||
											docElem.msMatchesSelector),
									))
								) {
									assert(function (el) {
										// Check to see if it's possible to do matchesSelector
										// on a disconnected node (IE 9)
										support.disconnectedMatch = matches.call(el, "*")

										// This should fail with an exception
										// Gecko does not error, returns false instead
										matches.call(el, "[s!='']:x")
										rbuggyMatches.push("!=", pseudos)
									})
								}

								rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"))
								rbuggyMatches =
									rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"))

								/* Contains
	---------------------------------------------------------------------- */
								hasCompare = rnative.test(docElem.compareDocumentPosition)

								// Element contains another
								// Purposefully self-exclusive
								// As in, an element does not contain itself
								contains =
									hasCompare || rnative.test(docElem.contains)
										? function (a, b) {
												var adown = a.nodeType === 9 ? a.documentElement : a,
													bup = b && b.parentNode
												return (
													a === bup ||
													!!(
														bup &&
														bup.nodeType === 1 &&
														(adown.contains
															? adown.contains(bup)
															: a.compareDocumentPosition &&
															  a.compareDocumentPosition(bup) & 16)
													)
												)
										  }
										: function (a, b) {
												if (b) {
													while ((b = b.parentNode)) {
														if (b === a) {
															return true
														}
													}
												}
												return false
										  }

								/* Sorting
	---------------------------------------------------------------------- */

								// Document order sorting
								sortOrder = hasCompare
									? function (a, b) {
											// Flag for duplicate removal
											if (a === b) {
												hasDuplicate = true
												return 0
											}

											// Sort on method existence if only one input has compareDocumentPosition
											var compare =
												!a.compareDocumentPosition - !b.compareDocumentPosition
											if (compare) {
												return compare
											}

											// Calculate position if both inputs belong to the same document
											// Support: IE 11+, Edge 17 - 18+
											// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
											// two documents; shallow comparisons work.
											// eslint-disable-next-line eqeqeq
											compare =
												(a.ownerDocument || a) == (b.ownerDocument || b)
													? a.compareDocumentPosition(b)
													: // Otherwise we know they are disconnected
													  1

											// Disconnected nodes
											if (
												compare & 1 ||
												(!support.sortDetached &&
													b.compareDocumentPosition(a) === compare)
											) {
												// Choose the first element that is related to our preferred document
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (
													a == document ||
													(a.ownerDocument == preferredDoc &&
														contains(preferredDoc, a))
												) {
													return -1
												}

												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (
													b == document ||
													(b.ownerDocument == preferredDoc &&
														contains(preferredDoc, b))
												) {
													return 1
												}

												// Maintain original order
												return sortInput
													? indexOf(sortInput, a) - indexOf(sortInput, b)
													: 0
											}

											return compare & 4 ? -1 : 1
									  }
									: function (a, b) {
											// Exit early if the nodes are identical
											if (a === b) {
												hasDuplicate = true
												return 0
											}

											var cur,
												i = 0,
												aup = a.parentNode,
												bup = b.parentNode,
												ap = [a],
												bp = [b]

											// Parentless nodes are either documents or disconnected
											if (!aup || !bup) {
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												/* eslint-disable eqeqeq */
												return a == document
													? -1
													: b == document
													? 1
													: /* eslint-enable eqeqeq */
													aup
													? -1
													: bup
													? 1
													: sortInput
													? indexOf(sortInput, a) - indexOf(sortInput, b)
													: 0

												// If the nodes are siblings, we can do a quick check
											} else if (aup === bup) {
												return siblingCheck(a, b)
											}

											// Otherwise we need full lists of their ancestors for comparison
											cur = a
											while ((cur = cur.parentNode)) {
												ap.unshift(cur)
											}
											cur = b
											while ((cur = cur.parentNode)) {
												bp.unshift(cur)
											}

											// Walk down the tree looking for a discrepancy
											while (ap[i] === bp[i]) {
												i++
											}

											return i
												? // Do a sibling check if the nodes have a common ancestor
												  siblingCheck(ap[i], bp[i])
												: // Otherwise nodes in our document sort first
												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												/* eslint-disable eqeqeq */
												ap[i] == preferredDoc
												? -1
												: bp[i] == preferredDoc
												? 1
												: /* eslint-enable eqeqeq */
												  0
									  }

								return document
							}

							Sizzle.matches = function (expr, elements) {
								return Sizzle(expr, null, null, elements)
							}

							Sizzle.matchesSelector = function (elem, expr) {
								setDocument(elem)

								if (
									support.matchesSelector &&
									documentIsHTML &&
									!nonnativeSelectorCache[expr + " "] &&
									(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
									(!rbuggyQSA || !rbuggyQSA.test(expr))
								) {
									try {
										var ret = matches.call(elem, expr)

										// IE 9's matchesSelector returns false on disconnected nodes
										if (
											ret ||
											support.disconnectedMatch ||
											// As well, disconnected nodes are said to be in a document
											// fragment in IE 9
											(elem.document && elem.document.nodeType !== 11)
										) {
											return ret
										}
									} catch (e) {
										nonnativeSelectorCache(expr, true)
									}
								}

								return Sizzle(expr, document, null, [elem]).length > 0
							}

							Sizzle.contains = function (context, elem) {
								// Set document vars if needed
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if ((context.ownerDocument || context) != document) {
									setDocument(context)
								}
								return contains(context, elem)
							}

							Sizzle.attr = function (elem, name) {
								// Set document vars if needed
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq
								if ((elem.ownerDocument || elem) != document) {
									setDocument(elem)
								}

								var fn = Expr.attrHandle[name.toLowerCase()],
									// Don't get fooled by Object.prototype properties (jQuery #13807)
									val =
										fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
											? fn(elem, name, !documentIsHTML)
											: undefined

								return val !== undefined
									? val
									: support.attributes || !documentIsHTML
									? elem.getAttribute(name)
									: (val = elem.getAttributeNode(name)) && val.specified
									? val.value
									: null
							}

							Sizzle.escape = function (sel) {
								return (sel + "").replace(rcssescape, fcssescape)
							}

							Sizzle.error = function (msg) {
								throw new Error("Syntax error, unrecognized expression: " + msg)
							}

							/**
							 * Document sorting and removing duplicates
							 * @param {ArrayLike} results
							 */
							Sizzle.uniqueSort = function (results) {
								var elem,
									duplicates = [],
									j = 0,
									i = 0

								// Unless we *know* we can detect duplicates, assume their presence
								hasDuplicate = !support.detectDuplicates
								sortInput = !support.sortStable && results.slice(0)
								results.sort(sortOrder)

								if (hasDuplicate) {
									while ((elem = results[i++])) {
										if (elem === results[i]) {
											j = duplicates.push(i)
										}
									}
									while (j--) {
										results.splice(duplicates[j], 1)
									}
								}

								// Clear input after sorting to release objects
								// See https://github.com/jquery/sizzle/pull/225
								sortInput = null

								return results
							}

							/**
							 * Utility function for retrieving the text value of an array of DOM nodes
							 * @param {Array|Element} elem
							 */
							getText = Sizzle.getText = function (elem) {
								var node,
									ret = "",
									i = 0,
									nodeType = elem.nodeType

								if (!nodeType) {
									// If no nodeType, this is expected to be an array
									while ((node = elem[i++])) {
										// Do not traverse comment nodes
										ret += getText(node)
									}
								} else if (
									nodeType === 1 ||
									nodeType === 9 ||
									nodeType === 11
								) {
									// Use textContent for elements
									// innerText usage removed for consistency of new lines (jQuery #11153)
									if (typeof elem.textContent === "string") {
										return elem.textContent
									} else {
										// Traverse its children
										for (
											elem = elem.firstChild;
											elem;
											elem = elem.nextSibling
										) {
											ret += getText(elem)
										}
									}
								} else if (nodeType === 3 || nodeType === 4) {
									return elem.nodeValue
								}

								// Do not include comment or processing instruction nodes

								return ret
							}

							Expr = Sizzle.selectors = {
								// Can be adjusted by the user
								cacheLength: 50,

								createPseudo: markFunction,

								match: matchExpr,

								attrHandle: {},

								find: {},

								relative: {
									">": { dir: "parentNode", first: true },
									" ": { dir: "parentNode" },
									"+": { dir: "previousSibling", first: true },
									"~": { dir: "previousSibling" },
								},

								preFilter: {
									ATTR: function (match) {
										match[1] = match[1].replace(runescape, funescape)

										// Move the given value to match[3] whether quoted or unquoted
										match[3] = (match[3] || match[4] || match[5] || "").replace(
											runescape,
											funescape,
										)

										if (match[2] === "~=") {
											match[3] = " " + match[3] + " "
										}

										return match.slice(0, 4)
									},

									CHILD: function (match) {
										/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
										match[1] = match[1].toLowerCase()

										if (match[1].slice(0, 3) === "nth") {
											// nth-* requires argument
											if (!match[3]) {
												Sizzle.error(match[0])
											}

											// numeric x and y parameters for Expr.filter.CHILD
											// remember that false/true cast respectively to 0/1
											match[4] = +(match[4]
												? match[5] + (match[6] || 1)
												: 2 * (match[3] === "even" || match[3] === "odd"))
											match[5] = +(match[7] + match[8] || match[3] === "odd")

											// other types prohibit arguments
										} else if (match[3]) {
											Sizzle.error(match[0])
										}

										return match
									},

									PSEUDO: function (match) {
										var excess,
											unquoted = !match[6] && match[2]

										if (matchExpr["CHILD"].test(match[0])) {
											return null
										}

										// Accept quoted arguments as-is
										if (match[3]) {
											match[2] = match[4] || match[5] || ""

											// Strip excess characters from unquoted arguments
										} else if (
											unquoted &&
											rpseudo.test(unquoted) &&
											// Get excess from tokenize (recursively)
											(excess = tokenize(unquoted, true)) &&
											// advance to the next closing parenthesis
											(excess =
												unquoted.indexOf(")", unquoted.length - excess) -
												unquoted.length)
										) {
											// excess is a negative index
											match[0] = match[0].slice(0, excess)
											match[2] = unquoted.slice(0, excess)
										}

										// Return only captures needed by the pseudo filter method (type and argument)
										return match.slice(0, 3)
									},
								},

								filter: {
									TAG: function (nodeNameSelector) {
										var nodeName = nodeNameSelector
											.replace(runescape, funescape)
											.toLowerCase()
										return nodeNameSelector === "*"
											? function () {
													return true
											  }
											: function (elem) {
													return (
														elem.nodeName &&
														elem.nodeName.toLowerCase() === nodeName
													)
											  }
									},

									CLASS: function (className) {
										var pattern = classCache[className + " "]

										return (
											pattern ||
											((pattern = new RegExp(
												"(^|" +
													whitespace +
													")" +
													className +
													"(" +
													whitespace +
													"|$)",
											)) &&
												classCache(className, function (elem) {
													return pattern.test(
														(typeof elem.className === "string" &&
															elem.className) ||
															(typeof elem.getAttribute !== "undefined" &&
																elem.getAttribute("class")) ||
															"",
													)
												}))
										)
									},

									ATTR: function (name, operator, check) {
										return function (elem) {
											var result = Sizzle.attr(elem, name)

											if (result == null) {
												return operator === "!="
											}
											if (!operator) {
												return true
											}

											result += ""

											/* eslint-disable max-len */

											return operator === "="
												? result === check
												: operator === "!="
												? result !== check
												: operator === "^="
												? check && result.indexOf(check) === 0
												: operator === "*="
												? check && result.indexOf(check) > -1
												: operator === "$="
												? check && result.slice(-check.length) === check
												: operator === "~="
												? (
														" " +
														result.replace(rwhitespace, " ") +
														" "
												  ).indexOf(check) > -1
												: operator === "|="
												? result === check ||
												  result.slice(0, check.length + 1) === check + "-"
												: false
											/* eslint-enable max-len */
										}
									},

									CHILD: function (type, what, _argument, first, last) {
										var simple = type.slice(0, 3) !== "nth",
											forward = type.slice(-4) !== "last",
											ofType = what === "of-type"

										return first === 1 && last === 0
											? // Shortcut for :nth-*(n)
											  function (elem) {
													return !!elem.parentNode
											  }
											: function (elem, _context, xml) {
													var cache,
														uniqueCache,
														outerCache,
														node,
														nodeIndex,
														start,
														dir =
															simple !== forward
																? "nextSibling"
																: "previousSibling",
														parent = elem.parentNode,
														name = ofType && elem.nodeName.toLowerCase(),
														useCache = !xml && !ofType,
														diff = false

													if (parent) {
														// :(first|last|only)-(child|of-type)
														if (simple) {
															while (dir) {
																node = elem
																while ((node = node[dir])) {
																	if (
																		ofType
																			? node.nodeName.toLowerCase() === name
																			: node.nodeType === 1
																	) {
																		return false
																	}
																}

																// Reverse direction for :only-* (if we haven't yet done so)
																start = dir =
																	type === "only" && !start && "nextSibling"
															}
															return true
														}

														start = [
															forward ? parent.firstChild : parent.lastChild,
														]

														// non-xml :nth-child(...) stores cache data on `parent`
														if (forward && useCache) {
															// Seek `elem` from a previously-cached index

															// ...in a gzip-friendly way
															node = parent
															outerCache = node[expando] || (node[expando] = {})

															// Support: IE <9 only
															// Defend against cloned attroperties (jQuery gh-1709)
															uniqueCache =
																outerCache[node.uniqueID] ||
																(outerCache[node.uniqueID] = {})

															cache = uniqueCache[type] || []
															nodeIndex = cache[0] === dirruns && cache[1]
															diff = nodeIndex && cache[2]
															node = nodeIndex && parent.childNodes[nodeIndex]

															while (
																(node =
																	(++nodeIndex && node && node[dir]) ||
																	// Fallback to seeking `elem` from the start
																	(diff = nodeIndex = 0) ||
																	start.pop())
															) {
																// When found, cache indexes on `parent` and break
																if (
																	node.nodeType === 1 &&
																	++diff &&
																	node === elem
																) {
																	uniqueCache[type] = [dirruns, nodeIndex, diff]
																	break
																}
															}
														} else {
															// Use previously-cached element index if available
															if (useCache) {
																// ...in a gzip-friendly way
																node = elem
																outerCache =
																	node[expando] || (node[expando] = {})

																// Support: IE <9 only
																// Defend against cloned attroperties (jQuery gh-1709)
																uniqueCache =
																	outerCache[node.uniqueID] ||
																	(outerCache[node.uniqueID] = {})

																cache = uniqueCache[type] || []
																nodeIndex = cache[0] === dirruns && cache[1]
																diff = nodeIndex
															}

															// xml :nth-child(...)
															// or :nth-last-child(...) or :nth(-last)?-of-type(...)
															if (diff === false) {
																// Use the same loop as above to seek `elem` from the start
																while (
																	(node =
																		(++nodeIndex && node && node[dir]) ||
																		(diff = nodeIndex = 0) ||
																		start.pop())
																) {
																	if (
																		(ofType
																			? node.nodeName.toLowerCase() === name
																			: node.nodeType === 1) &&
																		++diff
																	) {
																		// Cache the index of each encountered element
																		if (useCache) {
																			outerCache =
																				node[expando] || (node[expando] = {})

																			// Support: IE <9 only
																			// Defend against cloned attroperties (jQuery gh-1709)
																			uniqueCache =
																				outerCache[node.uniqueID] ||
																				(outerCache[node.uniqueID] = {})

																			uniqueCache[type] = [dirruns, diff]
																		}

																		if (node === elem) {
																			break
																		}
																	}
																}
															}
														}

														// Incorporate the offset, then check against cycle size
														diff -= last
														return (
															diff === first ||
															(diff % first === 0 && diff / first >= 0)
														)
													}
											  }
									},

									PSEUDO: function (pseudo, argument) {
										// pseudo-class names are case-insensitive
										// http://www.w3.org/TR/selectors/#pseudo-classes
										// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
										// Remember that setFilters inherits from pseudos
										var args,
											fn =
												Expr.pseudos[pseudo] ||
												Expr.setFilters[pseudo.toLowerCase()] ||
												Sizzle.error("unsupported pseudo: " + pseudo)

										// The user may use createPseudo to indicate that
										// arguments are needed to create the filter function
										// just as Sizzle does
										if (fn[expando]) {
											return fn(argument)
										}

										// But maintain support for old signatures
										if (fn.length > 1) {
											args = [pseudo, pseudo, "", argument]
											return Expr.setFilters.hasOwnProperty(
												pseudo.toLowerCase(),
											)
												? markFunction(function (seed, matches) {
														var idx,
															matched = fn(seed, argument),
															i = matched.length
														while (i--) {
															idx = indexOf(seed, matched[i])
															seed[idx] = !(matches[idx] = matched[i])
														}
												  })
												: function (elem) {
														return fn(elem, 0, args)
												  }
										}

										return fn
									},
								},

								pseudos: {
									// Potentially complex pseudos
									not: markFunction(function (selector) {
										// Trim the selector passed to compile
										// to avoid treating leading and trailing
										// spaces as combinators
										var input = [],
											results = [],
											matcher = compile(selector.replace(rtrim, "$1"))

										return matcher[expando]
											? markFunction(function (seed, matches, _context, xml) {
													var elem,
														unmatched = matcher(seed, null, xml, []),
														i = seed.length

													// Match elements unmatched by `matcher`
													while (i--) {
														if ((elem = unmatched[i])) {
															seed[i] = !(matches[i] = elem)
														}
													}
											  })
											: function (elem, _context, xml) {
													input[0] = elem
													matcher(input, null, xml, results)

													// Don't keep the element (issue #299)
													input[0] = null
													return !results.pop()
											  }
									}),

									has: markFunction(function (selector) {
										return function (elem) {
											return Sizzle(selector, elem).length > 0
										}
									}),

									contains: markFunction(function (text) {
										text = text.replace(runescape, funescape)
										return function (elem) {
											return (
												(elem.textContent || getText(elem)).indexOf(text) > -1
											)
										}
									}),

									// "Whether an element is represented by a :lang() selector
									// is based solely on the element's language value
									// being equal to the identifier C,
									// or beginning with the identifier C immediately followed by "-".
									// The matching of C against the element's language value is performed case-insensitively.
									// The identifier C does not have to be a valid language name."
									// http://www.w3.org/TR/selectors/#lang-pseudo
									lang: markFunction(function (lang) {
										// lang value must be a valid identifier
										if (!ridentifier.test(lang || "")) {
											Sizzle.error("unsupported lang: " + lang)
										}
										lang = lang.replace(runescape, funescape).toLowerCase()
										return function (elem) {
											var elemLang
											do {
												if (
													(elemLang = documentIsHTML
														? elem.lang
														: elem.getAttribute("xml:lang") ||
														  elem.getAttribute("lang"))
												) {
													elemLang = elemLang.toLowerCase()
													return (
														elemLang === lang ||
														elemLang.indexOf(lang + "-") === 0
													)
												}
											} while ((elem = elem.parentNode) && elem.nodeType === 1)
											return false
										}
									}),

									// Miscellaneous
									target: function (elem) {
										var hash = window.location && window.location.hash
										return hash && hash.slice(1) === elem.id
									},

									root: function (elem) {
										return elem === docElem
									},

									focus: function (elem) {
										return (
											elem === document.activeElement &&
											(!document.hasFocus || document.hasFocus()) &&
											!!(elem.type || elem.href || ~elem.tabIndex)
										)
									},

									// Boolean properties
									enabled: createDisabledPseudo(false),
									disabled: createDisabledPseudo(true),

									checked: function (elem) {
										// In CSS3, :checked should return both checked and selected elements
										// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
										var nodeName = elem.nodeName.toLowerCase()
										return (
											(nodeName === "input" && !!elem.checked) ||
											(nodeName === "option" && !!elem.selected)
										)
									},

									selected: function (elem) {
										// Accessing this property makes selected-by-default
										// options in Safari work properly
										if (elem.parentNode) {
											// eslint-disable-next-line no-unused-expressions
											elem.parentNode.selectedIndex
										}

										return elem.selected === true
									},

									// Contents
									empty: function (elem) {
										// http://www.w3.org/TR/selectors/#empty-pseudo
										// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
										//   but not by others (comment: 8; processing instruction: 7; etc.)
										// nodeType < 6 works because attributes (2) do not appear as children
										for (
											elem = elem.firstChild;
											elem;
											elem = elem.nextSibling
										) {
											if (elem.nodeType < 6) {
												return false
											}
										}
										return true
									},

									parent: function (elem) {
										return !Expr.pseudos["empty"](elem)
									},

									// Element/input types
									header: function (elem) {
										return rheader.test(elem.nodeName)
									},

									input: function (elem) {
										return rinputs.test(elem.nodeName)
									},

									button: function (elem) {
										var name = elem.nodeName.toLowerCase()
										return (
											(name === "input" && elem.type === "button") ||
											name === "button"
										)
									},

									text: function (elem) {
										var attr
										return (
											elem.nodeName.toLowerCase() === "input" &&
											elem.type === "text" &&
											// Support: IE<8
											// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
											((attr = elem.getAttribute("type")) == null ||
												attr.toLowerCase() === "text")
										)
									},

									// Position-in-collection
									first: createPositionalPseudo(function () {
										return [0]
									}),

									last: createPositionalPseudo(function (
										_matchIndexes,
										length,
									) {
										return [length - 1]
									}),

									eq: createPositionalPseudo(function (
										_matchIndexes,
										length,
										argument,
									) {
										return [argument < 0 ? argument + length : argument]
									}),

									even: createPositionalPseudo(function (matchIndexes, length) {
										var i = 0
										for (; i < length; i += 2) {
											matchIndexes.push(i)
										}
										return matchIndexes
									}),

									odd: createPositionalPseudo(function (matchIndexes, length) {
										var i = 1
										for (; i < length; i += 2) {
											matchIndexes.push(i)
										}
										return matchIndexes
									}),

									lt: createPositionalPseudo(function (
										matchIndexes,
										length,
										argument,
									) {
										var i =
											argument < 0
												? argument + length
												: argument > length
												? length
												: argument
										for (; --i >= 0; ) {
											matchIndexes.push(i)
										}
										return matchIndexes
									}),

									gt: createPositionalPseudo(function (
										matchIndexes,
										length,
										argument,
									) {
										var i = argument < 0 ? argument + length : argument
										for (; ++i < length; ) {
											matchIndexes.push(i)
										}
										return matchIndexes
									}),
								},
							}

							Expr.pseudos["nth"] = Expr.pseudos["eq"]

							// Add button/input type pseudos
							for (i in {
								radio: true,
								checkbox: true,
								file: true,
								password: true,
								image: true,
							}) {
								Expr.pseudos[i] = createInputPseudo(i)
							}
							for (i in { submit: true, reset: true }) {
								Expr.pseudos[i] = createButtonPseudo(i)
							}

							// Easy API for creating new setFilters
							function setFilters() {}
							setFilters.prototype = Expr.filters = Expr.pseudos
							Expr.setFilters = new setFilters()

							tokenize = Sizzle.tokenize = function (selector, parseOnly) {
								var matched,
									match,
									tokens,
									type,
									soFar,
									groups,
									preFilters,
									cached = tokenCache[selector + " "]

								if (cached) {
									return parseOnly ? 0 : cached.slice(0)
								}

								soFar = selector
								groups = []
								preFilters = Expr.preFilter

								while (soFar) {
									// Comma and first run
									if (!matched || (match = rcomma.exec(soFar))) {
										if (match) {
											// Don't consume trailing commas as valid
											soFar = soFar.slice(match[0].length) || soFar
										}
										groups.push((tokens = []))
									}

									matched = false

									// Combinators
									if ((match = rcombinators.exec(soFar))) {
										matched = match.shift()
										tokens.push({
											value: matched,

											// Cast descendant combinators to space
											type: match[0].replace(rtrim, " "),
										})
										soFar = soFar.slice(matched.length)
									}

									// Filters
									for (type in Expr.filter) {
										if (
											(match = matchExpr[type].exec(soFar)) &&
											(!preFilters[type] || (match = preFilters[type](match)))
										) {
											matched = match.shift()
											tokens.push({
												value: matched,
												type: type,
												matches: match,
											})
											soFar = soFar.slice(matched.length)
										}
									}

									if (!matched) {
										break
									}
								}

								// Return the length of the invalid excess
								// if we're just parsing
								// Otherwise, throw an error or return tokens
								return parseOnly
									? soFar.length
									: soFar
									? Sizzle.error(selector)
									: // Cache the tokens
									  tokenCache(selector, groups).slice(0)
							}

							function toSelector(tokens) {
								var i = 0,
									len = tokens.length,
									selector = ""
								for (; i < len; i++) {
									selector += tokens[i].value
								}
								return selector
							}

							function addCombinator(matcher, combinator, base) {
								var dir = combinator.dir,
									skip = combinator.next,
									key = skip || dir,
									checkNonElements = base && key === "parentNode",
									doneName = done++

								return combinator.first
									? // Check against closest ancestor/preceding element
									  function (elem, context, xml) {
											while ((elem = elem[dir])) {
												if (elem.nodeType === 1 || checkNonElements) {
													return matcher(elem, context, xml)
												}
											}
											return false
									  }
									: // Check against all ancestor/preceding elements
									  function (elem, context, xml) {
											var oldCache,
												uniqueCache,
												outerCache,
												newCache = [dirruns, doneName]

											// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
											if (xml) {
												while ((elem = elem[dir])) {
													if (elem.nodeType === 1 || checkNonElements) {
														if (matcher(elem, context, xml)) {
															return true
														}
													}
												}
											} else {
												while ((elem = elem[dir])) {
													if (elem.nodeType === 1 || checkNonElements) {
														outerCache = elem[expando] || (elem[expando] = {})

														// Support: IE <9 only
														// Defend against cloned attroperties (jQuery gh-1709)
														uniqueCache =
															outerCache[elem.uniqueID] ||
															(outerCache[elem.uniqueID] = {})

														if (skip && skip === elem.nodeName.toLowerCase()) {
															elem = elem[dir] || elem
														} else if (
															(oldCache = uniqueCache[key]) &&
															oldCache[0] === dirruns &&
															oldCache[1] === doneName
														) {
															// Assign to newCache so results back-propagate to previous elements
															return (newCache[2] = oldCache[2])
														} else {
															// Reuse newcache so results back-propagate to previous elements
															uniqueCache[key] = newCache

															// A match means we're done; a fail means we have to keep checking
															if ((newCache[2] = matcher(elem, context, xml))) {
																return true
															}
														}
													}
												}
											}
											return false
									  }
							}

							function elementMatcher(matchers) {
								return matchers.length > 1
									? function (elem, context, xml) {
											var i = matchers.length
											while (i--) {
												if (!matchers[i](elem, context, xml)) {
													return false
												}
											}
											return true
									  }
									: matchers[0]
							}

							function multipleContexts(selector, contexts, results) {
								var i = 0,
									len = contexts.length
								for (; i < len; i++) {
									Sizzle(selector, contexts[i], results)
								}
								return results
							}

							function condense(unmatched, map, filter, context, xml) {
								var elem,
									newUnmatched = [],
									i = 0,
									len = unmatched.length,
									mapped = map != null

								for (; i < len; i++) {
									if ((elem = unmatched[i])) {
										if (!filter || filter(elem, context, xml)) {
											newUnmatched.push(elem)
											if (mapped) {
												map.push(i)
											}
										}
									}
								}

								return newUnmatched
							}

							function setMatcher(
								preFilter,
								selector,
								matcher,
								postFilter,
								postFinder,
								postSelector,
							) {
								if (postFilter && !postFilter[expando]) {
									postFilter = setMatcher(postFilter)
								}
								if (postFinder && !postFinder[expando]) {
									postFinder = setMatcher(postFinder, postSelector)
								}
								return markFunction(function (seed, results, context, xml) {
									var temp,
										i,
										elem,
										preMap = [],
										postMap = [],
										preexisting = results.length,
										// Get initial elements from seed or context
										elems =
											seed ||
											multipleContexts(
												selector || "*",
												context.nodeType ? [context] : context,
												[],
											),
										// Prefilter to get matcher input, preserving a map for seed-results synchronization
										matcherIn =
											preFilter && (seed || !selector)
												? condense(elems, preMap, preFilter, context, xml)
												: elems,
										matcherOut = matcher
											? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
											  postFinder ||
											  (seed ? preFilter : preexisting || postFilter)
												? // ...intermediate processing is necessary
												  []
												: // ...otherwise use results directly
												  results
											: matcherIn

									// Find primary matches
									if (matcher) {
										matcher(matcherIn, matcherOut, context, xml)
									}

									// Apply postFilter
									if (postFilter) {
										temp = condense(matcherOut, postMap)
										postFilter(temp, [], context, xml)

										// Un-match failing elements by moving them back to matcherIn
										i = temp.length
										while (i--) {
											if ((elem = temp[i])) {
												matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)
											}
										}
									}

									if (seed) {
										if (postFinder || preFilter) {
											if (postFinder) {
												// Get the final matcherOut by condensing this intermediate into postFinder contexts
												temp = []
												i = matcherOut.length
												while (i--) {
													if ((elem = matcherOut[i])) {
														// Restore matcherIn since elem is not yet a final match
														temp.push((matcherIn[i] = elem))
													}
												}
												postFinder(null, (matcherOut = []), temp, xml)
											}

											// Move matched elements from seed to results to keep them synchronized
											i = matcherOut.length
											while (i--) {
												if (
													(elem = matcherOut[i]) &&
													(temp = postFinder
														? indexOf(seed, elem)
														: preMap[i]) > -1
												) {
													seed[temp] = !(results[temp] = elem)
												}
											}
										}

										// Add elements to results, through postFinder if defined
									} else {
										matcherOut = condense(
											matcherOut === results
												? matcherOut.splice(preexisting, matcherOut.length)
												: matcherOut,
										)
										if (postFinder) {
											postFinder(null, results, matcherOut, xml)
										} else {
											push.apply(results, matcherOut)
										}
									}
								})
							}

							function matcherFromTokens(tokens) {
								var checkContext,
									matcher,
									j,
									len = tokens.length,
									leadingRelative = Expr.relative[tokens[0].type],
									implicitRelative = leadingRelative || Expr.relative[" "],
									i = leadingRelative ? 1 : 0,
									// The foundational matcher ensures that elements are reachable from top-level context(s)
									matchContext = addCombinator(
										function (elem) {
											return elem === checkContext
										},
										implicitRelative,
										true,
									),
									matchAnyContext = addCombinator(
										function (elem) {
											return indexOf(checkContext, elem) > -1
										},
										implicitRelative,
										true,
									),
									matchers = [
										function (elem, context, xml) {
											var ret =
												(!leadingRelative &&
													(xml || context !== outermostContext)) ||
												((checkContext = context).nodeType
													? matchContext(elem, context, xml)
													: matchAnyContext(elem, context, xml))

											// Avoid hanging onto element (issue #299)
											checkContext = null
											return ret
										},
									]

								for (; i < len; i++) {
									if ((matcher = Expr.relative[tokens[i].type])) {
										matchers = [
											addCombinator(elementMatcher(matchers), matcher),
										]
									} else {
										matcher = Expr.filter[tokens[i].type].apply(
											null,
											tokens[i].matches,
										)

										// Return special upon seeing a positional matcher
										if (matcher[expando]) {
											// Find the next relative operator (if any) for proper handling
											j = ++i
											for (; j < len; j++) {
												if (Expr.relative[tokens[j].type]) {
													break
												}
											}
											return setMatcher(
												i > 1 && elementMatcher(matchers),
												i > 1 &&
													toSelector(
														// If the preceding token was a descendant combinator, insert an implicit any-element `*`
														tokens
															.slice(0, i - 1)
															.concat({
																value: tokens[i - 2].type === " " ? "*" : "",
															}),
													).replace(rtrim, "$1"),
												matcher,
												i < j && matcherFromTokens(tokens.slice(i, j)),
												j < len &&
													matcherFromTokens((tokens = tokens.slice(j))),
												j < len && toSelector(tokens),
											)
										}
										matchers.push(matcher)
									}
								}

								return elementMatcher(matchers)
							}

							function matcherFromGroupMatchers(elementMatchers, setMatchers) {
								var bySet = setMatchers.length > 0,
									byElement = elementMatchers.length > 0,
									superMatcher = function (
										seed,
										context,
										xml,
										results,
										outermost,
									) {
										var elem,
											j,
											matcher,
											matchedCount = 0,
											i = "0",
											unmatched = seed && [],
											setMatched = [],
											contextBackup = outermostContext,
											// We must always have either seed elements or outermost context
											elems =
												seed || (byElement && Expr.find["TAG"]("*", outermost)),
											// Use integer dirruns iff this is the outermost matcher
											dirrunsUnique = (dirruns +=
												contextBackup == null ? 1 : Math.random() || 0.1),
											len = elems.length

										if (outermost) {
											// Support: IE 11+, Edge 17 - 18+
											// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
											// two documents; shallow comparisons work.
											// eslint-disable-next-line eqeqeq
											outermostContext =
												context == document || context || outermost
										}

										// Add elements passing elementMatchers directly to results
										// Support: IE<9, Safari
										// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
										for (; i !== len && (elem = elems[i]) != null; i++) {
											if (byElement && elem) {
												j = 0

												// Support: IE 11+, Edge 17 - 18+
												// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
												// two documents; shallow comparisons work.
												// eslint-disable-next-line eqeqeq
												if (!context && elem.ownerDocument != document) {
													setDocument(elem)
													xml = !documentIsHTML
												}
												while ((matcher = elementMatchers[j++])) {
													if (matcher(elem, context || document, xml)) {
														results.push(elem)
														break
													}
												}
												if (outermost) {
													dirruns = dirrunsUnique
												}
											}

											// Track unmatched elements for set filters
											if (bySet) {
												// They will have gone through all possible matchers
												if ((elem = !matcher && elem)) {
													matchedCount--
												}

												// Lengthen the array for every element, matched or not
												if (seed) {
													unmatched.push(elem)
												}
											}
										}

										// `i` is now the count of elements visited above, and adding it to `matchedCount`
										// makes the latter nonnegative.
										matchedCount += i

										// Apply set filters to unmatched elements
										// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
										// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
										// no element matchers and no seed.
										// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
										// case, which will result in a "00" `matchedCount` that differs from `i` but is also
										// numerically zero.
										if (bySet && i !== matchedCount) {
											j = 0
											while ((matcher = setMatchers[j++])) {
												matcher(unmatched, setMatched, context, xml)
											}

											if (seed) {
												// Reintegrate element matches to eliminate the need for sorting
												if (matchedCount > 0) {
													while (i--) {
														if (!(unmatched[i] || setMatched[i])) {
															setMatched[i] = pop.call(results)
														}
													}
												}

												// Discard index placeholder values to get only actual matches
												setMatched = condense(setMatched)
											}

											// Add matches to results
											push.apply(results, setMatched)

											// Seedless set matches succeeding multiple successful matchers stipulate sorting
											if (
												outermost &&
												!seed &&
												setMatched.length > 0 &&
												matchedCount + setMatchers.length > 1
											) {
												Sizzle.uniqueSort(results)
											}
										}

										// Override manipulation of globals by nested matchers
										if (outermost) {
											dirruns = dirrunsUnique
											outermostContext = contextBackup
										}

										return unmatched
									}

								return bySet ? markFunction(superMatcher) : superMatcher
							}

							compile = Sizzle.compile = function (
								selector,
								match /* Internal Use Only */,
							) {
								var i,
									setMatchers = [],
									elementMatchers = [],
									cached = compilerCache[selector + " "]

								if (!cached) {
									// Generate a function of recursive functions that can be used to check each element
									if (!match) {
										match = tokenize(selector)
									}
									i = match.length
									while (i--) {
										cached = matcherFromTokens(match[i])
										if (cached[expando]) {
											setMatchers.push(cached)
										} else {
											elementMatchers.push(cached)
										}
									}

									// Cache the compiled function
									cached = compilerCache(
										selector,
										matcherFromGroupMatchers(elementMatchers, setMatchers),
									)

									// Save selector and tokenization
									cached.selector = selector
								}
								return cached
							}

							/**
							 * A low-level selection function that works with Sizzle's compiled
							 *  selector functions
							 * @param {String|Function} selector A selector or a pre-compiled
							 *  selector function built with Sizzle.compile
							 * @param {Element} context
							 * @param {Array} [results]
							 * @param {Array} [seed] A set of elements to match against
							 */
							select = Sizzle.select = function (
								selector,
								context,
								results,
								seed,
							) {
								var i,
									tokens,
									token,
									type,
									find,
									compiled = typeof selector === "function" && selector,
									match =
										!seed &&
										tokenize((selector = compiled.selector || selector))

								results = results || []

								// Try to minimize operations if there is only one selector in the list and no seed
								// (the latter of which guarantees us context)
								if (match.length === 1) {
									// Reduce context if the leading compound selector is an ID
									tokens = match[0] = match[0].slice(0)
									if (
										tokens.length > 2 &&
										(token = tokens[0]).type === "ID" &&
										context.nodeType === 9 &&
										documentIsHTML &&
										Expr.relative[tokens[1].type]
									) {
										context = (Expr.find["ID"](
											token.matches[0].replace(runescape, funescape),
											context,
										) || [])[0]
										if (!context) {
											return results

											// Precompiled matchers will still verify ancestry, so step up a level
										} else if (compiled) {
											context = context.parentNode
										}

										selector = selector.slice(tokens.shift().value.length)
									}

									// Fetch a seed set for right-to-left matching
									i = matchExpr["needsContext"].test(selector)
										? 0
										: tokens.length
									while (i--) {
										token = tokens[i]

										// Abort if we hit a combinator
										if (Expr.relative[(type = token.type)]) {
											break
										}
										if ((find = Expr.find[type])) {
											// Search, expanding context for leading sibling combinators
											if (
												(seed = find(
													token.matches[0].replace(runescape, funescape),
													(rsibling.test(tokens[0].type) &&
														testContext(context.parentNode)) ||
														context,
												))
											) {
												// If seed is empty or no tokens remain, we can return early
												tokens.splice(i, 1)
												selector = seed.length && toSelector(tokens)
												if (!selector) {
													push.apply(results, seed)
													return results
												}

												break
											}
										}
									}
								}

								// Compile and execute a filtering function if one is not provided
								// Provide `match` to avoid retokenization if we modified the selector above
								;(compiled || compile(selector, match))(
									seed,
									context,
									!documentIsHTML,
									results,
									!context ||
										(rsibling.test(selector) &&
											testContext(context.parentNode)) ||
										context,
								)
								return results
							}

							// One-time assignments

							// Sort stability
							support.sortStable =
								expando.split("").sort(sortOrder).join("") === expando

							// Support: Chrome 14-35+
							// Always assume duplicates if they aren't passed to the comparison function
							support.detectDuplicates = !!hasDuplicate

							// Initialize against the default document
							setDocument()

							// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
							// Detached nodes confoundingly follow *each other*
							support.sortDetached = assert(function (el) {
								// Should return 1, but returns 4 (following)
								return (
									el.compareDocumentPosition(
										document.createElement("fieldset"),
									) & 1
								)
							})

							// Support: IE<8
							// Prevent attribute/property "interpolation"
							// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
							if (
								!assert(function (el) {
									el.innerHTML = "<a href='#'></a>"
									return el.firstChild.getAttribute("href") === "#"
								})
							) {
								addHandle("type|href|height|width", function (
									elem,
									name,
									isXML,
								) {
									if (!isXML) {
										return elem.getAttribute(
											name,
											name.toLowerCase() === "type" ? 1 : 2,
										)
									}
								})
							}

							// Support: IE<9
							// Use defaultValue in place of getAttribute("value")
							if (
								!support.attributes ||
								!assert(function (el) {
									el.innerHTML = "<input/>"
									el.firstChild.setAttribute("value", "")
									return el.firstChild.getAttribute("value") === ""
								})
							) {
								addHandle("value", function (elem, _name, isXML) {
									if (!isXML && elem.nodeName.toLowerCase() === "input") {
										return elem.defaultValue
									}
								})
							}

							// Support: IE<9
							// Use getAttributeNode to fetch booleans when getAttribute lies
							if (
								!assert(function (el) {
									return el.getAttribute("disabled") == null
								})
							) {
								addHandle(booleans, function (elem, name, isXML) {
									var val
									if (!isXML) {
										return elem[name] === true
											? name.toLowerCase()
											: (val = elem.getAttributeNode(name)) && val.specified
											? val.value
											: null
									}
								})
							}

							return Sizzle
						})(window)

					jQuery.find = Sizzle
					jQuery.expr = Sizzle.selectors

					// Deprecated
					jQuery.expr[":"] = jQuery.expr.pseudos
					jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort
					jQuery.text = Sizzle.getText
					jQuery.isXMLDoc = Sizzle.isXML
					jQuery.contains = Sizzle.contains
					jQuery.escapeSelector = Sizzle.escape

					var dir = function (elem, dir, until) {
						var matched = [],
							truncate = until !== undefined

						while ((elem = elem[dir]) && elem.nodeType !== 9) {
							if (elem.nodeType === 1) {
								if (truncate && jQuery(elem).is(until)) {
									break
								}
								matched.push(elem)
							}
						}
						return matched
					}

					var siblings = function (n, elem) {
						var matched = []

						for (; n; n = n.nextSibling) {
							if (n.nodeType === 1 && n !== elem) {
								matched.push(n)
							}
						}

						return matched
					}

					var rneedsContext = jQuery.expr.match.needsContext

					function nodeName(elem, name) {
						return (
							elem.nodeName &&
							elem.nodeName.toLowerCase() === name.toLowerCase()
						)
					}
					var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i

					// Implement the identical functionality for filter and not
					function winnow(elements, qualifier, not) {
						if (isFunction(qualifier)) {
							return jQuery.grep(elements, function (elem, i) {
								return !!qualifier.call(elem, i, elem) !== not
							})
						}

						// Single element
						if (qualifier.nodeType) {
							return jQuery.grep(elements, function (elem) {
								return (elem === qualifier) !== not
							})
						}

						// Arraylike of elements (jQuery, arguments, Array)
						if (typeof qualifier !== "string") {
							return jQuery.grep(elements, function (elem) {
								return indexOf.call(qualifier, elem) > -1 !== not
							})
						}

						// Filtered directly for both simple and complex selectors
						return jQuery.filter(qualifier, elements, not)
					}

					jQuery.filter = function (expr, elems, not) {
						var elem = elems[0]

						if (not) {
							expr = ":not(" + expr + ")"
						}

						if (elems.length === 1 && elem.nodeType === 1) {
							return jQuery.find.matchesSelector(elem, expr) ? [elem] : []
						}

						return jQuery.find.matches(
							expr,
							jQuery.grep(elems, function (elem) {
								return elem.nodeType === 1
							}),
						)
					}

					jQuery.fn.extend({
						find: function (selector) {
							var i,
								ret,
								len = this.length,
								self = this

							if (typeof selector !== "string") {
								return this.pushStack(
									jQuery(selector).filter(function () {
										for (i = 0; i < len; i++) {
											if (jQuery.contains(self[i], this)) {
												return true
											}
										}
									}),
								)
							}

							ret = this.pushStack([])

							for (i = 0; i < len; i++) {
								jQuery.find(selector, self[i], ret)
							}

							return len > 1 ? jQuery.uniqueSort(ret) : ret
						},
						filter: function (selector) {
							return this.pushStack(winnow(this, selector || [], false))
						},
						not: function (selector) {
							return this.pushStack(winnow(this, selector || [], true))
						},
						is: function (selector) {
							return !!winnow(
								this,

								// If this is a positional/relative selector, check membership in the returned set
								// so $("p:first").is("p:last") won't return true for a doc with two "p".
								typeof selector === "string" && rneedsContext.test(selector)
									? jQuery(selector)
									: selector || [],
								false,
							).length
						},
					})

					// Initialize a jQuery object

					// A central reference to the root jQuery(document)
					var rootjQuery,
						// A simple way to check for HTML strings
						// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
						// Strict HTML recognition (#11290: must start with <)
						// Shortcut simple #id case for speed
						rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
						init = (jQuery.fn.init = function (selector, context, root) {
							var match, elem

							// HANDLE: $(""), $(null), $(undefined), $(false)
							if (!selector) {
								return this
							}

							// Method init() accepts an alternate rootjQuery
							// so migrate can support jQuery.sub (gh-2101)
							root = root || rootjQuery

							// Handle HTML strings
							if (typeof selector === "string") {
								if (
									selector[0] === "<" &&
									selector[selector.length - 1] === ">" &&
									selector.length >= 3
								) {
									// Assume that strings that start and end with <> are HTML and skip the regex check
									match = [null, selector, null]
								} else {
									match = rquickExpr.exec(selector)
								}

								// Match html or make sure no context is specified for #id
								if (match && (match[1] || !context)) {
									// HANDLE: $(html) -> $(array)
									if (match[1]) {
										context = context instanceof jQuery ? context[0] : context

										// Option to run scripts is true for back-compat
										// Intentionally let the error be thrown if parseHTML is not present
										jQuery.merge(
											this,
											jQuery.parseHTML(
												match[1],
												context && context.nodeType
													? context.ownerDocument || context
													: document,
												true,
											),
										)

										// HANDLE: $(html, props)
										if (
											rsingleTag.test(match[1]) &&
											jQuery.isPlainObject(context)
										) {
											for (match in context) {
												// Properties of context are called as methods if possible
												if (isFunction(this[match])) {
													this[match](context[match])

													// ...and otherwise set as attributes
												} else {
													this.attr(match, context[match])
												}
											}
										}

										return this

										// HANDLE: $(#id)
									} else {
										elem = document.getElementById(match[2])

										if (elem) {
											// Inject the element directly into the jQuery object
											this[0] = elem
											this.length = 1
										}
										return this
									}

									// HANDLE: $(expr, $(...))
								} else if (!context || context.jquery) {
									return (context || root).find(selector)

									// HANDLE: $(expr, context)
									// (which is just equivalent to: $(context).find(expr)
								} else {
									return this.constructor(context).find(selector)
								}

								// HANDLE: $(DOMElement)
							} else if (selector.nodeType) {
								this[0] = selector
								this.length = 1
								return this

								// HANDLE: $(function)
								// Shortcut for document ready
							} else if (isFunction(selector)) {
								return root.ready !== undefined
									? root.ready(selector)
									: // Execute immediately if ready is not present
									  selector(jQuery)
							}

							return jQuery.makeArray(selector, this)
						})

					// Give the init function the jQuery prototype for later instantiation
					init.prototype = jQuery.fn

					// Initialize central reference
					rootjQuery = jQuery(document)

					var rparentsprev = /^(?:parents|prev(?:Until|All))/,
						// Methods guaranteed to produce a unique set when starting from a unique set
						guaranteedUnique = {
							children: true,
							contents: true,
							next: true,
							prev: true,
						}

					jQuery.fn.extend({
						has: function (target) {
							var targets = jQuery(target, this),
								l = targets.length

							return this.filter(function () {
								var i = 0
								for (; i < l; i++) {
									if (jQuery.contains(this, targets[i])) {
										return true
									}
								}
							})
						},

						closest: function (selectors, context) {
							var cur,
								i = 0,
								l = this.length,
								matched = [],
								targets = typeof selectors !== "string" && jQuery(selectors)

							// Positional selectors never match, since there's no _selection_ context
							if (!rneedsContext.test(selectors)) {
								for (; i < l; i++) {
									for (
										cur = this[i];
										cur && cur !== context;
										cur = cur.parentNode
									) {
										// Always skip document fragments
										if (
											cur.nodeType < 11 &&
											(targets
												? targets.index(cur) > -1
												: // Don't pass non-elements to Sizzle
												  cur.nodeType === 1 &&
												  jQuery.find.matchesSelector(cur, selectors))
										) {
											matched.push(cur)
											break
										}
									}
								}
							}

							return this.pushStack(
								matched.length > 1 ? jQuery.uniqueSort(matched) : matched,
							)
						},

						// Determine the position of an element within the set
						index: function (elem) {
							// No argument, return index in parent
							if (!elem) {
								return this[0] && this[0].parentNode
									? this.first().prevAll().length
									: -1
							}

							// Index in selector
							if (typeof elem === "string") {
								return indexOf.call(jQuery(elem), this[0])
							}

							// Locate the position of the desired element
							return indexOf.call(
								this,

								// If it receives a jQuery object, the first element is used
								elem.jquery ? elem[0] : elem,
							)
						},

						add: function (selector, context) {
							return this.pushStack(
								jQuery.uniqueSort(
									jQuery.merge(this.get(), jQuery(selector, context)),
								),
							)
						},

						addBack: function (selector) {
							return this.add(
								selector == null
									? this.prevObject
									: this.prevObject.filter(selector),
							)
						},
					})

					function sibling(cur, dir) {
						while ((cur = cur[dir]) && cur.nodeType !== 1) {}
						return cur
					}

					jQuery.each(
						{
							parent: function (elem) {
								var parent = elem.parentNode
								return parent && parent.nodeType !== 11 ? parent : null
							},
							parents: function (elem) {
								return dir(elem, "parentNode")
							},
							parentsUntil: function (elem, _i, until) {
								return dir(elem, "parentNode", until)
							},
							next: function (elem) {
								return sibling(elem, "nextSibling")
							},
							prev: function (elem) {
								return sibling(elem, "previousSibling")
							},
							nextAll: function (elem) {
								return dir(elem, "nextSibling")
							},
							prevAll: function (elem) {
								return dir(elem, "previousSibling")
							},
							nextUntil: function (elem, _i, until) {
								return dir(elem, "nextSibling", until)
							},
							prevUntil: function (elem, _i, until) {
								return dir(elem, "previousSibling", until)
							},
							siblings: function (elem) {
								return siblings((elem.parentNode || {}).firstChild, elem)
							},
							children: function (elem) {
								return siblings(elem.firstChild)
							},
							contents: function (elem) {
								if (
									elem.contentDocument != null &&
									// Support: IE 11+
									// <object> elements with no `data` attribute has an object
									// `contentDocument` with a `null` prototype.
									getProto(elem.contentDocument)
								) {
									return elem.contentDocument
								}

								// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
								// Treat the template element as a regular one in browsers that
								// don't support it.
								if (nodeName(elem, "template")) {
									elem = elem.content || elem
								}

								return jQuery.merge([], elem.childNodes)
							},
						},
						function (name, fn) {
							jQuery.fn[name] = function (until, selector) {
								var matched = jQuery.map(this, fn, until)

								if (name.slice(-5) !== "Until") {
									selector = until
								}

								if (selector && typeof selector === "string") {
									matched = jQuery.filter(selector, matched)
								}

								if (this.length > 1) {
									// Remove duplicates
									if (!guaranteedUnique[name]) {
										jQuery.uniqueSort(matched)
									}

									// Reverse order for parents* and prev-derivatives
									if (rparentsprev.test(name)) {
										matched.reverse()
									}
								}

								return this.pushStack(matched)
							}
						},
					)
					var rnothtmlwhite = /[^\x20\t\r\n\f]+/g

					// Convert String-formatted options into Object-formatted ones
					function createOptions(options) {
						var object = {}
						jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
							object[flag] = true
						})
						return object
					}

					/*
					 * Create a callback list using the following parameters:
					 *
					 *	options: an optional list of space-separated options that will change how
					 *			the callback list behaves or a more traditional option object
					 *
					 * By default a callback list will act like an event callback list and can be
					 * "fired" multiple times.
					 *
					 * Possible options:
					 *
					 *	once:			will ensure the callback list can only be fired once (like a Deferred)
					 *
					 *	memory:			will keep track of previous values and will call any callback added
					 *					after the list has been fired right away with the latest "memorized"
					 *					values (like a Deferred)
					 *
					 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
					 *
					 *	stopOnFalse:	interrupt callings when a callback returns false
					 *
					 */
					jQuery.Callbacks = function (options) {
						// Convert options from String-formatted to Object-formatted if needed
						// (we check in cache first)
						options =
							typeof options === "string"
								? createOptions(options)
								: jQuery.extend({}, options)

						var // Flag to know if list is currently firing
							firing,
							// Last fire value for non-forgettable lists
							memory,
							// Flag to know if list was already fired
							fired,
							// Flag to prevent firing
							locked,
							// Actual callback list
							list = [],
							// Queue of execution data for repeatable lists
							queue = [],
							// Index of currently firing callback (modified by add/remove as needed)
							firingIndex = -1,
							// Fire callbacks
							fire = function () {
								// Enforce single-firing
								locked = locked || options.once

								// Execute callbacks for all pending executions,
								// respecting firingIndex overrides and runtime changes
								fired = firing = true
								for (; queue.length; firingIndex = -1) {
									memory = queue.shift()
									while (++firingIndex < list.length) {
										// Run callback and check for early termination
										if (
											list[firingIndex].apply(memory[0], memory[1]) === false &&
											options.stopOnFalse
										) {
											// Jump to end and forget the data so .add doesn't re-fire
											firingIndex = list.length
											memory = false
										}
									}
								}

								// Forget the data if we're done with it
								if (!options.memory) {
									memory = false
								}

								firing = false

								// Clean up if we're done firing for good
								if (locked) {
									// Keep an empty list if we have data for future add calls
									if (memory) {
										list = []

										// Otherwise, this object is spent
									} else {
										list = ""
									}
								}
							},
							// Actual Callbacks object
							self = {
								// Add a callback or a collection of callbacks to the list
								add: function () {
									if (list) {
										// If we have memory from a past run, we should fire after adding
										if (memory && !firing) {
											firingIndex = list.length - 1
											queue.push(memory)
										}

										;(function add(args) {
											jQuery.each(args, function (_, arg) {
												if (isFunction(arg)) {
													if (!options.unique || !self.has(arg)) {
														list.push(arg)
													}
												} else if (
													arg &&
													arg.length &&
													toType(arg) !== "string"
												) {
													// Inspect recursively
													add(arg)
												}
											})
										})(arguments)

										if (memory && !firing) {
											fire()
										}
									}
									return this
								},

								// Remove a callback from the list
								remove: function () {
									jQuery.each(arguments, function (_, arg) {
										var index
										while ((index = jQuery.inArray(arg, list, index)) > -1) {
											list.splice(index, 1)

											// Handle firing indexes
											if (index <= firingIndex) {
												firingIndex--
											}
										}
									})
									return this
								},

								// Check if a given callback is in the list.
								// If no argument is given, return whether or not list has callbacks attached.
								has: function (fn) {
									return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
								},

								// Remove all callbacks from the list
								empty: function () {
									if (list) {
										list = []
									}
									return this
								},

								// Disable .fire and .add
								// Abort any current/pending executions
								// Clear all callbacks and values
								disable: function () {
									locked = queue = []
									list = memory = ""
									return this
								},
								disabled: function () {
									return !list
								},

								// Disable .fire
								// Also disable .add unless we have memory (since it would have no effect)
								// Abort any pending executions
								lock: function () {
									locked = queue = []
									if (!memory && !firing) {
										list = memory = ""
									}
									return this
								},
								locked: function () {
									return !!locked
								},

								// Call all callbacks with the given context and arguments
								fireWith: function (context, args) {
									if (!locked) {
										args = args || []
										args = [context, args.slice ? args.slice() : args]
										queue.push(args)
										if (!firing) {
											fire()
										}
									}
									return this
								},

								// Call all the callbacks with the given arguments
								fire: function () {
									self.fireWith(this, arguments)
									return this
								},

								// To know if the callbacks have already been called at least once
								fired: function () {
									return !!fired
								},
							}

						return self
					}

					function Identity(v) {
						return v
					}
					function Thrower(ex) {
						throw ex
					}

					function adoptValue(value, resolve, reject, noValue) {
						var method

						try {
							// Check for promise aspect first to privilege synchronous behavior
							if (value && isFunction((method = value.promise))) {
								method.call(value).done(resolve).fail(reject)

								// Other thenables
							} else if (value && isFunction((method = value.then))) {
								method.call(value, resolve, reject)

								// Other non-thenables
							} else {
								// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
								// * false: [ value ].slice( 0 ) => resolve( value )
								// * true: [ value ].slice( 1 ) => resolve()
								resolve.apply(undefined, [value].slice(noValue))
							}

							// For Promises/A+, convert exceptions into rejections
							// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
							// Deferred#then to conditionally suppress rejection.
						} catch (value) {
							// Support: Android 4.0 only
							// Strict mode functions invoked without .call/.apply get global-object context
							reject.apply(undefined, [value])
						}
					}

					jQuery.extend({
						Deferred: function (func) {
							var tuples = [
									// action, add listener, callbacks,
									// ... .then handlers, argument index, [final state]
									[
										"notify",
										"progress",
										jQuery.Callbacks("memory"),
										jQuery.Callbacks("memory"),
										2,
									],
									[
										"resolve",
										"done",
										jQuery.Callbacks("once memory"),
										jQuery.Callbacks("once memory"),
										0,
										"resolved",
									],
									[
										"reject",
										"fail",
										jQuery.Callbacks("once memory"),
										jQuery.Callbacks("once memory"),
										1,
										"rejected",
									],
								],
								state = "pending",
								promise = {
									state: function () {
										return state
									},
									always: function () {
										deferred.done(arguments).fail(arguments)
										return this
									},
									catch: function (fn) {
										return promise.then(null, fn)
									},

									// Keep pipe for back-compat
									pipe: function (/* fnDone, fnFail, fnProgress */) {
										var fns = arguments

										return jQuery
											.Deferred(function (newDefer) {
												jQuery.each(tuples, function (_i, tuple) {
													// Map tuples (progress, done, fail) to arguments (done, fail, progress)
													var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]

													// deferred.progress(function() { bind to newDefer or newDefer.notify })
													// deferred.done(function() { bind to newDefer or newDefer.resolve })
													// deferred.fail(function() { bind to newDefer or newDefer.reject })
													deferred[tuple[1]](function () {
														var returned = fn && fn.apply(this, arguments)
														if (returned && isFunction(returned.promise)) {
															returned
																.promise()
																.progress(newDefer.notify)
																.done(newDefer.resolve)
																.fail(newDefer.reject)
														} else {
															newDefer[tuple[0] + "With"](
																this,
																fn ? [returned] : arguments,
															)
														}
													})
												})
												fns = null
											})
											.promise()
									},
									then: function (onFulfilled, onRejected, onProgress) {
										var maxDepth = 0
										function resolve(depth, deferred, handler, special) {
											return function () {
												var that = this,
													args = arguments,
													mightThrow = function () {
														var returned, then

														// Support: Promises/A+ section 2.3.3.3.3
														// https://promisesaplus.com/#point-59
														// Ignore double-resolution attempts
														if (depth < maxDepth) {
															return
														}

														returned = handler.apply(that, args)

														// Support: Promises/A+ section 2.3.1
														// https://promisesaplus.com/#point-48
														if (returned === deferred.promise()) {
															throw new TypeError("Thenable self-resolution")
														}

														// Support: Promises/A+ sections 2.3.3.1, 3.5
														// https://promisesaplus.com/#point-54
														// https://promisesaplus.com/#point-75
														// Retrieve `then` only once
														then =
															returned &&
															// Support: Promises/A+ section 2.3.4
															// https://promisesaplus.com/#point-64
															// Only check objects and functions for thenability
															(typeof returned === "object" ||
																typeof returned === "function") &&
															returned.then

														// Handle a returned thenable
														if (isFunction(then)) {
															// Special processors (notify) just wait for resolution
															if (special) {
																then.call(
																	returned,
																	resolve(
																		maxDepth,
																		deferred,
																		Identity,
																		special,
																	),
																	resolve(maxDepth, deferred, Thrower, special),
																)

																// Normal processors (resolve) also hook into progress
															} else {
																// ...and disregard older resolution values
																maxDepth++

																then.call(
																	returned,
																	resolve(
																		maxDepth,
																		deferred,
																		Identity,
																		special,
																	),
																	resolve(maxDepth, deferred, Thrower, special),
																	resolve(
																		maxDepth,
																		deferred,
																		Identity,
																		deferred.notifyWith,
																	),
																)
															}

															// Handle all other returned values
														} else {
															// Only substitute handlers pass on context
															// and multiple values (non-spec behavior)
															if (handler !== Identity) {
																that = undefined
																args = [returned]
															}

															// Process the value(s)
															// Default process is resolve
															;(special || deferred.resolveWith)(that, args)
														}
													},
													// Only normal processors (resolve) catch and reject exceptions
													process = special
														? mightThrow
														: function () {
																try {
																	mightThrow()
																} catch (e) {
																	if (jQuery.Deferred.exceptionHook) {
																		jQuery.Deferred.exceptionHook(
																			e,
																			process.stackTrace,
																		)
																	}

																	// Support: Promises/A+ section 2.3.3.3.4.1
																	// https://promisesaplus.com/#point-61
																	// Ignore post-resolution exceptions
																	if (depth + 1 >= maxDepth) {
																		// Only substitute handlers pass on context
																		// and multiple values (non-spec behavior)
																		if (handler !== Thrower) {
																			that = undefined
																			args = [e]
																		}

																		deferred.rejectWith(that, args)
																	}
																}
														  }

												// Support: Promises/A+ section 2.3.3.3.1
												// https://promisesaplus.com/#point-57
												// Re-resolve promises immediately to dodge false rejection from
												// subsequent errors
												if (depth) {
													process()
												} else {
													// Call an optional hook to record the stack, in case of exception
													// since it's otherwise lost when execution goes async
													if (jQuery.Deferred.getStackHook) {
														process.stackTrace = jQuery.Deferred.getStackHook()
													}
													window.setTimeout(process)
												}
											}
										}

										return jQuery
											.Deferred(function (newDefer) {
												// progress_handlers.add( ... )
												tuples[0][3].add(
													resolve(
														0,
														newDefer,
														isFunction(onProgress) ? onProgress : Identity,
														newDefer.notifyWith,
													),
												)

												// fulfilled_handlers.add( ... )
												tuples[1][3].add(
													resolve(
														0,
														newDefer,
														isFunction(onFulfilled) ? onFulfilled : Identity,
													),
												)

												// rejected_handlers.add( ... )
												tuples[2][3].add(
													resolve(
														0,
														newDefer,
														isFunction(onRejected) ? onRejected : Thrower,
													),
												)
											})
											.promise()
									},

									// Get a promise for this deferred
									// If obj is provided, the promise aspect is added to the object
									promise: function (obj) {
										return obj != null ? jQuery.extend(obj, promise) : promise
									},
								},
								deferred = {}

							// Add list-specific methods
							jQuery.each(tuples, function (i, tuple) {
								var list = tuple[2],
									stateString = tuple[5]

								// promise.progress = list.add
								// promise.done = list.add
								// promise.fail = list.add
								promise[tuple[1]] = list.add

								// Handle state
								if (stateString) {
									list.add(
										function () {
											// state = "resolved" (i.e., fulfilled)
											// state = "rejected"
											state = stateString
										},

										// rejected_callbacks.disable
										// fulfilled_callbacks.disable
										tuples[3 - i][2].disable,

										// rejected_handlers.disable
										// fulfilled_handlers.disable
										tuples[3 - i][3].disable,

										// progress_callbacks.lock
										tuples[0][2].lock,

										// progress_handlers.lock
										tuples[0][3].lock,
									)
								}

								// progress_handlers.fire
								// fulfilled_handlers.fire
								// rejected_handlers.fire
								list.add(tuple[3].fire)

								// deferred.notify = function() { deferred.notifyWith(...) }
								// deferred.resolve = function() { deferred.resolveWith(...) }
								// deferred.reject = function() { deferred.rejectWith(...) }
								deferred[tuple[0]] = function () {
									deferred[tuple[0] + "With"](
										this === deferred ? undefined : this,
										arguments,
									)
									return this
								}

								// deferred.notifyWith = list.fireWith
								// deferred.resolveWith = list.fireWith
								// deferred.rejectWith = list.fireWith
								deferred[tuple[0] + "With"] = list.fireWith
							})

							// Make the deferred a promise
							promise.promise(deferred)

							// Call given func if any
							if (func) {
								func.call(deferred, deferred)
							}

							// All done!
							return deferred
						},

						// Deferred helper
						when: function (singleValue) {
							var // count of uncompleted subordinates
								remaining = arguments.length,
								// count of unprocessed arguments
								i = remaining,
								// subordinate fulfillment data
								resolveContexts = Array(i),
								resolveValues = slice.call(arguments),
								// the master Deferred
								master = jQuery.Deferred(),
								// subordinate callback factory
								updateFunc = function (i) {
									return function (value) {
										resolveContexts[i] = this
										resolveValues[i] =
											arguments.length > 1 ? slice.call(arguments) : value
										if (!--remaining) {
											master.resolveWith(resolveContexts, resolveValues)
										}
									}
								}

							// Single- and empty arguments are adopted like Promise.resolve
							if (remaining <= 1) {
								adoptValue(
									singleValue,
									master.done(updateFunc(i)).resolve,
									master.reject,
									!remaining,
								)

								// Use .then() to unwrap secondary thenables (cf. gh-3000)
								if (
									master.state() === "pending" ||
									isFunction(resolveValues[i] && resolveValues[i].then)
								) {
									return master.then()
								}
							}

							// Multiple arguments are aggregated like Promise.all array elements
							while (i--) {
								adoptValue(resolveValues[i], updateFunc(i), master.reject)
							}

							return master.promise()
						},
					})

					// These usually indicate a programmer mistake during development,
					// warn about them ASAP rather than swallowing them by default.
					var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/

					jQuery.Deferred.exceptionHook = function (error, stack) {
						// Support: IE 8 - 9 only
						// Console exists when dev tools are open, which can happen at any time
						if (
							window.console &&
							window.console.warn &&
							error &&
							rerrorNames.test(error.name)
						) {
							window.console.warn(
								"jQuery.Deferred exception: " + error.message,
								error.stack,
								stack,
							)
						}
					}

					jQuery.readyException = function (error) {
						window.setTimeout(function () {
							throw error
						})
					}

					// The deferred used on DOM ready
					var readyList = jQuery.Deferred()

					jQuery.fn.ready = function (fn) {
						readyList
							.then(fn)

							// Wrap jQuery.readyException in a function so that the lookup
							// happens at the time of error handling instead of callback
							// registration.
							.catch(function (error) {
								jQuery.readyException(error)
							})

						return this
					}

					jQuery.extend({
						// Is the DOM ready to be used? Set to true once it occurs.
						isReady: false,

						// A counter to track how many items to wait for before
						// the ready event fires. See #6781
						readyWait: 1,

						// Handle when the DOM is ready
						ready: function (wait) {
							// Abort if there are pending holds or we're already ready
							if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
								return
							}

							// Remember that the DOM is ready
							jQuery.isReady = true

							// If a normal DOM Ready event fired, decrement, and wait if need be
							if (wait !== true && --jQuery.readyWait > 0) {
								return
							}

							// If there are functions bound, to execute
							readyList.resolveWith(document, [jQuery])
						},
					})

					jQuery.ready.then = readyList.then

					// The ready event handler and self cleanup method
					function completed() {
						document.removeEventListener("DOMContentLoaded", completed)
						window.removeEventListener("load", completed)
						jQuery.ready()
					}

					// Catch cases where $(document).ready() is called
					// after the browser event has already occurred.
					// Support: IE <=9 - 10 only
					// Older IE sometimes signals "interactive" too soon
					if (
						document.readyState === "complete" ||
						(document.readyState !== "loading" &&
							!document.documentElement.doScroll)
					) {
						// Handle it asynchronously to allow scripts the opportunity to delay ready
						window.setTimeout(jQuery.ready)
					} else {
						// Use the handy event callback
						document.addEventListener("DOMContentLoaded", completed)

						// A fallback to window.onload, that will always work
						window.addEventListener("load", completed)
					}

					// Multifunctional method to get and set values of a collection
					// The value/s can optionally be executed if it's a function
					var access = function (
						elems,
						fn,
						key,
						value,
						chainable,
						emptyGet,
						raw,
					) {
						var i = 0,
							len = elems.length,
							bulk = key == null

						// Sets many values
						if (toType(key) === "object") {
							chainable = true
							for (i in key) {
								access(elems, fn, i, key[i], true, emptyGet, raw)
							}

							// Sets one value
						} else if (value !== undefined) {
							chainable = true

							if (!isFunction(value)) {
								raw = true
							}

							if (bulk) {
								// Bulk operations run against the entire set
								if (raw) {
									fn.call(elems, value)
									fn = null

									// ...except when executing function values
								} else {
									bulk = fn
									fn = function (elem, _key, value) {
										return bulk.call(jQuery(elem), value)
									}
								}
							}

							if (fn) {
								for (; i < len; i++) {
									fn(
										elems[i],
										key,
										raw ? value : value.call(elems[i], i, fn(elems[i], key)),
									)
								}
							}
						}

						if (chainable) {
							return elems
						}

						// Gets
						if (bulk) {
							return fn.call(elems)
						}

						return len ? fn(elems[0], key) : emptyGet
					}

					// Matches dashed string for camelizing
					var rmsPrefix = /^-ms-/,
						rdashAlpha = /-([a-z])/g

					// Used by camelCase as callback to replace()
					function fcamelCase(_all, letter) {
						return letter.toUpperCase()
					}

					// Convert dashed to camelCase; used by the css and data modules
					// Support: IE <=9 - 11, Edge 12 - 15
					// Microsoft forgot to hump their vendor prefix (#9572)
					function camelCase(string) {
						return string
							.replace(rmsPrefix, "ms-")
							.replace(rdashAlpha, fcamelCase)
					}
					var acceptData = function (owner) {
						// Accepts only:
						//  - Node
						//    - Node.ELEMENT_NODE
						//    - Node.DOCUMENT_NODE
						//  - Object
						//    - Any
						return (
							owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType
						)
					}

					function Data() {
						this.expando = jQuery.expando + Data.uid++
					}

					Data.uid = 1

					Data.prototype = {
						cache: function (owner) {
							// Check if the owner object already has a cache
							var value = owner[this.expando]

							// If not, create one
							if (!value) {
								value = {}

								// We can accept data for non-element nodes in modern browsers,
								// but we should not, see #8335.
								// Always return an empty object.
								if (acceptData(owner)) {
									// If it is a node unlikely to be stringify-ed or looped over
									// use plain assignment
									if (owner.nodeType) {
										owner[this.expando] = value

										// Otherwise secure it in a non-enumerable property
										// configurable must be true to allow the property to be
										// deleted when data is removed
									} else {
										Object.defineProperty(owner, this.expando, {
											value: value,
											configurable: true,
										})
									}
								}
							}

							return value
						},
						set: function (owner, data, value) {
							var prop,
								cache = this.cache(owner)

							// Handle: [ owner, key, value ] args
							// Always use camelCase key (gh-2257)
							if (typeof data === "string") {
								cache[camelCase(data)] = value

								// Handle: [ owner, { properties } ] args
							} else {
								// Copy the properties one-by-one to the cache object
								for (prop in data) {
									cache[camelCase(prop)] = data[prop]
								}
							}
							return cache
						},
						get: function (owner, key) {
							return key === undefined
								? this.cache(owner)
								: // Always use camelCase key (gh-2257)
								  owner[this.expando] && owner[this.expando][camelCase(key)]
						},
						access: function (owner, key, value) {
							// In cases where either:
							//
							//   1. No key was specified
							//   2. A string key was specified, but no value provided
							//
							// Take the "read" path and allow the get method to determine
							// which value to return, respectively either:
							//
							//   1. The entire cache object
							//   2. The data stored at the key
							//
							if (
								key === undefined ||
								(key && typeof key === "string" && value === undefined)
							) {
								return this.get(owner, key)
							}

							// When the key is not a string, or both a key and value
							// are specified, set or extend (existing objects) with either:
							//
							//   1. An object of properties
							//   2. A key and value
							//
							this.set(owner, key, value)

							// Since the "set" path can have two possible entry points
							// return the expected data based on which path was taken[*]
							return value !== undefined ? value : key
						},
						remove: function (owner, key) {
							var i,
								cache = owner[this.expando]

							if (cache === undefined) {
								return
							}

							if (key !== undefined) {
								// Support array or space separated string of keys
								if (Array.isArray(key)) {
									// If key is an array of keys...
									// We always set camelCase keys, so remove that.
									key = key.map(camelCase)
								} else {
									key = camelCase(key)

									// If a key with the spaces exists, use it.
									// Otherwise, create an array by matching non-whitespace
									key = key in cache ? [key] : key.match(rnothtmlwhite) || []
								}

								i = key.length

								while (i--) {
									delete cache[key[i]]
								}
							}

							// Remove the expando if there's no more data
							if (key === undefined || jQuery.isEmptyObject(cache)) {
								// Support: Chrome <=35 - 45
								// Webkit & Blink performance suffers when deleting properties
								// from DOM nodes, so set to undefined instead
								// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
								if (owner.nodeType) {
									owner[this.expando] = undefined
								} else {
									delete owner[this.expando]
								}
							}
						},
						hasData: function (owner) {
							var cache = owner[this.expando]
							return cache !== undefined && !jQuery.isEmptyObject(cache)
						},
					}
					var dataPriv = new Data()

					var dataUser = new Data()

					//	Implementation Summary
					//
					//	1. Enforce API surface and semantic compatibility with 1.9.x branch
					//	2. Improve the module's maintainability by reducing the storage
					//		paths to a single mechanism.
					//	3. Use the same single mechanism to support "private" and "user" data.
					//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
					//	5. Avoid exposing implementation details on user objects (eg. expando properties)
					//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

					var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
						rmultiDash = /[A-Z]/g

					function getData(data) {
						if (data === "true") {
							return true
						}

						if (data === "false") {
							return false
						}

						if (data === "null") {
							return null
						}

						// Only convert to a number if it doesn't change the string
						if (data === +data + "") {
							return +data
						}

						if (rbrace.test(data)) {
							return JSON.parse(data)
						}

						return data
					}

					function dataAttr(elem, key, data) {
						var name

						// If nothing was found internally, try to fetch any
						// data from the HTML5 data-* attribute
						if (data === undefined && elem.nodeType === 1) {
							name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase()
							data = elem.getAttribute(name)

							if (typeof data === "string") {
								try {
									data = getData(data)
								} catch (e) {}

								// Make sure we set the data so it isn't changed later
								dataUser.set(elem, key, data)
							} else {
								data = undefined
							}
						}
						return data
					}

					jQuery.extend({
						hasData: function (elem) {
							return dataUser.hasData(elem) || dataPriv.hasData(elem)
						},

						data: function (elem, name, data) {
							return dataUser.access(elem, name, data)
						},

						removeData: function (elem, name) {
							dataUser.remove(elem, name)
						},

						// TODO: Now that all calls to _data and _removeData have been replaced
						// with direct calls to dataPriv methods, these can be deprecated.
						_data: function (elem, name, data) {
							return dataPriv.access(elem, name, data)
						},

						_removeData: function (elem, name) {
							dataPriv.remove(elem, name)
						},
					})

					jQuery.fn.extend({
						data: function (key, value) {
							var i,
								name,
								data,
								elem = this[0],
								attrs = elem && elem.attributes

							// Gets all values
							if (key === undefined) {
								if (this.length) {
									data = dataUser.get(elem)

									if (
										elem.nodeType === 1 &&
										!dataPriv.get(elem, "hasDataAttrs")
									) {
										i = attrs.length
										while (i--) {
											// Support: IE 11 only
											// The attrs elements can be null (#14894)
											if (attrs[i]) {
												name = attrs[i].name
												if (name.indexOf("data-") === 0) {
													name = camelCase(name.slice(5))
													dataAttr(elem, name, data[name])
												}
											}
										}
										dataPriv.set(elem, "hasDataAttrs", true)
									}
								}

								return data
							}

							// Sets multiple values
							if (typeof key === "object") {
								return this.each(function () {
									dataUser.set(this, key)
								})
							}

							return access(
								this,
								function (value) {
									var data

									// The calling jQuery object (element matches) is not empty
									// (and therefore has an element appears at this[ 0 ]) and the
									// `value` parameter was not undefined. An empty jQuery object
									// will result in `undefined` for elem = this[ 0 ] which will
									// throw an exception if an attempt to read a data cache is made.
									if (elem && value === undefined) {
										// Attempt to get data from the cache
										// The key will always be camelCased in Data
										data = dataUser.get(elem, key)
										if (data !== undefined) {
											return data
										}

										// Attempt to "discover" the data in
										// HTML5 custom data-* attrs
										data = dataAttr(elem, key)
										if (data !== undefined) {
											return data
										}

										// We tried really hard, but the data doesn't exist.
										return
									}

									// Set the data...
									this.each(function () {
										// We always store the camelCased key
										dataUser.set(this, key, value)
									})
								},
								null,
								value,
								arguments.length > 1,
								null,
								true,
							)
						},

						removeData: function (key) {
							return this.each(function () {
								dataUser.remove(this, key)
							})
						},
					})

					jQuery.extend({
						queue: function (elem, type, data) {
							var queue

							if (elem) {
								type = (type || "fx") + "queue"
								queue = dataPriv.get(elem, type)

								// Speed up dequeue by getting out quickly if this is just a lookup
								if (data) {
									if (!queue || Array.isArray(data)) {
										queue = dataPriv.access(elem, type, jQuery.makeArray(data))
									} else {
										queue.push(data)
									}
								}
								return queue || []
							}
						},

						dequeue: function (elem, type) {
							type = type || "fx"

							var queue = jQuery.queue(elem, type),
								startLength = queue.length,
								fn = queue.shift(),
								hooks = jQuery._queueHooks(elem, type),
								next = function () {
									jQuery.dequeue(elem, type)
								}

							// If the fx queue is dequeued, always remove the progress sentinel
							if (fn === "inprogress") {
								fn = queue.shift()
								startLength--
							}

							if (fn) {
								// Add a progress sentinel to prevent the fx queue from being
								// automatically dequeued
								if (type === "fx") {
									queue.unshift("inprogress")
								}

								// Clear up the last queue stop function
								delete hooks.stop
								fn.call(elem, next, hooks)
							}

							if (!startLength && hooks) {
								hooks.empty.fire()
							}
						},

						// Not public - generate a queueHooks object, or return the current one
						_queueHooks: function (elem, type) {
							var key = type + "queueHooks"
							return (
								dataPriv.get(elem, key) ||
								dataPriv.access(elem, key, {
									empty: jQuery.Callbacks("once memory").add(function () {
										dataPriv.remove(elem, [type + "queue", key])
									}),
								})
							)
						},
					})

					jQuery.fn.extend({
						queue: function (type, data) {
							var setter = 2

							if (typeof type !== "string") {
								data = type
								type = "fx"
								setter--
							}

							if (arguments.length < setter) {
								return jQuery.queue(this[0], type)
							}

							return data === undefined
								? this
								: this.each(function () {
										var queue = jQuery.queue(this, type, data)

										// Ensure a hooks for this queue
										jQuery._queueHooks(this, type)

										if (type === "fx" && queue[0] !== "inprogress") {
											jQuery.dequeue(this, type)
										}
								  })
						},
						dequeue: function (type) {
							return this.each(function () {
								jQuery.dequeue(this, type)
							})
						},
						clearQueue: function (type) {
							return this.queue(type || "fx", [])
						},

						// Get a promise resolved when queues of a certain type
						// are emptied (fx is the type by default)
						promise: function (type, obj) {
							var tmp,
								count = 1,
								defer = jQuery.Deferred(),
								elements = this,
								i = this.length,
								resolve = function () {
									if (!--count) {
										defer.resolveWith(elements, [elements])
									}
								}

							if (typeof type !== "string") {
								obj = type
								type = undefined
							}
							type = type || "fx"

							while (i--) {
								tmp = dataPriv.get(elements[i], type + "queueHooks")
								if (tmp && tmp.empty) {
									count++
									tmp.empty.add(resolve)
								}
							}
							resolve()
							return defer.promise(obj)
						},
					})
					var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source

					var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i")

					var cssExpand = ["Top", "Right", "Bottom", "Left"]

					var documentElement = document.documentElement

					var isAttached = function (elem) {
							return jQuery.contains(elem.ownerDocument, elem)
						},
						composed = { composed: true }

					// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
					// Check attachment across shadow DOM boundaries when possible (gh-3504)
					// Support: iOS 10.0-10.2 only
					// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
					// leading to errors. We need to check for `getRootNode`.
					if (documentElement.getRootNode) {
						isAttached = function (elem) {
							return (
								jQuery.contains(elem.ownerDocument, elem) ||
								elem.getRootNode(composed) === elem.ownerDocument
							)
						}
					}
					var isHiddenWithinTree = function (elem, el) {
						// isHiddenWithinTree might be called from jQuery#filter function;
						// in that case, element will be second argument
						elem = el || elem

						// Inline style trumps all
						return (
							elem.style.display === "none" ||
							(elem.style.display === "" &&
								// Otherwise, check computed style
								// Support: Firefox <=43 - 45
								// Disconnected elements can have computed display: none, so first confirm that elem is
								// in the document.
								isAttached(elem) &&
								jQuery.css(elem, "display") === "none")
						)
					}

					function adjustCSS(elem, prop, valueParts, tween) {
						var adjusted,
							scale,
							maxIterations = 20,
							currentValue = tween
								? function () {
										return tween.cur()
								  }
								: function () {
										return jQuery.css(elem, prop, "")
								  },
							initial = currentValue(),
							unit =
								(valueParts && valueParts[3]) ||
								(jQuery.cssNumber[prop] ? "" : "px"),
							// Starting value computation is required for potential unit mismatches
							initialInUnit =
								elem.nodeType &&
								(jQuery.cssNumber[prop] || (unit !== "px" && +initial)) &&
								rcssNum.exec(jQuery.css(elem, prop))

						if (initialInUnit && initialInUnit[3] !== unit) {
							// Support: Firefox <=54
							// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
							initial = initial / 2

							// Trust units reported by jQuery.css
							unit = unit || initialInUnit[3]

							// Iteratively approximate from a nonzero starting point
							initialInUnit = +initial || 1

							while (maxIterations--) {
								// Evaluate and update our best guess (doubling guesses that zero out).
								// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
								jQuery.style(elem, prop, initialInUnit + unit)
								if (
									(1 - scale) *
										(1 - (scale = currentValue() / initial || 0.5)) <=
									0
								) {
									maxIterations = 0
								}
								initialInUnit = initialInUnit / scale
							}

							initialInUnit = initialInUnit * 2
							jQuery.style(elem, prop, initialInUnit + unit)

							// Make sure we update the tween properties later on
							valueParts = valueParts || []
						}

						if (valueParts) {
							initialInUnit = +initialInUnit || +initial || 0

							// Apply relative offset (+=/-=) if specified
							adjusted = valueParts[1]
								? initialInUnit + (valueParts[1] + 1) * valueParts[2]
								: +valueParts[2]
							if (tween) {
								tween.unit = unit
								tween.start = initialInUnit
								tween.end = adjusted
							}
						}
						return adjusted
					}

					var defaultDisplayMap = {}

					function getDefaultDisplay(elem) {
						var temp,
							doc = elem.ownerDocument,
							nodeName = elem.nodeName,
							display = defaultDisplayMap[nodeName]

						if (display) {
							return display
						}

						temp = doc.body.appendChild(doc.createElement(nodeName))
						display = jQuery.css(temp, "display")

						temp.parentNode.removeChild(temp)

						if (display === "none") {
							display = "block"
						}
						defaultDisplayMap[nodeName] = display

						return display
					}

					function showHide(elements, show) {
						var display,
							elem,
							values = [],
							index = 0,
							length = elements.length

						// Determine new display value for elements that need to change
						for (; index < length; index++) {
							elem = elements[index]
							if (!elem.style) {
								continue
							}

							display = elem.style.display
							if (show) {
								// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
								// check is required in this first loop unless we have a nonempty display value (either
								// inline or about-to-be-restored)
								if (display === "none") {
									values[index] = dataPriv.get(elem, "display") || null
									if (!values[index]) {
										elem.style.display = ""
									}
								}
								if (elem.style.display === "" && isHiddenWithinTree(elem)) {
									values[index] = getDefaultDisplay(elem)
								}
							} else {
								if (display !== "none") {
									values[index] = "none"

									// Remember what we're overwriting
									dataPriv.set(elem, "display", display)
								}
							}
						}

						// Set the display of the elements in a second loop to avoid constant reflow
						for (index = 0; index < length; index++) {
							if (values[index] != null) {
								elements[index].style.display = values[index]
							}
						}

						return elements
					}

					jQuery.fn.extend({
						show: function () {
							return showHide(this, true)
						},
						hide: function () {
							return showHide(this)
						},
						toggle: function (state) {
							if (typeof state === "boolean") {
								return state ? this.show() : this.hide()
							}

							return this.each(function () {
								if (isHiddenWithinTree(this)) {
									jQuery(this).show()
								} else {
									jQuery(this).hide()
								}
							})
						},
					})
					var rcheckableType = /^(?:checkbox|radio)$/i

					var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i

					var rscriptType = /^$|^module$|\/(?:java|ecma)script/i

					;(function () {
						var fragment = document.createDocumentFragment(),
							div = fragment.appendChild(document.createElement("div")),
							input = document.createElement("input")

						// Support: Android 4.0 - 4.3 only
						// Check state lost if the name is set (#11217)
						// Support: Windows Web Apps (WWA)
						// `name` and `type` must use .setAttribute for WWA (#14901)
						input.setAttribute("type", "radio")
						input.setAttribute("checked", "checked")
						input.setAttribute("name", "t")

						div.appendChild(input)

						// Support: Android <=4.1 only
						// Older WebKit doesn't clone checked state correctly in fragments
						support.checkClone = div
							.cloneNode(true)
							.cloneNode(true).lastChild.checked

						// Support: IE <=11 only
						// Make sure textarea (and checkbox) defaultValue is properly cloned
						div.innerHTML = "<textarea>x</textarea>"
						support.noCloneChecked = !!div.cloneNode(true).lastChild
							.defaultValue

						// Support: IE <=9 only
						// IE <=9 replaces <option> tags with their contents when inserted outside of
						// the select element.
						div.innerHTML = "<option></option>"
						support.option = !!div.lastChild
					})()

					// We have to close these tags to support XHTML (#13200)
					var wrapMap = {
						// XHTML parsers do not magically insert elements in the
						// same way that tag soup parsers do. So we cannot shorten
						// this by omitting <tbody> or other required elements.
						thead: [1, "<table>", "</table>"],
						col: [2, "<table><colgroup>", "</colgroup></table>"],
						tr: [2, "<table><tbody>", "</tbody></table>"],
						td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

						_default: [0, "", ""],
					}

					wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption =
						wrapMap.thead
					wrapMap.th = wrapMap.td

					// Support: IE <=9 only
					if (!support.option) {
						wrapMap.optgroup = wrapMap.option = [
							1,
							"<select multiple='multiple'>",
							"</select>",
						]
					}

					function getAll(context, tag) {
						// Support: IE <=9 - 11 only
						// Use typeof to avoid zero-argument method invocation on host objects (#15151)
						var ret

						if (typeof context.getElementsByTagName !== "undefined") {
							ret = context.getElementsByTagName(tag || "*")
						} else if (typeof context.querySelectorAll !== "undefined") {
							ret = context.querySelectorAll(tag || "*")
						} else {
							ret = []
						}

						if (tag === undefined || (tag && nodeName(context, tag))) {
							return jQuery.merge([context], ret)
						}

						return ret
					}

					// Mark scripts as having already been evaluated
					function setGlobalEval(elems, refElements) {
						var i = 0,
							l = elems.length

						for (; i < l; i++) {
							dataPriv.set(
								elems[i],
								"globalEval",
								!refElements || dataPriv.get(refElements[i], "globalEval"),
							)
						}
					}

					var rhtml = /<|&#?\w+;/

					function buildFragment(elems, context, scripts, selection, ignored) {
						var elem,
							tmp,
							tag,
							wrap,
							attached,
							j,
							fragment = context.createDocumentFragment(),
							nodes = [],
							i = 0,
							l = elems.length

						for (; i < l; i++) {
							elem = elems[i]

							if (elem || elem === 0) {
								// Add nodes directly
								if (toType(elem) === "object") {
									// Support: Android <=4.0 only, PhantomJS 1 only
									// push.apply(_, arraylike) throws on ancient WebKit
									jQuery.merge(nodes, elem.nodeType ? [elem] : elem)

									// Convert non-html into a text node
								} else if (!rhtml.test(elem)) {
									nodes.push(context.createTextNode(elem))

									// Convert html into DOM nodes
								} else {
									tmp =
										tmp || fragment.appendChild(context.createElement("div"))

									// Deserialize a standard representation
									tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase()
									wrap = wrapMap[tag] || wrapMap._default
									tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]

									// Descend through wrappers to the right content
									j = wrap[0]
									while (j--) {
										tmp = tmp.lastChild
									}

									// Support: Android <=4.0 only, PhantomJS 1 only
									// push.apply(_, arraylike) throws on ancient WebKit
									jQuery.merge(nodes, tmp.childNodes)

									// Remember the top-level container
									tmp = fragment.firstChild

									// Ensure the created nodes are orphaned (#12392)
									tmp.textContent = ""
								}
							}
						}

						// Remove wrapper from fragment
						fragment.textContent = ""

						i = 0
						while ((elem = nodes[i++])) {
							// Skip elements already in the context collection (trac-4087)
							if (selection && jQuery.inArray(elem, selection) > -1) {
								if (ignored) {
									ignored.push(elem)
								}
								continue
							}

							attached = isAttached(elem)

							// Append to fragment
							tmp = getAll(fragment.appendChild(elem), "script")

							// Preserve script evaluation history
							if (attached) {
								setGlobalEval(tmp)
							}

							// Capture executables
							if (scripts) {
								j = 0
								while ((elem = tmp[j++])) {
									if (rscriptType.test(elem.type || "")) {
										scripts.push(elem)
									}
								}
							}
						}

						return fragment
					}

					var rkeyEvent = /^key/,
						rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
						rtypenamespace = /^([^.]*)(?:\.(.+)|)/

					function returnTrue() {
						return true
					}

					function returnFalse() {
						return false
					}

					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous, except when they are no-op.
					// So expect focus to be synchronous when the element is already active,
					// and blur to be synchronous when the element is not already active.
					// (focus and blur are always synchronous in other supported browsers,
					// this just defines when we can count on it).
					function expectSync(elem, type) {
						return (elem === safeActiveElement()) === (type === "focus")
					}

					// Support: IE <=9 only
					// Accessing document.activeElement can throw unexpectedly
					// https://bugs.jquery.com/ticket/13393
					function safeActiveElement() {
						try {
							return document.activeElement
						} catch (err) {}
					}

					function on(elem, types, selector, data, fn, one) {
						var origFn, type

						// Types can be a map of types/handlers
						if (typeof types === "object") {
							// ( types-Object, selector, data )
							if (typeof selector !== "string") {
								// ( types-Object, data )
								data = data || selector
								selector = undefined
							}
							for (type in types) {
								on(elem, type, selector, data, types[type], one)
							}
							return elem
						}

						if (data == null && fn == null) {
							// ( types, fn )
							fn = selector
							data = selector = undefined
						} else if (fn == null) {
							if (typeof selector === "string") {
								// ( types, selector, fn )
								fn = data
								data = undefined
							} else {
								// ( types, data, fn )
								fn = data
								data = selector
								selector = undefined
							}
						}
						if (fn === false) {
							fn = returnFalse
						} else if (!fn) {
							return elem
						}

						if (one === 1) {
							origFn = fn
							fn = function (event) {
								// Can use an empty set, since event contains the info
								jQuery().off(event)
								return origFn.apply(this, arguments)
							}

							// Use same guid so caller can remove using origFn
							fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)
						}
						return elem.each(function () {
							jQuery.event.add(this, types, fn, data, selector)
						})
					}

					/*
					 * Helper functions for managing events -- not part of the public interface.
					 * Props to Dean Edwards' addEvent library for many of the ideas.
					 */
					jQuery.event = {
						global: {},

						add: function (elem, types, handler, data, selector) {
							var handleObjIn,
								eventHandle,
								tmp,
								events,
								t,
								handleObj,
								special,
								handlers,
								type,
								namespaces,
								origType,
								elemData = dataPriv.get(elem)

							// Only attach events to objects that accept data
							if (!acceptData(elem)) {
								return
							}

							// Caller can pass in an object of custom data in lieu of the handler
							if (handler.handler) {
								handleObjIn = handler
								handler = handleObjIn.handler
								selector = handleObjIn.selector
							}

							// Ensure that invalid selectors throw exceptions at attach time
							// Evaluate against documentElement in case elem is a non-element node (e.g., document)
							if (selector) {
								jQuery.find.matchesSelector(documentElement, selector)
							}

							// Make sure that the handler has a unique ID, used to find/remove it later
							if (!handler.guid) {
								handler.guid = jQuery.guid++
							}

							// Init the element's event structure and main handler, if this is the first
							if (!(events = elemData.events)) {
								events = elemData.events = Object.create(null)
							}
							if (!(eventHandle = elemData.handle)) {
								eventHandle = elemData.handle = function (e) {
									// Discard the second event of a jQuery.event.trigger() and
									// when an event is called after a page has unloaded
									return typeof jQuery !== "undefined" &&
										jQuery.event.triggered !== e.type
										? jQuery.event.dispatch.apply(elem, arguments)
										: undefined
								}
							}

							// Handle multiple events separated by a space
							types = (types || "").match(rnothtmlwhite) || [""]
							t = types.length
							while (t--) {
								tmp = rtypenamespace.exec(types[t]) || []
								type = origType = tmp[1]
								namespaces = (tmp[2] || "").split(".").sort()

								// There *must* be a type, no attaching namespace-only handlers
								if (!type) {
									continue
								}

								// If event changes its type, use the special event handlers for the changed type
								special = jQuery.event.special[type] || {}

								// If selector defined, determine special event api type, otherwise given type
								type =
									(selector ? special.delegateType : special.bindType) || type

								// Update special based on newly reset type
								special = jQuery.event.special[type] || {}

								// handleObj is passed to all event handlers
								handleObj = jQuery.extend(
									{
										type: type,
										origType: origType,
										data: data,
										handler: handler,
										guid: handler.guid,
										selector: selector,
										needsContext:
											selector && jQuery.expr.match.needsContext.test(selector),
										namespace: namespaces.join("."),
									},
									handleObjIn,
								)

								// Init the event handler queue if we're the first
								if (!(handlers = events[type])) {
									handlers = events[type] = []
									handlers.delegateCount = 0

									// Only use addEventListener if the special events handler returns false
									if (
										!special.setup ||
										special.setup.call(elem, data, namespaces, eventHandle) ===
											false
									) {
										if (elem.addEventListener) {
											elem.addEventListener(type, eventHandle)
										}
									}
								}

								if (special.add) {
									special.add.call(elem, handleObj)

									if (!handleObj.handler.guid) {
										handleObj.handler.guid = handler.guid
									}
								}

								// Add to the element's handler list, delegates in front
								if (selector) {
									handlers.splice(handlers.delegateCount++, 0, handleObj)
								} else {
									handlers.push(handleObj)
								}

								// Keep track of which events have ever been used, for event optimization
								jQuery.event.global[type] = true
							}
						},

						// Detach an event or set of events from an element
						remove: function (elem, types, handler, selector, mappedTypes) {
							var j,
								origCount,
								tmp,
								events,
								t,
								handleObj,
								special,
								handlers,
								type,
								namespaces,
								origType,
								elemData = dataPriv.hasData(elem) && dataPriv.get(elem)

							if (!elemData || !(events = elemData.events)) {
								return
							}

							// Once for each type.namespace in types; type may be omitted
							types = (types || "").match(rnothtmlwhite) || [""]
							t = types.length
							while (t--) {
								tmp = rtypenamespace.exec(types[t]) || []
								type = origType = tmp[1]
								namespaces = (tmp[2] || "").split(".").sort()

								// Unbind all events (on this namespace, if provided) for the element
								if (!type) {
									for (type in events) {
										jQuery.event.remove(
											elem,
											type + types[t],
											handler,
											selector,
											true,
										)
									}
									continue
								}

								special = jQuery.event.special[type] || {}
								type =
									(selector ? special.delegateType : special.bindType) || type
								handlers = events[type] || []
								tmp =
									tmp[2] &&
									new RegExp(
										"(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)",
									)

								// Remove matching events
								origCount = j = handlers.length
								while (j--) {
									handleObj = handlers[j]

									if (
										(mappedTypes || origType === handleObj.origType) &&
										(!handler || handler.guid === handleObj.guid) &&
										(!tmp || tmp.test(handleObj.namespace)) &&
										(!selector ||
											selector === handleObj.selector ||
											(selector === "**" && handleObj.selector))
									) {
										handlers.splice(j, 1)

										if (handleObj.selector) {
											handlers.delegateCount--
										}
										if (special.remove) {
											special.remove.call(elem, handleObj)
										}
									}
								}

								// Remove generic event handler if we removed something and no more handlers exist
								// (avoids potential for endless recursion during removal of special event handlers)
								if (origCount && !handlers.length) {
									if (
										!special.teardown ||
										special.teardown.call(elem, namespaces, elemData.handle) ===
											false
									) {
										jQuery.removeEvent(elem, type, elemData.handle)
									}

									delete events[type]
								}
							}

							// Remove data and the expando if it's no longer used
							if (jQuery.isEmptyObject(events)) {
								dataPriv.remove(elem, "handle events")
							}
						},

						dispatch: function (nativeEvent) {
							var i,
								j,
								ret,
								matched,
								handleObj,
								handlerQueue,
								args = new Array(arguments.length),
								// Make a writable jQuery.Event from the native event object
								event = jQuery.event.fix(nativeEvent),
								handlers =
									(dataPriv.get(this, "events") || Object.create(null))[
										event.type
									] || [],
								special = jQuery.event.special[event.type] || {}

							// Use the fix-ed jQuery.Event rather than the (read-only) native event
							args[0] = event

							for (i = 1; i < arguments.length; i++) {
								args[i] = arguments[i]
							}

							event.delegateTarget = this

							// Call the preDispatch hook for the mapped type, and let it bail if desired
							if (
								special.preDispatch &&
								special.preDispatch.call(this, event) === false
							) {
								return
							}

							// Determine handlers
							handlerQueue = jQuery.event.handlers.call(this, event, handlers)

							// Run delegates first; they may want to stop propagation beneath us
							i = 0
							while (
								(matched = handlerQueue[i++]) &&
								!event.isPropagationStopped()
							) {
								event.currentTarget = matched.elem

								j = 0
								while (
									(handleObj = matched.handlers[j++]) &&
									!event.isImmediatePropagationStopped()
								) {
									// If the event is namespaced, then each handler is only invoked if it is
									// specially universal or its namespaces are a superset of the event's.
									if (
										!event.rnamespace ||
										handleObj.namespace === false ||
										event.rnamespace.test(handleObj.namespace)
									) {
										event.handleObj = handleObj
										event.data = handleObj.data

										ret = (
											(jQuery.event.special[handleObj.origType] || {}).handle ||
											handleObj.handler
										).apply(matched.elem, args)

										if (ret !== undefined) {
											if ((event.result = ret) === false) {
												event.preventDefault()
												event.stopPropagation()
											}
										}
									}
								}
							}

							// Call the postDispatch hook for the mapped type
							if (special.postDispatch) {
								special.postDispatch.call(this, event)
							}

							return event.result
						},

						handlers: function (event, handlers) {
							var i,
								handleObj,
								sel,
								matchedHandlers,
								matchedSelectors,
								handlerQueue = [],
								delegateCount = handlers.delegateCount,
								cur = event.target

							// Find delegate handlers
							if (
								delegateCount &&
								// Support: IE <=9
								// Black-hole SVG <use> instance trees (trac-13180)
								cur.nodeType &&
								// Support: Firefox <=42
								// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
								// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
								// Support: IE 11 only
								// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
								!(event.type === "click" && event.button >= 1)
							) {
								for (; cur !== this; cur = cur.parentNode || this) {
									// Don't check non-elements (#13208)
									// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
									if (
										cur.nodeType === 1 &&
										!(event.type === "click" && cur.disabled === true)
									) {
										matchedHandlers = []
										matchedSelectors = {}
										for (i = 0; i < delegateCount; i++) {
											handleObj = handlers[i]

											// Don't conflict with Object.prototype properties (#13203)
											sel = handleObj.selector + " "

											if (matchedSelectors[sel] === undefined) {
												matchedSelectors[sel] = handleObj.needsContext
													? jQuery(sel, this).index(cur) > -1
													: jQuery.find(sel, this, null, [cur]).length
											}
											if (matchedSelectors[sel]) {
												matchedHandlers.push(handleObj)
											}
										}
										if (matchedHandlers.length) {
											handlerQueue.push({
												elem: cur,
												handlers: matchedHandlers,
											})
										}
									}
								}
							}

							// Add the remaining (directly-bound) handlers
							cur = this
							if (delegateCount < handlers.length) {
								handlerQueue.push({
									elem: cur,
									handlers: handlers.slice(delegateCount),
								})
							}

							return handlerQueue
						},

						addProp: function (name, hook) {
							Object.defineProperty(jQuery.Event.prototype, name, {
								enumerable: true,
								configurable: true,

								get: isFunction(hook)
									? function () {
											if (this.originalEvent) {
												return hook(this.originalEvent)
											}
									  }
									: function () {
											if (this.originalEvent) {
												return this.originalEvent[name]
											}
									  },

								set: function (value) {
									Object.defineProperty(this, name, {
										enumerable: true,
										configurable: true,
										writable: true,
										value: value,
									})
								},
							})
						},

						fix: function (originalEvent) {
							return originalEvent[jQuery.expando]
								? originalEvent
								: new jQuery.Event(originalEvent)
						},

						special: {
							load: {
								// Prevent triggered image.load events from bubbling to window.load
								noBubble: true,
							},
							click: {
								// Utilize native event to ensure correct state for checkable inputs
								setup: function (data) {
									// For mutual compressibility with _default, replace `this` access with a local var.
									// `|| data` is dead code meant only to preserve the variable through minification.
									var el = this || data

									// Claim the first handler
									if (
										rcheckableType.test(el.type) &&
										el.click &&
										nodeName(el, "input")
									) {
										// dataPriv.set( el, "click", ... )
										leverageNative(el, "click", returnTrue)
									}

									// Return false to allow normal processing in the caller
									return false
								},
								trigger: function (data) {
									// For mutual compressibility with _default, replace `this` access with a local var.
									// `|| data` is dead code meant only to preserve the variable through minification.
									var el = this || data

									// Force setup before triggering a click
									if (
										rcheckableType.test(el.type) &&
										el.click &&
										nodeName(el, "input")
									) {
										leverageNative(el, "click")
									}

									// Return non-false to allow normal event-path propagation
									return true
								},

								// For cross-browser consistency, suppress native .click() on links
								// Also prevent it if we're currently inside a leveraged native-event stack
								_default: function (event) {
									var target = event.target
									return (
										(rcheckableType.test(target.type) &&
											target.click &&
											nodeName(target, "input") &&
											dataPriv.get(target, "click")) ||
										nodeName(target, "a")
									)
								},
							},

							beforeunload: {
								postDispatch: function (event) {
									// Support: Firefox 20+
									// Firefox doesn't alert if the returnValue field is not set.
									if (event.result !== undefined && event.originalEvent) {
										event.originalEvent.returnValue = event.result
									}
								},
							},
						},
					}

					// Ensure the presence of an event listener that handles manually-triggered
					// synthetic events by interrupting progress until reinvoked in response to
					// *native* events that it fires directly, ensuring that state changes have
					// already occurred before other listeners are invoked.
					function leverageNative(el, type, expectSync) {
						// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
						if (!expectSync) {
							if (dataPriv.get(el, type) === undefined) {
								jQuery.event.add(el, type, returnTrue)
							}
							return
						}

						// Register the controller as a special universal handler for all event namespaces
						dataPriv.set(el, type, false)
						jQuery.event.add(el, type, {
							namespace: false,
							handler: function (event) {
								var notAsync,
									result,
									saved = dataPriv.get(this, type)

								if (event.isTrigger & 1 && this[type]) {
									// Interrupt processing of the outer synthetic .trigger()ed event
									// Saved data should be false in such cases, but might be a leftover capture object
									// from an async native handler (gh-4350)
									if (!saved.length) {
										// Store arguments for use when handling the inner native event
										// There will always be at least one argument (an event object), so this array
										// will not be confused with a leftover capture object.
										saved = slice.call(arguments)
										dataPriv.set(this, type, saved)

										// Trigger the native event and capture its result
										// Support: IE <=9 - 11+
										// focus() and blur() are asynchronous
										notAsync = expectSync(this, type)
										this[type]()
										result = dataPriv.get(this, type)
										if (saved !== result || notAsync) {
											dataPriv.set(this, type, false)
										} else {
											result = {}
										}
										if (saved !== result) {
											// Cancel the outer synthetic event
											event.stopImmediatePropagation()
											event.preventDefault()
											return result.value
										}

										// If this is an inner synthetic event for an event with a bubbling surrogate
										// (focus or blur), assume that the surrogate already propagated from triggering the
										// native event and prevent that from happening again here.
										// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
										// bubbling surrogate propagates *after* the non-bubbling base), but that seems
										// less bad than duplication.
									} else if ((jQuery.event.special[type] || {}).delegateType) {
										event.stopPropagation()
									}

									// If this is a native event triggered above, everything is now in order
									// Fire an inner synthetic event with the original arguments
								} else if (saved.length) {
									// ...and capture the result
									dataPriv.set(this, type, {
										value: jQuery.event.trigger(
											// Support: IE <=9 - 11+
											// Extend with the prototype to reset the above stopImmediatePropagation()
											jQuery.extend(saved[0], jQuery.Event.prototype),
											saved.slice(1),
											this,
										),
									})

									// Abort handling of the native event
									event.stopImmediatePropagation()
								}
							},
						})
					}

					jQuery.removeEvent = function (elem, type, handle) {
						// This "if" is needed for plain objects
						if (elem.removeEventListener) {
							elem.removeEventListener(type, handle)
						}
					}

					jQuery.Event = function (src, props) {
						// Allow instantiation without the 'new' keyword
						if (!(this instanceof jQuery.Event)) {
							return new jQuery.Event(src, props)
						}

						// Event object
						if (src && src.type) {
							this.originalEvent = src
							this.type = src.type

							// Events bubbling up the document may have been marked as prevented
							// by a handler lower down the tree; reflect the correct value.
							this.isDefaultPrevented =
								src.defaultPrevented ||
								(src.defaultPrevented === undefined &&
									// Support: Android <=2.3 only
									src.returnValue === false)
									? returnTrue
									: returnFalse

							// Create target properties
							// Support: Safari <=6 - 7 only
							// Target should not be a text node (#504, #13143)
							this.target =
								src.target && src.target.nodeType === 3
									? src.target.parentNode
									: src.target

							this.currentTarget = src.currentTarget
							this.relatedTarget = src.relatedTarget

							// Event type
						} else {
							this.type = src
						}

						// Put explicitly provided properties onto the event object
						if (props) {
							jQuery.extend(this, props)
						}

						// Create a timestamp if incoming event doesn't have one
						this.timeStamp = (src && src.timeStamp) || Date.now()

						// Mark it as fixed
						this[jQuery.expando] = true
					}

					// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
					// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
					jQuery.Event.prototype = {
						constructor: jQuery.Event,
						isDefaultPrevented: returnFalse,
						isPropagationStopped: returnFalse,
						isImmediatePropagationStopped: returnFalse,
						isSimulated: false,

						preventDefault: function () {
							var e = this.originalEvent

							this.isDefaultPrevented = returnTrue

							if (e && !this.isSimulated) {
								e.preventDefault()
							}
						},
						stopPropagation: function () {
							var e = this.originalEvent

							this.isPropagationStopped = returnTrue

							if (e && !this.isSimulated) {
								e.stopPropagation()
							}
						},
						stopImmediatePropagation: function () {
							var e = this.originalEvent

							this.isImmediatePropagationStopped = returnTrue

							if (e && !this.isSimulated) {
								e.stopImmediatePropagation()
							}

							this.stopPropagation()
						},
					}

					// Includes all common event props including KeyEvent and MouseEvent specific props
					jQuery.each(
						{
							altKey: true,
							bubbles: true,
							cancelable: true,
							changedTouches: true,
							ctrlKey: true,
							detail: true,
							eventPhase: true,
							metaKey: true,
							pageX: true,
							pageY: true,
							shiftKey: true,
							view: true,
							char: true,
							code: true,
							charCode: true,
							key: true,
							keyCode: true,
							button: true,
							buttons: true,
							clientX: true,
							clientY: true,
							offsetX: true,
							offsetY: true,
							pointerId: true,
							pointerType: true,
							screenX: true,
							screenY: true,
							targetTouches: true,
							toElement: true,
							touches: true,

							which: function (event) {
								var button = event.button

								// Add which for key events
								if (event.which == null && rkeyEvent.test(event.type)) {
									return event.charCode != null ? event.charCode : event.keyCode
								}

								// Add which for click: 1 === left; 2 === middle; 3 === right
								if (
									!event.which &&
									button !== undefined &&
									rmouseEvent.test(event.type)
								) {
									if (button & 1) {
										return 1
									}

									if (button & 2) {
										return 3
									}

									if (button & 4) {
										return 2
									}

									return 0
								}

								return event.which
							},
						},
						jQuery.event.addProp,
					)

					jQuery.each({ focus: "focusin", blur: "focusout" }, function (
						type,
						delegateType,
					) {
						jQuery.event.special[type] = {
							// Utilize native event if possible so blur/focus sequence is correct
							setup: function () {
								// Claim the first handler
								// dataPriv.set( this, "focus", ... )
								// dataPriv.set( this, "blur", ... )
								leverageNative(this, type, expectSync)

								// Return false to allow normal processing in the caller
								return false
							},
							trigger: function () {
								// Force setup before trigger
								leverageNative(this, type)

								// Return non-false to allow normal event-path propagation
								return true
							},

							delegateType: delegateType,
						}
					})

					// Create mouseenter/leave events using mouseover/out and event-time checks
					// so that event delegation works in jQuery.
					// Do the same for pointerenter/pointerleave and pointerover/pointerout
					//
					// Support: Safari 7 only
					// Safari sends mouseenter too often; see:
					// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
					// for the description of the bug (it existed in older Chrome versions as well).
					jQuery.each(
						{
							mouseenter: "mouseover",
							mouseleave: "mouseout",
							pointerenter: "pointerover",
							pointerleave: "pointerout",
						},
						function (orig, fix) {
							jQuery.event.special[orig] = {
								delegateType: fix,
								bindType: fix,

								handle: function (event) {
									var ret,
										target = this,
										related = event.relatedTarget,
										handleObj = event.handleObj

									// For mouseenter/leave call the handler if related is outside the target.
									// NB: No relatedTarget if the mouse left/entered the browser window
									if (
										!related ||
										(related !== target && !jQuery.contains(target, related))
									) {
										event.type = handleObj.origType
										ret = handleObj.handler.apply(this, arguments)
										event.type = fix
									}
									return ret
								},
							}
						},
					)

					jQuery.fn.extend({
						on: function (types, selector, data, fn) {
							return on(this, types, selector, data, fn)
						},
						one: function (types, selector, data, fn) {
							return on(this, types, selector, data, fn, 1)
						},
						off: function (types, selector, fn) {
							var handleObj, type
							if (types && types.preventDefault && types.handleObj) {
								// ( event )  dispatched jQuery.Event
								handleObj = types.handleObj
								jQuery(types.delegateTarget).off(
									handleObj.namespace
										? handleObj.origType + "." + handleObj.namespace
										: handleObj.origType,
									handleObj.selector,
									handleObj.handler,
								)
								return this
							}
							if (typeof types === "object") {
								// ( types-object [, selector] )
								for (type in types) {
									this.off(type, selector, types[type])
								}
								return this
							}
							if (selector === false || typeof selector === "function") {
								// ( types [, fn] )
								fn = selector
								selector = undefined
							}
							if (fn === false) {
								fn = returnFalse
							}
							return this.each(function () {
								jQuery.event.remove(this, types, fn, selector)
							})
						},
					})

					var // Support: IE <=10 - 11, Edge 12 - 13 only
						// In IE/Edge using regex groups here causes severe slowdowns.
						// See https://connect.microsoft.com/IE/feedback/details/1736512/
						rnoInnerhtml = /<script|<style|<link/i,
						// checked="checked" or checked
						rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
						rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g

					// Prefer a tbody over its parent table for containing new rows
					function manipulationTarget(elem, content) {
						if (
							nodeName(elem, "table") &&
							nodeName(
								content.nodeType !== 11 ? content : content.firstChild,
								"tr",
							)
						) {
							return jQuery(elem).children("tbody")[0] || elem
						}

						return elem
					}

					// Replace/restore the type attribute of script elements for safe DOM manipulation
					function disableScript(elem) {
						elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type
						return elem
					}
					function restoreScript(elem) {
						if ((elem.type || "").slice(0, 5) === "true/") {
							elem.type = elem.type.slice(5)
						} else {
							elem.removeAttribute("type")
						}

						return elem
					}

					function cloneCopyEvent(src, dest) {
						var i, l, type, pdataOld, udataOld, udataCur, events

						if (dest.nodeType !== 1) {
							return
						}

						// 1. Copy private data: events, handlers, etc.
						if (dataPriv.hasData(src)) {
							pdataOld = dataPriv.get(src)
							events = pdataOld.events

							if (events) {
								dataPriv.remove(dest, "handle events")

								for (type in events) {
									for (i = 0, l = events[type].length; i < l; i++) {
										jQuery.event.add(dest, type, events[type][i])
									}
								}
							}
						}

						// 2. Copy user data
						if (dataUser.hasData(src)) {
							udataOld = dataUser.access(src)
							udataCur = jQuery.extend({}, udataOld)

							dataUser.set(dest, udataCur)
						}
					}

					// Fix IE bugs, see support tests
					function fixInput(src, dest) {
						var nodeName = dest.nodeName.toLowerCase()

						// Fails to persist the checked state of a cloned checkbox or radio button.
						if (nodeName === "input" && rcheckableType.test(src.type)) {
							dest.checked = src.checked

							// Fails to return the selected option to the default selected state when cloning options
						} else if (nodeName === "input" || nodeName === "textarea") {
							dest.defaultValue = src.defaultValue
						}
					}

					function domManip(collection, args, callback, ignored) {
						// Flatten any nested arrays
						args = flat(args)

						var fragment,
							first,
							scripts,
							hasScripts,
							node,
							doc,
							i = 0,
							l = collection.length,
							iNoClone = l - 1,
							value = args[0],
							valueIsFunction = isFunction(value)

						// We can't cloneNode fragments that contain checked, in WebKit
						if (
							valueIsFunction ||
							(l > 1 &&
								typeof value === "string" &&
								!support.checkClone &&
								rchecked.test(value))
						) {
							return collection.each(function (index) {
								var self = collection.eq(index)
								if (valueIsFunction) {
									args[0] = value.call(this, index, self.html())
								}
								domManip(self, args, callback, ignored)
							})
						}

						if (l) {
							fragment = buildFragment(
								args,
								collection[0].ownerDocument,
								false,
								collection,
								ignored,
							)
							first = fragment.firstChild

							if (fragment.childNodes.length === 1) {
								fragment = first
							}

							// Require either new content or an interest in ignored elements to invoke the callback
							if (first || ignored) {
								scripts = jQuery.map(getAll(fragment, "script"), disableScript)
								hasScripts = scripts.length

								// Use the original fragment for the last item
								// instead of the first because it can end up
								// being emptied incorrectly in certain situations (#8070).
								for (; i < l; i++) {
									node = fragment

									if (i !== iNoClone) {
										node = jQuery.clone(node, true, true)

										// Keep references to cloned scripts for later restoration
										if (hasScripts) {
											// Support: Android <=4.0 only, PhantomJS 1 only
											// push.apply(_, arraylike) throws on ancient WebKit
											jQuery.merge(scripts, getAll(node, "script"))
										}
									}

									callback.call(collection[i], node, i)
								}

								if (hasScripts) {
									doc = scripts[scripts.length - 1].ownerDocument

									// Reenable scripts
									jQuery.map(scripts, restoreScript)

									// Evaluate executable scripts on first document insertion
									for (i = 0; i < hasScripts; i++) {
										node = scripts[i]
										if (
											rscriptType.test(node.type || "") &&
											!dataPriv.access(node, "globalEval") &&
											jQuery.contains(doc, node)
										) {
											if (
												node.src &&
												(node.type || "").toLowerCase() !== "module"
											) {
												// Optional AJAX dependency, but won't run scripts if not present
												if (jQuery._evalUrl && !node.noModule) {
													jQuery._evalUrl(
														node.src,
														{
															nonce: node.nonce || node.getAttribute("nonce"),
														},
														doc,
													)
												}
											} else {
												DOMEval(
													node.textContent.replace(rcleanScript, ""),
													node,
													doc,
												)
											}
										}
									}
								}
							}
						}

						return collection
					}

					function remove(elem, selector, keepData) {
						var node,
							nodes = selector ? jQuery.filter(selector, elem) : elem,
							i = 0

						for (; (node = nodes[i]) != null; i++) {
							if (!keepData && node.nodeType === 1) {
								jQuery.cleanData(getAll(node))
							}

							if (node.parentNode) {
								if (keepData && isAttached(node)) {
									setGlobalEval(getAll(node, "script"))
								}
								node.parentNode.removeChild(node)
							}
						}

						return elem
					}

					jQuery.extend({
						htmlPrefilter: function (html) {
							return html
						},

						clone: function (elem, dataAndEvents, deepDataAndEvents) {
							var i,
								l,
								srcElements,
								destElements,
								clone = elem.cloneNode(true),
								inPage = isAttached(elem)

							// Fix IE cloning issues
							if (
								!support.noCloneChecked &&
								(elem.nodeType === 1 || elem.nodeType === 11) &&
								!jQuery.isXMLDoc(elem)
							) {
								// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
								destElements = getAll(clone)
								srcElements = getAll(elem)

								for (i = 0, l = srcElements.length; i < l; i++) {
									fixInput(srcElements[i], destElements[i])
								}
							}

							// Copy the events from the original to the clone
							if (dataAndEvents) {
								if (deepDataAndEvents) {
									srcElements = srcElements || getAll(elem)
									destElements = destElements || getAll(clone)

									for (i = 0, l = srcElements.length; i < l; i++) {
										cloneCopyEvent(srcElements[i], destElements[i])
									}
								} else {
									cloneCopyEvent(elem, clone)
								}
							}

							// Preserve script evaluation history
							destElements = getAll(clone, "script")
							if (destElements.length > 0) {
								setGlobalEval(destElements, !inPage && getAll(elem, "script"))
							}

							// Return the cloned set
							return clone
						},

						cleanData: function (elems) {
							var data,
								elem,
								type,
								special = jQuery.event.special,
								i = 0

							for (; (elem = elems[i]) !== undefined; i++) {
								if (acceptData(elem)) {
									if ((data = elem[dataPriv.expando])) {
										if (data.events) {
											for (type in data.events) {
												if (special[type]) {
													jQuery.event.remove(elem, type)

													// This is a shortcut to avoid jQuery.event.remove's overhead
												} else {
													jQuery.removeEvent(elem, type, data.handle)
												}
											}
										}

										// Support: Chrome <=35 - 45+
										// Assign undefined instead of using delete, see Data#remove
										elem[dataPriv.expando] = undefined
									}
									if (elem[dataUser.expando]) {
										// Support: Chrome <=35 - 45+
										// Assign undefined instead of using delete, see Data#remove
										elem[dataUser.expando] = undefined
									}
								}
							}
						},
					})

					jQuery.fn.extend({
						detach: function (selector) {
							return remove(this, selector, true)
						},

						remove: function (selector) {
							return remove(this, selector)
						},

						text: function (value) {
							return access(
								this,
								function (value) {
									return value === undefined
										? jQuery.text(this)
										: this.empty().each(function () {
												if (
													this.nodeType === 1 ||
													this.nodeType === 11 ||
													this.nodeType === 9
												) {
													this.textContent = value
												}
										  })
								},
								null,
								value,
								arguments.length,
							)
						},

						append: function () {
							return domManip(this, arguments, function (elem) {
								if (
									this.nodeType === 1 ||
									this.nodeType === 11 ||
									this.nodeType === 9
								) {
									var target = manipulationTarget(this, elem)
									target.appendChild(elem)
								}
							})
						},

						prepend: function () {
							return domManip(this, arguments, function (elem) {
								if (
									this.nodeType === 1 ||
									this.nodeType === 11 ||
									this.nodeType === 9
								) {
									var target = manipulationTarget(this, elem)
									target.insertBefore(elem, target.firstChild)
								}
							})
						},

						before: function () {
							return domManip(this, arguments, function (elem) {
								if (this.parentNode) {
									this.parentNode.insertBefore(elem, this)
								}
							})
						},

						after: function () {
							return domManip(this, arguments, function (elem) {
								if (this.parentNode) {
									this.parentNode.insertBefore(elem, this.nextSibling)
								}
							})
						},

						empty: function () {
							var elem,
								i = 0

							for (; (elem = this[i]) != null; i++) {
								if (elem.nodeType === 1) {
									// Prevent memory leaks
									jQuery.cleanData(getAll(elem, false))

									// Remove any remaining nodes
									elem.textContent = ""
								}
							}

							return this
						},

						clone: function (dataAndEvents, deepDataAndEvents) {
							dataAndEvents = dataAndEvents == null ? false : dataAndEvents
							deepDataAndEvents =
								deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents

							return this.map(function () {
								return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
							})
						},

						html: function (value) {
							return access(
								this,
								function (value) {
									var elem = this[0] || {},
										i = 0,
										l = this.length

									if (value === undefined && elem.nodeType === 1) {
										return elem.innerHTML
									}

									// See if we can take a shortcut and just use innerHTML
									if (
										typeof value === "string" &&
										!rnoInnerhtml.test(value) &&
										!wrapMap[
											(rtagName.exec(value) || ["", ""])[1].toLowerCase()
										]
									) {
										value = jQuery.htmlPrefilter(value)

										try {
											for (; i < l; i++) {
												elem = this[i] || {}

												// Remove element nodes and prevent memory leaks
												if (elem.nodeType === 1) {
													jQuery.cleanData(getAll(elem, false))
													elem.innerHTML = value
												}
											}

											elem = 0

											// If using innerHTML throws an exception, use the fallback method
										} catch (e) {}
									}

									if (elem) {
										this.empty().append(value)
									}
								},
								null,
								value,
								arguments.length,
							)
						},

						replaceWith: function () {
							var ignored = []

							// Make the changes, replacing each non-ignored context element with the new content
							return domManip(
								this,
								arguments,
								function (elem) {
									var parent = this.parentNode

									if (jQuery.inArray(this, ignored) < 0) {
										jQuery.cleanData(getAll(this))
										if (parent) {
											parent.replaceChild(elem, this)
										}
									}

									// Force callback invocation
								},
								ignored,
							)
						},
					})

					jQuery.each(
						{
							appendTo: "append",
							prependTo: "prepend",
							insertBefore: "before",
							insertAfter: "after",
							replaceAll: "replaceWith",
						},
						function (name, original) {
							jQuery.fn[name] = function (selector) {
								var elems,
									ret = [],
									insert = jQuery(selector),
									last = insert.length - 1,
									i = 0

								for (; i <= last; i++) {
									elems = i === last ? this : this.clone(true)
									jQuery(insert[i])[original](elems)

									// Support: Android <=4.0 only, PhantomJS 1 only
									// .get() because push.apply(_, arraylike) throws on ancient WebKit
									push.apply(ret, elems.get())
								}

								return this.pushStack(ret)
							}
						},
					)
					var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i")

					var getStyles = function (elem) {
						// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
						// IE throws on elements created in popups
						// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
						var view = elem.ownerDocument.defaultView

						if (!view || !view.opener) {
							view = window
						}

						return view.getComputedStyle(elem)
					}

					var swap = function (elem, options, callback) {
						var ret,
							name,
							old = {}

						// Remember the old values, and insert the new ones
						for (name in options) {
							old[name] = elem.style[name]
							elem.style[name] = options[name]
						}

						ret = callback.call(elem)

						// Revert the old values
						for (name in options) {
							elem.style[name] = old[name]
						}

						return ret
					}

					var rboxStyle = new RegExp(cssExpand.join("|"), "i")

					;(function () {
						// Executing both pixelPosition & boxSizingReliable tests require only one layout
						// so they're executed at the same time to save the second computation.
						function computeStyleTests() {
							// This is a singleton, we need to execute it only once
							if (!div) {
								return
							}

							container.style.cssText =
								"position:absolute;left:-11111px;width:60px;" +
								"margin-top:1px;padding:0;border:0"
							div.style.cssText =
								"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
								"margin:auto;border:1px;padding:1px;" +
								"width:60%;top:1%"
							documentElement.appendChild(container).appendChild(div)

							var divStyle = window.getComputedStyle(div)
							pixelPositionVal = divStyle.top !== "1%"

							// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
							reliableMarginLeftVal =
								roundPixelMeasures(divStyle.marginLeft) === 12

							// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
							// Some styles come back with percentage values, even though they shouldn't
							div.style.right = "60%"
							pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36

							// Support: IE 9 - 11 only
							// Detect misreporting of content dimensions for box-sizing:border-box elements
							boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36

							// Support: IE 9 only
							// Detect overflow:scroll screwiness (gh-3699)
							// Support: Chrome <=64
							// Don't get tricked when zoom affects offsetWidth (gh-4029)
							div.style.position = "absolute"
							scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12

							documentElement.removeChild(container)

							// Nullify the div so it wouldn't be stored in the memory and
							// it will also be a sign that checks already performed
							div = null
						}

						function roundPixelMeasures(measure) {
							return Math.round(parseFloat(measure))
						}

						var pixelPositionVal,
							boxSizingReliableVal,
							scrollboxSizeVal,
							pixelBoxStylesVal,
							reliableTrDimensionsVal,
							reliableMarginLeftVal,
							container = document.createElement("div"),
							div = document.createElement("div")

						// Finish early in limited (non-browser) environments
						if (!div.style) {
							return
						}

						// Support: IE <=9 - 11 only
						// Style of cloned element affects source element cloned (#8908)
						div.style.backgroundClip = "content-box"
						div.cloneNode(true).style.backgroundClip = ""
						support.clearCloneStyle = div.style.backgroundClip === "content-box"

						jQuery.extend(support, {
							boxSizingReliable: function () {
								computeStyleTests()
								return boxSizingReliableVal
							},
							pixelBoxStyles: function () {
								computeStyleTests()
								return pixelBoxStylesVal
							},
							pixelPosition: function () {
								computeStyleTests()
								return pixelPositionVal
							},
							reliableMarginLeft: function () {
								computeStyleTests()
								return reliableMarginLeftVal
							},
							scrollboxSize: function () {
								computeStyleTests()
								return scrollboxSizeVal
							},

							// Support: IE 9 - 11+, Edge 15 - 18+
							// IE/Edge misreport `getComputedStyle` of table rows with width/height
							// set in CSS while `offset*` properties report correct values.
							// Behavior in IE 9 is more subtle than in newer versions & it passes
							// some versions of this test; make sure not to make it pass there!
							reliableTrDimensions: function () {
								var table, tr, trChild, trStyle
								if (reliableTrDimensionsVal == null) {
									table = document.createElement("table")
									tr = document.createElement("tr")
									trChild = document.createElement("div")

									table.style.cssText = "position:absolute;left:-11111px"
									tr.style.height = "1px"
									trChild.style.height = "9px"

									documentElement
										.appendChild(table)
										.appendChild(tr)
										.appendChild(trChild)

									trStyle = window.getComputedStyle(tr)
									reliableTrDimensionsVal = parseInt(trStyle.height) > 3

									documentElement.removeChild(table)
								}
								return reliableTrDimensionsVal
							},
						})
					})()

					function curCSS(elem, name, computed) {
						var width,
							minWidth,
							maxWidth,
							ret,
							// Support: Firefox 51+
							// Retrieving style before computed somehow
							// fixes an issue with getting wrong values
							// on detached elements
							style = elem.style

						computed = computed || getStyles(elem)

						// getPropertyValue is needed for:
						//   .css('filter') (IE 9 only, #12537)
						//   .css('--customProperty) (#3144)
						if (computed) {
							ret = computed.getPropertyValue(name) || computed[name]

							if (ret === "" && !isAttached(elem)) {
								ret = jQuery.style(elem, name)
							}

							// A tribute to the "awesome hack by Dean Edwards"
							// Android Browser returns percentage for some values,
							// but width seems to be reliably pixels.
							// This is against the CSSOM draft spec:
							// https://drafts.csswg.org/cssom/#resolved-values
							if (
								!support.pixelBoxStyles() &&
								rnumnonpx.test(ret) &&
								rboxStyle.test(name)
							) {
								// Remember the original values
								width = style.width
								minWidth = style.minWidth
								maxWidth = style.maxWidth

								// Put in the new values to get a computed value out
								style.minWidth = style.maxWidth = style.width = ret
								ret = computed.width

								// Revert the changed values
								style.width = width
								style.minWidth = minWidth
								style.maxWidth = maxWidth
							}
						}

						return ret !== undefined
							? // Support: IE <=9 - 11 only
							  // IE returns zIndex value as an integer.
							  ret + ""
							: ret
					}

					function addGetHookIf(conditionFn, hookFn) {
						// Define the hook, we'll check on the first run if it's really needed.
						return {
							get: function () {
								if (conditionFn()) {
									// Hook not needed (or it's not possible to use it due
									// to missing dependency), remove it.
									delete this.get
									return
								}

								// Hook needed; redefine it so that the support test is not executed again.
								return (this.get = hookFn).apply(this, arguments)
							},
						}
					}

					var cssPrefixes = ["Webkit", "Moz", "ms"],
						emptyStyle = document.createElement("div").style,
						vendorProps = {}

					// Return a vendor-prefixed property or undefined
					function vendorPropName(name) {
						// Check for vendor prefixed names
						var capName = name[0].toUpperCase() + name.slice(1),
							i = cssPrefixes.length

						while (i--) {
							name = cssPrefixes[i] + capName
							if (name in emptyStyle) {
								return name
							}
						}
					}

					// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
					function finalPropName(name) {
						var final = jQuery.cssProps[name] || vendorProps[name]

						if (final) {
							return final
						}
						if (name in emptyStyle) {
							return name
						}
						return (vendorProps[name] = vendorPropName(name) || name)
					}

					var // Swappable if display is none or starts with table
						// except "table", "table-cell", or "table-caption"
						// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
						rdisplayswap = /^(none|table(?!-c[ea]).+)/,
						rcustomProp = /^--/,
						cssShow = {
							position: "absolute",
							visibility: "hidden",
							display: "block",
						},
						cssNormalTransform = {
							letterSpacing: "0",
							fontWeight: "400",
						}

					function setPositiveNumber(_elem, value, subtract) {
						// Any relative (+/-) values have already been
						// normalized at this point
						var matches = rcssNum.exec(value)
						return matches
							? // Guard against undefined "subtract", e.g., when used as in cssHooks
							  Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
							: value
					}

					function boxModelAdjustment(
						elem,
						dimension,
						box,
						isBorderBox,
						styles,
						computedVal,
					) {
						var i = dimension === "width" ? 1 : 0,
							extra = 0,
							delta = 0

						// Adjustment may not be necessary
						if (box === (isBorderBox ? "border" : "content")) {
							return 0
						}

						for (; i < 4; i += 2) {
							// Both box models exclude margin
							if (box === "margin") {
								delta += jQuery.css(elem, box + cssExpand[i], true, styles)
							}

							// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
							if (!isBorderBox) {
								// Add padding
								delta += jQuery.css(
									elem,
									"padding" + cssExpand[i],
									true,
									styles,
								)

								// For "border" or "margin", add border
								if (box !== "padding") {
									delta += jQuery.css(
										elem,
										"border" + cssExpand[i] + "Width",
										true,
										styles,
									)

									// But still keep track of it otherwise
								} else {
									extra += jQuery.css(
										elem,
										"border" + cssExpand[i] + "Width",
										true,
										styles,
									)
								}

								// If we get here with a border-box (content + padding + border), we're seeking "content" or
								// "padding" or "margin"
							} else {
								// For "content", subtract padding
								if (box === "content") {
									delta -= jQuery.css(
										elem,
										"padding" + cssExpand[i],
										true,
										styles,
									)
								}

								// For "content" or "padding", subtract border
								if (box !== "margin") {
									delta -= jQuery.css(
										elem,
										"border" + cssExpand[i] + "Width",
										true,
										styles,
									)
								}
							}
						}

						// Account for positive content-box scroll gutter when requested by providing computedVal
						if (!isBorderBox && computedVal >= 0) {
							// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
							// Assuming integer scroll gutter, subtract the rest and round down
							delta +=
								Math.max(
									0,
									Math.ceil(
										elem[
											"offset" + dimension[0].toUpperCase() + dimension.slice(1)
										] -
											computedVal -
											delta -
											extra -
											0.5,

										// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
										// Use an explicit zero to avoid NaN (gh-3964)
									),
								) || 0
						}

						return delta
					}

					function getWidthOrHeight(elem, dimension, extra) {
						// Start with computed style
						var styles = getStyles(elem),
							// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
							// Fake content-box until we know it's needed to know the true value.
							boxSizingNeeded = !support.boxSizingReliable() || extra,
							isBorderBox =
								boxSizingNeeded &&
								jQuery.css(elem, "boxSizing", false, styles) === "border-box",
							valueIsBorderBox = isBorderBox,
							val = curCSS(elem, dimension, styles),
							offsetProp =
								"offset" + dimension[0].toUpperCase() + dimension.slice(1)

						// Support: Firefox <=54
						// Return a confounding non-pixel value or feign ignorance, as appropriate.
						if (rnumnonpx.test(val)) {
							if (!extra) {
								return val
							}
							val = "auto"
						}

						// Support: IE 9 - 11 only
						// Use offsetWidth/offsetHeight for when box sizing is unreliable.
						// In those cases, the computed value can be trusted to be border-box.
						if (
							((!support.boxSizingReliable() && isBorderBox) ||
								// Support: IE 10 - 11+, Edge 15 - 18+
								// IE/Edge misreport `getComputedStyle` of table rows with width/height
								// set in CSS while `offset*` properties report correct values.
								// Interestingly, in some cases IE 9 doesn't suffer from this issue.
								(!support.reliableTrDimensions() && nodeName(elem, "tr")) ||
								// Fall back to offsetWidth/offsetHeight when value is "auto"
								// This happens for inline elements with no explicit setting (gh-3571)
								val === "auto" ||
								// Support: Android <=4.1 - 4.3 only
								// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
								(!parseFloat(val) &&
									jQuery.css(elem, "display", false, styles) === "inline")) &&
							// Make sure the element is visible & connected
							elem.getClientRects().length
						) {
							isBorderBox =
								jQuery.css(elem, "boxSizing", false, styles) === "border-box"

							// Where available, offsetWidth/offsetHeight approximate border box dimensions.
							// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
							// retrieved value as a content box dimension.
							valueIsBorderBox = offsetProp in elem
							if (valueIsBorderBox) {
								val = elem[offsetProp]
							}
						}

						// Normalize "" and auto
						val = parseFloat(val) || 0

						// Adjust for the element's box model
						return (
							val +
							boxModelAdjustment(
								elem,
								dimension,
								extra || (isBorderBox ? "border" : "content"),
								valueIsBorderBox,
								styles,

								// Provide the current computed size to request scroll gutter calculation (gh-3589)
								val,
							) +
							"px"
						)
					}

					jQuery.extend({
						// Add in style property hooks for overriding the default
						// behavior of getting and setting a style property
						cssHooks: {
							opacity: {
								get: function (elem, computed) {
									if (computed) {
										// We should always get a number back from opacity
										var ret = curCSS(elem, "opacity")
										return ret === "" ? "1" : ret
									}
								},
							},
						},

						// Don't automatically add "px" to these possibly-unitless properties
						cssNumber: {
							animationIterationCount: true,
							columnCount: true,
							fillOpacity: true,
							flexGrow: true,
							flexShrink: true,
							fontWeight: true,
							gridArea: true,
							gridColumn: true,
							gridColumnEnd: true,
							gridColumnStart: true,
							gridRow: true,
							gridRowEnd: true,
							gridRowStart: true,
							lineHeight: true,
							opacity: true,
							order: true,
							orphans: true,
							widows: true,
							zIndex: true,
							zoom: true,
						},

						// Add in properties whose names you wish to fix before
						// setting or getting the value
						cssProps: {},

						// Get and set the style property on a DOM Node
						style: function (elem, name, value, extra) {
							// Don't set styles on text and comment nodes
							if (
								!elem ||
								elem.nodeType === 3 ||
								elem.nodeType === 8 ||
								!elem.style
							) {
								return
							}

							// Make sure that we're working with the right name
							var ret,
								type,
								hooks,
								origName = camelCase(name),
								isCustomProp = rcustomProp.test(name),
								style = elem.style

							// Make sure that we're working with the right name. We don't
							// want to query the value if it is a CSS custom property
							// since they are user-defined.
							if (!isCustomProp) {
								name = finalPropName(origName)
							}

							// Gets hook for the prefixed version, then unprefixed version
							hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]

							// Check if we're setting a value
							if (value !== undefined) {
								type = typeof value

								// Convert "+=" or "-=" to relative numbers (#7345)
								if (
									type === "string" &&
									(ret = rcssNum.exec(value)) &&
									ret[1]
								) {
									value = adjustCSS(elem, name, ret)

									// Fixes bug #9237
									type = "number"
								}

								// Make sure that null and NaN values aren't set (#7116)
								if (value == null || value !== value) {
									return
								}

								// If a number was passed in, add the unit (except for certain CSS properties)
								// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
								// "px" to a few hardcoded values.
								if (type === "number" && !isCustomProp) {
									value +=
										(ret && ret[3]) || (jQuery.cssNumber[origName] ? "" : "px")
								}

								// background-* props affect original clone's values
								if (
									!support.clearCloneStyle &&
									value === "" &&
									name.indexOf("background") === 0
								) {
									style[name] = "inherit"
								}

								// If a hook was provided, use that value, otherwise just set the specified value
								if (
									!hooks ||
									!("set" in hooks) ||
									(value = hooks.set(elem, value, extra)) !== undefined
								) {
									if (isCustomProp) {
										style.setProperty(name, value)
									} else {
										style[name] = value
									}
								}
							} else {
								// If a hook was provided get the non-computed value from there
								if (
									hooks &&
									"get" in hooks &&
									(ret = hooks.get(elem, false, extra)) !== undefined
								) {
									return ret
								}

								// Otherwise just get the value from the style object
								return style[name]
							}
						},

						css: function (elem, name, extra, styles) {
							var val,
								num,
								hooks,
								origName = camelCase(name),
								isCustomProp = rcustomProp.test(name)

							// Make sure that we're working with the right name. We don't
							// want to modify the value if it is a CSS custom property
							// since they are user-defined.
							if (!isCustomProp) {
								name = finalPropName(origName)
							}

							// Try prefixed name followed by the unprefixed name
							hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]

							// If a hook was provided get the computed value from there
							if (hooks && "get" in hooks) {
								val = hooks.get(elem, true, extra)
							}

							// Otherwise, if a way to get the computed value exists, use that
							if (val === undefined) {
								val = curCSS(elem, name, styles)
							}

							// Convert "normal" to computed value
							if (val === "normal" && name in cssNormalTransform) {
								val = cssNormalTransform[name]
							}

							// Make numeric if forced or a qualifier was provided and val looks numeric
							if (extra === "" || extra) {
								num = parseFloat(val)
								return extra === true || isFinite(num) ? num || 0 : val
							}

							return val
						},
					})

					jQuery.each(["height", "width"], function (_i, dimension) {
						jQuery.cssHooks[dimension] = {
							get: function (elem, computed, extra) {
								if (computed) {
									// Certain elements can have dimension info if we invisibly show them
									// but it must have a current display style that would benefit
									return rdisplayswap.test(jQuery.css(elem, "display")) &&
										// Support: Safari 8+
										// Table columns in Safari have non-zero offsetWidth & zero
										// getBoundingClientRect().width unless display is changed.
										// Support: IE <=11 only
										// Running getBoundingClientRect on a disconnected node
										// in IE throws an error.
										(!elem.getClientRects().length ||
											!elem.getBoundingClientRect().width)
										? swap(elem, cssShow, function () {
												return getWidthOrHeight(elem, dimension, extra)
										  })
										: getWidthOrHeight(elem, dimension, extra)
								}
							},

							set: function (elem, value, extra) {
								var matches,
									styles = getStyles(elem),
									// Only read styles.position if the test has a chance to fail
									// to avoid forcing a reflow.
									scrollboxSizeBuggy =
										!support.scrollboxSize() && styles.position === "absolute",
									// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
									boxSizingNeeded = scrollboxSizeBuggy || extra,
									isBorderBox =
										boxSizingNeeded &&
										jQuery.css(elem, "boxSizing", false, styles) ===
											"border-box",
									subtract = extra
										? boxModelAdjustment(
												elem,
												dimension,
												extra,
												isBorderBox,
												styles,
										  )
										: 0

								// Account for unreliable border-box dimensions by comparing offset* to computed and
								// faking a content-box to get border and padding (gh-3699)
								if (isBorderBox && scrollboxSizeBuggy) {
									subtract -= Math.ceil(
										elem[
											"offset" + dimension[0].toUpperCase() + dimension.slice(1)
										] -
											parseFloat(styles[dimension]) -
											boxModelAdjustment(
												elem,
												dimension,
												"border",
												false,
												styles,
											) -
											0.5,
									)
								}

								// Convert to pixels if value adjustment is needed
								if (
									subtract &&
									(matches = rcssNum.exec(value)) &&
									(matches[3] || "px") !== "px"
								) {
									elem.style[dimension] = value
									value = jQuery.css(elem, dimension)
								}

								return setPositiveNumber(elem, value, subtract)
							},
						}
					})

					jQuery.cssHooks.marginLeft = addGetHookIf(
						support.reliableMarginLeft,
						function (elem, computed) {
							if (computed) {
								return (
									(parseFloat(curCSS(elem, "marginLeft")) ||
										elem.getBoundingClientRect().left -
											swap(elem, { marginLeft: 0 }, function () {
												return elem.getBoundingClientRect().left
											})) + "px"
								)
							}
						},
					)

					// These hooks are used by animate to expand properties
					jQuery.each(
						{
							margin: "",
							padding: "",
							border: "Width",
						},
						function (prefix, suffix) {
							jQuery.cssHooks[prefix + suffix] = {
								expand: function (value) {
									var i = 0,
										expanded = {},
										// Assumes a single number if not a string
										parts =
											typeof value === "string" ? value.split(" ") : [value]

									for (; i < 4; i++) {
										expanded[prefix + cssExpand[i] + suffix] =
											parts[i] || parts[i - 2] || parts[0]
									}

									return expanded
								},
							}

							if (prefix !== "margin") {
								jQuery.cssHooks[prefix + suffix].set = setPositiveNumber
							}
						},
					)

					jQuery.fn.extend({
						css: function (name, value) {
							return access(
								this,
								function (elem, name, value) {
									var styles,
										len,
										map = {},
										i = 0

									if (Array.isArray(name)) {
										styles = getStyles(elem)
										len = name.length

										for (; i < len; i++) {
											map[name[i]] = jQuery.css(elem, name[i], false, styles)
										}

										return map
									}

									return value !== undefined
										? jQuery.style(elem, name, value)
										: jQuery.css(elem, name)
								},
								name,
								value,
								arguments.length > 1,
							)
						},
					})

					function Tween(elem, options, prop, end, easing) {
						return new Tween.prototype.init(elem, options, prop, end, easing)
					}
					jQuery.Tween = Tween

					Tween.prototype = {
						constructor: Tween,
						init: function (elem, options, prop, end, easing, unit) {
							this.elem = elem
							this.prop = prop
							this.easing = easing || jQuery.easing._default
							this.options = options
							this.start = this.now = this.cur()
							this.end = end
							this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
						},
						cur: function () {
							var hooks = Tween.propHooks[this.prop]

							return hooks && hooks.get
								? hooks.get(this)
								: Tween.propHooks._default.get(this)
						},
						run: function (percent) {
							var eased,
								hooks = Tween.propHooks[this.prop]

							if (this.options.duration) {
								this.pos = eased = jQuery.easing[this.easing](
									percent,
									this.options.duration * percent,
									0,
									1,
									this.options.duration,
								)
							} else {
								this.pos = eased = percent
							}
							this.now = (this.end - this.start) * eased + this.start

							if (this.options.step) {
								this.options.step.call(this.elem, this.now, this)
							}

							if (hooks && hooks.set) {
								hooks.set(this)
							} else {
								Tween.propHooks._default.set(this)
							}
							return this
						},
					}

					Tween.prototype.init.prototype = Tween.prototype

					Tween.propHooks = {
						_default: {
							get: function (tween) {
								var result

								// Use a property on the element directly when it is not a DOM element,
								// or when there is no matching style property that exists.
								if (
									tween.elem.nodeType !== 1 ||
									(tween.elem[tween.prop] != null &&
										tween.elem.style[tween.prop] == null)
								) {
									return tween.elem[tween.prop]
								}

								// Passing an empty string as a 3rd parameter to .css will automatically
								// attempt a parseFloat and fallback to a string if the parse fails.
								// Simple values such as "10px" are parsed to Float;
								// complex values such as "rotate(1rad)" are returned as-is.
								result = jQuery.css(tween.elem, tween.prop, "")

								// Empty strings, null, undefined and "auto" are converted to 0.
								return !result || result === "auto" ? 0 : result
							},
							set: function (tween) {
								// Use step hook for back compat.
								// Use cssHook if its there.
								// Use .style if available and use plain properties where available.
								if (jQuery.fx.step[tween.prop]) {
									jQuery.fx.step[tween.prop](tween)
								} else if (
									tween.elem.nodeType === 1 &&
									(jQuery.cssHooks[tween.prop] ||
										tween.elem.style[finalPropName(tween.prop)] != null)
								) {
									jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
								} else {
									tween.elem[tween.prop] = tween.now
								}
							},
						},
					}

					// Support: IE <=9 only
					// Panic based approach to setting things on disconnected nodes
					Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
						set: function (tween) {
							if (tween.elem.nodeType && tween.elem.parentNode) {
								tween.elem[tween.prop] = tween.now
							}
						},
					}

					jQuery.easing = {
						linear: function (p) {
							return p
						},
						swing: function (p) {
							return 0.5 - Math.cos(p * Math.PI) / 2
						},
						_default: "swing",
					}

					jQuery.fx = Tween.prototype.init

					// Back compat <1.8 extension point
					jQuery.fx.step = {}

					var fxNow,
						inProgress,
						rfxtypes = /^(?:toggle|show|hide)$/,
						rrun = /queueHooks$/

					function schedule() {
						if (inProgress) {
							if (document.hidden === false && window.requestAnimationFrame) {
								window.requestAnimationFrame(schedule)
							} else {
								window.setTimeout(schedule, jQuery.fx.interval)
							}

							jQuery.fx.tick()
						}
					}

					// Animations created synchronously will run synchronously
					function createFxNow() {
						window.setTimeout(function () {
							fxNow = undefined
						})
						return (fxNow = Date.now())
					}

					// Generate parameters to create a standard animation
					function genFx(type, includeWidth) {
						var which,
							i = 0,
							attrs = { height: type }

						// If we include width, step value is 1 to do all cssExpand values,
						// otherwise step value is 2 to skip over Left and Right
						includeWidth = includeWidth ? 1 : 0
						for (; i < 4; i += 2 - includeWidth) {
							which = cssExpand[i]
							attrs["margin" + which] = attrs["padding" + which] = type
						}

						if (includeWidth) {
							attrs.opacity = attrs.width = type
						}

						return attrs
					}

					function createTween(value, prop, animation) {
						var tween,
							collection = (Animation.tweeners[prop] || []).concat(
								Animation.tweeners["*"],
							),
							index = 0,
							length = collection.length
						for (; index < length; index++) {
							if ((tween = collection[index].call(animation, prop, value))) {
								// We're done with this property
								return tween
							}
						}
					}

					function defaultPrefilter(elem, props, opts) {
						var prop,
							value,
							toggle,
							hooks,
							oldfire,
							propTween,
							restoreDisplay,
							display,
							isBox = "width" in props || "height" in props,
							anim = this,
							orig = {},
							style = elem.style,
							hidden = elem.nodeType && isHiddenWithinTree(elem),
							dataShow = dataPriv.get(elem, "fxshow")

						// Queue-skipping animations hijack the fx hooks
						if (!opts.queue) {
							hooks = jQuery._queueHooks(elem, "fx")
							if (hooks.unqueued == null) {
								hooks.unqueued = 0
								oldfire = hooks.empty.fire
								hooks.empty.fire = function () {
									if (!hooks.unqueued) {
										oldfire()
									}
								}
							}
							hooks.unqueued++

							anim.always(function () {
								// Ensure the complete handler is called before this completes
								anim.always(function () {
									hooks.unqueued--
									if (!jQuery.queue(elem, "fx").length) {
										hooks.empty.fire()
									}
								})
							})
						}

						// Detect show/hide animations
						for (prop in props) {
							value = props[prop]
							if (rfxtypes.test(value)) {
								delete props[prop]
								toggle = toggle || value === "toggle"
								if (value === (hidden ? "hide" : "show")) {
									// Pretend to be hidden if this is a "show" and
									// there is still data from a stopped show/hide
									if (
										value === "show" &&
										dataShow &&
										dataShow[prop] !== undefined
									) {
										hidden = true

										// Ignore all other no-op show/hide data
									} else {
										continue
									}
								}
								orig[prop] =
									(dataShow && dataShow[prop]) || jQuery.style(elem, prop)
							}
						}

						// Bail out if this is a no-op like .hide().hide()
						propTween = !jQuery.isEmptyObject(props)
						if (!propTween && jQuery.isEmptyObject(orig)) {
							return
						}

						// Restrict "overflow" and "display" styles during box animations
						if (isBox && elem.nodeType === 1) {
							// Support: IE <=9 - 11, Edge 12 - 15
							// Record all 3 overflow attributes because IE does not infer the shorthand
							// from identically-valued overflowX and overflowY and Edge just mirrors
							// the overflowX value there.
							opts.overflow = [style.overflow, style.overflowX, style.overflowY]

							// Identify a display type, preferring old show/hide data over the CSS cascade
							restoreDisplay = dataShow && dataShow.display
							if (restoreDisplay == null) {
								restoreDisplay = dataPriv.get(elem, "display")
							}
							display = jQuery.css(elem, "display")
							if (display === "none") {
								if (restoreDisplay) {
									display = restoreDisplay
								} else {
									// Get nonempty value(s) by temporarily forcing visibility
									showHide([elem], true)
									restoreDisplay = elem.style.display || restoreDisplay
									display = jQuery.css(elem, "display")
									showHide([elem])
								}
							}

							// Animate inline elements as inline-block
							if (
								display === "inline" ||
								(display === "inline-block" && restoreDisplay != null)
							) {
								if (jQuery.css(elem, "float") === "none") {
									// Restore the original display value at the end of pure show/hide animations
									if (!propTween) {
										anim.done(function () {
											style.display = restoreDisplay
										})
										if (restoreDisplay == null) {
											display = style.display
											restoreDisplay = display === "none" ? "" : display
										}
									}
									style.display = "inline-block"
								}
							}
						}

						if (opts.overflow) {
							style.overflow = "hidden"
							anim.always(function () {
								style.overflow = opts.overflow[0]
								style.overflowX = opts.overflow[1]
								style.overflowY = opts.overflow[2]
							})
						}

						// Implement show/hide animations
						propTween = false
						for (prop in orig) {
							// General show/hide setup for this element animation
							if (!propTween) {
								if (dataShow) {
									if ("hidden" in dataShow) {
										hidden = dataShow.hidden
									}
								} else {
									dataShow = dataPriv.access(elem, "fxshow", {
										display: restoreDisplay,
									})
								}

								// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
								if (toggle) {
									dataShow.hidden = !hidden
								}

								// Show elements before animating them
								if (hidden) {
									showHide([elem], true)
								}

								/* eslint-disable no-loop-func */

								anim.done(function () {
									/* eslint-enable no-loop-func */

									// The final step of a "hide" animation is actually hiding the element
									if (!hidden) {
										showHide([elem])
									}
									dataPriv.remove(elem, "fxshow")
									for (prop in orig) {
										jQuery.style(elem, prop, orig[prop])
									}
								})
							}

							// Per-property setup
							propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim)
							if (!(prop in dataShow)) {
								dataShow[prop] = propTween.start
								if (hidden) {
									propTween.end = propTween.start
									propTween.start = 0
								}
							}
						}
					}

					function propFilter(props, specialEasing) {
						var index, name, easing, value, hooks

						// camelCase, specialEasing and expand cssHook pass
						for (index in props) {
							name = camelCase(index)
							easing = specialEasing[name]
							value = props[index]
							if (Array.isArray(value)) {
								easing = value[1]
								value = props[index] = value[0]
							}

							if (index !== name) {
								props[name] = value
								delete props[index]
							}

							hooks = jQuery.cssHooks[name]
							if (hooks && "expand" in hooks) {
								value = hooks.expand(value)
								delete props[name]

								// Not quite $.extend, this won't overwrite existing keys.
								// Reusing 'index' because we have the correct "name"
								for (index in value) {
									if (!(index in props)) {
										props[index] = value[index]
										specialEasing[index] = easing
									}
								}
							} else {
								specialEasing[name] = easing
							}
						}
					}

					function Animation(elem, properties, options) {
						var result,
							stopped,
							index = 0,
							length = Animation.prefilters.length,
							deferred = jQuery.Deferred().always(function () {
								// Don't match elem in the :animated selector
								delete tick.elem
							}),
							tick = function () {
								if (stopped) {
									return false
								}
								var currentTime = fxNow || createFxNow(),
									remaining = Math.max(
										0,
										animation.startTime + animation.duration - currentTime,
									),
									// Support: Android 2.3 only
									// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
									temp = remaining / animation.duration || 0,
									percent = 1 - temp,
									index = 0,
									length = animation.tweens.length

								for (; index < length; index++) {
									animation.tweens[index].run(percent)
								}

								deferred.notifyWith(elem, [animation, percent, remaining])

								// If there's more to do, yield
								if (percent < 1 && length) {
									return remaining
								}

								// If this was an empty animation, synthesize a final progress notification
								if (!length) {
									deferred.notifyWith(elem, [animation, 1, 0])
								}

								// Resolve the animation and report its conclusion
								deferred.resolveWith(elem, [animation])
								return false
							},
							animation = deferred.promise({
								elem: elem,
								props: jQuery.extend({}, properties),
								opts: jQuery.extend(
									true,
									{
										specialEasing: {},
										easing: jQuery.easing._default,
									},
									options,
								),
								originalProperties: properties,
								originalOptions: options,
								startTime: fxNow || createFxNow(),
								duration: options.duration,
								tweens: [],
								createTween: function (prop, end) {
									var tween = jQuery.Tween(
										elem,
										animation.opts,
										prop,
										end,
										animation.opts.specialEasing[prop] || animation.opts.easing,
									)
									animation.tweens.push(tween)
									return tween
								},
								stop: function (gotoEnd) {
									var index = 0,
										// If we are going to the end, we want to run all the tweens
										// otherwise we skip this part
										length = gotoEnd ? animation.tweens.length : 0
									if (stopped) {
										return this
									}
									stopped = true
									for (; index < length; index++) {
										animation.tweens[index].run(1)
									}

									// Resolve when we played the last frame; otherwise, reject
									if (gotoEnd) {
										deferred.notifyWith(elem, [animation, 1, 0])
										deferred.resolveWith(elem, [animation, gotoEnd])
									} else {
										deferred.rejectWith(elem, [animation, gotoEnd])
									}
									return this
								},
							}),
							props = animation.props

						propFilter(props, animation.opts.specialEasing)

						for (; index < length; index++) {
							result = Animation.prefilters[index].call(
								animation,
								elem,
								props,
								animation.opts,
							)
							if (result) {
								if (isFunction(result.stop)) {
									jQuery._queueHooks(
										animation.elem,
										animation.opts.queue,
									).stop = result.stop.bind(result)
								}
								return result
							}
						}

						jQuery.map(props, createTween, animation)

						if (isFunction(animation.opts.start)) {
							animation.opts.start.call(elem, animation)
						}

						// Attach callbacks from options
						animation
							.progress(animation.opts.progress)
							.done(animation.opts.done, animation.opts.complete)
							.fail(animation.opts.fail)
							.always(animation.opts.always)

						jQuery.fx.timer(
							jQuery.extend(tick, {
								elem: elem,
								anim: animation,
								queue: animation.opts.queue,
							}),
						)

						return animation
					}

					jQuery.Animation = jQuery.extend(Animation, {
						tweeners: {
							"*": [
								function (prop, value) {
									var tween = this.createTween(prop, value)
									adjustCSS(tween.elem, prop, rcssNum.exec(value), tween)
									return tween
								},
							],
						},

						tweener: function (props, callback) {
							if (isFunction(props)) {
								callback = props
								props = ["*"]
							} else {
								props = props.match(rnothtmlwhite)
							}

							var prop,
								index = 0,
								length = props.length

							for (; index < length; index++) {
								prop = props[index]
								Animation.tweeners[prop] = Animation.tweeners[prop] || []
								Animation.tweeners[prop].unshift(callback)
							}
						},

						prefilters: [defaultPrefilter],

						prefilter: function (callback, prepend) {
							if (prepend) {
								Animation.prefilters.unshift(callback)
							} else {
								Animation.prefilters.push(callback)
							}
						},
					})

					jQuery.speed = function (speed, easing, fn) {
						var opt =
							speed && typeof speed === "object"
								? jQuery.extend({}, speed)
								: {
										complete:
											fn || (!fn && easing) || (isFunction(speed) && speed),
										duration: speed,
										easing:
											(fn && easing) ||
											(easing && !isFunction(easing) && easing),
								  }

						// Go to the end state if fx are off
						if (jQuery.fx.off) {
							opt.duration = 0
						} else {
							if (typeof opt.duration !== "number") {
								if (opt.duration in jQuery.fx.speeds) {
									opt.duration = jQuery.fx.speeds[opt.duration]
								} else {
									opt.duration = jQuery.fx.speeds._default
								}
							}
						}

						// Normalize opt.queue - true/undefined/null -> "fx"
						if (opt.queue == null || opt.queue === true) {
							opt.queue = "fx"
						}

						// Queueing
						opt.old = opt.complete

						opt.complete = function () {
							if (isFunction(opt.old)) {
								opt.old.call(this)
							}

							if (opt.queue) {
								jQuery.dequeue(this, opt.queue)
							}
						}

						return opt
					}

					jQuery.fn.extend({
						fadeTo: function (speed, to, easing, callback) {
							// Show any hidden elements after setting opacity to 0
							return (
								this.filter(isHiddenWithinTree)
									.css("opacity", 0)
									.show()

									// Animate to the value specified
									.end()
									.animate({ opacity: to }, speed, easing, callback)
							)
						},
						animate: function (prop, speed, easing, callback) {
							var empty = jQuery.isEmptyObject(prop),
								optall = jQuery.speed(speed, easing, callback),
								doAnimation = function () {
									// Operate on a copy of prop so per-property easing won't be lost
									var anim = Animation(this, jQuery.extend({}, prop), optall)

									// Empty animations, or finishing resolves immediately
									if (empty || dataPriv.get(this, "finish")) {
										anim.stop(true)
									}
								}
							doAnimation.finish = doAnimation

							return empty || optall.queue === false
								? this.each(doAnimation)
								: this.queue(optall.queue, doAnimation)
						},
						stop: function (type, clearQueue, gotoEnd) {
							var stopQueue = function (hooks) {
								var stop = hooks.stop
								delete hooks.stop
								stop(gotoEnd)
							}

							if (typeof type !== "string") {
								gotoEnd = clearQueue
								clearQueue = type
								type = undefined
							}
							if (clearQueue) {
								this.queue(type || "fx", [])
							}

							return this.each(function () {
								var dequeue = true,
									index = type != null && type + "queueHooks",
									timers = jQuery.timers,
									data = dataPriv.get(this)

								if (index) {
									if (data[index] && data[index].stop) {
										stopQueue(data[index])
									}
								} else {
									for (index in data) {
										if (data[index] && data[index].stop && rrun.test(index)) {
											stopQueue(data[index])
										}
									}
								}

								for (index = timers.length; index--; ) {
									if (
										timers[index].elem === this &&
										(type == null || timers[index].queue === type)
									) {
										timers[index].anim.stop(gotoEnd)
										dequeue = false
										timers.splice(index, 1)
									}
								}

								// Start the next in the queue if the last step wasn't forced.
								// Timers currently will call their complete callbacks, which
								// will dequeue but only if they were gotoEnd.
								if (dequeue || !gotoEnd) {
									jQuery.dequeue(this, type)
								}
							})
						},
						finish: function (type) {
							if (type !== false) {
								type = type || "fx"
							}
							return this.each(function () {
								var index,
									data = dataPriv.get(this),
									queue = data[type + "queue"],
									hooks = data[type + "queueHooks"],
									timers = jQuery.timers,
									length = queue ? queue.length : 0

								// Enable finishing flag on private data
								data.finish = true

								// Empty the queue first
								jQuery.queue(this, type, [])

								if (hooks && hooks.stop) {
									hooks.stop.call(this, true)
								}

								// Look for any active animations, and finish them
								for (index = timers.length; index--; ) {
									if (
										timers[index].elem === this &&
										timers[index].queue === type
									) {
										timers[index].anim.stop(true)
										timers.splice(index, 1)
									}
								}

								// Look for any animations in the old queue and finish them
								for (index = 0; index < length; index++) {
									if (queue[index] && queue[index].finish) {
										queue[index].finish.call(this)
									}
								}

								// Turn off finishing flag
								delete data.finish
							})
						},
					})

					jQuery.each(["toggle", "show", "hide"], function (_i, name) {
						var cssFn = jQuery.fn[name]
						jQuery.fn[name] = function (speed, easing, callback) {
							return speed == null || typeof speed === "boolean"
								? cssFn.apply(this, arguments)
								: this.animate(genFx(name, true), speed, easing, callback)
						}
					})

					// Generate shortcuts for custom animations
					jQuery.each(
						{
							slideDown: genFx("show"),
							slideUp: genFx("hide"),
							slideToggle: genFx("toggle"),
							fadeIn: { opacity: "show" },
							fadeOut: { opacity: "hide" },
							fadeToggle: { opacity: "toggle" },
						},
						function (name, props) {
							jQuery.fn[name] = function (speed, easing, callback) {
								return this.animate(props, speed, easing, callback)
							}
						},
					)

					jQuery.timers = []
					jQuery.fx.tick = function () {
						var timer,
							i = 0,
							timers = jQuery.timers

						fxNow = Date.now()

						for (; i < timers.length; i++) {
							timer = timers[i]

							// Run the timer and safely remove it when done (allowing for external removal)
							if (!timer() && timers[i] === timer) {
								timers.splice(i--, 1)
							}
						}

						if (!timers.length) {
							jQuery.fx.stop()
						}
						fxNow = undefined
					}

					jQuery.fx.timer = function (timer) {
						jQuery.timers.push(timer)
						jQuery.fx.start()
					}

					jQuery.fx.interval = 13
					jQuery.fx.start = function () {
						if (inProgress) {
							return
						}

						inProgress = true
						schedule()
					}

					jQuery.fx.stop = function () {
						inProgress = null
					}

					jQuery.fx.speeds = {
						slow: 600,
						fast: 200,

						// Default speed
						_default: 400,
					}

					// Based off of the plugin by Clint Helfers, with permission.
					// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
					jQuery.fn.delay = function (time, type) {
						time = jQuery.fx ? jQuery.fx.speeds[time] || time : time
						type = type || "fx"

						return this.queue(type, function (next, hooks) {
							var timeout = window.setTimeout(next, time)
							hooks.stop = function () {
								window.clearTimeout(timeout)
							}
						})
					}

					;(function () {
						var input = document.createElement("input"),
							select = document.createElement("select"),
							opt = select.appendChild(document.createElement("option"))

						input.type = "checkbox"

						// Support: Android <=4.3 only
						// Default value for a checkbox should be "on"
						support.checkOn = input.value !== ""

						// Support: IE <=11 only
						// Must access selectedIndex to make default options select
						support.optSelected = opt.selected

						// Support: IE <=11 only
						// An input loses its value after becoming a radio
						input = document.createElement("input")
						input.value = "t"
						input.type = "radio"
						support.radioValue = input.value === "t"
					})()

					var boolHook,
						attrHandle = jQuery.expr.attrHandle

					jQuery.fn.extend({
						attr: function (name, value) {
							return access(
								this,
								jQuery.attr,
								name,
								value,
								arguments.length > 1,
							)
						},

						removeAttr: function (name) {
							return this.each(function () {
								jQuery.removeAttr(this, name)
							})
						},
					})

					jQuery.extend({
						attr: function (elem, name, value) {
							var ret,
								hooks,
								nType = elem.nodeType

							// Don't get/set attributes on text, comment and attribute nodes
							if (nType === 3 || nType === 8 || nType === 2) {
								return
							}

							// Fallback to prop when attributes are not supported
							if (typeof elem.getAttribute === "undefined") {
								return jQuery.prop(elem, name, value)
							}

							// Attribute hooks are determined by the lowercase version
							// Grab necessary hook if one is defined
							if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
								hooks =
									jQuery.attrHooks[name.toLowerCase()] ||
									(jQuery.expr.match.bool.test(name) ? boolHook : undefined)
							}

							if (value !== undefined) {
								if (value === null) {
									jQuery.removeAttr(elem, name)
									return
								}

								if (
									hooks &&
									"set" in hooks &&
									(ret = hooks.set(elem, value, name)) !== undefined
								) {
									return ret
								}

								elem.setAttribute(name, value + "")
								return value
							}

							if (
								hooks &&
								"get" in hooks &&
								(ret = hooks.get(elem, name)) !== null
							) {
								return ret
							}

							ret = jQuery.find.attr(elem, name)

							// Non-existent attributes return null, we normalize to undefined
							return ret == null ? undefined : ret
						},

						attrHooks: {
							type: {
								set: function (elem, value) {
									if (
										!support.radioValue &&
										value === "radio" &&
										nodeName(elem, "input")
									) {
										var val = elem.value
										elem.setAttribute("type", value)
										if (val) {
											elem.value = val
										}
										return value
									}
								},
							},
						},

						removeAttr: function (elem, value) {
							var name,
								i = 0,
								// Attribute names can contain non-HTML whitespace characters
								// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
								attrNames = value && value.match(rnothtmlwhite)

							if (attrNames && elem.nodeType === 1) {
								while ((name = attrNames[i++])) {
									elem.removeAttribute(name)
								}
							}
						},
					})

					// Hooks for boolean attributes
					boolHook = {
						set: function (elem, value, name) {
							if (value === false) {
								// Remove boolean attributes when set to false
								jQuery.removeAttr(elem, name)
							} else {
								elem.setAttribute(name, name)
							}
							return name
						},
					}

					jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (
						_i,
						name,
					) {
						var getter = attrHandle[name] || jQuery.find.attr

						attrHandle[name] = function (elem, name, isXML) {
							var ret,
								handle,
								lowercaseName = name.toLowerCase()

							if (!isXML) {
								// Avoid an infinite loop by temporarily removing this function from the getter
								handle = attrHandle[lowercaseName]
								attrHandle[lowercaseName] = ret
								ret = getter(elem, name, isXML) != null ? lowercaseName : null
								attrHandle[lowercaseName] = handle
							}
							return ret
						}
					})

					var rfocusable = /^(?:input|select|textarea|button)$/i,
						rclickable = /^(?:a|area)$/i

					jQuery.fn.extend({
						prop: function (name, value) {
							return access(
								this,
								jQuery.prop,
								name,
								value,
								arguments.length > 1,
							)
						},

						removeProp: function (name) {
							return this.each(function () {
								delete this[jQuery.propFix[name] || name]
							})
						},
					})

					jQuery.extend({
						prop: function (elem, name, value) {
							var ret,
								hooks,
								nType = elem.nodeType

							// Don't get/set properties on text, comment and attribute nodes
							if (nType === 3 || nType === 8 || nType === 2) {
								return
							}

							if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
								// Fix name and attach hooks
								name = jQuery.propFix[name] || name
								hooks = jQuery.propHooks[name]
							}

							if (value !== undefined) {
								if (
									hooks &&
									"set" in hooks &&
									(ret = hooks.set(elem, value, name)) !== undefined
								) {
									return ret
								}

								return (elem[name] = value)
							}

							if (
								hooks &&
								"get" in hooks &&
								(ret = hooks.get(elem, name)) !== null
							) {
								return ret
							}

							return elem[name]
						},

						propHooks: {
							tabIndex: {
								get: function (elem) {
									// Support: IE <=9 - 11 only
									// elem.tabIndex doesn't always return the
									// correct value when it hasn't been explicitly set
									// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
									// Use proper attribute retrieval(#12072)
									var tabindex = jQuery.find.attr(elem, "tabindex")

									if (tabindex) {
										return parseInt(tabindex, 10)
									}

									if (
										rfocusable.test(elem.nodeName) ||
										(rclickable.test(elem.nodeName) && elem.href)
									) {
										return 0
									}

									return -1
								},
							},
						},

						propFix: {
							for: "htmlFor",
							class: "className",
						},
					})

					// Support: IE <=11 only
					// Accessing the selectedIndex property
					// forces the browser to respect setting selected
					// on the option
					// The getter ensures a default option is selected
					// when in an optgroup
					// eslint rule "no-unused-expressions" is disabled for this code
					// since it considers such accessions noop
					if (!support.optSelected) {
						jQuery.propHooks.selected = {
							get: function (elem) {
								/* eslint no-unused-expressions: "off" */

								var parent = elem.parentNode
								if (parent && parent.parentNode) {
									parent.parentNode.selectedIndex
								}
								return null
							},
							set: function (elem) {
								/* eslint no-unused-expressions: "off" */

								var parent = elem.parentNode
								if (parent) {
									parent.selectedIndex

									if (parent.parentNode) {
										parent.parentNode.selectedIndex
									}
								}
							},
						}
					}

					jQuery.each(
						[
							"tabIndex",
							"readOnly",
							"maxLength",
							"cellSpacing",
							"cellPadding",
							"rowSpan",
							"colSpan",
							"useMap",
							"frameBorder",
							"contentEditable",
						],
						function () {
							jQuery.propFix[this.toLowerCase()] = this
						},
					)

					// Strip and collapse whitespace according to HTML spec
					// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
					function stripAndCollapse(value) {
						var tokens = value.match(rnothtmlwhite) || []
						return tokens.join(" ")
					}

					function getClass(elem) {
						return (elem.getAttribute && elem.getAttribute("class")) || ""
					}

					function classesToArray(value) {
						if (Array.isArray(value)) {
							return value
						}
						if (typeof value === "string") {
							return value.match(rnothtmlwhite) || []
						}
						return []
					}

					jQuery.fn.extend({
						addClass: function (value) {
							var classes,
								elem,
								cur,
								curValue,
								clazz,
								j,
								finalValue,
								i = 0

							if (isFunction(value)) {
								return this.each(function (j) {
									jQuery(this).addClass(value.call(this, j, getClass(this)))
								})
							}

							classes = classesToArray(value)

							if (classes.length) {
								while ((elem = this[i++])) {
									curValue = getClass(elem)
									cur =
										elem.nodeType === 1 &&
										" " + stripAndCollapse(curValue) + " "

									if (cur) {
										j = 0
										while ((clazz = classes[j++])) {
											if (cur.indexOf(" " + clazz + " ") < 0) {
												cur += clazz + " "
											}
										}

										// Only assign if different to avoid unneeded rendering.
										finalValue = stripAndCollapse(cur)
										if (curValue !== finalValue) {
											elem.setAttribute("class", finalValue)
										}
									}
								}
							}

							return this
						},

						removeClass: function (value) {
							var classes,
								elem,
								cur,
								curValue,
								clazz,
								j,
								finalValue,
								i = 0

							if (isFunction(value)) {
								return this.each(function (j) {
									jQuery(this).removeClass(value.call(this, j, getClass(this)))
								})
							}

							if (!arguments.length) {
								return this.attr("class", "")
							}

							classes = classesToArray(value)

							if (classes.length) {
								while ((elem = this[i++])) {
									curValue = getClass(elem)

									// This expression is here for better compressibility (see addClass)
									cur =
										elem.nodeType === 1 &&
										" " + stripAndCollapse(curValue) + " "

									if (cur) {
										j = 0
										while ((clazz = classes[j++])) {
											// Remove *all* instances
											while (cur.indexOf(" " + clazz + " ") > -1) {
												cur = cur.replace(" " + clazz + " ", " ")
											}
										}

										// Only assign if different to avoid unneeded rendering.
										finalValue = stripAndCollapse(cur)
										if (curValue !== finalValue) {
											elem.setAttribute("class", finalValue)
										}
									}
								}
							}

							return this
						},

						toggleClass: function (value, stateVal) {
							var type = typeof value,
								isValidValue = type === "string" || Array.isArray(value)

							if (typeof stateVal === "boolean" && isValidValue) {
								return stateVal ? this.addClass(value) : this.removeClass(value)
							}

							if (isFunction(value)) {
								return this.each(function (i) {
									jQuery(this).toggleClass(
										value.call(this, i, getClass(this), stateVal),
										stateVal,
									)
								})
							}

							return this.each(function () {
								var className, i, self, classNames

								if (isValidValue) {
									// Toggle individual class names
									i = 0
									self = jQuery(this)
									classNames = classesToArray(value)

									while ((className = classNames[i++])) {
										// Check each className given, space separated list
										if (self.hasClass(className)) {
											self.removeClass(className)
										} else {
											self.addClass(className)
										}
									}

									// Toggle whole class name
								} else if (value === undefined || type === "boolean") {
									className = getClass(this)
									if (className) {
										// Store className if set
										dataPriv.set(this, "__className__", className)
									}

									// If the element has a class name or if we're passed `false`,
									// then remove the whole classname (if there was one, the above saved it).
									// Otherwise bring back whatever was previously saved (if anything),
									// falling back to the empty string if nothing was stored.
									if (this.setAttribute) {
										this.setAttribute(
											"class",
											className || value === false
												? ""
												: dataPriv.get(this, "__className__") || "",
										)
									}
								}
							})
						},

						hasClass: function (selector) {
							var className,
								elem,
								i = 0

							className = " " + selector + " "
							while ((elem = this[i++])) {
								if (
									elem.nodeType === 1 &&
									(" " + stripAndCollapse(getClass(elem)) + " ").indexOf(
										className,
									) > -1
								) {
									return true
								}
							}

							return false
						},
					})

					var rreturn = /\r/g

					jQuery.fn.extend({
						val: function (value) {
							var hooks,
								ret,
								valueIsFunction,
								elem = this[0]

							if (!arguments.length) {
								if (elem) {
									hooks =
										jQuery.valHooks[elem.type] ||
										jQuery.valHooks[elem.nodeName.toLowerCase()]

									if (
										hooks &&
										"get" in hooks &&
										(ret = hooks.get(elem, "value")) !== undefined
									) {
										return ret
									}

									ret = elem.value

									// Handle most common string cases
									if (typeof ret === "string") {
										return ret.replace(rreturn, "")
									}

									// Handle cases where value is null/undef or number
									return ret == null ? "" : ret
								}

								return
							}

							valueIsFunction = isFunction(value)

							return this.each(function (i) {
								var val

								if (this.nodeType !== 1) {
									return
								}

								if (valueIsFunction) {
									val = value.call(this, i, jQuery(this).val())
								} else {
									val = value
								}

								// Treat null/undefined as ""; convert numbers to string
								if (val == null) {
									val = ""
								} else if (typeof val === "number") {
									val += ""
								} else if (Array.isArray(val)) {
									val = jQuery.map(val, function (value) {
										return value == null ? "" : value + ""
									})
								}

								hooks =
									jQuery.valHooks[this.type] ||
									jQuery.valHooks[this.nodeName.toLowerCase()]

								// If set returns undefined, fall back to normal setting
								if (
									!hooks ||
									!("set" in hooks) ||
									hooks.set(this, val, "value") === undefined
								) {
									this.value = val
								}
							})
						},
					})

					jQuery.extend({
						valHooks: {
							option: {
								get: function (elem) {
									var val = jQuery.find.attr(elem, "value")
									return val != null
										? val
										: // Support: IE <=10 - 11 only
										  // option.text throws exceptions (#14686, #14858)
										  // Strip and collapse whitespace
										  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
										  stripAndCollapse(jQuery.text(elem))
								},
							},
							select: {
								get: function (elem) {
									var value,
										option,
										i,
										options = elem.options,
										index = elem.selectedIndex,
										one = elem.type === "select-one",
										values = one ? null : [],
										max = one ? index + 1 : options.length

									if (index < 0) {
										i = max
									} else {
										i = one ? index : 0
									}

									// Loop through all the selected options
									for (; i < max; i++) {
										option = options[i]

										// Support: IE <=9 only
										// IE8-9 doesn't update selected after form reset (#2551)
										if (
											(option.selected || i === index) &&
											// Don't return options that are disabled or in a disabled optgroup
											!option.disabled &&
											(!option.parentNode.disabled ||
												!nodeName(option.parentNode, "optgroup"))
										) {
											// Get the specific value for the option
											value = jQuery(option).val()

											// We don't need an array for one selects
											if (one) {
												return value
											}

											// Multi-Selects return an array
											values.push(value)
										}
									}

									return values
								},

								set: function (elem, value) {
									var optionSet,
										option,
										options = elem.options,
										values = jQuery.makeArray(value),
										i = options.length

									while (i--) {
										option = options[i]

										/* eslint-disable no-cond-assign */

										if (
											(option.selected =
												jQuery.inArray(
													jQuery.valHooks.option.get(option),
													values,
												) > -1)
										) {
											optionSet = true
										}

										/* eslint-enable no-cond-assign */
									}

									// Force browsers to behave consistently when non-matching value is set
									if (!optionSet) {
										elem.selectedIndex = -1
									}
									return values
								},
							},
						},
					})

					// Radios and checkboxes getter/setter
					jQuery.each(["radio", "checkbox"], function () {
						jQuery.valHooks[this] = {
							set: function (elem, value) {
								if (Array.isArray(value)) {
									return (elem.checked =
										jQuery.inArray(jQuery(elem).val(), value) > -1)
								}
							},
						}
						if (!support.checkOn) {
							jQuery.valHooks[this].get = function (elem) {
								return elem.getAttribute("value") === null ? "on" : elem.value
							}
						}
					})

					// Return jQuery for attributes-only inclusion

					support.focusin = "onfocusin" in window

					var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
						stopPropagationCallback = function (e) {
							e.stopPropagation()
						}

					jQuery.extend(jQuery.event, {
						trigger: function (event, data, elem, onlyHandlers) {
							var i,
								cur,
								tmp,
								bubbleType,
								ontype,
								handle,
								special,
								lastElement,
								eventPath = [elem || document],
								type = hasOwn.call(event, "type") ? event.type : event,
								namespaces = hasOwn.call(event, "namespace")
									? event.namespace.split(".")
									: []

							cur = lastElement = tmp = elem = elem || document

							// Don't do events on text and comment nodes
							if (elem.nodeType === 3 || elem.nodeType === 8) {
								return
							}

							// focus/blur morphs to focusin/out; ensure we're not firing them right now
							if (rfocusMorph.test(type + jQuery.event.triggered)) {
								return
							}

							if (type.indexOf(".") > -1) {
								// Namespaced trigger; create a regexp to match event type in handle()
								namespaces = type.split(".")
								type = namespaces.shift()
								namespaces.sort()
							}
							ontype = type.indexOf(":") < 0 && "on" + type

							// Caller can pass in a jQuery.Event object, Object, or just an event type string
							event = event[jQuery.expando]
								? event
								: new jQuery.Event(type, typeof event === "object" && event)

							// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
							event.isTrigger = onlyHandlers ? 2 : 3
							event.namespace = namespaces.join(".")
							event.rnamespace = event.namespace
								? new RegExp(
										"(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)",
								  )
								: null

							// Clean up the event in case it is being reused
							event.result = undefined
							if (!event.target) {
								event.target = elem
							}

							// Clone any incoming data and prepend the event, creating the handler arg list
							data = data == null ? [event] : jQuery.makeArray(data, [event])

							// Allow special events to draw outside the lines
							special = jQuery.event.special[type] || {}
							if (
								!onlyHandlers &&
								special.trigger &&
								special.trigger.apply(elem, data) === false
							) {
								return
							}

							// Determine event propagation path in advance, per W3C events spec (#9951)
							// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
							if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
								bubbleType = special.delegateType || type
								if (!rfocusMorph.test(bubbleType + type)) {
									cur = cur.parentNode
								}
								for (; cur; cur = cur.parentNode) {
									eventPath.push(cur)
									tmp = cur
								}

								// Only add window if we got to document (e.g., not plain obj or detached DOM)
								if (tmp === (elem.ownerDocument || document)) {
									eventPath.push(tmp.defaultView || tmp.parentWindow || window)
								}
							}

							// Fire handlers on the event path
							i = 0
							while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
								lastElement = cur
								event.type = i > 1 ? bubbleType : special.bindType || type

								// jQuery handler
								handle =
									(dataPriv.get(cur, "events") || Object.create(null))[
										event.type
									] && dataPriv.get(cur, "handle")
								if (handle) {
									handle.apply(cur, data)
								}

								// Native handler
								handle = ontype && cur[ontype]
								if (handle && handle.apply && acceptData(cur)) {
									event.result = handle.apply(cur, data)
									if (event.result === false) {
										event.preventDefault()
									}
								}
							}
							event.type = type

							// If nobody prevented the default action, do it now
							if (!onlyHandlers && !event.isDefaultPrevented()) {
								if (
									(!special._default ||
										special._default.apply(eventPath.pop(), data) === false) &&
									acceptData(elem)
								) {
									// Call a native DOM method on the target with the same name as the event.
									// Don't do default actions on window, that's where global variables be (#6170)
									if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
										// Don't re-trigger an onFOO event when we call its FOO() method
										tmp = elem[ontype]

										if (tmp) {
											elem[ontype] = null
										}

										// Prevent re-triggering of the same event, since we already bubbled it above
										jQuery.event.triggered = type

										if (event.isPropagationStopped()) {
											lastElement.addEventListener(
												type,
												stopPropagationCallback,
											)
										}

										elem[type]()

										if (event.isPropagationStopped()) {
											lastElement.removeEventListener(
												type,
												stopPropagationCallback,
											)
										}

										jQuery.event.triggered = undefined

										if (tmp) {
											elem[ontype] = tmp
										}
									}
								}
							}

							return event.result
						},

						// Piggyback on a donor event to simulate a different one
						// Used only for `focus(in | out)` events
						simulate: function (type, elem, event) {
							var e = jQuery.extend(new jQuery.Event(), event, {
								type: type,
								isSimulated: true,
							})

							jQuery.event.trigger(e, null, elem)
						},
					})

					jQuery.fn.extend({
						trigger: function (type, data) {
							return this.each(function () {
								jQuery.event.trigger(type, data, this)
							})
						},
						triggerHandler: function (type, data) {
							var elem = this[0]
							if (elem) {
								return jQuery.event.trigger(type, data, elem, true)
							}
						},
					})

					// Support: Firefox <=44
					// Firefox doesn't have focus(in | out) events
					// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
					//
					// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
					// focus(in | out) events fire after focus & blur events,
					// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
					// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
					if (!support.focusin) {
						jQuery.each({ focus: "focusin", blur: "focusout" }, function (
							orig,
							fix,
						) {
							// Attach a single capturing handler on the document while someone wants focusin/focusout
							var handler = function (event) {
								jQuery.event.simulate(
									fix,
									event.target,
									jQuery.event.fix(event),
								)
							}

							jQuery.event.special[fix] = {
								setup: function () {
									// Handle: regular nodes (via `this.ownerDocument`), window
									// (via `this.document`) & document (via `this`).
									var doc = this.ownerDocument || this.document || this,
										attaches = dataPriv.access(doc, fix)

									if (!attaches) {
										doc.addEventListener(orig, handler, true)
									}
									dataPriv.access(doc, fix, (attaches || 0) + 1)
								},
								teardown: function () {
									var doc = this.ownerDocument || this.document || this,
										attaches = dataPriv.access(doc, fix) - 1

									if (!attaches) {
										doc.removeEventListener(orig, handler, true)
										dataPriv.remove(doc, fix)
									} else {
										dataPriv.access(doc, fix, attaches)
									}
								},
							}
						})
					}
					var location = window.location

					var nonce = { guid: Date.now() }

					var rquery = /\?/

					// Cross-browser xml parsing
					jQuery.parseXML = function (data) {
						var xml
						if (!data || typeof data !== "string") {
							return null
						}

						// Support: IE 9 - 11 only
						// IE throws on parseFromString with invalid input.
						try {
							xml = new window.DOMParser().parseFromString(data, "text/xml")
						} catch (e) {
							xml = undefined
						}

						if (!xml || xml.getElementsByTagName("parsererror").length) {
							jQuery.error("Invalid XML: " + data)
						}
						return xml
					}

					var rbracket = /\[\]$/,
						rCRLF = /\r?\n/g,
						rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
						rsubmittable = /^(?:input|select|textarea|keygen)/i

					function buildParams(prefix, obj, traditional, add) {
						var name

						if (Array.isArray(obj)) {
							// Serialize array item.
							jQuery.each(obj, function (i, v) {
								if (traditional || rbracket.test(prefix)) {
									// Treat each array item as a scalar.
									add(prefix, v)
								} else {
									// Item is non-scalar (array or object), encode its numeric index.
									buildParams(
										prefix +
											"[" +
											(typeof v === "object" && v != null ? i : "") +
											"]",
										v,
										traditional,
										add,
									)
								}
							})
						} else if (!traditional && toType(obj) === "object") {
							// Serialize object item.
							for (name in obj) {
								buildParams(
									prefix + "[" + name + "]",
									obj[name],
									traditional,
									add,
								)
							}
						} else {
							// Serialize scalar item.
							add(prefix, obj)
						}
					}

					// Serialize an array of form elements or a set of
					// key/values into a query string
					jQuery.param = function (a, traditional) {
						var prefix,
							s = [],
							add = function (key, valueOrFunction) {
								// If value is a function, invoke it and use its return value
								var value = isFunction(valueOrFunction)
									? valueOrFunction()
									: valueOrFunction

								s[s.length] =
									encodeURIComponent(key) +
									"=" +
									encodeURIComponent(value == null ? "" : value)
							}

						if (a == null) {
							return ""
						}

						// If an array was passed in, assume that it is an array of form elements.
						if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
							// Serialize the form elements
							jQuery.each(a, function () {
								add(this.name, this.value)
							})
						} else {
							// If traditional, encode the "old" way (the way 1.3.2 or older
							// did it), otherwise encode params recursively.
							for (prefix in a) {
								buildParams(prefix, a[prefix], traditional, add)
							}
						}

						// Return the resulting serialization
						return s.join("&")
					}

					jQuery.fn.extend({
						serialize: function () {
							return jQuery.param(this.serializeArray())
						},
						serializeArray: function () {
							return this.map(function () {
								// Can add propHook for "elements" to filter or add form elements
								var elements = jQuery.prop(this, "elements")
								return elements ? jQuery.makeArray(elements) : this
							})
								.filter(function () {
									var type = this.type

									// Use .is( ":disabled" ) so that fieldset[disabled] works
									return (
										this.name &&
										!jQuery(this).is(":disabled") &&
										rsubmittable.test(this.nodeName) &&
										!rsubmitterTypes.test(type) &&
										(this.checked || !rcheckableType.test(type))
									)
								})
								.map(function (_i, elem) {
									var val = jQuery(this).val()

									if (val == null) {
										return null
									}

									if (Array.isArray(val)) {
										return jQuery.map(val, function (val) {
											return {
												name: elem.name,
												value: val.replace(rCRLF, "\r\n"),
											}
										})
									}

									return { name: elem.name, value: val.replace(rCRLF, "\r\n") }
								})
								.get()
						},
					})

					var r20 = /%20/g,
						rhash = /#.*$/,
						rantiCache = /([?&])_=[^&]*/,
						rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
						// #7653, #8125, #8152: local protocol detection
						rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
						rnoContent = /^(?:GET|HEAD)$/,
						rprotocol = /^\/\//,
						/* Prefilters
						 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
						 * 2) These are called:
						 *    - BEFORE asking for a transport
						 *    - AFTER param serialization (s.data is a string if s.processData is true)
						 * 3) key is the dataType
						 * 4) the catchall symbol "*" can be used
						 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
						 */
						prefilters = {},
						/* Transports bindings
						 * 1) key is the dataType
						 * 2) the catchall symbol "*" can be used
						 * 3) selection will start with transport dataType and THEN go to "*" if needed
						 */
						transports = {},
						// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
						allTypes = "*/".concat("*"),
						// Anchor tag for parsing the document origin
						originAnchor = document.createElement("a")
					originAnchor.href = location.href

					// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
					function addToPrefiltersOrTransports(structure) {
						// dataTypeExpression is optional and defaults to "*"
						return function (dataTypeExpression, func) {
							if (typeof dataTypeExpression !== "string") {
								func = dataTypeExpression
								dataTypeExpression = "*"
							}

							var dataType,
								i = 0,
								dataTypes =
									dataTypeExpression.toLowerCase().match(rnothtmlwhite) || []

							if (isFunction(func)) {
								// For each dataType in the dataTypeExpression
								while ((dataType = dataTypes[i++])) {
									// Prepend if requested
									if (dataType[0] === "+") {
										dataType = dataType.slice(1) || "*"
										;(structure[dataType] = structure[dataType] || []).unshift(
											func,
										)

										// Otherwise append
									} else {
										;(structure[dataType] = structure[dataType] || []).push(
											func,
										)
									}
								}
							}
						}
					}

					// Base inspection function for prefilters and transports
					function inspectPrefiltersOrTransports(
						structure,
						options,
						originalOptions,
						jqXHR,
					) {
						var inspected = {},
							seekingTransport = structure === transports

						function inspect(dataType) {
							var selected
							inspected[dataType] = true
							jQuery.each(structure[dataType] || [], function (
								_,
								prefilterOrFactory,
							) {
								var dataTypeOrTransport = prefilterOrFactory(
									options,
									originalOptions,
									jqXHR,
								)
								if (
									typeof dataTypeOrTransport === "string" &&
									!seekingTransport &&
									!inspected[dataTypeOrTransport]
								) {
									options.dataTypes.unshift(dataTypeOrTransport)
									inspect(dataTypeOrTransport)
									return false
								} else if (seekingTransport) {
									return !(selected = dataTypeOrTransport)
								}
							})
							return selected
						}

						return (
							inspect(options.dataTypes[0]) || (!inspected["*"] && inspect("*"))
						)
					}

					// A special extend for ajax options
					// that takes "flat" options (not to be deep extended)
					// Fixes #9887
					function ajaxExtend(target, src) {
						var key,
							deep,
							flatOptions = jQuery.ajaxSettings.flatOptions || {}

						for (key in src) {
							if (src[key] !== undefined) {
								;(flatOptions[key] ? target : deep || (deep = {}))[key] =
									src[key]
							}
						}
						if (deep) {
							jQuery.extend(true, target, deep)
						}

						return target
					}

					/* Handles responses to an ajax request:
					 * - finds the right dataType (mediates between content-type and expected dataType)
					 * - returns the corresponding response
					 */
					function ajaxHandleResponses(s, jqXHR, responses) {
						var ct,
							type,
							finalDataType,
							firstDataType,
							contents = s.contents,
							dataTypes = s.dataTypes

						// Remove auto dataType and get content-type in the process
						while (dataTypes[0] === "*") {
							dataTypes.shift()
							if (ct === undefined) {
								ct = s.mimeType || jqXHR.getResponseHeader("Content-Type")
							}
						}

						// Check if we're dealing with a known content-type
						if (ct) {
							for (type in contents) {
								if (contents[type] && contents[type].test(ct)) {
									dataTypes.unshift(type)
									break
								}
							}
						}

						// Check to see if we have a response for the expected dataType
						if (dataTypes[0] in responses) {
							finalDataType = dataTypes[0]
						} else {
							// Try convertible dataTypes
							for (type in responses) {
								if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
									finalDataType = type
									break
								}
								if (!firstDataType) {
									firstDataType = type
								}
							}

							// Or just use first one
							finalDataType = finalDataType || firstDataType
						}

						// If we found a dataType
						// We add the dataType to the list if needed
						// and return the corresponding response
						if (finalDataType) {
							if (finalDataType !== dataTypes[0]) {
								dataTypes.unshift(finalDataType)
							}
							return responses[finalDataType]
						}
					}

					/* Chain conversions given the request and the original response
					 * Also sets the responseXXX fields on the jqXHR instance
					 */
					function ajaxConvert(s, response, jqXHR, isSuccess) {
						var conv2,
							current,
							conv,
							tmp,
							prev,
							converters = {},
							// Work with a copy of dataTypes in case we need to modify it for conversion
							dataTypes = s.dataTypes.slice()

						// Create converters map with lowercased keys
						if (dataTypes[1]) {
							for (conv in s.converters) {
								converters[conv.toLowerCase()] = s.converters[conv]
							}
						}

						current = dataTypes.shift()

						// Convert to each sequential dataType
						while (current) {
							if (s.responseFields[current]) {
								jqXHR[s.responseFields[current]] = response
							}

							// Apply the dataFilter if provided
							if (!prev && isSuccess && s.dataFilter) {
								response = s.dataFilter(response, s.dataType)
							}

							prev = current
							current = dataTypes.shift()

							if (current) {
								// There's only work to do if current dataType is non-auto
								if (current === "*") {
									current = prev

									// Convert response if prev dataType is non-auto and differs from current
								} else if (prev !== "*" && prev !== current) {
									// Seek a direct converter
									conv =
										converters[prev + " " + current] ||
										converters["* " + current]

									// If none found, seek a pair
									if (!conv) {
										for (conv2 in converters) {
											// If conv2 outputs current
											tmp = conv2.split(" ")
											if (tmp[1] === current) {
												// If prev can be converted to accepted input
												conv =
													converters[prev + " " + tmp[0]] ||
													converters["* " + tmp[0]]
												if (conv) {
													// Condense equivalence converters
													if (conv === true) {
														conv = converters[conv2]

														// Otherwise, insert the intermediate dataType
													} else if (converters[conv2] !== true) {
														current = tmp[0]
														dataTypes.unshift(tmp[1])
													}
													break
												}
											}
										}
									}

									// Apply converter (if not an equivalence)
									if (conv !== true) {
										// Unless errors are allowed to bubble, catch and return them
										if (conv && s.throws) {
											response = conv(response)
										} else {
											try {
												response = conv(response)
											} catch (e) {
												return {
													state: "parsererror",
													error: conv
														? e
														: "No conversion from " + prev + " to " + current,
												}
											}
										}
									}
								}
							}
						}

						return { state: "success", data: response }
					}

					jQuery.extend({
						// Counter for holding the number of active queries
						active: 0,

						// Last-Modified header cache for next request
						lastModified: {},
						etag: {},

						ajaxSettings: {
							url: location.href,
							type: "GET",
							isLocal: rlocalProtocol.test(location.protocol),
							global: true,
							processData: true,
							async: true,
							contentType: "application/x-www-form-urlencoded; charset=UTF-8",

							/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

							accepts: {
								"*": allTypes,
								text: "text/plain",
								html: "text/html",
								xml: "application/xml, text/xml",
								json: "application/json, text/javascript",
							},

							contents: {
								xml: /\bxml\b/,
								html: /\bhtml/,
								json: /\bjson\b/,
							},

							responseFields: {
								xml: "responseXML",
								text: "responseText",
								json: "responseJSON",
							},

							// Data converters
							// Keys separate source (or catchall "*") and destination types with a single space
							converters: {
								// Convert anything to text
								"* text": String,

								// Text to html (true = no transformation)
								"text html": true,

								// Evaluate text as a json expression
								"text json": JSON.parse,

								// Parse text as xml
								"text xml": jQuery.parseXML,
							},

							// For options that shouldn't be deep extended:
							// you can add your own custom options here if
							// and when you create one that shouldn't be
							// deep extended (see ajaxExtend)
							flatOptions: {
								url: true,
								context: true,
							},
						},

						// Creates a full fledged settings object into target
						// with both ajaxSettings and settings fields.
						// If target is omitted, writes into ajaxSettings.
						ajaxSetup: function (target, settings) {
							return settings
								? // Building a settings object
								  ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
								: // Extending ajaxSettings
								  ajaxExtend(jQuery.ajaxSettings, target)
						},

						ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
						ajaxTransport: addToPrefiltersOrTransports(transports),

						// Main method
						ajax: function (url, options) {
							// If url is an object, simulate pre-1.5 signature
							if (typeof url === "object") {
								options = url
								url = undefined
							}

							// Force options to be an object
							options = options || {}

							var transport,
								// URL without anti-cache param
								cacheURL,
								// Response headers
								responseHeadersString,
								responseHeaders,
								// timeout handle
								timeoutTimer,
								// Url cleanup var
								urlAnchor,
								// Request state (becomes false upon send and true upon completion)
								completed,
								// To know if global events are to be dispatched
								fireGlobals,
								// Loop variable
								i,
								// uncached part of the url
								uncached,
								// Create the final options object
								s = jQuery.ajaxSetup({}, options),
								// Callbacks context
								callbackContext = s.context || s,
								// Context for global events is callbackContext if it is a DOM node or jQuery collection
								globalEventContext =
									s.context &&
									(callbackContext.nodeType || callbackContext.jquery)
										? jQuery(callbackContext)
										: jQuery.event,
								// Deferreds
								deferred = jQuery.Deferred(),
								completeDeferred = jQuery.Callbacks("once memory"),
								// Status-dependent callbacks
								statusCode = s.statusCode || {},
								// Headers (they are sent all at once)
								requestHeaders = {},
								requestHeadersNames = {},
								// Default abort message
								strAbort = "canceled",
								// Fake xhr
								jqXHR = {
									readyState: 0,

									// Builds headers hashtable if needed
									getResponseHeader: function (key) {
										var match
										if (completed) {
											if (!responseHeaders) {
												responseHeaders = {}
												while ((match = rheaders.exec(responseHeadersString))) {
													responseHeaders[match[1].toLowerCase() + " "] = (
														responseHeaders[match[1].toLowerCase() + " "] || []
													).concat(match[2])
												}
											}
											match = responseHeaders[key.toLowerCase() + " "]
										}
										return match == null ? null : match.join(", ")
									},

									// Raw string
									getAllResponseHeaders: function () {
										return completed ? responseHeadersString : null
									},

									// Caches the header
									setRequestHeader: function (name, value) {
										if (completed == null) {
											name = requestHeadersNames[name.toLowerCase()] =
												requestHeadersNames[name.toLowerCase()] || name
											requestHeaders[name] = value
										}
										return this
									},

									// Overrides response content-type header
									overrideMimeType: function (type) {
										if (completed == null) {
											s.mimeType = type
										}
										return this
									},

									// Status-dependent callbacks
									statusCode: function (map) {
										var code
										if (map) {
											if (completed) {
												// Execute the appropriate callbacks
												jqXHR.always(map[jqXHR.status])
											} else {
												// Lazy-add the new callbacks in a way that preserves old ones
												for (code in map) {
													statusCode[code] = [statusCode[code], map[code]]
												}
											}
										}
										return this
									},

									// Cancel the request
									abort: function (statusText) {
										var finalText = statusText || strAbort
										if (transport) {
											transport.abort(finalText)
										}
										done(0, finalText)
										return this
									},
								}

							// Attach deferreds
							deferred.promise(jqXHR)

							// Add protocol if not provided (prefilters might expect it)
							// Handle falsy url in the settings object (#10093: consistency with old signature)
							// We also use the url parameter if available
							s.url = ((url || s.url || location.href) + "").replace(
								rprotocol,
								location.protocol + "//",
							)

							// Alias method option to type as per ticket #12004
							s.type = options.method || options.type || s.method || s.type

							// Extract dataTypes list
							s.dataTypes = (s.dataType || "*")
								.toLowerCase()
								.match(rnothtmlwhite) || [""]

							// A cross-domain request is in order when the origin doesn't match the current origin.
							if (s.crossDomain == null) {
								urlAnchor = document.createElement("a")

								// Support: IE <=8 - 11, Edge 12 - 15
								// IE throws exception on accessing the href property if url is malformed,
								// e.g. http://example.com:80x/
								try {
									urlAnchor.href = s.url

									// Support: IE <=8 - 11 only
									// Anchor's host property isn't correctly set when s.url is relative
									urlAnchor.href = urlAnchor.href
									s.crossDomain =
										originAnchor.protocol + "//" + originAnchor.host !==
										urlAnchor.protocol + "//" + urlAnchor.host
								} catch (e) {
									// If there is an error parsing the URL, assume it is crossDomain,
									// it can be rejected by the transport if it is invalid
									s.crossDomain = true
								}
							}

							// Convert data if not already a string
							if (s.data && s.processData && typeof s.data !== "string") {
								s.data = jQuery.param(s.data, s.traditional)
							}

							// Apply prefilters
							inspectPrefiltersOrTransports(prefilters, s, options, jqXHR)

							// If request was aborted inside a prefilter, stop there
							if (completed) {
								return jqXHR
							}

							// We can fire global events as of now if asked to
							// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
							fireGlobals = jQuery.event && s.global

							// Watch for a new set of requests
							if (fireGlobals && jQuery.active++ === 0) {
								jQuery.event.trigger("ajaxStart")
							}

							// Uppercase the type
							s.type = s.type.toUpperCase()

							// Determine if request has content
							s.hasContent = !rnoContent.test(s.type)

							// Save the URL in case we're toying with the If-Modified-Since
							// and/or If-None-Match header later on
							// Remove hash to simplify url manipulation
							cacheURL = s.url.replace(rhash, "")

							// More options handling for requests with no content
							if (!s.hasContent) {
								// Remember the hash so we can put it back
								uncached = s.url.slice(cacheURL.length)

								// If data is available and should be processed, append data to url
								if (s.data && (s.processData || typeof s.data === "string")) {
									cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data

									// #9682: remove data so that it's not used in an eventual retry
									delete s.data
								}

								// Add or update anti-cache param if needed
								if (s.cache === false) {
									cacheURL = cacheURL.replace(rantiCache, "$1")
									uncached =
										(rquery.test(cacheURL) ? "&" : "?") +
										"_=" +
										nonce.guid++ +
										uncached
								}

								// Put hash and anti-cache on the URL that will be requested (gh-1732)
								s.url = cacheURL + uncached

								// Change '%20' to '+' if this is encoded form body content (gh-2658)
							} else if (
								s.data &&
								s.processData &&
								(s.contentType || "").indexOf(
									"application/x-www-form-urlencoded",
								) === 0
							) {
								s.data = s.data.replace(r20, "+")
							}

							// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
							if (s.ifModified) {
								if (jQuery.lastModified[cacheURL]) {
									jqXHR.setRequestHeader(
										"If-Modified-Since",
										jQuery.lastModified[cacheURL],
									)
								}
								if (jQuery.etag[cacheURL]) {
									jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])
								}
							}

							// Set the correct header, if data is being sent
							if (
								(s.data && s.hasContent && s.contentType !== false) ||
								options.contentType
							) {
								jqXHR.setRequestHeader("Content-Type", s.contentType)
							}

							// Set the Accepts header for the server, depending on the dataType
							jqXHR.setRequestHeader(
								"Accept",
								s.dataTypes[0] && s.accepts[s.dataTypes[0]]
									? s.accepts[s.dataTypes[0]] +
											(s.dataTypes[0] !== "*"
												? ", " + allTypes + "; q=0.01"
												: "")
									: s.accepts["*"],
							)

							// Check for headers option
							for (i in s.headers) {
								jqXHR.setRequestHeader(i, s.headers[i])
							}

							// Allow custom headers/mimetypes and early abort
							if (
								s.beforeSend &&
								(s.beforeSend.call(callbackContext, jqXHR, s) === false ||
									completed)
							) {
								// Abort if not done already and return
								return jqXHR.abort()
							}

							// Aborting is no longer a cancellation
							strAbort = "abort"

							// Install callbacks on deferreds
							completeDeferred.add(s.complete)
							jqXHR.done(s.success)
							jqXHR.fail(s.error)

							// Get transport
							transport = inspectPrefiltersOrTransports(
								transports,
								s,
								options,
								jqXHR,
							)

							// If no transport, we auto-abort
							if (!transport) {
								done(-1, "No Transport")
							} else {
								jqXHR.readyState = 1

								// Send global event
								if (fireGlobals) {
									globalEventContext.trigger("ajaxSend", [jqXHR, s])
								}

								// If request was aborted inside ajaxSend, stop there
								if (completed) {
									return jqXHR
								}

								// Timeout
								if (s.async && s.timeout > 0) {
									timeoutTimer = window.setTimeout(function () {
										jqXHR.abort("timeout")
									}, s.timeout)
								}

								try {
									completed = false
									transport.send(requestHeaders, done)
								} catch (e) {
									// Rethrow post-completion exceptions
									if (completed) {
										throw e
									}

									// Propagate others as results
									done(-1, e)
								}
							}

							// Callback for when everything is done
							function done(status, nativeStatusText, responses, headers) {
								var isSuccess,
									success,
									error,
									response,
									modified,
									statusText = nativeStatusText

								// Ignore repeat invocations
								if (completed) {
									return
								}

								completed = true

								// Clear timeout if it exists
								if (timeoutTimer) {
									window.clearTimeout(timeoutTimer)
								}

								// Dereference transport for early garbage collection
								// (no matter how long the jqXHR object will be used)
								transport = undefined

								// Cache response headers
								responseHeadersString = headers || ""

								// Set readyState
								jqXHR.readyState = status > 0 ? 4 : 0

								// Determine if successful
								isSuccess = (status >= 200 && status < 300) || status === 304

								// Get response data
								if (responses) {
									response = ajaxHandleResponses(s, jqXHR, responses)
								}

								// Use a noop converter for missing script
								if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1) {
									s.converters["text script"] = function () {}
								}

								// Convert no matter what (that way responseXXX fields are always set)
								response = ajaxConvert(s, response, jqXHR, isSuccess)

								// If successful, handle type chaining
								if (isSuccess) {
									// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
									if (s.ifModified) {
										modified = jqXHR.getResponseHeader("Last-Modified")
										if (modified) {
											jQuery.lastModified[cacheURL] = modified
										}
										modified = jqXHR.getResponseHeader("etag")
										if (modified) {
											jQuery.etag[cacheURL] = modified
										}
									}

									// if no content
									if (status === 204 || s.type === "HEAD") {
										statusText = "nocontent"

										// if not modified
									} else if (status === 304) {
										statusText = "notmodified"

										// If we have data, let's convert it
									} else {
										statusText = response.state
										success = response.data
										error = response.error
										isSuccess = !error
									}
								} else {
									// Extract error from statusText and normalize for non-aborts
									error = statusText
									if (status || !statusText) {
										statusText = "error"
										if (status < 0) {
											status = 0
										}
									}
								}

								// Set data for the fake xhr object
								jqXHR.status = status
								jqXHR.statusText = (nativeStatusText || statusText) + ""

								// Success/Error
								if (isSuccess) {
									deferred.resolveWith(callbackContext, [
										success,
										statusText,
										jqXHR,
									])
								} else {
									deferred.rejectWith(callbackContext, [
										jqXHR,
										statusText,
										error,
									])
								}

								// Status-dependent callbacks
								jqXHR.statusCode(statusCode)
								statusCode = undefined

								if (fireGlobals) {
									globalEventContext.trigger(
										isSuccess ? "ajaxSuccess" : "ajaxError",
										[jqXHR, s, isSuccess ? success : error],
									)
								}

								// Complete
								completeDeferred.fireWith(callbackContext, [jqXHR, statusText])

								if (fireGlobals) {
									globalEventContext.trigger("ajaxComplete", [jqXHR, s])

									// Handle the global AJAX counter
									if (!--jQuery.active) {
										jQuery.event.trigger("ajaxStop")
									}
								}
							}

							return jqXHR
						},

						getJSON: function (url, data, callback) {
							return jQuery.get(url, data, callback, "json")
						},

						getScript: function (url, callback) {
							return jQuery.get(url, undefined, callback, "script")
						},
					})

					jQuery.each(["get", "post"], function (_i, method) {
						jQuery[method] = function (url, data, callback, type) {
							// Shift arguments if data argument was omitted
							if (isFunction(data)) {
								type = type || callback
								callback = data
								data = undefined
							}

							// The url can be an options object (which then must have .url)
							return jQuery.ajax(
								jQuery.extend(
									{
										url: url,
										type: method,
										dataType: type,
										data: data,
										success: callback,
									},
									jQuery.isPlainObject(url) && url,
								),
							)
						}
					})

					jQuery.ajaxPrefilter(function (s) {
						var i
						for (i in s.headers) {
							if (i.toLowerCase() === "content-type") {
								s.contentType = s.headers[i] || ""
							}
						}
					})

					jQuery._evalUrl = function (url, options, doc) {
						return jQuery.ajax({
							url: url,

							// Make this explicit, since user can override this through ajaxSetup (#11264)
							type: "GET",
							dataType: "script",
							cache: true,
							async: false,
							global: false,

							// Only evaluate the response if it is successful (gh-4126)
							// dataFilter is not invoked for failure responses, so using it instead
							// of the default converter is kludgy but it works.
							converters: {
								"text script": function () {},
							},
							dataFilter: function (response) {
								jQuery.globalEval(response, options, doc)
							},
						})
					}

					jQuery.fn.extend({
						wrapAll: function (html) {
							var wrap

							if (this[0]) {
								if (isFunction(html)) {
									html = html.call(this[0])
								}

								// The elements to wrap the target around
								wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true)

								if (this[0].parentNode) {
									wrap.insertBefore(this[0])
								}

								wrap
									.map(function () {
										var elem = this

										while (elem.firstElementChild) {
											elem = elem.firstElementChild
										}

										return elem
									})
									.append(this)
							}

							return this
						},

						wrapInner: function (html) {
							if (isFunction(html)) {
								return this.each(function (i) {
									jQuery(this).wrapInner(html.call(this, i))
								})
							}

							return this.each(function () {
								var self = jQuery(this),
									contents = self.contents()

								if (contents.length) {
									contents.wrapAll(html)
								} else {
									self.append(html)
								}
							})
						},

						wrap: function (html) {
							var htmlIsFunction = isFunction(html)

							return this.each(function (i) {
								jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html)
							})
						},

						unwrap: function (selector) {
							this.parent(selector)
								.not("body")
								.each(function () {
									jQuery(this).replaceWith(this.childNodes)
								})
							return this
						},
					})

					jQuery.expr.pseudos.hidden = function (elem) {
						return !jQuery.expr.pseudos.visible(elem)
					}
					jQuery.expr.pseudos.visible = function (elem) {
						return !!(
							elem.offsetWidth ||
							elem.offsetHeight ||
							elem.getClientRects().length
						)
					}

					jQuery.ajaxSettings.xhr = function () {
						try {
							return new window.XMLHttpRequest()
						} catch (e) {}
					}

					var xhrSuccessStatus = {
							// File protocol always yields status code 0, assume 200
							0: 200,

							// Support: IE <=9 only
							// #1450: sometimes IE returns 1223 when it should be 204
							1223: 204,
						},
						xhrSupported = jQuery.ajaxSettings.xhr()

					support.cors = !!xhrSupported && "withCredentials" in xhrSupported
					support.ajax = xhrSupported = !!xhrSupported

					jQuery.ajaxTransport(function (options) {
						var callback, errorCallback

						// Cross domain only allowed if supported through XMLHttpRequest
						if (support.cors || (xhrSupported && !options.crossDomain)) {
							return {
								send: function (headers, complete) {
									var i,
										xhr = options.xhr()

									xhr.open(
										options.type,
										options.url,
										options.async,
										options.username,
										options.password,
									)

									// Apply custom fields if provided
									if (options.xhrFields) {
										for (i in options.xhrFields) {
											xhr[i] = options.xhrFields[i]
										}
									}

									// Override mime type if needed
									if (options.mimeType && xhr.overrideMimeType) {
										xhr.overrideMimeType(options.mimeType)
									}

									// X-Requested-With header
									// For cross-domain requests, seeing as conditions for a preflight are
									// akin to a jigsaw puzzle, we simply never set it to be sure.
									// (it can always be set on a per-request basis or even using ajaxSetup)
									// For same-domain requests, won't change header if already provided.
									if (!options.crossDomain && !headers["X-Requested-With"]) {
										headers["X-Requested-With"] = "XMLHttpRequest"
									}

									// Set headers
									for (i in headers) {
										xhr.setRequestHeader(i, headers[i])
									}

									// Callback
									callback = function (type) {
										return function () {
											if (callback) {
												callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null

												if (type === "abort") {
													xhr.abort()
												} else if (type === "error") {
													// Support: IE <=9 only
													// On a manual native abort, IE9 throws
													// errors on any property access that is not readyState
													if (typeof xhr.status !== "number") {
														complete(0, "error")
													} else {
														complete(
															// File: protocol always yields status 0; see #8605, #14207
															xhr.status,
															xhr.statusText,
														)
													}
												} else {
													complete(
														xhrSuccessStatus[xhr.status] || xhr.status,
														xhr.statusText,

														// Support: IE <=9 only
														// IE9 has no XHR2 but throws on binary (trac-11426)
														// For XHR2 non-text, let the caller handle it (gh-2498)
														(xhr.responseType || "text") !== "text" ||
															typeof xhr.responseText !== "string"
															? { binary: xhr.response }
															: { text: xhr.responseText },
														xhr.getAllResponseHeaders(),
													)
												}
											}
										}
									}

									// Listen to events
									xhr.onload = callback()
									errorCallback = xhr.onerror = xhr.ontimeout = callback(
										"error",
									)

									// Support: IE 9 only
									// Use onreadystatechange to replace onabort
									// to handle uncaught aborts
									if (xhr.onabort !== undefined) {
										xhr.onabort = errorCallback
									} else {
										xhr.onreadystatechange = function () {
											// Check readyState before timeout as it changes
											if (xhr.readyState === 4) {
												// Allow onerror to be called first,
												// but that will not handle a native abort
												// Also, save errorCallback to a variable
												// as xhr.onerror cannot be accessed
												window.setTimeout(function () {
													if (callback) {
														errorCallback()
													}
												})
											}
										}
									}

									// Create the abort callback
									callback = callback("abort")

									try {
										// Do send the request (this may raise an exception)
										xhr.send((options.hasContent && options.data) || null)
									} catch (e) {
										// #14683: Only rethrow if this hasn't been notified as an error yet
										if (callback) {
											throw e
										}
									}
								},

								abort: function () {
									if (callback) {
										callback()
									}
								},
							}
						}
					})

					// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
					jQuery.ajaxPrefilter(function (s) {
						if (s.crossDomain) {
							s.contents.script = false
						}
					})

					// Install script dataType
					jQuery.ajaxSetup({
						accepts: {
							script:
								"text/javascript, application/javascript, " +
								"application/ecmascript, application/x-ecmascript",
						},
						contents: {
							script: /\b(?:java|ecma)script\b/,
						},
						converters: {
							"text script": function (text) {
								jQuery.globalEval(text)
								return text
							},
						},
					})

					// Handle cache's special case and crossDomain
					jQuery.ajaxPrefilter("script", function (s) {
						if (s.cache === undefined) {
							s.cache = false
						}
						if (s.crossDomain) {
							s.type = "GET"
						}
					})

					// Bind script tag hack transport
					jQuery.ajaxTransport("script", function (s) {
						// This transport only deals with cross domain or forced-by-attrs requests
						if (s.crossDomain || s.scriptAttrs) {
							var script, callback
							return {
								send: function (_, complete) {
									script = jQuery("<script>")
										.attr(s.scriptAttrs || {})
										.prop({ charset: s.scriptCharset, src: s.url })
										.on(
											"load error",
											(callback = function (evt) {
												script.remove()
												callback = null
												if (evt) {
													complete(evt.type === "error" ? 404 : 200, evt.type)
												}
											}),
										)

									// Use native DOM manipulation to avoid our domManip AJAX trickery
									document.head.appendChild(script[0])
								},
								abort: function () {
									if (callback) {
										callback()
									}
								},
							}
						}
					})

					var oldCallbacks = [],
						rjsonp = /(=)\?(?=&|$)|\?\?/

					// Default jsonp settings
					jQuery.ajaxSetup({
						jsonp: "callback",
						jsonpCallback: function () {
							var callback =
								oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++
							this[callback] = true
							return callback
						},
					})

					// Detect, normalize options and install callbacks for jsonp requests
					jQuery.ajaxPrefilter("json jsonp", function (
						s,
						originalSettings,
						jqXHR,
					) {
						var callbackName,
							overwritten,
							responseContainer,
							jsonProp =
								s.jsonp !== false &&
								(rjsonp.test(s.url)
									? "url"
									: typeof s.data === "string" &&
									  (s.contentType || "").indexOf(
											"application/x-www-form-urlencoded",
									  ) === 0 &&
									  rjsonp.test(s.data) &&
									  "data")

						// Handle iff the expected data type is "jsonp" or we have a parameter to set
						if (jsonProp || s.dataTypes[0] === "jsonp") {
							// Get callback name, remembering preexisting value associated with it
							callbackName = s.jsonpCallback = isFunction(s.jsonpCallback)
								? s.jsonpCallback()
								: s.jsonpCallback

							// Insert callback into url or form data
							if (jsonProp) {
								s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName)
							} else if (s.jsonp !== false) {
								s.url +=
									(rquery.test(s.url) ? "&" : "?") +
									s.jsonp +
									"=" +
									callbackName
							}

							// Use data converter to retrieve json after script execution
							s.converters["script json"] = function () {
								if (!responseContainer) {
									jQuery.error(callbackName + " was not called")
								}
								return responseContainer[0]
							}

							// Force json dataType
							s.dataTypes[0] = "json"

							// Install callback
							overwritten = window[callbackName]
							window[callbackName] = function () {
								responseContainer = arguments
							}

							// Clean-up function (fires after converters)
							jqXHR.always(function () {
								// If previous value didn't exist - remove it
								if (overwritten === undefined) {
									jQuery(window).removeProp(callbackName)

									// Otherwise restore preexisting value
								} else {
									window[callbackName] = overwritten
								}

								// Save back as free
								if (s[callbackName]) {
									// Make sure that re-using the options doesn't screw things around
									s.jsonpCallback = originalSettings.jsonpCallback

									// Save the callback name for future use
									oldCallbacks.push(callbackName)
								}

								// Call if it was a function and we have a response
								if (responseContainer && isFunction(overwritten)) {
									overwritten(responseContainer[0])
								}

								responseContainer = overwritten = undefined
							})

							// Delegate to script
							return "script"
						}
					})

					// Support: Safari 8 only
					// In Safari 8 documents created via document.implementation.createHTMLDocument
					// collapse sibling forms: the second one becomes a child of the first one.
					// Because of that, this security measure has to be disabled in Safari 8.
					// https://bugs.webkit.org/show_bug.cgi?id=137337
					support.createHTMLDocument = (function () {
						var body = document.implementation.createHTMLDocument("").body
						body.innerHTML = "<form></form><form></form>"
						return body.childNodes.length === 2
					})()

					// Argument "data" should be string of html
					// context (optional): If specified, the fragment will be created in this context,
					// defaults to document
					// keepScripts (optional): If true, will include scripts passed in the html string
					jQuery.parseHTML = function (data, context, keepScripts) {
						if (typeof data !== "string") {
							return []
						}
						if (typeof context === "boolean") {
							keepScripts = context
							context = false
						}

						var base, parsed, scripts

						if (!context) {
							// Stop scripts or inline event handlers from being executed immediately
							// by using document.implementation
							if (support.createHTMLDocument) {
								context = document.implementation.createHTMLDocument("")

								// Set the base href for the created document
								// so any parsed elements with URLs
								// are based on the document's URL (gh-2965)
								base = context.createElement("base")
								base.href = document.location.href
								context.head.appendChild(base)
							} else {
								context = document
							}
						}

						parsed = rsingleTag.exec(data)
						scripts = !keepScripts && []

						// Single tag
						if (parsed) {
							return [context.createElement(parsed[1])]
						}

						parsed = buildFragment([data], context, scripts)

						if (scripts && scripts.length) {
							jQuery(scripts).remove()
						}

						return jQuery.merge([], parsed.childNodes)
					}

					/**
					 * Load a url into a page
					 */
					jQuery.fn.load = function (url, params, callback) {
						var selector,
							type,
							response,
							self = this,
							off = url.indexOf(" ")

						if (off > -1) {
							selector = stripAndCollapse(url.slice(off))
							url = url.slice(0, off)
						}

						// If it's a function
						if (isFunction(params)) {
							// We assume that it's the callback
							callback = params
							params = undefined

							// Otherwise, build a param string
						} else if (params && typeof params === "object") {
							type = "POST"
						}

						// If we have elements to modify, make the request
						if (self.length > 0) {
							jQuery
								.ajax({
									url: url,

									// If "type" variable is undefined, then "GET" method will be used.
									// Make value of this field explicit since
									// user can override it through ajaxSetup method
									type: type || "GET",
									dataType: "html",
									data: params,
								})
								.done(function (responseText) {
									// Save response for use in complete callback
									response = arguments

									self.html(
										selector
											? // If a selector was specified, locate the right elements in a dummy div
											  // Exclude scripts to avoid IE 'Permission Denied' errors
											  jQuery("<div>")
													.append(jQuery.parseHTML(responseText))
													.find(selector)
											: // Otherwise use the full result
											  responseText,
									)

									// If the request succeeds, this function gets "data", "status", "jqXHR"
									// but they are ignored because response was set above.
									// If it fails, this function gets "jqXHR", "status", "error"
								})
								.always(
									callback &&
										function (jqXHR, status) {
											self.each(function () {
												callback.apply(
													this,
													response || [jqXHR.responseText, status, jqXHR],
												)
											})
										},
								)
						}

						return this
					}

					jQuery.expr.pseudos.animated = function (elem) {
						return jQuery.grep(jQuery.timers, function (fn) {
							return elem === fn.elem
						}).length
					}

					jQuery.offset = {
						setOffset: function (elem, options, i) {
							var curPosition,
								curLeft,
								curCSSTop,
								curTop,
								curOffset,
								curCSSLeft,
								calculatePosition,
								position = jQuery.css(elem, "position"),
								curElem = jQuery(elem),
								props = {}

							// Set position first, in-case top/left are set even on static elem
							if (position === "static") {
								elem.style.position = "relative"
							}

							curOffset = curElem.offset()
							curCSSTop = jQuery.css(elem, "top")
							curCSSLeft = jQuery.css(elem, "left")
							calculatePosition =
								(position === "absolute" || position === "fixed") &&
								(curCSSTop + curCSSLeft).indexOf("auto") > -1

							// Need to be able to calculate position if either
							// top or left is auto and position is either absolute or fixed
							if (calculatePosition) {
								curPosition = curElem.position()
								curTop = curPosition.top
								curLeft = curPosition.left
							} else {
								curTop = parseFloat(curCSSTop) || 0
								curLeft = parseFloat(curCSSLeft) || 0
							}

							if (isFunction(options)) {
								// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
								options = options.call(elem, i, jQuery.extend({}, curOffset))
							}

							if (options.top != null) {
								props.top = options.top - curOffset.top + curTop
							}
							if (options.left != null) {
								props.left = options.left - curOffset.left + curLeft
							}

							if ("using" in options) {
								options.using.call(elem, props)
							} else {
								if (typeof props.top === "number") {
									props.top += "px"
								}
								if (typeof props.left === "number") {
									props.left += "px"
								}
								curElem.css(props)
							}
						},
					}

					jQuery.fn.extend({
						// offset() relates an element's border box to the document origin
						offset: function (options) {
							// Preserve chaining for setter
							if (arguments.length) {
								return options === undefined
									? this
									: this.each(function (i) {
											jQuery.offset.setOffset(this, options, i)
									  })
							}

							var rect,
								win,
								elem = this[0]

							if (!elem) {
								return
							}

							// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
							// Support: IE <=11 only
							// Running getBoundingClientRect on a
							// disconnected node in IE throws an error
							if (!elem.getClientRects().length) {
								return { top: 0, left: 0 }
							}

							// Get document-relative position by adding viewport scroll to viewport-relative gBCR
							rect = elem.getBoundingClientRect()
							win = elem.ownerDocument.defaultView
							return {
								top: rect.top + win.pageYOffset,
								left: rect.left + win.pageXOffset,
							}
						},

						// position() relates an element's margin box to its offset parent's padding box
						// This corresponds to the behavior of CSS absolute positioning
						position: function () {
							if (!this[0]) {
								return
							}

							var offsetParent,
								offset,
								doc,
								elem = this[0],
								parentOffset = { top: 0, left: 0 }

							// position:fixed elements are offset from the viewport, which itself always has zero offset
							if (jQuery.css(elem, "position") === "fixed") {
								// Assume position:fixed implies availability of getBoundingClientRect
								offset = elem.getBoundingClientRect()
							} else {
								offset = this.offset()

								// Account for the *real* offset parent, which can be the document or its root element
								// when a statically positioned element is identified
								doc = elem.ownerDocument
								offsetParent = elem.offsetParent || doc.documentElement
								while (
									offsetParent &&
									(offsetParent === doc.body ||
										offsetParent === doc.documentElement) &&
									jQuery.css(offsetParent, "position") === "static"
								) {
									offsetParent = offsetParent.parentNode
								}
								if (
									offsetParent &&
									offsetParent !== elem &&
									offsetParent.nodeType === 1
								) {
									// Incorporate borders into its offset, since they are outside its content origin
									parentOffset = jQuery(offsetParent).offset()
									parentOffset.top += jQuery.css(
										offsetParent,
										"borderTopWidth",
										true,
									)
									parentOffset.left += jQuery.css(
										offsetParent,
										"borderLeftWidth",
										true,
									)
								}
							}

							// Subtract parent offsets and element margins
							return {
								top:
									offset.top -
									parentOffset.top -
									jQuery.css(elem, "marginTop", true),
								left:
									offset.left -
									parentOffset.left -
									jQuery.css(elem, "marginLeft", true),
							}
						},

						// This method will return documentElement in the following cases:
						// 1) For the element inside the iframe without offsetParent, this method will return
						//    documentElement of the parent window
						// 2) For the hidden or detached element
						// 3) For body or html element, i.e. in case of the html node - it will return itself
						//
						// but those exceptions were never presented as a real life use-cases
						// and might be considered as more preferable results.
						//
						// This logic, however, is not guaranteed and can change at any point in the future
						offsetParent: function () {
							return this.map(function () {
								var offsetParent = this.offsetParent

								while (
									offsetParent &&
									jQuery.css(offsetParent, "position") === "static"
								) {
									offsetParent = offsetParent.offsetParent
								}

								return offsetParent || documentElement
							})
						},
					})

					// Create scrollLeft and scrollTop methods
					jQuery.each(
						{ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
						function (method, prop) {
							var top = "pageYOffset" === prop

							jQuery.fn[method] = function (val) {
								return access(
									this,
									function (elem, method, val) {
										// Coalesce documents and windows
										var win
										if (isWindow(elem)) {
											win = elem
										} else if (elem.nodeType === 9) {
											win = elem.defaultView
										}

										if (val === undefined) {
											return win ? win[prop] : elem[method]
										}

										if (win) {
											win.scrollTo(
												!top ? val : win.pageXOffset,
												top ? val : win.pageYOffset,
											)
										} else {
											elem[method] = val
										}
									},
									method,
									val,
									arguments.length,
								)
							}
						},
					)

					// Support: Safari <=7 - 9.1, Chrome <=37 - 49
					// Add the top/left cssHooks using jQuery.fn.position
					// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
					// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
					// getComputedStyle returns percent when specified for top/left/bottom/right;
					// rather than make the css module depend on the offset module, just check for it here
					jQuery.each(["top", "left"], function (_i, prop) {
						jQuery.cssHooks[prop] = addGetHookIf(
							support.pixelPosition,
							function (elem, computed) {
								if (computed) {
									computed = curCSS(elem, prop)

									// If curCSS returns percentage, fallback to offset
									return rnumnonpx.test(computed)
										? jQuery(elem).position()[prop] + "px"
										: computed
								}
							},
						)
					})

					// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
					jQuery.each({ Height: "height", Width: "width" }, function (
						name,
						type,
					) {
						jQuery.each(
							{ padding: "inner" + name, content: type, "": "outer" + name },
							function (defaultExtra, funcName) {
								// Margin is only for outerHeight, outerWidth
								jQuery.fn[funcName] = function (margin, value) {
									var chainable =
											arguments.length &&
											(defaultExtra || typeof margin !== "boolean"),
										extra =
											defaultExtra ||
											(margin === true || value === true ? "margin" : "border")

									return access(
										this,
										function (elem, type, value) {
											var doc

											if (isWindow(elem)) {
												// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
												return funcName.indexOf("outer") === 0
													? elem["inner" + name]
													: elem.document.documentElement["client" + name]
											}

											// Get document width or height
											if (elem.nodeType === 9) {
												doc = elem.documentElement

												// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
												// whichever is greatest
												return Math.max(
													elem.body["scroll" + name],
													doc["scroll" + name],
													elem.body["offset" + name],
													doc["offset" + name],
													doc["client" + name],
												)
											}

											return value === undefined
												? // Get width or height on the element, requesting but not forcing parseFloat
												  jQuery.css(elem, type, extra)
												: // Set width or height on the element
												  jQuery.style(elem, type, value, extra)
										},
										type,
										chainable ? margin : undefined,
										chainable,
									)
								}
							},
						)
					})

					jQuery.each(
						[
							"ajaxStart",
							"ajaxStop",
							"ajaxComplete",
							"ajaxError",
							"ajaxSuccess",
							"ajaxSend",
						],
						function (_i, type) {
							jQuery.fn[type] = function (fn) {
								return this.on(type, fn)
							}
						},
					)

					jQuery.fn.extend({
						bind: function (types, data, fn) {
							return this.on(types, null, data, fn)
						},
						unbind: function (types, fn) {
							return this.off(types, null, fn)
						},

						delegate: function (selector, types, data, fn) {
							return this.on(types, selector, data, fn)
						},
						undelegate: function (selector, types, fn) {
							// ( namespace ) or ( selector, types [, fn] )
							return arguments.length === 1
								? this.off(selector, "**")
								: this.off(types, selector || "**", fn)
						},

						hover: function (fnOver, fnOut) {
							return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
						},
					})

					jQuery.each(
						(
							"blur focus focusin focusout resize scroll click dblclick " +
							"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
							"change select submit keydown keypress keyup contextmenu"
						).split(" "),
						function (_i, name) {
							// Handle event binding
							jQuery.fn[name] = function (data, fn) {
								return arguments.length > 0
									? this.on(name, null, data, fn)
									: this.trigger(name)
							}
						},
					)

					// Support: Android <=4.0 only
					// Make sure we trim BOM and NBSP
					var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g

					// Bind a function to a context, optionally partially applying any
					// arguments.
					// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
					// However, it is not slated for removal any time soon
					jQuery.proxy = function (fn, context) {
						var tmp, args, proxy

						if (typeof context === "string") {
							tmp = fn[context]
							context = fn
							fn = tmp
						}

						// Quick check to determine if target is callable, in the spec
						// this throws a TypeError, but we will just return undefined.
						if (!isFunction(fn)) {
							return undefined
						}

						// Simulated bind
						args = slice.call(arguments, 2)
						proxy = function () {
							return fn.apply(
								context || this,
								args.concat(slice.call(arguments)),
							)
						}

						// Set the guid of unique handler to the same of original handler, so it can be removed
						proxy.guid = fn.guid = fn.guid || jQuery.guid++

						return proxy
					}

					jQuery.holdReady = function (hold) {
						if (hold) {
							jQuery.readyWait++
						} else {
							jQuery.ready(true)
						}
					}
					jQuery.isArray = Array.isArray
					jQuery.parseJSON = JSON.parse
					jQuery.nodeName = nodeName
					jQuery.isFunction = isFunction
					jQuery.isWindow = isWindow
					jQuery.camelCase = camelCase
					jQuery.type = toType

					jQuery.now = Date.now

					jQuery.isNumeric = function (obj) {
						// As of jQuery 3.0, isNumeric is limited to
						// strings and numbers (primitives or objects)
						// that can be coerced to finite numbers (gh-2662)
						var type = jQuery.type(obj)
						return (
							(type === "number" || type === "string") &&
							// parseFloat NaNs numeric-cast false positives ("")
							// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
							// subtraction forces infinities to NaN
							!isNaN(obj - parseFloat(obj))
						)
					}

					jQuery.trim = function (text) {
						return text == null ? "" : (text + "").replace(rtrim, "")
					}

					// Register as a named AMD module, since jQuery can be concatenated with other
					// files that may use define, but not via a proper concatenation script that
					// understands anonymous AMD modules. A named AMD is safest and most robust
					// way to register. Lowercase jquery is used because AMD module names are
					// derived from file names, and jQuery is normally delivered in a lowercase
					// file name. Do this after creating the global so that if an AMD module wants
					// to call noConflict to hide this version of jQuery, it will work.

					// Note that for maximum portability, libraries that are not jQuery should
					// declare themselves as anonymous modules, and avoid setting a global if an
					// AMD loader is present. jQuery is a special case. For more information, see
					// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

					if (true) {
						!((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
						(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
							return jQuery
						}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
						__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
							(module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
					}

					var // Map over jQuery in case of overwrite
						_jQuery = window.jQuery,
						// Map over the $ in case of overwrite
						_$ = window.$

					jQuery.noConflict = function (deep) {
						if (window.$ === jQuery) {
							window.$ = _$
						}

						if (deep && window.jQuery === jQuery) {
							window.jQuery = _jQuery
						}

						return jQuery
					}

					// Expose jQuery and $ identifiers, even in AMD
					// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
					// and CommonJS for browser emulators (#13566)
					if (typeof noGlobal === "undefined") {
						window.jQuery = window.$ = jQuery
					}

					return jQuery
				})

				/***/
			},

		/***/ "./node_modules/.pnpm/style-loader@1.2.1_webpack@4.43.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
			/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/style-loader@1.2.1_webpack@4.43.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \*********************************************************************************************************************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				"use strict"

				var isOldIE = (function isOldIE() {
					var memo
					return function memorize() {
						if (typeof memo === "undefined") {
							// Test for IE <= 9 as proposed by Browserhacks
							// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
							// Tests for existence of standard globals is to allow style-loader
							// to operate correctly into non-standard environments
							// @see https://github.com/webpack-contrib/style-loader/issues/177
							memo = Boolean(window && document && document.all && !window.atob)
						}

						return memo
					}
				})()

				var getTarget = (function getTarget() {
					var memo = {}
					return function memorize(target) {
						if (typeof memo[target] === "undefined") {
							var styleTarget = document.querySelector(target) // Special case to return head of iframe instead of iframe itself

							if (
								window.HTMLIFrameElement &&
								styleTarget instanceof window.HTMLIFrameElement
							) {
								try {
									// This will throw an exception if access to iframe is blocked
									// due to cross-origin restrictions
									styleTarget = styleTarget.contentDocument.head
								} catch (e) {
									// istanbul ignore next
									styleTarget = null
								}
							}

							memo[target] = styleTarget
						}

						return memo[target]
					}
				})()

				var stylesInDom = []

				function getIndexByIdentifier(identifier) {
					var result = -1

					for (var i = 0; i < stylesInDom.length; i++) {
						if (stylesInDom[i].identifier === identifier) {
							result = i
							break
						}
					}

					return result
				}

				function modulesToDom(list, options) {
					var idCountMap = {}
					var identifiers = []

					for (var i = 0; i < list.length; i++) {
						var item = list[i]
						var id = options.base ? item[0] + options.base : item[0]
						var count = idCountMap[id] || 0
						var identifier = "".concat(id, " ").concat(count)
						idCountMap[id] = count + 1
						var index = getIndexByIdentifier(identifier)
						var obj = {
							css: item[1],
							media: item[2],
							sourceMap: item[3],
						}

						if (index !== -1) {
							stylesInDom[index].references++
							stylesInDom[index].updater(obj)
						} else {
							stylesInDom.push({
								identifier: identifier,
								updater: addStyle(obj, options),
								references: 1,
							})
						}

						identifiers.push(identifier)
					}

					return identifiers
				}

				function insertStyleElement(options) {
					var style = document.createElement("style")
					var attributes = options.attributes || {}

					if (typeof attributes.nonce === "undefined") {
						var nonce = true ? __webpack_require__.nc : undefined

						if (nonce) {
							attributes.nonce = nonce
						}
					}

					Object.keys(attributes).forEach(function (key) {
						style.setAttribute(key, attributes[key])
					})

					if (typeof options.insert === "function") {
						options.insert(style)
					} else {
						var target = getTarget(options.insert || "head")

						if (!target) {
							throw new Error(
								"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.",
							)
						}

						target.appendChild(style)
					}

					return style
				}

				function removeStyleElement(style) {
					// istanbul ignore if
					if (style.parentNode === null) {
						return false
					}

					style.parentNode.removeChild(style)
				}
				/* istanbul ignore next  */

				var replaceText = (function replaceText() {
					var textStore = []
					return function replace(index, replacement) {
						textStore[index] = replacement
						return textStore.filter(Boolean).join("\n")
					}
				})()

				function applyToSingletonTag(style, index, remove, obj) {
					var css = remove
						? ""
						: obj.media
						? "@media ".concat(obj.media, " {").concat(obj.css, "}")
						: obj.css // For old IE

					/* istanbul ignore if  */

					if (style.styleSheet) {
						style.styleSheet.cssText = replaceText(index, css)
					} else {
						var cssNode = document.createTextNode(css)
						var childNodes = style.childNodes

						if (childNodes[index]) {
							style.removeChild(childNodes[index])
						}

						if (childNodes.length) {
							style.insertBefore(cssNode, childNodes[index])
						} else {
							style.appendChild(cssNode)
						}
					}
				}

				function applyToTag(style, options, obj) {
					var css = obj.css
					var media = obj.media
					var sourceMap = obj.sourceMap

					if (media) {
						style.setAttribute("media", media)
					} else {
						style.removeAttribute("media")
					}

					if (sourceMap && btoa) {
						css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(
							btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))),
							" */",
						)
					} // For old IE

					/* istanbul ignore if  */

					if (style.styleSheet) {
						style.styleSheet.cssText = css
					} else {
						while (style.firstChild) {
							style.removeChild(style.firstChild)
						}

						style.appendChild(document.createTextNode(css))
					}
				}

				var singleton = null
				var singletonCounter = 0

				function addStyle(obj, options) {
					var style
					var update
					var remove

					if (options.singleton) {
						var styleIndex = singletonCounter++
						style = singleton || (singleton = insertStyleElement(options))
						update = applyToSingletonTag.bind(null, style, styleIndex, false)
						remove = applyToSingletonTag.bind(null, style, styleIndex, true)
					} else {
						style = insertStyleElement(options)
						update = applyToTag.bind(null, style, options)

						remove = function remove() {
							removeStyleElement(style)
						}
					}

					update(obj)
					return function updateStyle(newObj) {
						if (newObj) {
							if (
								newObj.css === obj.css &&
								newObj.media === obj.media &&
								newObj.sourceMap === obj.sourceMap
							) {
								return
							}

							update((obj = newObj))
						} else {
							remove()
						}
					}
				}

				module.exports = function (list, options) {
					options = options || {} // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
					// tags it will allow on a page

					if (!options.singleton && typeof options.singleton !== "boolean") {
						options.singleton = isOldIE()
					}

					list = list || []
					var lastIdentifiers = modulesToDom(list, options)
					return function update(newList) {
						newList = newList || []

						if (Object.prototype.toString.call(newList) !== "[object Array]") {
							return
						}

						for (var i = 0; i < lastIdentifiers.length; i++) {
							var identifier = lastIdentifiers[i]
							var index = getIndexByIdentifier(identifier)
							stylesInDom[index].references--
						}

						var newLastIdentifiers = modulesToDom(newList, options)

						for (var _i = 0; _i < lastIdentifiers.length; _i++) {
							var _identifier = lastIdentifiers[_i]

							var _index = getIndexByIdentifier(_identifier)

							if (stylesInDom[_index].references === 0) {
								stylesInDom[_index].updater()

								stylesInDom.splice(_index, 1)
							}
						}

						lastIdentifiers = newLastIdentifiers
					}
				}

				/***/
			},

		/***/ "./src/_css/images/workdayplanner1.jpg":
			/*!*********************************************!*\
  !*** ./src/_css/images/workdayplanner1.jpg ***!
  \*********************************************/
			/*! no static exports found */
			/***/ function (module, exports) {
				module.exports =
					"data:image/jpeg;base64,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"

				/***/
			},

		/***/ "./src/_css/style.css":
			/*!****************************!*\
  !*** ./src/_css/style.css ***!
  \****************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				var api = __webpack_require__(
					/*! ../../node_modules/.pnpm/style-loader@1.2.1_webpack@4.43.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/.pnpm/style-loader@1.2.1_webpack@4.43.0/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js",
				)
				var content = __webpack_require__(
					/*! !../../node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader??ref--5-1!./style.css */ "./node_modules/.pnpm/css-loader@0.28.11/node_modules/css-loader/index.js?!./src/_css/style.css",
				)

				content = content.__esModule ? content.default : content

				if (typeof content === "string") {
					content = [[module.i, content, ""]]
				}

				var options = {}

				options.insert = "head"
				options.singleton = false

				var update = api(content, options)

				module.exports = content.locals || {}

				/***/
			},

		/***/ "./src/_js/index.js":
			/*!**************************!*\
  !*** ./src/_js/index.js ***!
  \**************************/
			/*! no static exports found */
			/***/ function (module, exports, __webpack_require__) {
				"use strict"

				var _jquery = __webpack_require__(
					/*! jquery */ "./node_modules/.pnpm/jquery@3.5.1/node_modules/jquery/dist/jquery.js",
				)

				var _jquery2 = _interopRequireDefault(_jquery)

				__webpack_require__(/*! ../_css/style.css */ "./src/_css/style.css")

				function _interopRequireDefault(obj) {
					return obj && obj.__esModule ? obj : { default: obj }
				}

				// start..
				var activeSession = (0, _jquery2.default)("#mainContentContainer").data(
					"received-session",
				)

				if (activeSession) {
					// hide when signed in
					;(0, _jquery2.default)("#nav-signup-link").hide()
					;(0, _jquery2.default)("#nav-login-link").hide()

					// show when signed in
					;(0, _jquery2.default)("#nav-logout-link").show()
					;(0, _jquery2.default)("#nav-dashboard-link").show()
				}

				/***/
			},

		/******/
	},
)
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL19jc3MvcGxhbm5lci5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL19jc3Mvc3R5bGUuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3MtbG9hZGVyQDAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3MtbG9hZGVyQDAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2pxdWVyeUAzLjUuMS9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHlsZS1sb2FkZXJAMS4yLjFfd2VicGFja0A0LjQzLjAvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovLy8uL3NyYy9fY3NzL2ltYWdlcy93b3JrZGF5cGxhbm5lcjEuanBnIiwid2VicGFjazovLy8uL3NyYy9fY3NzL3N0eWxlLmNzcz9jYzU3Iiwid2VicGFjazovLy8uL3NyYy9fanMvaW5kZXguanMiXSwibmFtZXMiOlsiYWN0aXZlU2Vzc2lvbiIsImRhdGEiLCJoaWRlIiwic2hvdyJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQTs7Ozs7Ozs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUEwQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLDZDQUE2QztBQUM3QztBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEsc0NBQXNDO0FBQzlDLFFBQVE7QUFDUixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksdUVBQXVFO0FBQ25GO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSw0Q0FBNEM7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxRQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQiwwQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUF1RDtBQUM5RTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQ0FBK0M7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGNBQWMscUNBQXFDO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaURBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0JBQWdCO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMOztBQUVBLFdBQVc7QUFDWCxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUEwQztBQUMvQyxDQUFDLGlDQUFrQixFQUFFLG1DQUFFO0FBQ3ZCO0FBQ0EsRUFBRTtBQUFBLG9HQUFFO0FBQ0o7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFF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QXlCQSxJQUF6QjtBQUNBLEMiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvX2pzL2luZGV4LmpzXCIpO1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3MtbG9hZGVyQDAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5wbGFubmVyLWhlYWRlciB7XFxyXFxuXFx0ZGlzcGxheTogZmxleCAhaW1wb3J0YW50O1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnBsYW5uZXItaGVhZGVyIC5sZWFkIHtcXHJcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbnRleHRhcmVhIHtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbnRleHRhcmVhLm5vdGUtc2xvdHM6bnRoLW9mLXR5cGUoMm4pIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjYzAyMzIzNTA7XFxyXFxufVxcclxcblxcclxcbi5wbGFubmVyLWhlYWRlciBoMiB7XFxyXFxuXFx0Zm9udC13ZWlnaHQ6IDgwMDtcXHJcXG5cXHRsaW5lLWhlaWdodDogMS4yO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnRpbWUtc2xvdC1yb3cge1xcclxcblxcdGhlaWdodDogOS4yMzQ4OTR2aDtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAwLjE1cmVtO1xcclxcblxcdHdpZHRoOiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG4uc2F2ZS1idG4sXFxyXFxuLm5vdGUtc2xvdHMge1xcclxcblxcdHotaW5kZXg6IDk5O1xcclxcbn1cXHJcXG5cXHJcXG4uaG91ci1kaXNwbGF5IHtcXHJcXG5cXHRib3JkZXItdG9wOiAxcHggc29saWQgIzAwMDAwMDFjO1xcclxcblxcdGZvbnQtc2l6ZTogMS4yM3JlbTtcXHJcXG5cXHRmb250LXdlaWdodDogNjAwO1xcclxcblxcdGxpbmUtaGVpZ2h0OiAxO1xcclxcblxcdHBhZGRpbmc6IDAuMjVyZW0gMXJlbTtcXHJcXG5cXHR0ZXh0LWFsaWduOiByaWdodDtcXHJcXG59XFxyXFxuXFxyXFxuLmhvdXItZGlzcGxheSA+IHNwYW4ge1xcclxcblxcdHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG5cXHR0b3A6IC0xNXB4O1xcclxcblxcdHotaW5kZXg6IDk3O1xcclxcbn1cXHJcXG5cXHJcXG4ubm90ZS1zbG90cyB7XFxyXFxuXFx0Ym9yZGVyOiBub25lO1xcclxcblxcdGJvcmRlci10b3A6IDFweCBpbnNldCAjMDAwO1xcclxcblxcdGhlaWdodDogNTBweDtcXHJcXG5cXHRoZWlnaHQ6IDEwMCU7XFxyXFxuXFx0cGFkZGluZy1sZWZ0OiAwLjI1cmVtO1xcclxcblxcdHJlc2l6ZTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuI2NvbnRhaW5lclJvdyB7XFxyXFxuXFx0bWFyZ2luOiAycmVtIDA7XFxyXFxuXFx0cGFkZGluZzogMCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4jZGF0ZVJvdyBwIHtcXHJcXG5cXHRhbGlnbi1zZWxmOiBjZW50ZXI7XFxyXFxuXFx0bWFyZ2luOiAwO1xcclxcblxcdHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuI2RhdGVSb3cgaSB7XFxyXFxuXFx0Zm9udC1zaXplOiAyLjVyZW07XFxyXFxufVxcclxcblxcclxcbiNkYXRlUm93IC5jaGV2cm9ucyB7XFxyXFxuXFx0Y29sb3I6IHZhcigtLWJsYWNrKTtcXHJcXG5cXHRwYWRkaW5nOiAxcmVtIDA7XFxyXFxufVxcclxcblxcclxcbiNjdXJyZW50LXRpbWUtbGluZSB7XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogM3B4IGRhc2hlZCAjZTcwMDAwNTAgIWltcG9ydGFudDtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0d2lkdGg6IDEwMCU7XFxyXFxuXFx0ei1pbmRleDogNTk7XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2OHB4KSB7XFxyXFxuXFxyXFxuXFx0LnBsYW5uZXItaGVhZGVyIC5sZWFkLFxcclxcblxcdC5wbGFubmVyLWhlYWRlciBoMiB7XFxyXFxuXFx0XFx0dGV4dC1hbGlnbjogbGVmdDtcXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0LnBsYW5uZXItaGVhZGVyIGgyIHtcXHJcXG5cXHRcXHRkaXNwbGF5OiBub25lO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQucGxhbm5lci1oZWFkZXIgLmxlYWQge1xcclxcblxcdFxcdGZvbnQtc2l6ZTogMXJlbSAhaW1wb3J0YW50O1xcclxcblxcdFxcdHBhZGRpbmctYm90dG9tOiAwO1xcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQjY3VycmVudERheSB7XFxyXFxuXFx0XFx0Zm9udC1zaXplOiAxLjVyZW07XFxyXFxuXFx0fVxcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJ2YXIgZXNjYXBlID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3MtbG9hZGVyQDAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcIik7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nzcy1sb2FkZXJAMC4yOC4xMS9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5pKHJlcXVpcmUoXCItIS4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3MtbG9hZGVyQDAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS0xIS4vcGxhbm5lci5jc3NcIiksIFwiXCIpO1xuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIioge1xcblxcdGZvbnQtZmFtaWx5OlxcblxcdFxcdC1hcHBsZS1zeXN0ZW0sXFxuXFx0XFx0QmxpbmtNYWNTeXN0ZW1Gb250LFxcblxcdFxcdFxcXCJTZWdvZSBVSVxcXCIsXFxuXFx0XFx0Um9ib3RvLFxcblxcdFxcdE94eWdlbixcXG5cXHRcXHRVYnVudHUsXFxuXFx0XFx0Q2FudGFyZWxsLFxcblxcdFxcdFxcXCJPcGVuIFNhbnNcXFwiLFxcblxcdFxcdFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsXFxuXFx0XFx0c2Fucy1zZXJpZjtcXG59XFxuXFxuOnJvb3Qge1xcblxcdC0tb3JhbmdlOiAjZmY3ODNhO1xcblxcdC0tY2hhcmNvYWw6ICMyZjQ4NTggIWltcG9ydGFudDtcXG5cXHQtLXBsYXRpbnVtOiAjZTdlN2U3ICFpbXBvcnRhbnQ7XFxuXFx0LS1nb2xkY3JheW9sYTogI2Y5Yzc4NCAhaW1wb3J0YW50O1xcblxcdC0tYmxhY2s6ICMwNzA3MDcgIWltcG9ydGFudDtcXG5cXHQtLWJsYWNrLWZhZGVkLTE6ICMwNzA3MDdjNyAhaW1wb3J0YW50O1xcblxcdC0td2hpdGU6ICNmNGY0ZjQgIWltcG9ydGFudDtcXG5cXHQtLXdoaXRlLWZhZGVkLTE6ICNmNGY0ZjRlMCAhaW1wb3J0YW50O1xcblxcdC0td2hpdGUtZmFkZWQtMjogI2Y0ZjRmNDlkICFpbXBvcnRhbnQ7XFxuXFx0LS1ncmF5OiAjYTdhN2E3ICFpbXBvcnRhbnQ7XFxuXFx0LS1saW5rLWJsdWU6ICMwMDdiZmYgIWltcG9ydGFudDtcXG5cXHQtLWNvbG9yLXBhc3Q6ICMyZjQ4NTggIWltcG9ydGFudDsgLyogY2hhcmNvYWwgKi9cXG5cXHQtLWNvbG9yLWN1cnJlbnQ6ICNiN2I3YjcgIWltcG9ydGFudDtcXG5cXHQtLWNvbG9yLWZ1dHVyZTogIzkxYjE4YiAhaW1wb3J0YW50O1xcbn1cXG5cXG5odG1sIHtcXG5cXHRtYXJnaW46IDA7XFxufVxcblxcbmhlYWRlciB7XFxuXFx0YmFja2dyb3VuZDogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuL2ltYWdlcy93b3JrZGF5cGxhbm5lcjEuanBnXCIpKSArIFwiKTtcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwJSA0MCU7XFxuXFx0YmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG5cXHRtaW4taGVpZ2h0OiAxMjhweDtcXG59XFxuXFxuaGVhZGVyID4gLmNvbnRhaW5lci1tZCB7XFxuXFx0YWxpZ24tc2VsZjogY2VudGVyO1xcblxcdGJhY2tncm91bmQ6IHZhcigtLXdoaXRlLWZhZGVkLTIpO1xcblxcdGNvbG9yOiB2YXIoLS1ibGFjayk7XFxufVxcblxcbmhlYWRlciBoMSxcXG5oZWFkZXIgcCB7XFxuXFx0bWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuXFxuXFxubWFpbiB7XFxuXFx0YmFja2dyb3VuZDogdmFyKC0tcGxhdGludW0pO1xcbn1cXG5cXG5ibG9ja3F1b3RlIHtcXG5cXHRtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuXFx0cGFkZGluZy10b3A6IDFyZW07XFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG5mb3JtI3NpZ251cCxcXG5mb3JtI2xvZ2luIHtcXG5cXHRtYXJnaW46IGF1dG87XFxufVxcblxcbmZvcm0jZGVtby1sb2dpbiB7XFxuXFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ29sZGNyYXlvbGEpO1xcblxcdGZvbnQtc2l6ZTogMXJlbTtcXG5cXHRtYXJnaW46IGF1dG87XFxuXFx0bWFyZ2luLXRvcDogM3JlbTtcXG59XFxuXFxuI25hdmJhci11c2VyIHtcXG5cXHRib3JkZXI6IG5vbmU7XFxuXFx0Y29sb3I6IHZhcigtLWdvbGRjcmF5b2xhKTtcXG5cXHRmbG9hdDogbGVmdDtcXG59XFxuXFxuI3NpZ251cC1lcnItdG9hc3Qge1xcblxcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBsYXRpbnVtKTtcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjMDAwO1xcblxcdGJveC1zaGFkb3c6IDFweCAxcHggMnB4IDFweCAjMDAwO1xcblxcdGNvbG9yOiB2YXIoLS1saW5rLWJsdWUpO1xcblxcdGZvbnQtc2l6ZTogMC44OXJlbTtcXG5cXHRwYWRkaW5nOiAwLjVyZW07XFxufVxcblxcbi5iZy1jaGFyY29hbCB7XFxuXFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY2hhcmNvYWwpO1xcbn1cXG5cXG4uZm9ybS1ncm91cCA+IGxhYmVsIHtcXG5cXHRmbG9hdDogbGVmdDtcXG5cXHR0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG5cXG4jYmxvY2txdW90ZUJvZHkge1xcblxcdHRleHQtYWxpZ246IGp1c3RpZnk7XFxufVxcblxcbiNwcm9maWxlLWhlYWRlci1yb3cge1xcblxcdGxpbmUtaGVpZ2h0OiAzMnB4O1xcblxcdHBhZGRpbmc6IDZyZW0gMXJlbTtcXG59XFxuXFxuLmdyaWQtY29udGFpbmVyIHtcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jaGFyY29hbCk7XFxuXFx0ZGlzcGxheTogZ3JpZDtcXG5cXHRncmlkLXRlbXBsYXRlLXJvd3M6IGF1dG8gMWZyIGF1dG87XFxuXFx0aGVpZ2h0OiAxMDB2aDtcXG5cXHRtYXJnaW46IDA7XFxuXFx0cGFkZGluZzogMDtcXG59XFxuXFxuLmxvZ2luLWNvbnRhaW5lcixcXG4uc2lnbnVwLWNvbnRhaW5lciB7XFxuXFx0bWFyZ2luOiAyLjY1cmVtIGF1dG87XFxuXFx0bWF4LXdpZHRoOiA0MjVweDtcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxuXFx0d2lkdGg6IDcwJTtcXG59XFxuXFxuLmxvZ2luLWNvbnRhaW5lciBpbnB1dCxcXG4uc2lnbnVwLWNvbnRhaW5lciBpbnB1dCB7XFxuXFx0Ym94LXNoYWRvdzogaW5zZXQgMXB4IDFweCAjMDAwNDtcXG59XFxuXFxuLnRleHQtZGF0ZSB7XFxuXFx0Y29sb3I6IHZhcigtLW9yYW5nZSk7XFxuXFx0Zm9udC1zaXplOiAxLjdyZW07XFxuXFx0Zm9udC13ZWlnaHQ6IDcwMDtcXG5cXHR3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxufVxcblxcbi50ZXh0LWdvbGRjcmF5b2xhIHtcXG5cXHRjb2xvcjogdmFyKC0tZ29sZGNyYXlvbGEpO1xcbn1cXG5cXG4uYmctcGFzdCB7XFxuXFx0YmFja2dyb3VuZDogdmFyKC0tY29sb3ItcGFzdCk7XFxuXFx0Y29sb3I6IHZhcigtLXdoaXRlLWZhZGVkLTEpO1xcbn1cXG5cXG4uYmctY3VycmVudCB7XFxuXFx0YmFja2dyb3VuZDogdmFyKC0tY29sb3ItY3VycmVudCk7XFxufVxcblxcbi5iZy1mdXR1cmUge1xcblxcdGJhY2tncm91bmQ6IHZhcigtLWNvbG9yLWZ1dHVyZSk7XFxufVxcblxcbi5iZy1ncmF5IHtcXG5cXHRiYWNrZ3JvdW5kOiAjZGJkYmRiO1xcbn1cXG5cXG4uZm9vdGVyIHtcXG5cXG5cXHQvKiBWZXJ0aWNhbGx5IGNlbnRlciB0aGUgdGV4dCB0aGVyZSAqL1xcblxcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNoYXJjb2FsKTtcXG5cXHRib3JkZXItdG9wOiAxcHggdHJhbnNwYXJlbnQgIzAwMDtcXG5cXHRib3gtc2hhZG93OiAwIC0ycHggLTJweCAycHggIzAwMDQ7XFxuXFx0aGVpZ2h0OiBhdXRvO1xcblxcdHBhZGRpbmc6IDAuNXJlbSAwO1xcblxcdHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4uZm9vdGVyIC53cmFwcGVyIHtcXG5cXHRkaXNwbGF5OiBmbGV4O1xcblxcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG5cXHRtYXJnaW46IGF1dG8gMCAhaW1wb3J0YW50O1xcblxcdHBhZGRpbmc6IDAgMXJlbSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uZm9vdGVyIHNwYW4ge1xcblxcdGxldHRlci1zcGFjaW5nOiAxcHg7XFxufVxcblxcbi5saW5rLWJ1dHRvbiB7XFxuXFx0YmFja2dyb3VuZDogbm9uZTtcXG5cXHRib3JkZXI6IG5vbmU7XFxuXFx0Y29sb3I6IHZhcigtLWxpbmstYmx1ZSk7XFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcblxcdHBhZGRpbmc6IDAuMjVyZW07XFxuXFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5cXG4ubGluay1idXR0b246aG92ZXIge1xcblxcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4uZGlzYWJsZS1jbGljayB7XFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5mYS1zYXZlIHtcXG5cXHRmb250LXNpemU6IDE4cHg7XFxufVxcblxcbi5jaGV2cm9uczpob3ZlciB7XFxuXFx0YmFja2dyb3VuZDogIzI5MmIyYzM0O1xcblxcblxcdC8qIG9wYWNpdHk6IC4yOyAqL1xcbn1cXG5cXG4vKiBUaGUgTW9kYWwgKGJhY2tncm91bmQpICovXFxuXFxuLm1vZGFsIHtcXG5cXG5cXHQvKiBFbmFibGUgc2Nyb2xsIGlmIG5lZWRlZCAqL1xcblxcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJsYWNrKTtcXG5cXG5cXHQvKiBGYWxsYmFjayBjb2xvciAqL1xcblxcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJsYWNrLWZhZGVkLTEpO1xcblxcdGRpc3BsYXk6IG5vbmU7XFxuXFxuXFx0LyogRnVsbCB3aWR0aCAqL1xcblxcdGhlaWdodDogMTAwJTtcXG5cXG5cXHQvKiBMb2NhdGlvbiBvZiB0aGUgYm94ICovXFxuXFx0bGVmdDogMDtcXG5cXG5cXHQvKiBGdWxsIGhlaWdodCAqL1xcblxcdG92ZXJmbG93OiBhdXRvO1xcblxcblxcdC8qIFNpdCBvbiB0b3AgKi9cXG5cXHRwYWRkaW5nLXRvcDogMTAwcHg7XFxuXFxuXFx0LyogSGlkZGVuIGJ5IGRlZmF1bHQgKi9cXG5cXHRwb3NpdGlvbjogZml4ZWQ7XFxuXFx0dG9wOiAwO1xcblxcdHdpZHRoOiAxMDAlO1xcblxcblxcdC8qIFN0YXkgaW4gcGxhY2UgKi9cXG5cXHR6LWluZGV4OiAxO1xcblxcblxcdC8qIEJsYWNrIHcvIG9wYWNpdHkgKi9cXG59XFxuXFxuLyogTW9kYWwgQ29udGVudCAqL1xcblxcbi5zZXR0aW5ncy1tb2RhbC1jb250ZW50IHtcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1mdXR1cmUpO1xcblxcdGJvcmRlcjogMXB4IHNvbGlkICM4ODg7XFxuXFx0bWFyZ2luOiBhdXRvO1xcblxcdHBhZGRpbmc6IDIwcHg7XFxuXFx0dGV4dC1hbGlnbjogY2VudGVyO1xcblxcdHdpZHRoOiA2OCU7XFxufVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDU3NnB4KSB7XFxuXFxuXFx0Lm1vZGFsLWNvbnRlbnQge1xcblxcdFxcdGZvbnQtc2l6ZTogc21hbGw7XFxuXFx0XFx0cGFkZGluZzogMjBweDtcXG5cXHRcXHR3aWR0aDogMTAwJTtcXG5cXHR9XFxuXFxuXFx0LnNpZ251cC1jb250YWluZXIsXFxuXFx0LmxvZ2luLWNvbnRhaW5lciB7XFxuXFx0XFx0d2lkdGg6IDkwJTtcXG5cXHR9XFxufVxcblxcbi8qIGFueXRoaW5nIGFib3ZlIDEyMDBweCAqL1xcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDEyMDBweCkge1xcblxcblxcdC8qIFxcblxcdC5zaWdudXAtY29udGFpbmVyLFxcblxcdC5sb2dpbi1jb250YWluZXIge1xcblxcdFxcdHdpZHRoOiA4MDBweDtcXG5cXHR9ICovXFxufVxcblxcbi8qIFRoZSBDbG9zZSBCdXR0b24gKi9cXG5cXG4uY2xvc2Uge1xcblxcdGNvbG9yOiB2YXIoLS1ncmF5KTtcXG5cXHRmbG9hdDogcmlnaHQ7XFxuXFx0Zm9udC1zaXplOiA4cHg7XFxuXFx0Zm9udC13ZWlnaHQ6IDYwMDtcXG59XFxuXFxuLm1vZGFsLXNhdmUtYnV0dG9uIHtcXG5cXHRiYWNrZ3JvdW5kOiAjMDA4NGZmZGE7XFxuXFx0bWFyZ2luLXRvcDogMC4yNWVtO1xcblxcblxcdC8qIGZsb2F0OiByaWdodDsgKi9cXG5cXHRwYWRkaW5nOiAwLjVlbSAxZW07XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHVybCkge1xuICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuICAgIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICAvLyBTaG91bGQgdXJsIGJlIHdyYXBwZWQ/XG4gICAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgICBpZiAoL1tcIicoKSBcXHRcXG5dLy50ZXN0KHVybCkpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSArICdcIidcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsXG59XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNS4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMC0wNS0wNFQyMjo0OVpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy41LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGV2ZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAoIGkgKyAxICkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdG9kZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG5cdC8vIGlmIG5vdCBzcGVjaWZpZWQuXG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zLCBkb2MgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0sIGRvYyApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjVcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMjAtMDMtMTRcbiAqL1xuKCBmdW5jdGlvbiggd2luZG93ICkge1xudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKCB7fSApLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaE5hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58XCIgK1xuXHRcdFwiaXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV1cblx0XHQvLyBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaHRtbCA9IC9IVE1MJC9pLFxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcblxuXHRcdHJldHVybiBub25IZXggP1xuXG5cdFx0XHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2Vcblx0XHRcdG5vbkhleCA6XG5cblx0XHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICtcblx0XHRcdFx0Y2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGVscyApICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAoIHRhcmdldFsgaisrIF0gPSBlbHNbIGkrKyBdICkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQoIG5vZGVUeXBlICE9PSAxIHx8IGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG5cdFx0XHRcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgfHwgcmNvbWJpbmF0b3JzLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblxuXHRcdFx0XHRcdC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHQvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT09IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblxuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KCBcInxcIiApLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyWyBpIF0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIubmV4dFNpYmxpbmcgKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAoIG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBuYW1lc3BhY2UgPSBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PThcblx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xuXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuXHRyZXR1cm4gIXJodG1sLnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPSBkb2N1bWVudCAmJlxuXHRcdCggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBDaHJvbWUgPD0xNiAtIDI1IG9ubHksIEZpcmVmb3ggPD0zLjYgLSAzMSBvbmx5LFxuXHQvLyBTYWZhcmkgNCAtIDUgb25seSwgT3BlcmEgPD0xMS42IC0gMTIueCBvbmx5XG5cdC8vIElFL0VkZ2UgJiBvbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wIG9ubHlcblx0Ly8gU2FmYXJpIDYuMCBzdXBwb3J0cyA6c2NvcGUgYnV0IGl0J3MgYW4gYWxpYXMgb2YgOnJvb3QgdGhlcmUuXG5cdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblx0XHRyZXR1cm4gdHlwZW9mIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdCFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpzY29wZSBmaWVsZHNldCBkaXZcIiApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiApO1xuXHR9ICk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoIFwiXCIgKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlclsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImlkXCIgKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbIFwiVEFHXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kWyBcIkNMQVNTXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoIHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkgKSApIHtcblxuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdFx0dmFyIGlucHV0O1xuXG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIn49XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0XHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxuXHRcdFx0Ly8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3Ncblx0XHRcdC8vIGFyb3VuZCB0aGUgaXNzdWUuXG5cdFx0XHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJcIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIio9XCIgK1xuXHRcdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpjaGVja2VkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjpjaGVja2VkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIi4jLitbK35dXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTMuNiAtIDUgb25seVxuXHRcdFx0Ly8gT2xkIEZpcmVmb3ggZG9lc24ndCB0aHJvdyBvbiBhIGJhZGx5LWVzY2FwZWQgaWRlbnRpZmllci5cblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiXFxcXFxcZlwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbXFxcXHJcXFxcblxcXFxmXVwiICk7XG5cdFx0fSApO1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT1kXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjplbmFibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZGlzYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBPcGVyYSAxMCAtIDExIG9ubHlcblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIiosOnhcIiApO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLC4qOlwiICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAoIG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvciApICkgKSApIHtcblxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oIFwifFwiICkgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkgKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGIgPSBiLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUgKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBhID09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0Y29udGFpbnMoIHByZWZlcnJlZERvYywgYSApICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGIgPT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRyZXR1cm4gYSA9PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwWyBpIF0gPT09IGJwWyBpIF0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbIGkgXSwgYnBbIGkgXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRhcFsgaSBdID09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuXHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHxcblx0XHRcdFx0bWF0Y2hbIDUgXSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMiBdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWyAzIF0gPSBcIiBcIiArIG1hdGNoWyAzIF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWyA0IF0gPSArKCBtYXRjaFsgNCBdID9cblx0XHRcdFx0XHRtYXRjaFsgNSBdICsgKCBtYXRjaFsgNiBdIHx8IDEgKSA6XG5cdFx0XHRcdFx0MiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWyA1IF0gPSArKCAoIG1hdGNoWyA3IF0gKyBtYXRjaFsgOCBdICkgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbIDYgXSAmJiBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwclsgXCJDSElMRFwiIF0udGVzdCggbWF0Y2hbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KCBleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSApICYmXG5cblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XHRcdFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApICkgJiYgY2xhc3NDYWNoZShcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoXG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8XG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcblx0XHRcdFx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGkgXSA9ICEoIG1hdGNoZXNbIGkgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXCJcIiApICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJ4bWw6bGFuZ1wiICkgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoIFwibGFuZ1wiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoICggZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuXHRcdFx0XHQoICFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpICkgJiZcblx0XHRcdFx0ISEoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXggKTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCApIHx8XG5cdFx0XHRcdCggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkICk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbIFwiZW1wdHlcIiBdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKCBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgKSA9PSBudWxsIHx8XG5cdFx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9ICksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9ICksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID9cblx0XHRcdFx0YXJndW1lbnQgKyBsZW5ndGggOlxuXHRcdFx0XHRhcmd1bWVudCA+IGxlbmd0aCA/XG5cdFx0XHRcdFx0bGVuZ3RoIDpcblx0XHRcdFx0XHRhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbIFwibnRoXCIgXSA9IEV4cHIucHNldWRvc1sgXCJlcVwiIF07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8ICggbWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFsgMCBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICggdG9rZW5zID0gW10gKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAoIG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWyAwIF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0gKTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoICggbWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApICkgJiYgKCAhcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdCggbWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkgKSApICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbIGkgXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICggb2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0gKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKCBuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWyAwIF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbIGkgXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoXG5cdFx0XHRcdHNlbGVjdG9yIHx8IFwiKlwiLFxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LFxuXHRcdFx0XHRbXVxuXHRcdFx0KSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoIGVsZW0gPSB0ZW1wWyBpIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwWyBpIF0gXSA9ICEoIG1hdGNoZXJJblsgcG9zdE1hcFsgaSBdIF0gPSBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goICggbWF0Y2hlckluWyBpIF0gPSBlbGVtICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKCBtYXRjaGVyT3V0ID0gW10gKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgJiZcblx0XHRcdFx0XHRcdCggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcIiBcIiBdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoIGNoZWNrQ29udGV4dCA9IGNvbnRleHQgKS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggbWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaSBdLnR5cGUgXSApICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbIGkgXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1sgaSBdLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHR0b2tlbnNcblx0XHRcdFx0XHRcdC5zbGljZSggMCwgaSAtIDEgKVxuXHRcdFx0XHRcdFx0LmNvbmNhdCggeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0gKVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKCB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFsgXCJUQUdcIiBdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9ICggZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEgKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFsgaSBdID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbIGkgXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZShcblx0XHRcdHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzIClcblx0XHQpO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoIHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IgKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAxIF0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbIFwiSURcIiBdKCB0b2tlbi5tYXRjaGVzWyAwIF1cblx0XHRcdFx0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksIGNvbnRleHQgKSB8fCBbXSApWyAwIF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByWyBcIm5lZWRzQ29udGV4dFwiIF0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICggZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdICkgKSB7XG5cblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKCBzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0XG5cdFx0XHRcdCkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdCggXCJcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFwiXCIgKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbn0gKTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJocmVmXCIgKSA9PT0gXCIjXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSApICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIF9uYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09IG51bGw7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdCggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9ICk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0gKSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIF9hbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gSUUgPD05IHJlcGxhY2VzIDxvcHRpb24+IHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50cyB3aGVuIGluc2VydGVkIG91dHNpZGUgb2Zcblx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXHRkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xuXHRzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xuXHR3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF07XG59XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbmZ1bmN0aW9uIGV4cGVjdFN5bmMoIGVsZW0sIHR5cGUgKSB7XG5cdHJldHVybiAoIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgKSA9PT0gKCB0eXBlID09PSBcImZvY3VzXCIgKTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXG5cblx0XHRcdGhhbmRsZXJzID0gKFxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuXHQvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFleHBlY3RTeW5jICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgbm90QXN5bmMsIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0Ly8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3Rcblx0XHRcdFx0Ly8gZnJvbSBhbiBhc3luYyBuYXRpdmUgaGFuZGxlciAoZ2gtNDM1MClcblx0XHRcdFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHQvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRcdG5vdEFzeW5jID0gZXhwZWN0U3luYyggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYyApIHtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuXHRcdFx0XHQvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHRcdC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG5cdFx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4XCI7XG5cdFx0XHRcdHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnRcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRhYmxlIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyQ2hpbGQgKTtcblxuXHRcdFx0XHR0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIHRyICk7XG5cdFx0XHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0ICkgPiAzO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IChcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHQpWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHRcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJiBqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICkge1xuXHRcdFx0XHRzLmNvbnZlcnRlcnNbIFwidGV4dCBzY3JpcHRcIiBdID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggX2ksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0aWYgKCBpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgKSB7XG5cdFx0XHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zLCBkb2MgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucywgZG9jICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMudG9wID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRwcm9wcy50b3AgKz0gXCJweFwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMubGVmdCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cHJvcHMubGVmdCArPSBcInB4XCI7XG5cdFx0XHR9XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxudmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5qUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcIlwiIDpcblx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBU0FCSUFBRC80UUFpUlhocFpnQUFUVTBBS2dBQUFBZ0FBUUVTQUFNQUFBQUJBQUVBQUFBQUFBRC80Z0ljU1VORFgxQlNUMFpKVEVVQUFRRUFBQUlNYkdOdGN3SVFBQUJ0Ym5SeVVrZENJRmhaV2lBSDNBQUJBQmtBQXdBcEFEbGhZM053UVZCUVRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTl0WUFBUUFBQUFEVExXeGpiWE1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFwa1pYTmpBQUFBL0FBQUFGNWpjSEowQUFBQlhBQUFBQXQzZEhCMEFBQUJhQUFBQUJSaWEzQjBBQUFCZkFBQUFCUnlXRmxhQUFBQmtBQUFBQlJuV0ZsYUFBQUJwQUFBQUJSaVdGbGFBQUFCdUFBQUFCUnlWRkpEQUFBQnpBQUFBRUJuVkZKREFBQUJ6QUFBQUVCaVZGSkRBQUFCekFBQUFFQmtaWE5qQUFBQUFBQUFBQU5qTWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFpYaDBBQUFBQUVsWUFBQllXVm9nQUFBQUFBQUE5dFlBQVFBQUFBRFRMVmhaV2lBQUFBQUFBQUFERmdBQUF6TUFBQUtrV0ZsYUlBQUFBQUFBQUcraUFBQTQ5UUFBQTVCWVdWb2dBQUFBQUFBQVlwa0FBTGVGQUFBWTJsaFpXaUFBQUFBQUFBQWtvQUFBRDRRQUFMYlBZM1Z5ZGdBQUFBQUFBQUFhQUFBQXl3SEpBMk1Ga2dockMvWVFQeFZSR3pRaDhTbVFNaGc3a2tZRlVYZGQ3V3R3ZWdXSnNacDhyR20vZmRQRDZURC8vLy9iQUVNQUFnRUJBZ0VCQWdJQ0FnSUNBZ0lEQlFNREF3TURCZ1FFQXdVSEJnY0hCd1lIQndnSkN3a0lDQW9JQndjS0RRb0tDd3dNREF3SENRNFBEUXdPQ3d3TURQL2JBRU1CQWdJQ0F3TURCZ01EQmd3SUJ3Z01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNRFAvQUFCRUlBa0FEQUFNQklnQUNFUUVERVFIL3hBQWZBQUFCQlFFQkFRRUJBUUFBQUFBQUFBQUFBUUlEQkFVR0J3Z0pDZ3YveEFDMUVBQUNBUU1EQWdRREJRVUVCQUFBQVgwQkFnTUFCQkVGRWlFeFFRWVRVV0VISW5FVU1vR1JvUWdqUXJIQkZWTFI4Q1F6WW5LQ0NRb1dGeGdaR2lVbUp5Z3BLalExTmpjNE9UcERSRVZHUjBoSlNsTlVWVlpYV0ZsYVkyUmxabWRvYVdwemRIVjJkM2g1ZW9PRWhZYUhpSW1La3BPVWxaYVhtSm1hb3FPa3BhYW5xS21xc3JPMHRiYTN1TG02d3NQRXhjYkh5TW5LMHRQVTFkYlgyTm5hNGVMajVPWG01K2pwNnZIeTgvVDE5dmY0K2ZyL3hBQWZBUUFEQVFFQkFRRUJBUUVCQUFBQUFBQUFBUUlEQkFVR0J3Z0pDZ3YveEFDMUVRQUNBUUlFQkFNRUJ3VUVCQUFCQW5jQUFRSURFUVFGSVRFR0VrRlJCMkZ4RXlJeWdRZ1VRcEdoc2NFSkl6TlM4QlZpY3RFS0ZpUTA0U1h4RnhnWkdpWW5LQ2txTlRZM09EazZRMFJGUmtkSVNVcFRWRlZXVjFoWldtTmtaV1puYUdscWMzUjFkbmQ0ZVhxQ2c0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaTQrVGw1dWZvNmVyeTgvVDE5dmY0K2ZyLzJnQU1Bd0VBQWhFREVRQS9BUHk3L2FaMDlkYi9BR2NiNlNPUGMybTZyYlhERWZ3Qmc4WlBIdTRITmZLUDJmelc1WUtPZnFhK3FmakNiNkg0TCtOTkx2N2VhQzl0VnQ1SGhkU3JMdHVJem5IcGduMndLK1pkQTBpVFhyN3lZOGJzYm5KL2hYb1Q5ZmF2aWVEWmNtQ3FLVDBVMzl6akYvcWViZzVLTVczMy9SRGRQU1o1VWVCcEVhSWdxNmtobEk2WUk3L1N2MjcvQU9DSnYvQlRtOC9hSytIZytGL2o3VVdrOGJlR1lCL1pGL08zNzNXTE5SamE3SDcwc2VNRTlXWEI1T2EvSHpTUENUWExMYVdjT2V3WTkvcWVtUnorSFBTbTZOOFZkUytHdmovVGRZOEk2bmNXRjlvTnd0MWJYMXY4c2treW5odjl6T1JnNTNBblBXdUhqSGh2QzhTNENlWDFVcjJ2R1hXTDZQNTl1dnlLcDRsem43cTBQNlRQaU5wRWZpV3lraGtUYmNSOGdqaXZHcGRNZTB2V2hsSGx5Um41WEFQWGovUHBWai9nbnY4QXRxYU4rMzErejliNjFFMXRaK05ORFJMZlg5UFJobUtiSCt0VVp6c2ZsbDlPUjFGZXFlTFBoOUQ0bXRESkN2azNFWEo3SC9PUDYxL0V0VEs4ZmxXWnp5M01ZMmxGNlA1N3J1bnVhVmRQZmdlWVdHciticDkzWk9xUnlUTVQ4cWY2MDRIekgzeDYxNEIrMHovd1VQaitCT2t3ZUEvQ3NkeHErcXh4biszYnV5dWtqbXM4OGlDUGRqYytEOHdCR09CMVBIdlhpQmJqUmI4ZkorK2hJS3Vlb3hYai93QVYvd0RnbjU0SC9hWitLRVBqQnJ5NjBXLzIrWnJXbjZmQ2luVldHQ0hCUDNHSTRZNE9SanZ5ZnVzbHlITHFtUFZiTVUybXIyNlNsc3IyYWUyMXJKdTE3bm4xWnlrbTR1M2NkK3hwL3dBRkd4NGp2b3RQMVRYTlFranp0RmxybG95WEM5c0NVNXo3WVlpdnIrMCtLdWxhNWE3WTQ1SUoySEc0N2xPZWVPLzUxNFg4UC9nRDRiOEUyVU5sb3VqV2VsMlVXQ3pBYm5rLzM1RytZbjZuOGhYWTZyYzZmb2FLek0wcXFCOHFBbkIrdGRtWmNLT3JpSlZjTlAyY1h0R1NVdnk1V3Z2WjVIMXhRMFYydjYyT3Uxdld0VUlaclczdnBvMUJabWlZQlFQZmJrL2lhODUrSUhpUi9GMmt6NmRxV2s2YnFsbk1Dc2x2ZXhMY3h5SDB3NElQNVZvYUg4YVpOTG54cHR2ZUxNT0UvZGxsYjhLb2FsNGx1anVtYlROUGh4OHg4M0Mvekk5dWY4SzdzbnlyNnRyV1VGSytqZzI3K3Q5bjgyYytJcWM3VHBTZnpzZVQzdnd3OEU2ZGJJWS9BK2lhYnRVbmZwdHY5aktaSko0andDTTVPQ01aNXI1Qy9ibStHV3FlRHJteThWZUhidTgxRHczWW8wZDdBMG1aclF5Tmt2SXE0OHhQdWpjT21Ca2Q2Ky9OUnVZOWJqWmJqUllXV1RHREZKdExlaEdENzllYThEL2FqK0ZVdXErQnRZdFk3Rys4dTZ0bVY3Wjl4YVRnbjVUakpQQTZlbkZmWlpmTjBzUkd2VVNmUitqMFlxYm45cDNQQy8yWS93QnViL2hXalNhYmVYZjluZnV3RVc5UjdnalBLaU5RRHdlZ1lEQkREMDQ4NzE3NHhYUHhhL2Exdk5TMUpwZk1nVW1ReVlHZGcyNXdEd01BanIrdkErWmZqUHFNbWlmRTNUN2hKZHkySldOR1J1dmxNTWZrUWV0ZWcvRC9BTVpXdi9DOHZFVjFOTXFSYXBkZWNaSk1LRlNYRWpkL1JqK0FyN212dzdDbFJuaXFkM3owM3AydTFlMy9BQVR0clU2anBxcE4zN2ZmYjVuczN4aCtQZXNmRFR4MThKZkR2aG8zRCtMTlUxTTZ6ZFc5c3pOSkkwcFczczRTb1BVL3ZpUWV6S2ErNy8yaFAybWRZOGQrR2ZEbmgvVXRRamtzZkRkbEhiTkRiVGVkSExjNCtiYTNHOEtTVVUraURHZURYNWkvczcvRUd6OFlmSC94VjhTNzZTRnJ5NnUyMC9SRW1VWnNZQW9YelZKKzY2UWVWR3B4L3dBdEpEd1FEWDJKOE12RDkvOEFFclVkT2ExdGJwcmVaR0ZuR1A4QVdPQWN0TG4rQkFDUDNqREEzY0JqZ1Y4N3hUVHhPSHdOTElNTW1sbzZsdXNucnlyeXU3ZkpkajBPWjA0S2t0K3ZxK255TzA4R3FtbjNwbnVvVnVycENjSTN6UndISjRZZEdJeU9PZzlEWFhTK09WMUViN2lXV1pqbk8zT1NNK3BPQUs5Si9aLy9BR003L3dDTDJvalNkSGlqdUk3SWhkVTFTY01OUDAwa0E3ZjcwMDJEeEdDdll0dEZmY1h3Zy9ZajhBL0NMVFkwWFI3ZlhOUUNnU1h1cFFwS1dQZlpGalpHUFFBRWorOGErZHkzd214bVl5OXBpSnFNZkw4dHZ5dmJ1YTA4REthdkoyUitibGpyZDNmZ2ZaTkx1SjlyRG5ZejU2ZTFkWDRhOENlUHZGWC9BQjRlRmRVbVU0d1Z0WDJuOHhuL0FEK05mcVBZK0hySFNJdGxuWTJkcW82TERicEdQL0hSVnRTeWpidUk2OFY5ZmgvQS9LNHI5OVViKy84QXovUTZJNWRSVzdiUHphZy9aNitMRU51ckh3YmZiZXFueVNTVCtIK2VsR29mQ1g0bDZSQ3MwM2hHL2ppWGxuK3pNMk1jNTRIOHgrZGZwSm5uK3RTUlRZUGY2WnJvbDRJNUg5bVV2eC96UnAvWjlMcGY3LzhBZ0g1ZC93QnQrSXJDYjk5cG9ESjhwUmtZSDlRRC9uMzQwWWZGcjNEcTF4cGJLT0Eyd1pJOVA1VitsZW9lSGROMXBOdDVwOWpkcVI4M213SzUrbklybjlXL1owOEc2L0g4K2kyMExFRERRamIvQVBXcnpNWDROd2pyaEpML0FNQ2tuK3EvRXpsbHNmc3lQaDN3bjRndFJlYm9aWmJYT052T052Ymo4LzVmajdkOFB2amZxbWxDTlk5UWVSVndjcTNYOEs5RDEvOEFZYTBhN0xTYWRjTEMvd0RkbWlCWDZaSDE5SzREeE4reVhybmhPUjVJN2VTV0xQOEFySUR2R1A1OXZhdmhNejREemJMNSsyaXB4dDlwYTIvN2VpOVBuWW1PRnIwM2VPdm9ldGVFZjJvWVJ0ajFERWk5Mis2dyt2YXZUdkNYeEYwbnhsQ3JXTjBqT3d6c1k0Yi9BT3ZYeHFQRHVyYWFyUnNWbTJuN3JydFlWZjBYeEhkYUZPcGplNHNabFlIblBQOEErcXVyS3ZFbmlQSjVKWXo5L1JYZjRyZVVscjk2WnZERVc5MlNQdGxmbU5PUmNWNEY0RC9hYnZkTmtqaDFaZnRWdjA4d0REQWZXdmFQQ3ZqZlRmR05xc2xqY3BJMk9VSjJzdjRWKzU4TThmWlBubjd2QzFPV3IxaExTWHk2U1hwZnpzZGNaSm11Um1rSCtjMDhLQjdWbTYzNHYwdnczRVh2TDIzdHdvemhuR1QrSFd2c2ExYW5TaTUxWktLWFZ1eSs5bEYvT0taY1hNZHJHWGxkWTBYcVdPQUs4czhWZnRLeGxuaDBPemE0Zi9udE53djFBcml0UnZOYjhlVDd0U3U1cEkyUEVLWkVZL0FmMXI4K3pueE15ckJweHc3OXJMeTBqLzRGMStTWWF2WTlVOFUvSGJTZERmeWJWanFWejB4RnlxL1U5SzR1NzhWK0lmSGwySXpOSmJXOGh3SUxmSzVIdTNXcjNnNzRRWEYwSTJlSHlVL3ZFWUlyMExTdkRGcjRldDlzU2d1b3lYUFUxOHpUL3dCWk9KNUxtYncrSDdwTk5yeTZ5K2RvbGNpV3MvdU9OMEw0Znc2RkQ1MXlxelM5UW5VZlUxbCtLNW1rWmgvQ09nRmR4cmo0VnY4QUd1RDF3ZWJLZmF2MFhKK0hNRGxOSDJlRWpyMWs5WlAxZjZiSFZTZDlUajljRzJOdXVmNTEyM2dqU1A3SDhJV2NlM2E4aWVhM3FTL3pjOGVoQS80Q0s1VzUwczZ0cVZ0YTQvNCtKVmpKeHlxbjd4L0FaTmVqWEVXQjhvNEhYQTZDdnBNREhWeStST0lsME0rZGZteDN6NlZWbGo5UHlCOWV0WHAwM0x1Kzc3MVZsSHpqcnVIVmNWNlJ6eEt1UDNmZFNNZEs2TDRXNkgvYi9qelRiZGwzUnJMNTBudXNmem44OXVQeHJCQ1lLL0o4M3A2ZDY5SStBR21DM09yYW93MnJid2kzVC9lWTdtL0VCUi8zMVFLYnNybk8vdGovQUJkMC93Q0ZmdzY4UmVKTldtOG5TL0R1blhPcDNzaC9nZ2dpYVdVL2dpTjcxL0lqOEp0R0g3WlA3WXVrV25pelZOVTArNitLZmluRjdlYWRaTGVYQzNkL2NFcnRqYVNNYlROS3FzeEo4dEN6aEpDb2piK2p6L2d2NU40dzE3L2duWjhVclB3WnA5OXFHcFh0aEhCY0paeFBMTXRpMXpDTHh3cUFzd0Z0NXhiQVB5N3pnNHhYOHpmd1ErS2x2OEl2aWpwdmlPVFJORzhUUjZZSmgvWitwUkpOYnlHU0dTSVNiWFYwOHlJeUNXTXVqb0pJMExJNEJVa1d1YXpNck5RTzQrUG53cDhOMkh3WDhKK05mRCtueCtFUnFsM2RhY05CdnRmWFVkVDFLMmptbmpoMVlLeVJTYldsdDd1MmxBZ2lqV1MyalpWSG5GRThaemdWNkorMUY4ZTUvd0JwVDR3WFhpaVczMUt4aGt0TFN5dDdXOTFSdFJrdGtoZ1NOc1NGSTFVUElKSmZMaWlpaVF6TXFJcWdDdlBNZi9YcVpXdm9CR3pialNaVURyU2taL3hwckFzZjhha0I5bmZUYWZkUnp3VFMyOXhDUThjc2JsSGpZZENHSElJOVJYM0Qvd0FFd3Y4QWdxciswYjhQUDJrL0JQaDJ4K0luaXJ4ajRidnRVdGJHNThPNi9kdnExdmR4elRSMjZXOFJtTFNXN1BKTEdpdkV5N1dkU1F5Z3FmaHZabnYrbGZmL0FQd2JqL3MrSDR4ZjhGRC9BQTNxczF1Sk5QOEFCcTNIaVc0SjZiTEpFRWY0cnFGNXBVZy82NW4zclNuSnAyUk1vUmU1KzBIL0FBVXIvd0NDcy93cC93Q0NabW5hRGFlTmJQWFBGR3NlS3ZPTmpvdWoyOE1zclc4WkN5WEV6VE9pSkhsZ295V1oyeUF1RlpsK05ZdjJuLzhBZ2w3L0FNRkZrV1B4aDRWOE8vRGZ4SmZNZm4xTFJaZkMxMTVoNnU5N3A3RzFZOTh6eUhQcDFyNEQvd0NEaGI5b1AvaGZuL0JVTHhsYnd6Uno2YjhQN1cyOEpXaktjNE1BYWE1Qjl4ZFhGd3YvQUFFVjhSdHdQUVVtNFA0bzMvTXJtbXZoZHZ5KzQvY1h4cC93YXRmQnY0NzZKSDRoK0JmeDQxYVBSTGc3a2t1VXMvRlZpK2M4SmMyandiUU93SWM4Y2s5YStzOWQvd0NDYldyL0FMTFgvQkczeDE4Q2ZoRGVUZUtmR0dwZUh0UWpmVWJrSlp6ZUlMNjVpV0tZcXUvWkR1dDBTM2lWbklSSW9RenRndWY1cGZoeDhVdkZId2M4UkxySGcveEo0ZzhKNnVnd3Q5b3VwVFdGeVBwSkV5dCt0Zm9WL3dBRTQvOEFnNEIvYVU4Ti9IM3diNFc4VitKditGcCtGdFR2NHJHN3NkYXM0NU5TZUp5Ri9jWGthQ2RyZ2tnSUpXa1ZuWlFSem1uR0VIcEZ0WDc2L2ovd0FkU2U4a242YWZoL3dUODl2aXA4SXZGZndMOFV5YUQ0MDhMK0l2QitzUUVockhXdE9sc0xnQWNaMlNLRGozNmU5YzVuSnIrdFQvZ3BCKzNYOEJQMk52aHhZMnZ4NG0wM1d0TjhSVFMyMWg0ZW4wUk5kazFQeTl2bXVMV1JUR0kwRHJ1YVFxdnpBQWxpRnI0WmwvWmovd0NDVy84QXdVamRwUENuaVB3djhPdkVtb0VLSTlKMWwvQ040SEo0UkxLL1g3SzV5ZnV3d25QWTRGUjdPcDBWL1RmN2lwU3BkN2V1MzMvOEEvQko1R2xjc3pNek1ja2s1SlB2WDdZLzhHbkh3RmhzSWZpWjhVdFRXTzN0OUwwMlBTTFc2a1VCVk4zTjUxMWs5akZEcHRtK2Y3bDhjY0U1eS9qci93QUdnT3V4L3dDbWZDbjQwYUxxVnRjSGZEYWVMdEtsczlrZkhTNnRQUEV2Zm55RUZmYS9oZjhBNEo4K0xmOEFnbnovQU1FUS9pVjhMZkJNeDhjL0U3VXZET3JYRjVjYVZhdkVkUnY3aXpXMTIya2ZNakdLMWhoaWl5QThyd2h0cUdUWXBHVnJ0NkI3TzlyTzUvT2grMTE4ZUp2Mm9QMnB2aUo4UkoybVAvQ1plSWIzVllWbFB6UXdTVE1ZWS9va1hsb1BaYTd6L2duSjhLOUs4ZWZGdnhUcjNpRFRiZlZ2RC93OThJNmpydDViM0dreTZ0YitkSUk5T3NwSkxXTDU1bzRiMit0cDNVWi9kd09TQ0FSWGd1cDZYTm9XcDNHbjNrTTFuZVdUbUdhQ2VObzVZbVU0S3NqQU1DTzRPQ01WWjhMZUxOVzhDYS9iYXRvZXFhbG91cTJUaVMzdmJDNWUydUxkaDBaSkVJWlQ3ZzA0MldwTXIvTTBmaXRxMm42NThTdGF1ZExzZkQrbTZjMTA2VzhPaEpkcHBySXZ5Q1NCYnQzdUZTVGI1bTJVaGwzNDJvQUVYNlIvNElsZnM2TCswei93VWQrR21nWEZ1TGpUWTlaaHU3MVN1NVh0N2JmZlhFYi9BT3pKYVdkMUZ6eG1SUjNyNU9rbGFXUm5kbVpuSlptWTVMRThrays5ZnRCL3dhTWZzN2kvK0kzeEUrSjExRGhORjBaTkl0SlhYNWZOdjduRzlTZU44VWVtWENrOWt2ejY4MVQzdUVqeWYvZzYrL2FPYjRuL0FMZnZoN3dMYjNUVFdmdzM4T28xekVUbnk3Ky9iN1JKK2R1dG1mWE9mYXZ5OVM0YTFuRHh1eVNSc0dSMGJCVTlRUWVvSXIxYjl2TDlvVnYyci8yMGZpajhSUE9NMXI0cThSM2QxWUU5VnNsa01kcW4vQWJkSWwvQ3VzLzRKamZzeFdIN1V2N1NGMXBPc2FmcE9yYVhvK2dYMS84QVlkVXZiaXlzcisvbFZiSFNiYVdXM1pabFNYVmJ5d2pJalpYWU1WQkJiSWlOMjlCeXRjMHYyZVArQ3lIN1QzN0xvaGk4Si9HZnhrZFBnd3FhYnJOeU5hc1ZVZndyRGVDVlVIKzV0UHVLL1E3OWpEL2c3WjhaYXY0LzBmUWZqTjhOL0MycGFMZVNpSzgxend1MDFqZFdNSVV0SmN5VzB6eXh6aEZET3lJME9WQnh6Z0g4bWYycTlGOEMrSFBqdHJGcDhON3lTKzhLeHcyYlJzWlpabzRMdHJTRnIyQ0dTYU9PV1NDSzhOeEhGSklpdThjYU1ja2xqNjEvd1I1L1p4UDdVMy9CUXI0WitFWnJjM0ZqcUd0MjYzcUg3c2xvaGE0dmtQOEF2YWRiMytQY0N0WXlrM2FXdjRtTHBSU3ZIVDAwUDZRUDI0LzJCUDJQZkZYaERVUEVueDA4Qi9CL3c3cHhuRUUzaVc4bGg4TXp5VHR1MnFiMkY0SkpKR3d4Q3N6RTdTZHZCcjRWOFkvOEdyZjdPdjdVV2d2NGgvWi8rTzJzV09uelB2M3hYTmo0eTBxSUgrQkpJSGhrUWY3OHNqVjg4LzhBQjNKKzBwY2ZFUDhBYlE4Ri9EZUc4a2wwL3dBQzZDMnEzY1FrK1ZML0FGQ1RKM0tPTWkzZ2dZRThnVEhIVTUvSy93QUFmRVh4QjhKL0U4R3VlRk5lMXJ3dnJWcWN3NmhwRjlMWTNVUjYvTExFeXNQd05ZcW5UN1c5UDhqZVZTcjNUOVZmOGVoL1ZCOEhQK0NaTjUrd3Qvd1NjK0lQd1crRSt1VGVKUEhuaUR3L3JEeDYzY3hSNmNkUjFpNXNCYXhPcWJtVzNSVml0NDFETzJDbTltSlpqWDh3UHhuK0FYano5bUh4R2ZEL0FNUS9CWGlyd1Bxc0JNWXQ5YjB1YXhhWGFjRmszcUE2bnFHUWxTRGtFam12ckg5bmYvZzVDL2EwK0FCdDRicng5YWZFYlRiZFFvdFBHZW5wcVVqZ2YzcnRESGVFL1djMStnLzdMSC9CMkY0RC9hUDFqU3ZBSHgyK0RFV2s2VHIwcVdkM3FOamRKcm1pcHY0YVM0MCs0aURyQW8rWnlKSm1DaGp0YkdEZksyN3dhOUgvQUZZelZSS05xa1g2clg4Ti93QWo4bnYrQ2UzN2Nkait4UjRzMTdVN3ZROWUxVmRaT25TR1RSTlhqMHU3dUVzN3RicHRObmxlR2JkcDkyeVJyY1JLb1p4REZ5UUdSdm56VnIvKzFOVHVycnliZTMrMVRQTjVOdkg1Y01KWmkyeEYvaFFad0J6Z1lGZjFTZnRUZjhHL1A3SG54MHNOUTFQV2ZodnBIdzV1SWtQbmF4NFMxRC9oSG9yUWNLRzhvWnNsNXh5MEhKUHZYd244ZnY4QWd6Z25udDIxTDRQL0FCd3RiaXp1QUpMU3g4WTZTVmpLSHY4QWI3TXVKTWowdGxIdWFpVTVXOTVmUCt0ZndORkdGL2RsdjBlbi9BL0V4LzhBZ3o3L0FHY3hxZnhPK0ozeFF2TGRWajBmUzRkR3M1WlB1TzkzTTN6b2V6UnJaWFNNZjd0eU8yYS9OWDl1NzlvLy9ockg5dHY0dy9Fd1hKdXJQeGQ0b3VwTk5rTEgva0h4T1liUWZoYnh4TCtIYXY2SVAyWFArQ2IvQUlzLzRKbi9BUEJIejRqL0FBNjhHM3R2NHkrTHVxK0hkYTFGTG5Tb0doaHVOWGwwOW9iZUMxRGtPeW95UmxTKzB2Szd0dGpEN0YvbDQxalQ3endIcWsyZzZ2WlgyamF0cGJtM3VySyt0M3RyaTNrQitaWGpjQmxZSHNRQ0syalVqeitpSjVXb04rZjVIb3Y3TEVmalFmR2kxdnZBR242WHJIaUxUclc1Yit6YithM1dQVTdhYUZyUzV0dkttbGpNNWxodUpJekZFVE1WZDJRQXFXVjM3WFh4dDhVL0ZyeDdwMm4rTHZETnI0TTFid0RweWVGWmRGZ3RKN1JyRnJTUjRnczBVN1BNTGlPTlliZDJsWnBXRm9tOW1ZR3FmN1BIeGowbjRFNnhxbmlyK3lXMWp4cnA5dWc4SU5jUnh5YWJvOTZ6Zk5xVXlOa3l5MjZETnZGdDJlZTZTdVNzSGt6ZWQ2dnFOeHExOWNYVjFOY1hWM2R5Tk5QY1RTR1NXZVJqdVozWThzek1TU1Nja2trMVVwYVdKWGMrbnY4QWdqRit6a3Y3VmY4QXdVaStHZmhXNHRsdXRObTFhS2UvaVpjcE5hUkh6cnVOdjk2eml1OGU0cjdrL3dDRHN6NC9TL0ZMOXUvd0g4TjdlNkUybi9EZndySnJOOUVHTzJQVWRTbE9RdzZFaTJndFhCOUpHL0c5L3dBR2Z2N09UZUpQano4UVBpUmNRZVpENGIwbGJDMURyd3R6ZHlHS0dWRDZpR0hVNHo3Uys5ZkNmL0JSRDlvcGYycHYyOFBqaDhTSTVsbXN2RVhpeTVzOUttQnlyNmZaRDdMWnNEN3d4SjA3K3RPRWJ6akY5TmY2L0FYU1VsNUkrZWZzRWsrcVIyOXVWTTAweXhSQXlCQVhKQ3FOeElBNUk1SkFIVTRGZlgxeCsyRCsycC93U1o4VmFUb2QxOFJ2aUo0VVc0czF1TExTOVUxRCszTklhTENNWTRvN29UV3JiUThlVEJrTHZBRFo2ZktmZzNUUEVHdWVOZE9oOEoyMnVYWGlTT2NYT214Nk5GTkpxQ1RSZnZSSkNJY3lCMDJGOXk4cnMzWkdNaXg4YS9qMzR1L2FFOFRXK3JlTk5jdU5jMUd4dEUwKzNrbWpqait6VzZGaWtLcWlxQWlsbXd1UGx5UU1kSzFsTG9tTGtVdmlWejliL3dCaS93RDRPNC9pRko0OTBIUWZqTjhQL0NQaURSZFF1b3JTNjF2dzE1dWw2aGFJeHcwN1FTUExCTVZCM0ZGOGdFRGdpdjFUL2J4L1krL1pHOGIrQXI3eFYrMEo0TCtEdGhwRWtpd3orSmRiV0RSTHBwSHlVUWFoRzBOd1pHd3hDQ1RjY0hqZzEvTXAvd0FFay8yZGYrR3Ivd0Rnb2o4TVBCY3R2OXEwL1V0WWgvdENESEUxa0dCdkI5VnN4Y3lmU0kxK2ovOEF3ZGkvSDZYNGwvdGxmREg0WFFYREhUZmgvd0NHcnJ4YnFNU1M0amE5MUNieUlsZFJ4dmppdGxkU1JrTGNOakc0MWhLbkdiaXJhdC8xK29VK2VMZkpKclR1ZnB2L0FNRXdQMkRmMlUvMmFJdGU4V2ZzMXQ0ZDE1dkVVUXRMeldkTzhWdDRrYUMzM0svMldPVHpaQkRHWFJHWlJobk1jZTh0NWFiZnk4LzRMQWY4RzdYN1JIajc5c2Y0amZGdjRWMm1rZkUvUS9pQnJFdXVQcC85cncyR3RhWThvQmVBcGNsSXBZMElLeG1PUm1LYlJzQkhQNVA2WnIycS9EcnhWRHJYaC9VOVMwSFdiVTdvZFEwMjdrczd1RThZMlN4bFhYOEdGZlpud2EvNEx6L3RrZnNnVDZQYTZuOFFMdnhacDk5WVFhcGE2WjQ1dFl0Wk56YVRLVEZLMDdNdDhxeUlBNlpuVWxHU1FBbzZNMnJ3OW5lRXJQejFIR3BOWDVrcEw3dnUvd0NIdDVIeTk4UWZoZjhBRjc5aDd4dmIzUGk3d3A4VHZoRHIwSmxodEw2OTArODBpUTdrZUovSnVRRjNLeU95a3h2aGxZamtFNWsrSlg3VXZqejQrK0NQRG1nK0pQR09yK0p0RDhHUUMzMExUWmJoVGIyQ2xRcEtLb0NtUndvM3l2bVJ5TXN4SkpyOWtmMlNQK0RzdlEvakQ0azBmd1Q4YnZoSFo2VHB2aUNhT3d2TmEwTFVQdCtuTDVoQytaTnAxeW00UWpJTGJaNVcyNXdqSENuN08vYXcvd0NDRmY3Ry93QWNORXZ0YThWL0Mzd2Y0RWExakxTNi93Q0c3b2VGMXRkeEE4MWpBMGRxU1NSODBzYlpKSFVtajIxYUN0TlhYbC9UL1FTOWxKMzFpL05YL0ZXL0M1K0Ivd0FOZjJGckhXdjJrUGhyNFg4Sy9FTHcvd0NPTEw0Z2EwK2kydDNwa2NrTnhaNHZZdE4rMlBDMlNzSDJtWXZESmtpV08zWndCaGxUOUNmK0R1WDQvUTZSTjhCdmdib2MwZHBwY0J1L0dXcDZkR05zYVFXNnJaNllDdlFvRysyZ0tmN3ExOWFmOEU5LytEZDc0TGZzTGZ0RWFmOEFGendyNDArSVBqbHRQaWtmUUlOWnZyTzRzYlI1WVhoTndaTGVGUHREQ09Sd21TRVVzSDJzNm95L0ZQOEF3Y2dmOEV5LzJndmk1KzNDM3hrOEYrQXRlK0tIZ202OE0yV2pSUWVIWWhlYWxvUnR6SVpJbXRGUG5TSzhqdEtyeHF3L2VNQ1ZJR2M1MW95bkhtMFY5YmxVNE50dU9ydHBiOUwrUitWSGgveFJxUGhmWG9kUzB6VXI3U2RTaE8rRzhzYm1TMnVZVDZyTEdWZFQ5Q092YXZzYjluci9BSUxZZnRYL0FMUGVsMnQxWS9FdlgvRlBoMVpqYnh3K01ySWE5WlR5cW9MUkc2bEF1aVFwVWxFdVZJREtjWU9hK0k5ZDFPUHdqNGptMFhYN1hVdkRPc1dyK1ZjYWRyTnBKWTNOdWZSMWxVYlQ5ZjhBOVhyM2l6OW83eGwrMEg4TWZocDhQOVcxVzExRFEvaDJMalQvQUEzdlpJVXRvN3VTRE1ja2dJVFlwaWpBZGhsVnp1SnhtdlM5MmE5MnovRTU1UXM3VFZuOXpQMWEvWjkvNE92NXZLdGJmNHFmQitPUk9CY2FwNE8xWGFlY2NpeXZNQUQ2M1pQYXYxditEUHhXOFBmdEMvQ3Z3LzR6OEwzVGFsNGY4VFdpWHRqSzBMUlNGV3lDcnhzTnlTS3daV1FqS3NyQTlLL2xaOGRmc21haDhPL0N0djRxaDF2UmZFZmdXNjFSOU1qMWV4Y3FaOWsweU13aWJsZjNjQm1HR082S1dObEovZWlQOVgvK0N5bnhBMXYvQUlKei93REJ2MzhQL2hmcE41UG9QalQ0aUhTL0NHcE5hVG1HZUtTNlNYVU5aWlNNSFk4Z21oZkg4RjFnOWE0Y1ZDRVV1WGU1cFNqSnp0ZlN6ZmZZL0t2NHEybHI0NDhMMytpK0lJWnBiYTdpTVAyeUQ1YmlCY2dqRFk1QVlBN1d5RGl2Q0pQMmVVK0hIaHFacks2aDF5M25rTHZkeHJ0WUwvQXJyenR4M3dTQ1NhKzNmRmZoclFmSGx2SjUxdTBFMGk0TTFzTWZUY2hHRCtocnh2eGo4RnRXOEh5UGZXQjg2ejV5MFB6THRPZnZMMUF3ZVFSK05meTV3OXhFNlZQNnZHWEltN3VMMmI4bjArWHpSNTFTalVVSEY2cnlQbFg0alhpK0RmRDhPbndOdDFIV0ZMenRuNTRiZmtBZGVybkk5Y0tmWE5mUkhnZjlnWFFkYi9ZTDAzeFJmWE9vTjRtMTh2UFkyOEtvc2R1QStFZlAzbUJYcXZjZStDT0I4ZWZEcTExdlhwZFVHbHdYV29TYlVuZ21rMks0VlFxK1UzM1ZJeDkxaGcrb3Jiay9iaDFydzlvMXI0VXZ0TTFBNmRZSWtjY01zWVdhMzJqQ2JlY0h1T09DSyswekxGWmppc05SaGxEdE5TVTV1NnUwdWk3clplYVhlNDZOU0toeUphbm5mN01meDk4Y2Y4RTQvd0JwM1Q5ZXMxbWprdDlzV3BXSllyRHJGa3pmTWhCOWNFcVNNcXcrdGZ2ZDhFdjJtUEQvQU8wYjhLZEo4ZGVGWHVKTkgxcUxkSXM4VFJ5MjBnNFpIVStoeU1qZzlRYS9NVDltRC9nbGxxMnZrL0U3NHBXRjFlM1d0RVhtbDZIZEEvSkVlVWE0NVBHMGphbkhIWDByMjcvaHZud2YreDk0dSt6YS9yaVQyc2dTMnU5RjAySTNNc1VYT0NFVGlQYU9lY1o1RmZtM2lGak1OeERpYWVGeTZrNnVKcDZTbkJPemZXS1ZuZFgrMWRKZEcrblRLc2xhTXZpNjJQcy80ZytGN2Z4Yll5WEZ1cXJJZ0xkY2NldkZlTmYyaGRlQ2RlVzRXUWlTRmdWYisrUFFpdlRQQzNqVzMxblN0TjFyUmJ5SFV0RDFxM1M2c2JwYzdKNG5HUWZ4emoyUDVWejN4YzhOcHFHbjNGOUJ0UkVKRW9CKzRlL1QvUFR2WDVyaHNWVm9YcDFGb3ROZDBjbk9veUtYeEsrS1Z2NFcrSFZ6NHFqMDNVOVdqczhOZDJWbXk3NGdUamY4eEdGQjVPTWtkZW1hOG44SWZ0UzN2eFJ1cG9JOUpzOUhqbkJWQThyU1NqM0Q0Q2cvOEJJclM4TGVQVDRidjJobTJ6VzB3TVUwTC9jbFRvUVJqMFA2Vnl2aTM0ZVdQaDdVRGY2SXpTNlRLLzd2bjVyVW4vbG0zZmpvQ2VvcjNLK01uOVhjZGJ2N1g2SEZpTUxEbjVrZG9mQkd0YWxhM051dDllYW5IZFI1bXNycVpoSVU5VUtuRHI3cGdqdUJpdmtuNDdmc2l6ZUJQRWphenBuMnZVUERkd1RIZXhUTjVrK21samc3czh0R2M4T2VWSTU5VDlTK0VQaTFOWmVUWjNxc3l4T0NzdWZtamJzUWV4SFhJcjFtR0RUUGlQcHp6WENxMHdRcTEyc1lLeXFSZ2laZTRJL2l4eG5tdkd5M2liRTVkVlh0WGErajE5MlMvd0RiWDJmZlI2R3VIbEdmdVNWbWZpdjRsL2FDOFVmQWllUHc5OXUrMTJzYzhxM05sZVJpZUFCVzIvS3Jjb0NRZVVLbm9lSzNQRHZ4djhRV096eGQ4T3ZFV3I2ZkxwLzd6VWZEc3Q2YmdiQU1zOFViNVNlSUFNY0ZkeWpPUmdaUHNuL0JXdjhBNEoxYTU0VzhRM0h4TThMMk1sNW9mMmRGMVN3dGtMdllCUGwrMFI0ejVrVGRXSTVRNUo0NmZCbmc3eExjYURxa2NrVTBrVzF0OGJ4TmhvbkJ5cktldkJIVWNpdjZwNGZoZ00yeTZHT3d0dWRyMzFiZDlZeVg1UGUxbW5iZnNsZ1k4blBIZjh6NlMrTTE5WWZ0ZGFkcU9wejZicCtsK05yTzNhOHM3blRJaERiNjBvK1pvcG9zN2ZOSURGWkV3U2VHRFpCWHk1UENUZUxyYXp1bzJ1NDdtOGdqUmxoSHp2bFFDZS9QSkE5T0sxZitFMG0walNMUHhMcG5sdTBMK1ZxY1FDcXNFeGI1WkZVSGhYNHpnWUQ1SEFkUlhwUHcxL2E4K0hYZ2J4SnQxandtczFqTUVJdTlLZ1JiaTFZcDgyVWM0WUJpUU1GU0J6ZzhDdG8vWHNQVDVNUEJ6U3ZaWFduZGE5Tm1sOTJsakNuR28wbzluL1NQZHYyRWYrQ2ZXbCtEOUxYV1BGdGpiYWxkM0NmNkhaM2taa1MzQmJPNHIwSndPcEhKend2US9ZL2gzeFAvQU1JaGJYMm55YVZwY3kzTUN3dThFSDJPWllpUjhvZVBhY0ZpWEdlTW5wNmVCZUJmaUQ0ZjFmU1lkUzhLNnRKcWtVMW9sNUhDanQ1MGNCSkFrYUZnc3FLU0NBU29CNHhualBxSGhENDJmYjRGVzRpanVJdG9VYjE1QTZqbkE5ZlN2NXY0cXhuRU1zZExGMXB5NXV5Ymp5K1NYVDllb3EzdG5kcjhEN28vWm4vYlM4SStCZkJtaitGNXREL3NIVHJGZkpTU0VtVEpQV1J5Zm1kbVBMTVRrbm5tdnByd3Q0OTBQeHpENW1rNnBaM294bmJHL3dBdy9Eclg1ZTZYNGswM1U5TlZZWkk0NUpNWTh6SEg0L2pWN1MvRU91ZUQ3LzdSYTNFakp3OFJqWWpERDB4OVBYMCt0ZC9Edmpabk9YcjZ2bUZPTmFDMFY3UWtsMlRTNVg4MWZ6TWFPYVZvdmxtci9tZnFZOE8wOC9MVVRJYy81NHI0ZitFUDdmM2lqd2JFc09zS3VxMllCSGx6N2pNdVBSdXY0R3ZwZjRXL3RiK0QvaWhISEg5c1hTNzV1REJkSGF1Zlp1bjU0cjk0NGI4VWNoemkxT0ZUMlZWL1lubzc5ay9oZnlkL0k5cWppcWMxMlBSaXBiNlk2VTVPdnB4MXFUQ3lJR1ZsWldHUVJ5RFI1ZVB1aXYwSjl6cld3NkVaL3JWdTMraHhWZUpkeDcxYmdHMzg2UXkzQ1B6TldWSHpmclZlRmZscUxVL0VtbjZGQzBsNWR3VzZyL2VibjhxeXJWNmRHRHFWWktNVnUyN0w3MkJCci93OTBmeFJHd3ZiR0dSai9HbzJ1RDlSWG5makw5bVJwd3phWkxIY1I5ZkpuNFlmUTF0YS93RHRKYURwWlpiTlp0UWtYKzZ1MWZ6TmNqclg3Ukd1NjBQOUJ0NDdLTWpqamMzNW4rbGZrWEZYRW5Cazd4clNWU3AzcEs3K2NsN3IrYlpVcVhNdFR6M1h2Zy9xR2kza2tjVyt6a2g0Wkp1RVA0MDdRYmk3OEpYRWNxMzM3NU9kdHZuK1pyWHVOUDFieGRjK2RlVFhGd3puT1dKclMwdndJa0JIbTdTekR0MXI4RHhGVER5eFB0c05UY1VuZE51ejh0RnBmN3pPbmg0eGVoSHEvd0FWL0ZYaXlKWURleVd0dmpiaUVCV2Y2dGpOWjF0NE9tdjdqekxpU1NaaWY0MkxmajYxMkZub3NOaEI1azIyT05lN1ZpNmg4V2JIU05Samh0ck9TVGEvTWt3MnFmWGpyN1YxWXpOTWJqVno0bXE1THZKdHBlaS95Um80d2hyTjJPZzhIZkM2YlVIVVF3a3IvZXg4cS9qWHFYaHI0YTJlZ3FIbFVUVGVwSHlqOEtxL0RmNHM2UDR2dGtoaEtXZDJCZ3dOd0NmWTk2N1F4NS8vQUYxKy9jRGNGNUxDakhId3FyRXovbSt6RjlsSG8xL2UxOUNuVVZyUTBSVktBTHhpcVYybkorbk5hY2k3ZTFaOSt1M1A1VityR1p5L2lFL0szMHJpOVRqM1NOMy9BQjdWMm5pSVlybEwrTEM1d2VlZnBYTFVPMm10Q2g0TDByN1Q0bWVZcUdXMGpKejZNM3lqOHh1cnE3dVBCd1A1WXdhcmVCOU0reTZWSmNmeFhFcDdmd3I4by9YZFYrNWo2OFo3L1d2UXc4ZVdtam1yU3ZJekprM0xsZlhHS3B5UjRiYjZjLzByUXVGd3hITGQvd0NWVkpSOHlqSTdDdWhNbUpXZEdHMWMvTDc5NjljOEtXMy9BQWkzd2x0OGpiSmZGcnAvZmR3di9qcXJYbDlsWVNhbmZ3MjBYelMzRWl4SmtmeE53T1BxYTlRK0wxN0hwV21MYXcvNm0zakVhTG5vRkdCVkdkVHNmbXYvQU1GVVArQzR2Z3YvQUlKeGZGUFJmQ01uaFBXUEhmaXJVclpkVXVyVzF2NDlQaDB1MVozU04ybFpKTjByc2toRVlVWVZjbGdHWFB6YmMvOEFCVFQvQUlKNi93REJRSml2eGQrSDFwNFcxeTlJRTE5NGg4Tm0zdUpHUHBxZW1NMDIwZjNwR2ovQ3Z6RC9BT0NybngrUDdTdi9BQVVUK0xYaW1PZGJpdy90MlhTZE9rVnR5UGEySUZwRTYraXVJZk14L3dCTkQ2MTg4bDlxN2UyYzFMbEY2U1Z5YnlqOExhUDI0MS8vQUlOei93Qm1uOXJ2UnJuWFAyZmZqUmVXS01kL2wyT3BXbml2VGJiMFFxcnBjUituN3labUhvVHdmay80L2Y4QUJzeiswcDhKUkpjZUY0UEIvd0FUdFBqSklHaDZwOWt2UWc1QmVDN0VRM2Y3RVR5ZTJhL1AvUU5jdlBDK3RXK3A2WGVYV21hbGF0dmh1N1NacmU0Z2IxU1JDR1UrNE5mV2Y3UHYvQmQzOXFMOW5oN2VHMStKbDk0djB5M0lIMkR4YmJwckt5S1A0VFBKL3BLcjIrU1phUFp3Nk5yOGYrQ1Ayaisway93UG5MNDEvczVmRUg5bS9XVjAvd0NJWGdieGI0SXVwR0t4cHJla3pXUW14L2NhUlFyajNVa1Z4WUc2UGNwR01kYS9kZjhBNEo4LzhISlgvRFhQeFcwSDRWL0ZqNFlhUHAzL0FBbUZ4RnBRMVhScmg3alMydUo1WTdlQ080c2JnT3l4U1RTeG9YRXo3UzRKWGJsaDlJL3RsZjhBQkkzOWlueEZvdjhBYkh4RThMK0EvaE8yb3pHMXQ5WjAvVzR2Q1N2TTJUc2pUZWxySkoxT0RFNS9DcDVKOU5mVC9ML2dqL2R0WHZiMS93QXorWlhQTmZ1Si93QUcybmdEVGYyZGYyTy9pOThidkVVWmgwK3h0MHRIbEF3d3RyTzJmVmJ4MHpnSGZIZDJjWjUrL1pFZHF5L2lWL3dhWWVGdkdhUTZ0OEsvanhkcm9GNWd3cnJXa3c2cWpvZXBXOHRKSWtmanBpSUErbzYxOVVmdGEvc0VlS1BnSi93UkM4VmZBLzRPcHFQaS93QVMyK2pHT2E0VzNXRzk4UXZQZnJjNms2eEtTQThrVDNDUndnc1FubHhCbktnbWxMbFR1ckZSaGQ2YW44M2Z4QThkNmo4VlBIK3VlS3RaazgvVnZFMnBYR3IzOGdHUE1udUpXbGtQNHN4cjZMLzRKb2VGZmhub2Z4QXRQSFh4RzhUZkQrRzgwM1ZyZXk4TmVHdkV5VDNObnFsejVrTFhGMWVSUXd6QllJWVpQM0szSWpobnVHUU16eFc5eEczemQ0djhMYXA0QzhTWFdqNjdwZXBhTHExbS9sejJXbzJyMnR6QzNvMGNnREtmWWlzN0dhSVNTZHpPU2Uyek9yK1BIZ0J2aFQ4Yy9HM2hXU0pvWDhOZUlOUTBveHNNR013WE1rVzBqMjJZcjY0LzRONnYyZW0rUEgvQlNud1ZOTEdzbW0rRWJqL2hJNzBNbTdhbGlEZFF1UHBmUjZlaDlwejFHUlh3N3U4eC9tT1N4NU9lVDZtdjIyLzROZC9oVFovQ240QmZGNzR6NjhGdGROczdaTkpXN2tHUHM2S2d2OVE1L3UvWjAwaVQvdnFuVDN1RytoOGUvd0RCeUo4ZnYrRjAvd0RCVHpYOUpnbWFYVC9oNXBWcDRlaXcyVU14WDdWT1FPeEVsd1l6M3pEN1Y4RXNnWVliNWgzeU0xMVB4dCtLMS84QUhmNHkrTHZIR3FjYWg0eTFxODF1NVhQM1h1SjNtS2oyRy9BSFlBQ3ZYdjhBZ25EOElsK0tmeGh2STd6d0ZxM2pLeGx0NDlGdGIyMjBLYlhyVHd6cWw5S0Vzcnk4c1lpR3VMY21PYU1yenRNaXVGbGRFaWtVWXVUc2dsTHFjZCt6diszUjhaUDJUTG1Gdmh2OFR2R25nK0dLVHpmc1ZocWtuMkNRL3dDM2FzVEJKOUdRMStqMy9CUHYvZzZBK050MThaUERQaFg0c2FYNFg4ZStIdFV1VnQ3N1ZMVFRScGV0VzBmSmFaQmI3YmVWbFVNUkY1S21RNFhlaE82dnl0K0wxZ3VsZkZyeFJheDJPZzZhdHJxOTNBTFRRN3FTNjB1MzJUT3V5MWxra2tlU0FZd2p0STdNdTBsaVRtdnE3L2dnWit6eC93QU5EZjhBQlM3NGQyODl1SjlOMERWWU5idnR3eXNjZGx2MUVidjloM3NrZ1ByOXBBNzFwQ3BLNlRkMFJLbkgrdjhBZ0g5QjMvQlNHWDlsdndUNEVoMWI5cDZ6K0dMYVhlWERXRm5kZUpOSVcrdnA1UVBtUzJhS043djVRY2xvY0JBd3lSa1Y4SlNmOEVHUDJGZitDZ3RwOXEvWjkrS3plSDlUZUlzTFB3MzRsajE2S0FZeUhsMCs4WTNxbjFCbGpIOHErTlArRHBQOW9kdmk1L3dVbFh3aERjeVNhZjhBRER3OWE2ZThmL0xNWGwwUHRzenI3bUthMVErOFdPMWZtM0JJMXJkUnp3czBVMExCMGxSaXJ4c09RUVJ5Q0RnNUZZcUZQdDkyaHJLcFZXaWYzcTUrcW54OS93Q0RSdjQrZUFMdWFYd0I0dytIM3hGc1ZiYkhETmNTYUZxUjU2dEZNR2dIYnBjRTU3R3YwQStDZjdGM2piL2dsUDhBOEVKZmlsb1N3Mm1xZkZhOThQNnZyVittZzc3aU8wdW5zRXRJRWdiYUdrTU1FRWNya0xnekdmWnVVcXpmaXArem4vd1c1L2FtL1plRnZiK0hmakY0bzFMUzdjcmpUUEVicHJ0cHNIOENyZGlSb2xQVDkweUgwSXI5SGYyRHYrRHNueEI4US9pcDRmOEFDdnhpK0d2aCtHMTFXNUVFM2lUd3Jjeld2OW1JQVdhNGtzN2hwZk1WQXBaL0xsVmdBU2lPMkVPaWhvMUdXL2RmMStaSHRXbW5LUDNQL1A4QXlQdzJVS2liUXdZTDh1UnowcS9wdmlQVnZDYzF4SFk2aHFHbHZOc1c0VzNuZUV5R09SWlVEN1NNN0pFUnhuN3JJcEdDQWEvcTgvYngvd0NDYWY3SEhqZlFOUThUZkhEd1A4Sy9Cc2NsMklianhQUGZ4ZUZKV3VuM0FiN3FLU0FUU3NWWWdTRnlkcE9DQWErRmZpaC93YVYvQ0g0NStHUCtFay9aL3dEanJxVU9sM0FNa1A4QWFKdFBFK2x6RThoVXZMTXhGRkhUSldWc2RjbXMxenBYYSthL3E1bzFCdXlsOStuK2FQd3Y4WStMZFQrSVhpL1Z2RUdzM2JYMnNhOWV6YWhmM1RxRmE1dUpwR2tra0lVQlFXZG1PQUFPZUFLL1g3L2cwVS9aMGJ4QjhmdkhIeEd1SUZhSHdyb1p0N1ZtSC9MemZ6RzNna1UrcXcybXJJZmFjZXVLK2QvajUvd2JEZnRiZkJTNWtmUi9DZmgvNG1hYW1mOEFTL0N1dHd5UGpJQS8wYTY4aTRKLzNJMkF3Y252WDZoZnNXZnMwK05mK0NPMy9CQ2o0c2EzNGowZGRMK0tWMW8ycWVJNXJLMm5qdXBOSWVQVDF0N09KNUlpeU5zZU43cDlyRUlidVZjNVUwUnFLellwVTVYU1orR1AvQlVIOW9ZZnRVLzhGRFBqRjQ4aHVGdkxEV1BFOXpiNlpNcDRrc0xVL1piUS9qYnd4SDYxeGY3SC93QU40ZmpKKzFiOE9QQnR4b3NmaUdIeGY0aXN0Q09ueVhzbG1rNXVwbGdVbWFQNTR3cGtEbGhrRFp5Q01pdk8yZ2ExUll6amNvQU9DRGc5NjJ2aHo4UjlkK0VYak96OFJlR3RTbjBmWE5PRW4yVzhoQ21TM01rYnhNVjNBZ05zZGdHSEtrNUJCQUljZEhxVExVMnYyaUpQaDYveGYxbGZoYmErS3JYd1REY1BGcDMvQUFrT293Mzk5T2l5TW9tTWtWdkFvVjBDc0VLWlRKQlo4Ymo2Wi93UzEvWnliOXF6OXU3NGIrQjJqZVd4MTdXN1d6djFYdlpQS1B0MlBkYkFYa2cvNjVWOCtoZHFnRHAwSE5mcjEvd2FML3M1SHh4KzExNG8rSU54YXRKYmVCZENsZUJ5ditydkwwbXl0V1UvN1Z2L0FHMHAvd0IwZWxPbnZmc0V0VWRGL3dBSGZmN1ZGLzRvL2FFK0hQd2J0YitaZEQwUFNaUEZ1cldVY21MZWE4dVpaSUxmekV6Z3RERERJVnlPRnUyeDk0MStYZjdQbjdhL3hlL1pLdjFtK0dYeE04YitCMVdUekh0OUsxZWFHem1iL3BwYjdqREo5SFJoWHBQL0FBV0MvYUZYOXA3L0FJS2QvR3Z4ZkROOW8wLy9BSVNHVFJOUGtXVGVrbHBwNkxZd3VweWVIVzNFbkhkeWU5ZU9mczAvQy9UZmpoKzBINFI4RjZ0cVUraTJ2aTNVbzlHanZvb3cvd0JtdUxqTVZzekEvd0RMUHozaURrY2hDeEhJRkZPVXRPWGRoVWpIWjdJL1JEOW5IL2c3Uy9hUCtGVFc5djQ4MHJ3TDhWOVBqUDd5YThzUDdHMU5sLzJaclBiQ0Q3dGJzYSsxdmhWL3djSC9BTEh2L0JUZlhOQjhEL0hqNE5qUmRXMXVaTEcxbjhVNlBaZUl0SXRKWElWUUw0S3R4YjVZNDh6eUVWZnZNNmpKSDRLL0h2NExQK3ovQU9Ob2ZETjlyMmk2MTRoczdSVzEyMzB1VTNFR2gzcFp3OWcwNC9kelRSS0U4eG9TMGF1eklIWW94cnR2K0NjbjdQYzM3Vlg3YS93OThCd3JKczhSYXhiMkZ3MGYzNElKNWtnbG1YM2lTVnBjOWhFZlNxanl6ZkxOSnIwSTVYRFdEYWZyL1g2SDlBWDdSUDhBd2FoL3N2OEF4bWttbDhHMnZqZjRUNnFkMjFkQjFWOVFzdDU3dmIzbm5PUUQvREhMR093d0srRFAyaFArRFB2NDRlQkx5YVQ0Yy9FYjRmOEFqK3hqQksyK3JSeitIOVNZOWxDRVRRZmlaMStsZXMvOEhiMzdkUGludzc4Ui9oNThFdkMzaVRXUEQrbDMybHplTFBFMXRwdHk5dC9hS3lUdmIyVU16SVFXalF3WEwrVVR0SmVOaUNWUWo4MVAyZFArQ3p2N1QzN0tBaHQvQi94bzhaTnBkcnRWTkwxdWRkY3NFVWNCVmh2RmxFYTQ0L2Q3RDdpczQwNDJ1bTEvWG4raHJLcFVXNlQvQUEvTDlXZnZQK3dUK3doOFFQOEFna3YvQU1FZGZpWnBzTU9uNjE4WnBkQjFqeEJIYmFBejNTdzN5V0Vnc3JTR1FxclR1c3F0S2RxNDgyNWtSTjZoWGIrWnJROWJ0djhBaEhiR3lobWh6REdOdzNjbGprbjlTZjhBSXI5ZWYyY3YrRHhyeDdvRWx2Yi9BQlgrRVhoZnhQQ3BWWDFEd3RmemFQZEFjWmN3VGZhSTNmdmhXaUgwcjZPOE8vdDAvd0RCTkgvZ3NUNHp0ZEU4ZmVBOUc4UC9BQkE4VlhTV2tFbmlmUURvZXA2aGN1Y0l2OXJhZklWWm1ZNFh6cmhkeElBQkp4VzBaVGpMbWphWDVtY1p3Y2VXYWNldTExODlkUHZQeVYvNEpnZkdiNGEvQS80aitKTlM4ZjZoWjZiOXZoc0xBU2FnbXF0YXo2U2J4SmRWZ2ovc3dyY0MvZUtHQVd6T3l3YmhLSkdYY2hIelg4VmZHMTE4VGZpWDRrOFRYMDF4YzMzaVRWcnpWcDVwbzQ0NUpaTGlkNVdaMWlDeHF4TDVJUUJBU1FvQXdLL2ZEOW9uL2d6NitFdmk0WEZ4OExQaWg0OCtIdDVKSVdGbHJjTU92NmNnN1JwajdQT2dHT3J5U3NQZkZmQjM3UUgvQUFhdy90WmZDSzRkdkRPaytDZml0cHFrN0pmRDJ1eDJkeXFkaTBGOTVCei9BTE1aaytwb2xpSXkzVFJwR2k5ZVZwLzE1Mlo2Ny93YUQvczVmOEpwKzFUNDErSTF4YmlTRHdYbzdRVzVZY3hYbDJUYndPdnMwQjFORDdyN1Y4eC84RkgvQUk3ciswei9BTUZEL3dCb1R4OGsvd0Jxc2RROFd5K0h0SmtWOXlQWTZYR0xPRjFIVGJJc1NQeDNKOTYvWUQvZ2xuK3lQNDgvNEpBZjhFY2ZpeDRrOFZlSDRyTDRxTG8ycitLVHBGdGNSMzAxa3RuWVN0WldqeVFsbzNiei90TStFWmdvdTloSlpUWDg4M2c3eEJCRjRDMDJ6am5qdUpGUXlUdDVnZGpLNUxObnZuSngrRmJZYTBxMSt5L1ArbVpTVGpDL2QvbC9TS25pbVBNTW43eFlONFpWY25vY0hwbnZXciswZjhWby9qWjhiUEVQaW0xczIweXgxT1pFc0xCNVJKOWdzNFlZN2UydHd3QUJFVUVVVVlJQTRRY1Y3djhBOEU2LzJnUERQd0MrSlhqRFZ2RkhpWHhCNE5zN3p3OTltVFhQREY0OXI0b3RXUy9zN243UHBickJLbm5YQzI1Z2s4MW9JL0lsbDNUQmN4eS9PUHhrOGJENG1mRlB4TjRtajBtdzhQcDRrMWU4MVFhWllMdHRkTUU4OGt3dDRSamlPUGVFWGdmS280SFN1cXBjVUxPL2M5Uy80Sm1mQUYvMnNmMjZ2aHo0Rk1UeldtdWF2YjIxK3FENWxzNVpVaXVuVS8zbzdlU2VVZW5rNTQ2ajlRditEc3I5b1M0K0lIN1Izd3ArQzl2ZHlmMkY0YjBTNjhlYTNZYnMyODl6UEkxblpHUmVoZUZZcmdybm90MHg3MTVKL3dBR2tYN08zL0NmZnRuZUp2aUZjVzdUV3ZnWFI1bWdrQS80OXIyNFUya0lQdEpCYzZqajN0L2JueGIvQUlLYi9HK1A5cFAvQUlLYi90RWVObzVtbTA2MjhSSjRQMHRzN2srejZUQ2xxN0oyMlNTUmViNkV1VDNya2plVldNZm4vWDRGTDdVdlJIemg4S1AyamZpWit5dnJyWG53MzhlZU1QQXM4a2dlUmRFMWVleGptYi9wcEhFd2prNTVJZFdCN2pyWDNEOEUvd0RnNS84QTJxLzJmWk5QdC9pQmErR2ZpUnA5NUJGZXcvOEFDUTZHTkx2cm0xWmlxU1EzRm1JVUt0c1lDUjRaY2xUMU9hL1AzeE1oQ3lNdUc0Skc0OFovRDgveXFUOXByNHFhZjhTdmlEYlNhSGIzbHA0ZThQYVBwM2h6UjQ3d0t0eTFyWldrZHVKcGxSbVZKWjVFbHVKRVZtVlh1SFVNd1VNZXFvdTVuR25GdS81YUg3bGZCei9nNDMvWmgvNEtFYXBvZmdINCtmQnhkSmsxeTdqczRKTmVzckx4VDRmdDVaRHNRdExJaVR3NVpnTjYyNUM3c3N5cU0xN04rMEQvQU1HdFA3S3Z4b3U3aTU4TDZGNHUrRWV0U003bTQ4SGEzS0lXWS8zcmE2OCtJTC9zeENNWTlLL25mL1lDK0J0eCsxVCsydjhBRFh3QkNzaGo4U2E3YVdWdzBaTzZDRjVsUjV2WDkzdjNuSFpDYS9ZZi9nNi8vYXgxcTkrS3Z3citBdWk2dGZhZm9OMXBWMzQzOFUyTnRLMGFhbkY1clcybnhUYlNOOGFTdzNEbU5zcVNVWWdsRnh3enBRY284aXMyelNGU3FuSk4zaWxmWCtyZnFkWDhDdjhBZzFMMUw0UC9BTFEvaC9VdGUrTzYrTHZocnBlb0pxTjdvVng0VCt4Mytwb3BBYTFhUmJobzFXV01lVkpNQnYyTXdWVk8xbHpQK0R0djRLL0VyNGkzSHdTOFg2UDRYOFErSXZoeDRKVFdKTmJ1TkhzcEx4dEp2TGo3T0VtdVVqQlpJZktoT0pDTnFsWEJJTEtHL01MNElmOEFCVWI5b2Y4QVpIbWlnOEIvRm54bHBPbTJ2eXg2WFBlLzJscHFLUDRVdGJzU3dJUDkxRkk5YSs0djJiLytEdVg0cGVFcEliZjRtL0Ryd2o0eXQ0eHNlOTBhYWJRci9qcTc1OCtHUnNmd3BGRUQ3VnJVdzlSTk5TdmJhLzhBWDZrd3FLTDk2Ry9iK3YwN25ndjJTVFNycGxHNkYxSXlwSngvOWI4SzByTy9tdEpsZmF3YkJMTU93NmZNT3Y0L3lyejM0TmZ0TzZmOFV0R2toOFNXNjZiZld6TEI5dWpIN3E0R0JneUtPVUpPY2tjZlRtdlFMNkdUVHJlT1dObHVyTnh1U1ZENWtiWkhZLzRmL3IvalBIWU9wUXFPamlZOHN2d2ZvLzBNSTFVMXpSTUx4bDhMUER2anVHU1NhM0ZqZE1DVFBhRWJXUDhBdEllUHJqQjk2OVovWXkvWVI4TStCN2U0K0xYeFZiUzcvd0FNK0ZNM1dqbTZpKytVQUpsY04xVlRnQmVRV0hHY0N1ZitFUHd6WDQwZkUvU2RGdFhrdFpOUW5DeU1oK1ZJeHk1STlOb1A0NCt0ZW4vdDdmSHhkTjhXMnZnSFFZeGIrRy9ETUtSU2dEOTNQSUJqYWZaUmoySlB0WE5ETXNXcGZVcVZSMnRkNjZwZGs5MWZiMDZHTlJ4dHpRVnBQcjI4ejUyLzRLQi84RkgvQUJ2KzBFdDFwdmdOcHRJOEVxcFNWZE9tTWVyWGFkekp4dVZNZnd4bk9Pdm9QZ01TYVRkVHNaZnRVYkZpV0xMbGlUa25uMTdjNTcvaDltK0xmZzVvL2l4VGVhQjVlZzZ1VHZhRm5ZV3R3ZlVIbnl6OVBsNTZDdktQRnVnMmNlb1MyUGkzUlk3UytrSkszcTI0TE1PT1QyY2NkUWMxK3I4TTUzaGNQUjloUWhhMjZWbEwxYSsxNnI3ano1VVpVdCt2VTllLzRKai9BTGQ4UHdIa2o4QmVJZFUvdER3THFrMzdpYTRKV1RRSlgvaVFuanltT055Y2JUbGdlb1AzMzR5MXk1Ui9za0x4eTI4K0pGZFR2U1pTTWdnOUR3Uno2R3Z4czhRZkJYV3RMdkltMFdhTzd0NXVMVW1KWllwU2VpaVJVeUc2L0s0R2M5Y1Y5amZzRS90WGVLdkN0aFkvRDM0dGVISnRGc3k2UTZKcnhZUEhDNTRFRndOekdOQ2NCWCs2cE9EZ0VHdmxlTytGNldMYnpYTFpSY25yT0YwbkwrOG82WGt1cVcvcWlwVTVTamU5L3dBejZBK0kzaG9Ra1hFTEF4OUEyZmxCN2ovUHJYRTZCOFVsOE5hak5iM0N4eVd0d0RGZFJNMk42LzRpdTQrSmwyOGN6YWJzMnRuOTRGOWY3d3J4VHh4NE5PbnViaGR6YzVVWTY4LzByNHJDUmJvcU5YNFdhNGVWMWFSNjk0VjhKV2ZpTzlaTFM4anVZV1VTUkFPUE1aRDdlbzZISGY4QUt2UnZCYTNuZ2U0Um9tWm9lcFV0MHI1VjhGZU5QS2pHa3pYazFrck9KTE8raC8xbGhjY2hYWEhiMUI0SUpITmQvd0RCajl1cXlsOFdUZUR2aVFsdm91dVdzcHQwMVZCaTB1V3p4NW8vNVpsaGdoaGxTQ0Q4dmY1dlBPRjhiV3B5cVlWZTBpbGR4KzBsM1hkZW1xN00ybFRweHRiVHpQc0xRcGJYeFpZN2JWb0xlVmhsN2VaTjhFaEk1NC9oSjl2eU5mR243YWYvQUFRODhKL0h6V2J6eEQ0SnVMZjRiK0tMZ21TZTArem1YUnRRa0p6dXdtREF4UFVxQ3Zjcm12cDJ6MDZldzh1NnM1RlpXRzlYUnR5dXZZZzlNZjRWNkY0SitJOGQrRXQ3MzkzSi9mUG9QWC9QZXZnY2o0dXp6aDNFZTN5aXE3ZFl2WDVOUGRldTNRN3NQVSt6VTA4ejhIZmo1L3dUeitObjdOT242aGErSVBBK3JYT25YU0tCcWVqeG5VYkdVSzZ0OStJRXJ5UDR3cDl1dGVDMkovNFJUV2tsdnJHT1NlMllPTFM5allLeEJCeEltUXhVNDZjWkZmMDUvRTc0ZmF0OFF2QTBzUGhUeE0zaEh4SUZhVFR0U1cyVzR0dk03SmNRTU1TUkU5Y1lZWjRJcjhNUCtDcC94Qy9hTjBUNGd5ZUEvamhhNkhhN1pCZVdzMm1hSmF3Mm1yS3BJV2VHNldNU1NMeVFRV0JIUmxCNHIrdWZDM3hNeGZFdDZPSnAwNFQza3VlVVpOVzNqRnhha3JiMmtyZFVsWTBkTlJ1b255cXZqdldMSHhYL0FHOWE2dHFWcnJJazgxTDYzbmEzdUkyNmZLNkVGY0RnWXdBQmdBQVY5cWZzNGY4QUJVNjNrMHkyMG40cmFXMTF0eEd2aWJTN2RWdXZ2WXpjVy9DeTRIOFVSVnVNbFhPYStIWTdaWVV6SUdMWitVKy92Vy80TitIZmlENG0rSUxYUmZET2g2djRpMVY0dzMyVFRyV1M2bUpQSk8xQVNCZ2ptdjFmT3NseS9NTVA3UEd3WEt1dXpqNlBwK1JNcWFsb2o5Zi9BSWJYMmwvRURRanJYZzN4RnBmaWpRYzRNOXJKNWh0Mi91eUljUEVSbjdycXA1ejlldzhOK1BMMnhtOGxwZk1hSDd5RTlNZjUvd0QxVjUvL0FNRVB2MmZ2RjM3RmZpSHhKckh4U3NkUDBUUmRkaGFBYVJKZFEzZDdjZEdHK0tNa0l1L0FPOWdlRDh1U0RYMFo4WUxyNFo2djQrdTlTOEkrRnJ6VDRKc3Q5bmU4Y3diODlRQmdqL2R6Z2UxZnlqeHRsT1M0U2NwWWZGUnI2MjVWWnlYbTNIM1d1N3VuMlRQUHhHRnA5N21YcG5pS3oxeTBqanVOdHRMdXh2WDdwUHZpcjluNFkxSzF1NG5naG5uV1J2bE1lY2M4REI2ZjVOWi9nbUh4TjRpMVZZOUQ4UG16dHhrZWJiMlprYnR4dmJQdjNyMVBTdjJiZkdIaWZEYXRxOEdrUTQrN0pJWnBHLzRBdVFQeE5ma3p3ZFIxT1dpdE9xdmUzejJYM2swY0xKNnh1ZE44TFAya3ZFM3doMkMrMWJUUDdQakFEMmM4M25saGpzRnp0UGJxSzlRLzRlUytHWkpvNGJmUjlSdWJobHl3amNiYyszR1NQd3J6dncxK3lONFR0SWNhcGVhbHEwbUJuY3dnUmozNEdUK3VhOUc4TCtCdEMrSDlza2VpNlRZNmVxOGVZcUF5TjlXYkxmcjJyOUl5SGpuaUxMS1AxV2hpR29MWlNTbmIwY2s5UG5ZOWlsaDUyOTZTWDRtMXBuN1UzaWJYNDQ1clh3Wk5ZMmtnSjh5OWZ5OGo4Y0g5SzBvdjJpZGVSV00wT214N3Z1ckFqUGovQUlFeHhXQkpIZWF6OHNjWmtPN2xpRGdjKzlYckh3Q0NvYTZsVmVoMnA4eHIwcVhIWEVsU1RtOFhLM255eFgzSkk2T1dDMFJKcVB4djhSYXlyUmk2YTNRL3d3cUZQNTlmeXJNaTB2VS9FOG02VHpaRmJxWEpiOWY2MTFlbWVHckd5Yk1OdjVrbWZ2U2MvcFczYTZWTmNqYjkxZlFEQXJ4OGJqY1RtRlJQRzE1MVg2dHI1WC9SRlJpN2U2amxkSStHMGNXMXJtVGI2Z2NrbXVpMDN3L1oyUS9kd3F6OWkzTlY5YzhYYUg0V1Z2dGwvRzgwZi9MQ0g1NUQ3WUg5YTRYWC9qVHJHcnlOSG9lbHkyc0hRU09tNlJoOU9ncnpzUm0rQndMOW5PVVl2dHUvdS96TkkwWlBXMXowKzVNTnBFV21taHQxWG5CSUIvQVZqYW40OWgwLzVkUHQvT2x4ekpMOXdmUWRhOHBUVC9FbXB6ZVkxcmZ6TXh6bDFZLzA0cTVEb0hpYU0vOEFJUHZXSUdRQkV4cnpLK2V1ckQvWm0xZjdYSzIxNmFXWDRzUFoxYjZSUFFkUitJMm9heGF4dzNGanBubHhZd1VqMnRuNjVxaE5wOXBycmdUV1VUZHcyL0dLNW0zOEorS0xxWDViQzh6Z0hIbHNLMExQd2Q0czgwQkxHN2J1UjVaRmViaU15ektyVjVxczZzOWw4Rjl0TGFJbjZ0T1dqZ2RObzNnaXlzbldTRTNFTEw5M2JMbmovd0N0WHFYaFQ0akhTTEZiZTdra3V0Z3dyc1J1SHNUM3J5RFIvQXZqUytqK1hUcm41UVFNL0wrcHF4Y2VDL0Y5aVdhYTB1STFYZ2x1bjUxOWp3N3hCbW1SM3h1RG8xWXFTMWJweTVYNjZXMEplSG5za3Z2UGRJZmlYcGR5bnpTU1FrZjMxUDhBTVVrM2lqVDczL1Yza0o5czRyd3Ezc05ZaXdKREd1N2dicEs2ZXgrSGZpQzZzVm1XUzJDU0RJK2V2MG5LUEY3aVBHUzluaDhKN1ZwWGFVSlh0OG4raEhzbXQvelIyK3B3TmU3bWhaWkZQSUtzRFhQNnZwczBTdCs3azlzQ3M1UEJPc1JOaHByZVAxUG05S2xzOUExcVc3RU1Pb0lzalp4bG00d00rLzByN25CY2RaN1dTOXJsVlQ1WFg0U1MvTTFYTWwwT3Z0OU4vczNUb1lQK2VLQlNSM0k2bjg4bXF0MUVDTWVuWDJybjdqdzE0cmlWditKaEczT09KVC9oV1hQb3ZpNVczQzZWc2M0ODNQOEFTdnBvOGNZeUsvZVpYWFhvay8xTWVWdnFqcGJsY0J2dktlQnoyNlZVdUZ3eHprZHNldGN5TEh4Y1grYVdGZWNITHJ3ZnlwSWJUeFF0d3JTVFd6TDMzRUZSajhLNlljY1ZaSk5aZGlQL0FBQmYvSkZLaSs2Kzg5UStEMmpycUhqbUdabEd5d2plNVBma2ZLdi9BSTh5bjhLOG0vNEtrL3RKTCt6Uit5VjhUUEhmbkpGY2VHZEF1cnF6TG5DdGRsQ2xzcC8zcmg0azk5d0hldmRmZzNaVGFmNE92dFF1UExFMHpDRWJSMUNqSlAweTM2VjhDZjhBQndGOEJQaU4rMU4rd240aDhNL0RmVDduWEw5OVJzYjIvd0JNdEFHdXRVczRKeEs4Y0tFcUhkWEVVb1RJTENFaGNzVlUvYllmRWUwb3hxeWk0M1Y3T3lhOWJONi9NNStXODdJL201K0Nmd04xcjQ4ZUlOUTAvUzd2UzdYK3g5THVOYTFPOTFLNjh0TFN6dDA4eTR1TmloNTUvTFRkSTBkdkZMTHNSMjJGVWRsaCtNUHdtYjRXYXBwajJ1cFJhLzRmOFJhZkhxbWk2eEZBMEVXcFFFdEcvd0M3YzdvM2luam1oZEc1RFJFamNqSXphV2phaDRvL1pOK0tVMzl2ZUU1dEwxcGJLNzAyOTBYeFJwbHpadE5iWFVFbHRjUnNoTU02YjRwWkUzUnNqZ01jTUtwL0duNDRhNThjTmN0YmpWSld0OUwwdTNpc2RHMGFDNXVKTlAwSzFpZ2lnU0MyU2FTUmxVUndSQWxtWjNLYm5abTVybzkxeHVpV21uWm5GazQ5eFNCY25pbDI0TkNMay9qanJVZ2ZlUDhBd2IyZnMrZjhMbC80S0VlRWI2YTFNK24rRmJpVHhGY3VWeXF4YWVxekljZXE2ak5wQjdjRSt0TS80T0ovMmpyajQ5LzhGSnZFR2hpNmU2MFg0WjJOdjRkczQvTkx4UnpsUHRGMndYTzFaUE9tOHBqakpGdWdQM1FCOWsvOEcxUHd4MHo0SS9zN2ZGbjR5K0ltVzEwM1RMR0hUV3V2K2VNTWNCMWEvY2V4dDV0TEJIOTYxUDhBZEZmalY4VXZpVHFIeGwrSmZpVHhscXhCMVR4ZHExMXJWNFFjZ1MzTXp6UHo5WHgrRmFTMDBLNkYvd0NEbjdRdmo3OW5EVy83UytIM2pqeGQ0SHZuSU1rMmc2dlBwNWx4MmNSTW9jZXpBZ2pyeFgydjhBUCtEbXo5cHI0TStUYmVKTDN3bjhUdE5qSURMcjJscmIzbXp1RnVMUXhFdC90U0xJZlhOZkVmd2krSTFyOE1mRThsOWZlRlBDL2pLMXVMYzJrMm42N0ROSkFZMmRDNVF4U1J2SEtVVmtFcXNIakVqTWhWd3JyaWVOZFVzTmY4Vlg5NXBlajIzaC9Ucm1VdmJhYkJjVFhFZG1uUUlKSm1hUittU3pIa2s0QUdGQjdTU1dqK1g5YUdiaEZ1OXY2L00vZVQ5bUQvQUlMMi9BWC9BSUtlZU92RC93QUxmako4RTdYVDlVOFEzS2FmcHAxdTN0UEZHaWZhWkdXT0pUSkxDa2xzMGtqSWl0NVJWV1pRWFVIY1BWUDJnLzhBZzJlL1paK005dmNYMmphTjRqK0ZkNjdaTng0ZDFsamFiMjZiNExzVFJnZWl4bVB2WDQvZjhFR1AyZS8rRi9mOEZJdmg3YXpSdEpwK2g2bW12WGgyOEpGcHl0cUtzZjhBWk56YTJVSi82K2g2bXZXUCtEbkg5cS9WUGpOKzNnZmh2SHFsMUw0VitGMm0yMFAyQVA4QTZNK3BYTVl1WnA5dlJwQkRMYnhaUDNmS1lER1RtWlJobzJ0ZkxRMGpLYWphK25ucWVvZkhIL2cwSytKWGgvVWwvd0NGZC9GendUNGlzMmJsUEV1bjNXaDNNUUo0L3dCU3QwcjRIZktaN0FkSyt4ZjJoLzJLdkZYN0NIL0JBanh0OEt2QmNiZU12R3gwR1pkWHVOS3RKRkdveVhVMFVkOFlZOGIyU0d4ekNtUnZlTzJRbFFXMmo4T3YyZFArQ212N1FYN0pwdDQvQUh4YzhhYVBZMm94RnBzOTcvYUdtSVBhMHVoSkIvNDVYM1grenovd2RwL0Z2d1NzTnI4Uy9oNTROOGUyOFlVTmVhVk5Kb1dvUDZzMkJOYms5OExDZytsT01GYTBaZmYvQU1BWHRIZTdqOTMvQUFUOG0yZFEreFdHVk8wai93Q3QxL09yR21hdmVhSGNQTFkzbDFaVFNSdkM3Mjh6Uk02TU1NaEtrRXFSd1IwSXIrZ1g0Vi84RkRmMkJ2OEFnc2I4UmROOEcrUC9BSVUydWovRUR4VktsbmF0NGswS0t6dU5TdW53RmdnMWF4azg3ZXpmS3ZtdENYWXFvQlpsVXovSC93RDROSmZnbjhTV3VicjRiZU5QSFB3NXZwdm1qdGJoVTEvVFl2OEFaVkhNZHdCN3RPNTlxaDg4Tld2dWR4eFVKYlA3MVkvbnF4dEdQd3I5dHY4QWcweStCVnZvZWxmRkQ0dGFyNWR0YTZmcDhlaTJ0MUo4cWdYRXZuM1lZLzhBVEtQVDdKd2Y3dDIzUUU1K2Vmam4vd0FHcHY3VGZ3NHZwRDRQdVBBUHhNc1dmRVJzTmFHbDNRVW5ySkhlaUtOVDZoSlgrcHI5Qy9FWDdMM2lyL2dsWi93YnVmRW53d3R0QnFYeEN1UERkOWQ2K2RHZHBvYmFhOGloc1pIU1RBSit5MkNSRjVBTUY3ZVIxTzBnMDQxRWsyUDJidWwrditSK0EzN1YzeDB1UDJuZjJtdmlGOFJMcHB0M2pYeEJlNnZHa3B5ME1Vc3pORkg5RWoySUIyQ2l1dS9aaThIK0U5RStDUHhSK0pYamJ3cmJlTk5QOE5uU2ZEdWlhVmMzdDNaeFQ2dHFGeTAyOHlXMGtjaEthZllhanRHNHFKSkltWlhBMnQ0a20xUUZVcnRYamc1cnMvZzkrMGo4UlAyZVo3dVR3RjQ2OFhlQzVOUTJHNk9pYXRQWWk0S1oyTTRqWUJtWEoyc2VWSnlDRFRqWlBVaVYyYm43YWZ3VTB2OEFaeS9hbThZK0N0SG0xQnRQMEs2ampXMzFDUkpMN1MzZUNLV1N3dVdRS3JYRnJKSTl0S3dWQVpJSE94TTdSN0ovd1JFL1p6SDdTMy9CU0g0WjZIY1FMUHBrV3R3WGQ4R1hjcGd0dDkvUEczK3pMYTJWMUZuMWxBNzE4bjMrb1Q2dGZ6M2QxY1RYVjFkU3ROUFBOSVpKSnBHT1dkbVBMTVNTU1R5U2EvWi8vZzBSL1p5L3RMNGwvRVA0bVhNSTI2TG95NlRaU045MXBiKzV4dUI3UEVtbVRxZjltKzlEVlU5N2lsZG5tWC9CMmwrMDFOOFVQMjdQQy93M3Q3K1NiUy9odjRlUzV1N2JkOHNXcDZneG1rWWpwazJxV1hKNStZK3RmbVg4TGZqRjR1K0JYaWhkYThEK0t2RW5nM1dJK0Z2OUMxU2ZUcmxmKzJrTEszNjE2Ri93VUUvYUpQN1d2N2IvQU1WdmlRczdYRm40cThTWGMybk8zVVdDUDVObXYvQWJlT0pmd28vWWMvWnUwMzlwajR5M3VrNjVOZFcrZzZIb09vNjlxQnQ5VHRkS2VWYmUzZjdOQUx5NkRXOXUxeGV2WjJ3a2xVcURjNXdTRlZwaHpOKzd1T3BiWjdIMUIremwvd0FIT0g3V0h3Rk1GdnEzaXJRL2lmcGNJQ2kzOFg2V3M4NUE5YnEzTU53ekVkNUpINTZnMStpLzdGUC9BQWRhZkR2OXBYeC9vL2dmNG9mQy9WUEFkeDRnbEZnZFZzYjlOYTBaUzZuYzl6RThjY3NGdmpPOXYzd1ZjbHZsREVmZ1I4WXZEK2srRS9panJtbGFISHJzT202YmNtMVdIV2ZKKzNXOGlBTE5ISVlTWW0yU2lSUTZZREtxdGhTU285Mi80SSsvczZmOE5SLzhGQ3ZobjRSbWdhNHM5UzF1QkwxTTRWN1JTWjcxU2ZmVDRMOGozV3RJeTVueXoxL3J1WnVDaXVhT245ZGorZ2I5cUQvZzNEL1pGK1A2YWxxTng0RG0rR09wT3hlZlV2QitwblNZWUdMWUIrelNDU3lqWGNRTUxDbzVBcjRKL2FQL0FPRE56eFRwU1NYbndqK01taWEzRklkOEduZUw5TGswMlFSOWd0MWJHZEpTZlV3eGo2ZGF3ZjhBZzc0L2EyMUx4cCswcjREK0RkbnFWeC9ZUGhqUmo0bDFlemltS3czR28za3JwRjV5QTRab3JlRU1tN08wWGI0KzhjL20zK3poL3dBRkRmanAreUJMQ3Z3MStMSGpud25aMjdiMTA2MjFSNWROWThmZXM1ZDl1LzhBd0tNMWpHRVBOZW4rV3h0S3BQeWZyL210VDB6OW9EL2doUisxcCt6ZmRPdXNmQkh4aHJsbXJFTGZlRklGOFJXektQNGliSXl0R0QvMDBWRDdWK3cvL0JKVDRIZUt2K0NUSC9CRS93Q0xIeE44WStHOVE4TStQTHpTTlE4VVE2UnFOc1lMK3poc3RQWVdNRnpHUnZqWjd4cnViWTRESWw0dVFwM0tQaVg5bTMvZzd0K1BudzBOcmEvRWp3ajRGK0tGbEVNUzNVVVRlSDlVbDkvTWdEV3cvQzJGZm9MK3l0L3djby9zei90NWF2WmZEZnhqNGY4QUUzZ25WUEd5SFNKZFA4UzJFR29hRGZtY0dNMnJYTVROOGpxeFZtbmhpand4M01CbXE5bkt6VVdtWisxaW1uS0xWdm4vQUY4eithYWF6dXJLMGhlNml1RWt1bGFaWkprWmZ0QTNzak1DMzNodlIxSjUrWkdIVUVWdC9CejRzYXA4Q1BpNzRaOGJhSEhZeWEzNFMxT0RWOU8rMlFtYUZMbUJ4SkU3SmtidHJxckFaeGxSbkl5Sy9vdy9hUi80TkwvMmJ2ak5lWGwzNEZ2dkhId2oxV2JjVXQ5TXZQN1cwdU51NSt6WFdac1ovaFc0VURvTURBSDUvd0Q3U1A4QXdhTGZ0RWZDMFhWejhQZkUzZ0g0cFdNSXpEYS9hVzBMVnBmckZjLzZNUG9MbzFuN1JwNnByK3ZJMjluZlpwL2grZjZINVRqY3Y5NWkzSkpPU2ZyWDZ3ZjhHa1g3T3grSS93QzNkckhqcTV0MmF6K0graVhkNURMai9WM2t5TFpReG4ya2l2Ynh4L3RXZzlNajgvdjJqdjJBL2pkK3lIY1NyOFRQaFQ0NjhIMjhMN1B0MTlwTXAwK1E1LzVaM1NCb0pQcXJrVis1Zi9CdjM0R3VQK0NkMy9CRzc0bmZIcnhKbzF4WTNXcGFiYytKYktLOGdhR1RVdE4wMjBudUxadGpZWlJKZDNOOGlFZ2VaR3NUakt1cE4wNXF6a25zaVpVNTNTYTNQeWIvQU9DNDM3UTQvYVgvQU9Dci93QWF0ZWh1R24welF0WS80UlhUK2N4aUxUa1cwWXAvc3ZORkxJUCt1bWErZmZnOThGbCtLL2gzNGlhMWNhci9BR1Jwdnc4OE1QNGh1SlJiZmFHdTVHdkxXeHRyVlJ2VUtaYmk4aUJiSjJvc2piVzI0cmw3aSt1ZFhqa3ZyNmVXNnY3K1Y3cTZtbGJkSk5LN0ZtY251U1RrbjF6WFovQWI0K3cvQjdUdkZXaWF4NFkwL3dBWmVFZkcxcEJhYXZwVnhkeldNaE1FNnp3VHdYRUpEUlN4dURqY0hSZzdCa2JncmNZcXlqSW1jdGJyK3Y2UmdmRWo0UmF0OEo5SThHM21yU1dhL3dEQ2JhQ3ZpT3lnaWtacDdhMWU2dWJlUHoxS2dJOG4yWXpLb0xBeFRRdGtGaW83TDloUDRQYWgrMFArMTU4UC9CZWx5VFc5NTRrMXUwMDJPNWp5V3MydUprdDBuNDUvZHlTbzU5bEo2Q3VVL2FEK05sNSswSDhVYnJ4SmRhYnAraXdyWldPbGFkcGRpMGpXdWxXRmxhUTJkbmJSdEl6U09JN2VDTlM3c1hkZ3pzU3pFMStoUC9CcC93RHM2LzhBQzJmK0NsTWZpNjVpM1dQdzMwUysxa01WSlJwMmlGbEhHZTI3ZGZyTXVlOXRrY3JSVDBuNkVUK0UrMlArRHBqL0FJS2UvRUw5bUx4SDhPL2hIOEtmRzJ0ZUJkUThRMlZ6NGw4UTZob3Q2OXBxbjJSWkJEWnd4M0tFU1JJOGtWeVgyRU0vbG9NNDNCdnpxL1ozL3dDRGxYOXJiOW5XUzN0cmp4OVovRWpTYmNCUHNQalRUazFGbUh2ZElZcnRqMnkwNXJuUCtEZ2I5bzgvdEZmOEZjUGpCZXhYQm0wM3dkZFJlRExBQTVFUXNFRU53bzlqZGk1YmorLytmeGw0VjhOYW44UWZHT2xhRG85cExmYXhybDdEcDlqYXg4dmNUelNDT09NZTdNd0g0MFFrMUhUcVhVaEhaOVA2Wis5UDdPdi9BQWVTZUR0YjhtMStMbndhMS9RWk5vRXVwZUV0VGkxS0dSajFQMlc1RUxvdnNKcEQ5YTdiU1BnWi93QUVydjhBZ3IzNHBqdGZDYy9oZndiOFFkZVpVZ3R0RW51UEJlc1N6dnpzaXM1VVd6dUppZTBVVXBKeWNubXY1NWZpSjRQbStHL3hDMTd3NWNYbW42aGNlSHRTdU5NbHU3Q1l6V2wwOEVyUk5KQzVDbDQyS2txeFVFcVFjRHBYYi9zYmVBdForTHY3VTNnRHd2NGZtZTIxN1hkZHN0UDB5ZFJuN1BlVHpwRGJTSHI4cXp5UkVrOEFBNXhRbENiU2t2bXQvd0N2dUp2T21ueXY1UFZIN0pmdEQvOEFCbmxxMW90MWQvQno0NlIzUzliYlIvSFdsRWJSL3RYOXJ1ejdmNktvcjRSL2FILzRJTS90ZmZzN1BLdW8vQlRXUEdXbnh2c2oxRHdSS212ck1NOE1JSUMxeW8vNjZSS2EvV3ovQUlPVXYrQ3VIeEUvNEovTDhPZkFId2YxeUh3LzR2OEFHaTNtc2FwckQybHZlM2RqcDF1VmpqU09PZU9TSU5QSVpjeUZDeS9aOExqY1RYd0QrejcvQU1IYVg3UjN3a25odGZIbWwrQmZpenA4YmZ2WmJ1dy9zYlVwQi9zeldleUFmVnJaalRwODlyeGxwNTYvOEV1VXVyajkyai95UDBDLzRJbmZzK2VKditDVmYvQkl6NHFmRlR4MTRSMVh3MzR4YlI5UThXTm8ycHdHMzFGTExUTEc0dWJhSzRoUHpSU1BjU1hqQkhBWVJ5UjdncHlCK0VQZ1BVblQ0YldIMmk0ZTV2cjd6TDY4bWNrdkxQTElaR0xIdTJHQUo2NTk2L2MzNEFmOEhhSDdOdnhxMDRhVDhUUEN2alQ0Y3lhaEUwRjZ0MVl4K0lORktPTnJJendmdjNSZ1NDRGFZSTllbFljSC9CRnYvZ25yL3dBRkliaVRVUGdEOFRZL0NQaUMrVjd2N0Q0SDhWcE50SnlTMHVrM3UrYU5CeWZMUVFnQVlBQUZhMDZrNmMzVWxHK25UcC9YcVpYcHlqeU44cnZmVyt2OWFuNWZmc1YrRjdmeEpGNDZ1ZFBid0Qvd25sbkJwa1BoK1h4bWRPazByVExhYStVYWxxYlJham0ybE52Ym9GSWRYTWNkMUxLcTc0bGRQblQ5cTdVL0MrdC90QytQNzd3TGFteDhEWHZpWFVyanc1YitVWXZJMHhycVJyUmRoNVhFQmpHMDhqcHpqSi9UNzlvai9nMDIvYUE4QXJOY2ZEYjRrZkQzNHBhZENtOUxUVjRKZkR1cVNIc3FMKzl0aWVUOHp6b1BhdmdYOXAzL0FJSncvdEJmc3ZQTi93QUxJK0IveEU4TjJ0dUNaTlR0OU9PcWFXT1NmK1B1MTN3Zmh2eld6eFZLV3Q3UHpOSTBhaXVscjZhLzF2Mi9JK3VQK0RTYjluZHZpWi93VVUxYngxY1c3TlpmRG5RTHU3aG0yYmxGMU9xMmlSSDBMSmRQSUQ2MjljWC9BTUZhdmpiL0FNTklmOEZZdjJndkUwYy8yalMvQ3VwUWVBOU1HY3JHbW5JSXJsVi8yV3VvNUhHUCtlbjQxK2lIL0J1UjhJYnIvZ25sL3dBRW8vaXQ4ZVBHbWc2aG84MnIyMTE0bVMxdmJkN2VhODByU3JXZWVLVFk0RHFKSGtuUUVqNTFqUnh1VmxZL2lqOE85WXZOVytIaWFocUZ5MTlyWGlTNnVOWjFLZDIrYWVlNGtMTkkzKzBRRlBIZXB3MFZLdXJmWlg1LzB6T1YxVGIvQUpuK1g5SXp0U3ZocG1zV3QyMXRhM290WjBsK3kzU3MwTnh0Y041Y2dWbFlvY2JTRllFZ25CQndhaStLdmo3US9IR3IyZHhvL2d2U2ZBOGthTXQ1QnBXb1h0emFYVWhiaDBTN2xtZUhBR0NvbFplNDIvZHJhMExSZkR1b2VLb0lQRkdvYTlwT2dzc2dtdXRHMHVIVTd1STRPeGx0NWJpMlJodXhrZWNweG5HU0FLOHoxZ0xiTkw1ZTR4NStRbFFHSXlPb3lRRGpQR1NPTVpOZWhVME00K1I5S2ZzNmZDSCswUERlcHlMY3JkQkx6RW5scXdBTzBjY2dkL1FIK3RhbjdTM3hiMUw5bXVmd25IWTNodFlaNHA3bTR0V2pFa04wdTVBQTZubmpubGNIazg5UlhwSDdBUDdOdmlyNE1mRDN4Um8vaS9UNDRwMTFSWnJXV0tkWjRibUl4cUM4YktmdTdsUEJBSTdpdkFmK0NtZXR3TisxSU5IdXZtc2RMMGkwZ1pWT1RHWERTbGdQVWJ3ZnB4M3IrVnNER2xtSEVzc0xLYXJVb3hjcnF6VFZrdk5YMS9wbm4xSWNrMUZIMlovd1NOL2FaOE4vRlB4UjR1OGNYMWdmRDJrK0JkRm11TlMxT2VUYnBzTE1BRlVUU0JjT2Y3bko5K2VlRCtJWGkrYnhUcjEvcXQwdm1wcTA4bDBycTI5U3JFa0ZTTWhoejIvclg1cytNTFhWL0JWaExvc0dyM3NuaG5VWmx2UmJRM0wvQUdLZVVBcXNwakIybGdDUUNSa2NpcHZnL3dEdENlTGZnOVA1ZWthajVtbms1bDAyN1BtV3NucVFoUHluL2FRcWVQd3IzY1Y0VzRlVlNlT3l5cFp5dGFNcjJzbHR6YnAzdm8wL2tkenBxcEZPUDlkejd2dkxlUFk4bHZNVTUzRkNQbEhYcngvOWFzZlV0YXQvRWxpMm42aGIydXEyN05oSXBDZDZOeGdvMzNsUGJLL1RucFhsUGhMOXJ6dzc0N3NJN2ZVREg0WjFWOGdwTSs2MWMrcXlZK1hucytQcWEraFAySnZnN2QrUHZqSERydDFISE5vZmhlUCswSnBqODBkeEoveXhqQkJ3ZHpmTjlGTmZKWmxnYW1WVXAxOGVuQndUYXZwZTIxbXQ3dlJXWmpLTFR0TmFITmFENFlqL0FHY05YdTdTeGd2THJVTDRBeXpTdHY4QXNpOWZJQlVBWkJ6dWJnbnQweWIzaUg0b2FQci9BSVltRndxMjhtU3VKQmxRZWg5K2Z5NlY5T2F0OFBMYTdpbnVHczQ1SkpHTHlLVkJ6bm5GZk9QeForSG1uWHZpamJhMnpJWGJCUUQ1Zi9yNTRyNXJLYytvNCt0elYwK2ZSdVY3M3QrWGtlUktIUExRNnI5bHo0NlhIanlGOUcxa1hFaTZiaU8wMVdjL0xzT0FzRHNjSFBJQ042Y0hzYTdyNHM2YzF2YnUrejVjY3FWK1lIbnArSDVmbFh6aDhjZmlCTjhFWTdMd3JwbW5TU1NKR2x6ZXRIRWNlYTRKV004WXdxc0Q5V3oxcmY4QWhWKzEzZStPb1cwUHhOcDk4OXd3QXROUkVERll3QjkyVWpqSEhEZHVoN1k5akZaYlhxMFhqc1BDMU42MjZ0ZDdkM3Y2R3RSMjkyUFFyNm5xUC9FellobVZrYmxjWUpQc1Bhc3Y5b0xUWS9pRDRGdC9FMW5IRzJzK0hFRWVvbm8xemFkRmxQcVViR2ZaaWUzR0I4WWZGY21nZUpQdFVmeVNSbkV1RGdQbnYvbmlvL0JueGJXeXZiWFVyWDk1QzdlWGN4RUFxeXR3NnN2UWhobmcrdUs5SERZR3RUVlBHVVZ0K1BlTDlWdDU2OUNvMXJybG5zZXZmc2tmdGcrSXZoclk2V3YyZ2FyNGZrdUJCZVdNN2x2SlFuNzhaNm93ejdqMjcxOTBmQzM0MCtCZmpaNGgxYlJ2RCt0V3NuaUxRWlBLMUxTM2NKZVczQVpXMkhsNHlDQ0hVRWNnSEI0SDVLYWJJZmg5OFk3N3crdTlkSjFJQzUweGlUdFdDVExSako2N1NOaDc1U3MvOXRHVzk4Q2ZHRHdoOFFORDFIWHRMOFE2OVl4eHgzZWt5ZVhQRGZXUWpoTGZLQXpNMFpqYjcyVHZ4d29HZk94M2gxbCtiNWhhTXZaVHFSY29TU3VtOUhhUzY2YzE5VTFZMnkyczNLVkdwci9YUS9jcndwNGx1dkRVcXgzSHp3OUJuK0gvQUQvS3JmeDIrQm53L3dEMnp2aGZONFI4ZmFKYjYxbzA1MzI3NUMzT25UWXdKb0pSODBiajI0STRJSXlLK1RQK0NjbjdaSGo3NHcvRHRyZjQwZUdXOFB6V3NNQXNQRVZ3RnRUclN1T3NsdDk1V0FHUzY0WDVnTUE4MTlacERObzAwYzl2T0pJbitaV1VobGNkc01PRCtIRmZsTlRLc1prMlBkS2MxN1NtMWFjSlhYbGFTZWo4dEd0ajE1UmxUK0hZL05iVlArQ0dXbS9zemZGcWJXZGVhNitJbmhHRzlXYlFyUllka2M0R1NFdnd2SlpUZ2JVd3NtM3JnbEsra1BnNzhIOWQvc1QreU5EMG5RZkJ1a3ljL1piV09IVGtseXhQS1IvTXgrWmlOd3pqTmZYV2wrTTQ5VnRtdFpXM0xJTnJJM3pLUi9oNzF3bmo3NFBZaWt2dE1aOWhHV1JQOVpDZlhQVXJYbzhRY1RaeG1Tdmk2cm1sMHZaZmN2ZHYzZGpKMmx2ZTNZNS93ZCt4OWF4WERTNjFyM21oamsyOWhEMUhmTWovQU5GcjFYd3g4SXZDdmcyUkcwM1E3WHpNajk3T1RQSUQvd0FDT1B5RmVXK0IvSCtwK0g3K094dllSTkN4QVYyR0s5dTBPN2pGb3JNMmZNVFAwOUsrUmpqc1BVWEpCWGxiVTJvY3Ryd1JvSTdTb0V5eXFNRGJuQS9Lcmx0WWljakc0NE9lUlZLOTFtSzJDS2crOTZkVFQ3WFZMaWE1alJZMlpXSFA5NFZuVHhFbFV0ME9oWGVoclFhUXFuY3pxcDlQU3RDd3RZRmwrV1B6RzY1WS93QTZrMEg0ZjZ6NGpJTU1FMjNqa3IxcnNyTDRJWDJsNlpKTVkwdkxoVnl0dUpSSHZQcGs4Vjl6aGNoempHMGI1ZFFsSld2ZFJiWDM3ZmRxYVJwMmZ2YUdIYnB1S3FtU09PQU9sYVVlbUxZd2VaZU5IQkgxSmtJR0s4YStKSHg1OFdlR05YbTB0dEdYd3p0TzNjRjh5WSsrNWhqbjFBL0d1SWk4YzYwZFFhOW12cnE3a2tQekNlUXNHOWVPbjVWODdVb1ZzSTVQRUp5bW5acmEzZmZ0MjBGVXhVSVBsaWo2UVg0bDZMWVhLcjVVOTFHR3dXUUFESHRuclhwM2h5MDBQeGRwS3lXN0xkMjdENWxMRVlQb3c2MThtYUQ4UUxhK0tyZFJ0YnpTRGJsUmhmci9BSi9sWG92Z2JYYmpRWGp1dFB1RzQ2RUhnajBQcUsrMDRSNDJ3T1dZaHh4dUhqVXB2ZjNVNVI5TDZOZDErSmw5WW5ONkgwQlorQU5FdEk5c2VrYWNxNXovQUtoZXRhbHRwZHZhcUJIYndSLzdxQWZ5cmkvQmZ4cHRkV0VjT29KOW1uNmIxSHlFL3dCSzdxMnVZN3lGWkk1RWtSdWpLZHdOZjA5dzdqc2l6Q2lxMlZLRnVxVVZGcnlhc212eTdGZTBrOUcyT1dOVkh5cW8rZ3AyM2o2MDdaeG4rZEFPMWUvRmZVY3FKR2tqUDlha2pPRFVUSFA0MDlXeUtvQ1pEL1NsbmpXZUZsWUt5c01FSG9haVY4SC9BRHhROG5IVTBwUlVsYVd3SEgrTGZoVGFhbm1TMTJ3eWRjSG9mcFhQYVZmWG5nMi9OdmNxeldySERMNmU0cjBlN2wveWF3dGFOdmV4ZVhjcHZROXg5NWZwWDVkbjNoL0NGYiswc2hmc2E4ZGJMU012THl2MjJmWU9TK3EzTXE2Y1N4K2FyYm8zR1ZQOUtrOExXNGU3dUp2N29FWU9QWGsveVg4NnozdG0wRm1hTnZ0RmczRDdmdko3KzFibWlSeHdhV3ZseUNRU01YTGp2NmZvQVB3cjZIaFBpSjQrVHcyTWo3UEVVL2lpK3Y4QWVqM1QvQTFkUzhiUGNtdXlHQi96aXMyNjU1OVA4S3ZYYlpCNCttS3pybzVEZnJ6MHI3dU81a1VwbEdQcDNxdXdVRGNRQVBjZmovbi9BUFZWaWJsdlhKOU90Vy9DZWpmMi93Q0pySzBQelJ6VEx2eC9kQnkzNlpxZ084MUFmOElyOE9kUHRPa2doRWtnUDk1OHMyZnhZaXZ4Zy80SzMvOEFCd3I0by9ZdC9heXVQaGw4Ti9DSGc3WHBQRGR2YnkrSWRROFFmYXBzenp4aVpiYTNTQ2FMWnRoZUl0STdQbHBDb1ZkbVcvWWo0NmVKcmZUckc0bnVyaU8xdGJaR2ttbWtiYWtLS0NXWW5zRkFKSjlxL2pSL2FiK04xeiswciswWDQ4K0lGMTVnazhaNjllYXVxU0htQ0tXWm1paitpUmJFSG9GRlhHVmpOTFM1K3VYZ1gvZzUyK0VQeDY4Tkw0ZCtQWHdSdlA3Tmx3a2l3UjJuaWJTMkpHR2RyYTZXSmtIc3ZtdHpqSnJhaS9aQi93Q0NadjhBd1VSbDNlQ2ZGbWgrQXZFZDg0Q3dhTHJrbmhxOGFROUVTdzFKREMzUEJFTU9EMlBldnc1MjhObnRVRWtTeWNNRks1emdpbEtNSHE0L2RveDg4MW9uOStxUDEzK1B2L0JwbjR6MFdKN3o0WC9Ganc5NGhoZjk1RFkrSjdDWFM1bVRyaFo0UE9TUSs1U01IMnI0eitLbi9CRWI5cXo0UzY5RnArb2ZCTHhockF1WlJERmMrSEJGcmNENU9BMisxZVR5d2V1WlFtTzRGZXRmOEc3WHh2OEFpWm9YN2ZQZy93QUgrSC9GSGlBK0VOWWxtdDlVMENTL2tiU1pvaGEzRnhKSzBERW9za2NOdE84Ym9GYnpGUmR4VjNSdjBvLzRLamY4SEJHaC93REJPMzQvMnZ3MTBmNGZQOFJOZnRMS0hVTmNsazEwYVhiNmFKaHZodDF4Qk0wa3pSNGtKSVZVVjQvdmxpRVhzMnZobDkvL0FBQ2xKVzk1ZmRwK2VoNXorMlg4TnRaLzRKdWY4Rzllb2VFSmJKTER4bDRxZ1d3MXlLM1lYQzJkMXE5NlpMbTNMb1NqTERheVBhQjFKVnZLUXFTQ00vZzZ6YlB1OUsvZmJ3bC93Y1kvc3BmdGdlQWJ2d2Y4Wi9DUGlEd3JwZXRRQ0hVYkxYZEpHdWFQS053TzN6TFhkS1NyQldWekFoVmxEQXF5Z2psN3YvZ2c1K3hYKzNoWnlYdjdQL3hlZlFkUWtpM3BaYUQ0aGc4Ulc5dG5rR1d3dUgrMklmOEFaYVpQcFZTak85N1g5QktVR3JYcy9PNStKL2hYNGxYSGhQd1g0bTBFYVQ0ZDFPejhVUVFSeVM2aHB5VFhlblNReUY0NTdTZmlXQ1REU0l3VnRraVNFT2o3VUtjeVJ3YS9UZjhBYUcvNE5XLzJnUGhxMTFjZUJOYjhFL0U2eGpKOHEzUzZPaWFvNDk0YmsrUUQ3QzRibXZpcjR3LzhFK3ZqcDhCTllYVHZHSHdoK0kyaFRUVEMzZ2xsMEM0bXRybVE4QVJUeHEwVXB6L3p6WnF5OW90bi9rVjdPWFQvQURQMUcvNE5WL2doYitGdkRmeFYrTG1ycXRyWTZacDBXaHdYY3d3a1JuWmIyKzU5RXQ3WFNwTTloTTNyWDVKL3RJL0dpNS9hUS9hRThlZkVDOFZvN2p4dDRndnRiOHRtUDdsSjUya1NNWnp3aUZWQXp3RkFyOXVQR3ZnalZQOEFnbUgvQU1HMmZpdXgxRFRielF2R3ZqYXduKzI2ZmNSbUc2czdqV1o0ckdPR1VZekhQYjZYOW5SbE9DcjJ4WGdpdndUMmlPUGFQdXF1QjlLMmJWOUNka2VoZnN1ZkJHeC9hQytLUjhNM2tuaVMxRTlsTmNwZDZQWTJ0MHVuK1h0YVM0dXpkWE5yRERaeHhlWTBrOGs2TEdBck1kb05jZjhBRXJ3M3BmaEQ0Z2ExcFdpZUlyUHhibytuWGtsdlo2M2FXMDF0YjZyRXJFTFBIRk1xeW9yZ1pBZFEyT29GZDc4SHYycGJuNFdmQ2J4RDRDdnZDZmh2eFI0UjhWWHNOOXF0dGNTWGRoZTNEd2o5MHB1ck9hS1NTSkdHOUlaeE5Bc243d1I3L21yeWRWSVZmbXkyT2VPdFRLMXRDVDZ6L3dDQ0lQd0huL2FBL3dDQ2xQd3QwMVZsTnBZNi9hYW5lTWhJMndXVE5xVW9ZZzhMSkRZU3haOVpsNzRyN0MvNE9hLytDamZqNjIvYTkwNzRQK0MvRzNpRHczNGU4RjZUYmFock1HajZoTFpQZWFuY2d6cDV6eE1yT3NkczFzeUtTUXBsYzR5YTZML2cwcytBQzNmajM0a2ZFeTZqaldMUWRIajBpMGtrWENtWFVKeXprSG9HaGkwems5bHYvUnEvTVg5dVg5b0J2MnEvMnlmaWg4UmZPa3VMWHhYNGp1N3F3Wjg1RmlybU8xWG4rN2JwRXY0VlYyckpCeXBwdG50djdPbi9BQVg1L2F1L1p0TnZCYS9GTFVQR0dsMjU1MC94aEN1dHBJUDd2bnkvNlNvNHhoSmxyN3UvWjgvNFBBWWJpS0d6K0wzd1grOG1KOVM4SGFsdVJqM3haWFo2SDBOeWZ4cjhoUGdSOEFkWi9hTThRYTFvZmhwWkw3eFJaNlJMcW1sYUpiV3IzRjc0aWtpbGk4MjF0a1RKYVpiZHA3amJnN2t0WEErWWl1YitKSGdXNitHUGpmVWZEOTlkYVBlWDJsU2lDNWwwclVJdFF0UE4ycVdTTzRoWm9wZGpFb1hqWmtMSzIxbVhERTlwTDdXdnFUN05MNGRQUS9mVHdYNGYvd0NDWC84QXdXQzhXV3VpNkxvZWdlRS9pTHIyNXJhd3M3SzU4SGF2Sktja2lNUkFXRnpNZVR0SG5NZXVEelhuUDdSZi9CbmxwZDM1MTE4SWZqTGZXUkMvdWRMOGE2YXR3R2IvQUdyMjBDRUQvdDFOZm1uL0FNRWRQZ3JmL0hUL0FJS1EvQ2ZSZFBrbWhrWHhEWjNUVHhjTkRGREtzOXl5bnM2MmtOMUlwN05FQ09RSy9UVC9BSU9UditDd1B4Vy9adS9hTDhNL0NYNFJlTkw3d090bG8wZXUrSU5RMGhsUytubnVKWkJCYW1RcVdqUklvaElRaEcvN1NOMlFxZ1RLbkN5YTA5UDBScEdwUHI3M3IvbWZCL3gyL3dDRGN2OEFhOCtCMTlJSS9oai9BTUoxcDZ1RWp2OEF3anFVR3FMTVQzRUc1THBSN3ZDbzk2L1ZiNEYvQXZ4WC93QUVoZjhBZzNwK0oxOXJtbFRhUDhTTlEwUFVkWXZyR0NSTGlYUnJxNHRvZE50QVhqSlVtT09PRzVrd1NFa2ttR1Rnay9uWCt6eC93ZE8vdFEvQjB3MjNpaTQ4Ry9GUFQ0eUFmN2QwbGJTOUNEc0xpek1PVy8ycEVrUDFyN3MrQ1A4QXdkaS9BUDQxYUxKb1B4ZitHdml6d1ZCcWtUMmw2QkhCNG4wV2FKMUt1c3k3WXBXallFZ3A5bms0SkJ6UnlPelVaSi9oL1h5SjlvdVpPVVd2VFg3dXYzbjgrS3dlUW5sL3hSL0tlZTRyVzhOK09kWjhMYUo0ZzBmVEwyYTFzdkYxbEZwbXFRSWdiKzBMZExxRzZTRW5CSUF1TGVDVEFJeTBTOVJ4WDc2V1gvQkpyL2dtL3dEOEZScnFhWDRLK05ySHcxNG92bGt1MTAvd2Y0aU5yZUhBeXpOcEdvSzBpeHIxSWhqaVZSM0ZmT3Y3UmY4QXdaOS9GVHdpWnJyNFZmRkx3ZDQ3dFZETXRscjFyTG9GODNYQ0t5bWVCejIzUEpFRDF3S2x1VWZpVFJTakdYd1NUL0EvSDJTM05ySTBicTBiUnNWWlNNRlNPQ0NPMksvWXovZzBSL1owL3dDRW4vYUk4YmZFUzR0OTBYaEhSakRiTnQrN2Mzc2h0N2VSVDdRMityeG5IL1BRZW96OEMvSHovZ2o5KzAvK3pOY3V2aTc0Ry9FR08xandEcUdrNmNkYTA4Wk9BRGMyZm14TG5zQ3dQdFg3UWY4QUJPZjRaK0l2K0NUSC9CQXY0bmZFTHhKb21wK0ZmSGVwYVBxSGlPRFR0U3RUYjMrbk10bWxycDBVOForWk4xMzV0eUZiNWxXKytZQWdnVlRxUnMybUVxY3JwTmJuNHJmOEZXZjJpVi9hcy80S1JmR2p4MWJ6eDNXbjZoNGx1TERTNWxZc3MxaFpZczdWeG5wdWd0NDJ4MkxHdUIvWisrQWRsOFd0TThZK0l2RVhpS1R3bjRJK0grblJYK3M2bEJwLzlvM2tqenpwYjIxcGEyeGtpV2E0bGxjbkR6UklzY016bC9rQ3Q1MURFWUlmTFlIZXZEWkhJUGZOZDE4RXZqOWUvQktIeEZZTm9lZytLL0RQaSt6anN0YjBIV2x1RFozeXhUTFBESnZ0NVlaNHBvcEVESkpGSWpBTTZIY2tqcXhHMnpKazd1NklmMmpmZzFEOEJ2aWxjZUhZZFIxVFVCRGJ3M0RKcXVnM09oYW5ZTTY3bXRydXpueVlwNHp3d2prbGpQQlNWd2NqMEwvZ21GOEFKdjJuZjI1ZmgzNExqV1h5ZGYxaTJzTHhvamg0N1NhVllydVJUL2VqdEh1WlIwUDducU90ZWIvSG40NDZ4KzBOOFEyOFFhekRZV1BrMlZwcFduNmRwNlNKWmFSWVdrQ1c5dGFRTEk3eWVYSEZHbzNTTzhqdHVkM2QzWnorbTMvQnBQOEFzOGY4SngrMko0azhmWEZ2NTFyNEYwYWFXRnltZkl2YmhUWjIvUDhBMDBndU5UeDd3ZXhxby9GY21XeDdKL3dkay84QUJRL3hwNEgrS3ZnRDRNK0NmRm11ZUZyU2JUWlBGZmlVYU5mUzJjbDgwc3p3Mmx2TEpHVll4eCtSUEo1ZWRyR1dOaUNVUWo4Ny93Qm5IL2d1OSsxZit5MklMZlEvakg0ajE3U2JkaC94TFBGV3p4QmJGUnhzVTNRZVdOZmFLUkt6UCtDMFA3UlAvRFVmL0JVWDR6K0tJcGpOcHRqcmJlSGRPSWZmSDltMDlGc2xaUDhBWmRvV2s5eklUWGhud1crQitwZkhDNjhXTll6eDJkcjRNOE1YM2lqVWJpU0o1QWtOdUZWSXdxQW5kTmNUVzhBUFJUTUdQQU5UR1VrdEdWVXB4Y3JXOGo5aHYyWnYrRHpIeERwTTBOcjhYUGc5cDk3R3hBbTFQd1Rxa3RqSWkrdjJPNk1vZHZiN1FnK25iN3orQlgvQmNQOEFaQS80S1phZko4TTdyeFZOWWFoOFFyZVRSWnZDM2pQVFp0TmsxWmJoREUxdDlvVXZiTThnY29xcmNiMkpBVUU0citXN3hoOE05WjhCZUh2Q3VxYXBieDI5bjQxMHA5YTBraVpYZWUwVzh1Yk15TW9KTWVaclNjQU5nbFZEQWJXQlBwZi9BQVR6K0MrcGZ0RWZ0bGVBUEIrbHlYRnZkNjlxOXRZQ2VIUG1XZ3VKa3RmUEdPY1JOT3NoUFpVSjdWVWJTZkxKZjErUm55dUh2UWUzOWV2NG43UmZ0TGY4R2Qzdy93REZWM2MzL3dBSS9pMzRxOEdUU004aTZYNG1zbzlhc3d4SndpenhtR2FOQmtETHJNM0hKSnI4L3YyanYrRFkzOXJyNEEvYUxqVGZCdWgvRkRTb0ZaMnZQQjJyUjNFMkIwQXRManlicG1JN1J4UDA2K3Y2SmY4QUIwWC9BTUZXZmlSK3l6NGkrSHZ3cCtFdmkvVlBBMnMrS3JTNThUZUlkUzBxVHlkUld5RXhodElZcHNib1ZlV0s3TGxDR2J5a0dRdTVXK0F2MmVmK0RudjlyVDRBdERiYXo0bThPL0ZQVElRcUMzOFc2UWozQVVkZjlLdFRCT3pIKzlJMG40MW5HbmRYVW44OVYvbWJTcU5ieFQ5Tkgva2ZBSHhVK0V2aXo0SCtKVzBYeHQ0VjhUZUM5YWpHV3NOZDB1YlQ3bGZySE1xdCtsZnZOL3diRytDYlA5anIvZ2xoOGFmMmlOZXQyaHM5UWl1TDZHUmhoYnl3MGExbnVIbGpQVTdyaTRudHpqK095eDFGUmZDdi9nN2UrREh4MjBCUER2eDgrQmVyNmZwOHhWSkRaaTA4VjZVNTd1OXRkSkM4YTllRkV4eDYxOTAvREQ5dkw5a1gvZ3B6OEl0UytFUGhQNG1lRGRXMDN4bHBFM2gxdkNZa2JRTlRrdHBJV1JvTFcwblNLVEt4N3NlUXJCZHVSd0FhcmxxSk5iK245YUU4OVBtVGxkZXYrZlUva2w4VWVLOVE4YmF4cVd1YXJjTmRhcnIxNU5xTjdNeCthYWFaeTdzZnF6RS9qWFRmc3UvSEpmMlovd0JvTHd2OFFGMHBkWnZmQnQyZFYwMjNhNDhsVXY0bzNheW5ZN1d5c056NU14VEh6aUlybGQyNGZyNSswNS93WnArS2RQbnZMMzRNL0diUmRhdFdsTDIraytNdFBrc0o0WStvVDdYYkNWSlc2OG1DRmVuQXI4OS8ybGYrQ0YzN1dYN0svd0JvbThTL0JUeFpxbWx3RmkycWVHWTExK3pDTHlaSGF6TWhpWEhlVlVQMHJQMmlYa2FTcHVXMnZwL1Yvd0FENUpRN0VBcjlKLzhBZzFiL0FHZWYrRjJmOEZUOUIxeTV0eExwM3c3MHk5OFRURng4ak5FaTI4SS8zbHVyeXpsQS93Q21KUFkxK2JWNWJ0YVhjbHZOSEpiM0VMRkpJcEZLUEd3T0NDRHlDRDJOZjBBZjhHa253dDAvOW5mOWl6NDZmSDd4S3FRYVJJNjIzMmh3UGtzdEt0WmIrOWtSL3dDNjMybUZHSDkrendlVklHa0drdWJ5TXBSYmZMMWJQaEgvQUlPTy93Qm8zL2hmWC9CWUw0bUxielIzT2wvRG13cy9CVml3NTJOQWdsdWxQdXQ1TmRyeDJBNzE4VC9DVDROK0tQMmd2R2NtaCtGZE5UVUwyQzBsMUM1a251NExHejArMWlHWmJtNXVyaDQ0TGFCTWpkTE5JaUFzb0xaWlFhdnhJK0pXcGZHSHg3NG44WmF4SjVtcytOTll1OWN2M0hPNmU0bWVhUS85OU9hN2I5bHY0eStGZkEvaGI0bmVEUEdrdXZhWDRlK0tHaFd1a3o2MW90akhmM3VrdmE2bGFhaEdUYXlUUUxjUXlQYWhIajg2TXFUSEtDeGk4dDZqOE1ZbDFKYXRyK2tjWDhXL2hMNG0rQTNqUi9EL0FJcTA0YWJxUWdpdkl2THVZYnkydTdlWlE4VnhiM0VEdkRQRElwQlNXSjNSaDBZMTBuN0lkbjRrOFIvdFEvRCt4OEgzRWxyNHVuMTYwVFE1NHpoNGI4eXFMZGdleE1wakdSenlLUDJyL2pQNGYrS3V0K0RkSjhJVzJyUStFZmh6NFh0L0N1a1hPcXhwRnFHcG9seGMzYzk1UEhHOGlRdExkWGx5NndySklJWXpISDVraFF5TjliLzhHd3Y3UEgvQy9mOEFnclI0TXZKcmRiclQvQUZ0YytLcnhDT0VGc2c4aVg2cGV5V1AvZmRPbTdUdXVobFUxaFo5VDltUCtEZ2IvZ3NONHMvNEprYUY4UDhBd3Y4QURTMzBDODhmL0VTNnZKL3R1cjJwdTdmU05QdFZRUEtJVmROMHNra2loQ3hLQVJTNVVrcVYrSi9nSi93ZUlmRUR3UmN4Mm54VStGWGhqeFZiL0tqNmo0V3ZwdEV1bFVkV2FHWTNNY3JIcmdOQ3VlbUJYejEvd2NpZnRDUi9ISC9nc0g0dzArTjFrMDM0VGVHN0h3bGJzSk1vWjJWcnk0T004TUpidVdJNDUvZEFkc2o4K2ZDbmdUWFBqQjhSdEo4TCtHTk11dGM4UmVJcnlPdzA2d3RWRFRYYzhqYlVSZWc1SjZuQUF5U1FBVFd0S0s5bHpOYnNkU0s1ckxvbDk1L1RKOEpQK0RrdjlqWDlzRHd0ZWVHL0dIaVRVdkE4ZmlLMmswMi8wanh6b3pwYTNrTXlGSlk1TGkzTTlzSTJWbVUrYkltUWVsZUNlSy8rRFhqNEJmdEhlSHJqeE4rekwrMEZySGgvUzdpVXlSdzIyb1dualB3L0Rua1J4bEpFbFFlOGswckRyelg0RGZFNzRaK0pQZ3g0MHV2RHZqRHc5clBoZlhyTlkzbTAvVkxON1c1UkpFRHh2c2NBbEhSbFpXR1ZaV0RLU0NEWFlmc1pmRVR4cDhMdjJvZkJPc2ZEZlVOUzB6eHBIcTBIOW5QcDg3d3pYTW03aUFsR1ZuV1Q3aklUdGNOdElJSkZaeGpHVTlMeGZkTUhLcENMNnJlelg5Vys0L1JUNC84QS9CdC8rMkI4RTJrbTBmUWZBZnhtMHRTNUUzaHJXbHNOUVdNZnhQQmVpTExrRDdzSmtPVHdUWHdqOGUvaGI0cStBbXRMcG54TThBK09QaHRxVGtwSEQ0ajBLZXlFeDdtTjJVQjE5eGtIUFhITmYwcmY4RnRmK0N2ZDUvd1NuK0cvZ1cxMEh3enBQaTc0amZFYSt1YlhUcmUvbGtoMDJ4Z3RJNDN1N3VWWS93QjVJRk0wS0pFSFRQbU0yLzhBZDdXK1NQZzcvd0FIY3ZoRHhIYWYySDhhdmd4ZjJ0bk1nUzR1L0RsOURxMXJjODhscks3RWV4UnhrZWZJZlRQU3RxTlRFTlhpK1pMdi9ub09UcHJlTFhwL2xxZURmRC80aitHZmpMNGViVlBDT3N4ekxzQm10dCsyNHRTZWNQR2NFY2pxT080cnpYNC9mczUrQWZqUE5MZGVLTktkZFpsUUovYk5qS1liejVSdFhkMVZ3QUFNTXA0SHRXaDhGUEIwbXBmRlc2V05mS1Y0M1hNUHlZSy9OMUg0MVIrS254Qi80Umo0cmF6cEdyTHUwKzNuQ1F6b3VKRUcxU2NqK0xrOXNINjEvRkdGeEU0Wmk0NEZ1TWxGTk5PMGtyclM2c25yNWE5ano0MUZaTm56VDQxLzRKMTY0dWt5Mi9oZlh0UDhWYVVISmp0THIvUkx1UG5xckhNZTc2TU01NkhwWHl2OFcvZ2w0bStCL2lNMlhpUFNMN1MzbHlZSHVJdHNjdy8yVzVWc2Y3Sk5mcWI0YjA3KzBZa3ZOTDFLSzh0K0R1aWszYmZaaDFYNk1CVy9xZ3NkZDBHVFM5YjAreDFheG1JRWx0ZXdMTkM1OTFZRmVQMHI5T3lMam5NY083WWhLckhyOW1YcnBwK0dwdlRxUmdmak15K2M0Mi9NMmRvVURMSDZWKzJmN0ZIN04wbjdJUDdLMmgrSGJpYVo5WjE5VTF6V0VsRzM3UE5LaWtRS01uQWpYQVBxY25ITmVkL0NQOWdiNFQrTlBqdjRidkxYd3paNmE5bmVKcUVsdkdwK3p5ckYrOHh0SjQrNzBCeDdWOVVlSVJKcTJyWE1yTjVpeU9jRW43b3oycjRqeGk0N2htVkNobG1IaTR4dTV6VHRyYlNLMDZYYmZxa1o0eXB6VXVXUFU1SHgvd0NJMTAvUm5XT01LekRidkE2bjZWNHY0VTBCZFQ4U1hXc1hpK1phNmFmTjI1LzFzbWNLbzl5ZlN1dytLMXpJOTVKQkMyZWlxQjYxNC84QXRqZkh5NC9abCtGZW4rSHZEYTJVL2pUVVVGNUliaFMwV25xNE8yVmhqRHlZQjJxZU9TVGtZQitKNFh5MnZYbEREWVdQTk9vK3VpVWVyYjZMcGZ6N25EUXBwTG1sNkZIOW9yNG0rR1BnN3BVK3VlS2dMalVMOGw3YXpnVWZhcnh1ZW1mdXhqakxuZ0FjWjRCby9zdy9zNWE1KzIvOE40L0VmaURYditFZThPMzh6aTEwTFEzK3pONVNuRytlVTVlUW5zRDh1QURqbXZnWHhSNHQ4WmVKZGFtdk5hMUJ0Y3VMdHQwc2w1TUpHWSt4T0NNZEFCd01jRHBYME4rdzcrM3BkL0FLMGJRZGVnOGpSWTh2YVhFYk5KNUJMY3hzRkRNRjVKQklPT1FlTVkvb0RGY0s0akE0QlZjTmFwV1RUYmowajJnbnFtdFBOcTluME83RDBhY0czS3o3SHYzN1RIL0JQS2I0YytESnA5RjEzVU5RdDdPSXRHdC9ONXpZQXdxYnNEWU9nenlQWUU4L0VkdjQ5dS9BV3VNN2VZNlJ5YkxtM1BCUE9DTy9UMStuU3ZyYjQvOEEvQlRleThRYUxMcGxxMXJlUlhTc3ltM2wzWWIrRUUvNzJEeUIzNEhGZkRlcWVPUFAxTzZtdWJmYjlva2VVcVJ4a25QOC9TdlM0YXdlS3JSbjlacHZrZHJjMmplOS9NOHYyYm5YbHl4ZkxwNWErUjcxNHp2RytKZmhMdy9lYVB0bTFYUzlSaXQ3WUw4clNSVG5CVmllZ1Z3RGs4RGN4NHI2azhHUVI2WFo2TE5KRllYMnNhUzd5UjNwajNtemtsVkVsTUpZWlhjc2FqY01FN2VvQklyNWIvWnI4WURXYm0xczdXUGJJMGFMbFNjNEJKT2VPaFVqSlBjZm45ZmVDUENzV24yMGMweUdWbkkyakJBeU1jRC9BQnI4OTR5clBDT09GMjVYSzNkcVc2djIzKzltK0ZoYTh1dXgyV2phbGQ2eWlNL21OTTMzbVkvZXIzYjRNL0V6VXZCZHRIYXpNTHJUR1A4QXg3U3RobDkwUGI2ZEQvTHlud2Y0TjFmeERJa2VuV0YxTXpnRDkzR2R2NTlQOC9XdXc4SytHTFRVZFRYVDV2RmZoWmI3eVduYTNqMVNHV2NSakFMZVVqRnNBNEJ5T3Y0VitQeWpWcnpjS0NmbWtuTDc3WE8rUE12ZTJQb3pTYnV4OFdXelhHbDNLekdMNzhmU1NMNmordGRGNGU4UlRXbHdzZHdHM2RCbnVLOEJ2UEZPaS9BL1NyYlZvWnRZMUtjc1FzbG9xd2g4Y1l6SVI4dkhwanZYTCtCLytDeVh3dnZ2amhlZUJmaURZWFhnQ1pZb3BMTFdicVVYR256Yi93Q0daMVVlUTJRZVNDbUFjc0s3TXQ0WHpqRVJsV29VSldqcTA3WGFXOWxmbXY4QUkxaFdwVkhvMWZ5MlBvcjRyL0NUVVBFcXc2cjRiWmZ0VnV3YVcwSUg3NWU1UTlpUFRvZnJYZWVBL2h4ckhpQ08xdC8rWGxvRmxNTzRlWUY0R1N2QnhualBxYTBQRGl0WldkdmZXVTBOOVkzQ0NXR2VHUVNSeXFjRU1yRGhnUWVvT01WMnZnK1RUOVErSXVsK0k1Uzl0cWxoYVRXQmtSc0xjVzhwUnlrZzc3WkkwWlQvQUEvTjJZaWpoL0o4c3hPWmV5ekNjcU1aYVhVVm83OWI3THZvenBwOHNkOXpWOEcvc3ZzVldiVnJyeSs0amlPNXZjRTlLOUw4Ty9ERFEvRHFKOW5zWTJkZWZNaytaai9TcjlucVNYVUNTUnNyS3crOERtcmtFdVIrUHJYOVQ1RDRjOE81ZENNNkZDTlNWdmpuYWJmbXIrNnYrM1VqVDJrdGxvVzRrVkkxVlYyakhRREFxUVI1eFVFYlpxd3JiaFgzU1NTc2lUSThXZUF0SThiMkRXK3JhZmIzMGJEYURJbnpMOUc2ajhLOEwrSVg3RkRhYnV1dkRjN1R3amtXazJQTVVmN0xkL3BYMGNxODVxVUlLK1g0aDRPeXZPSU5ZcW5hZHRKeDBrdm4xOUhkQTdQUm53emVlQXJqU2JwN2ZVTFdTMm1VNEtzcFZoai9BUFdLdTZDbDdvaHpESXhYSElOZlluaXJ3RnBualMyOHZVTFZaTUQ1WkI4cnI5RFhrM2kvOW11OTBVU1Q2UzM5b1FaejVSNGxBK25mL1BGZnpCeGw0TzV6bHRSNG5BWHhGTFYrNzhhWG5IcjZ4djZFcW5GNkhEK0hmRjhjK3dUSzBjZy95YTlFOExmRUc0MFRZWVpCSkRqbENldGVaWCtodFp0NWMwYlJ1bVF5c3BVcWFuczB1dEwydkd6U29EbkdhK0p5VFBjVmdheW5SbTRUajEyZjlkMFZhVWR6Nk84TS9FQ3g4Undxb2tFVXpjYkc0NXJmNml2bTdTdkVrYzJGK2FLWmV1YTd6d2w4VHJ2UlFxWEVqWGxtUndHUHpKOURYOUc4TGVMa0t5VkRObzIvdngyLzdlWFQxVi9RRnJzZXBTRGFhRzRQNjFTMEh4UForSklQTXRabFp1akllSFUrNHE2eS93Q2MxKzA0YkZVY1RUVmJEeVVvdlpwM1RBRWZhS2JMTDcvaFFUZ2Z6cUM1ZjVmV3RyZ1ZyeWZnNTdjMXp1cTNXNTYxTlZ1TmlkZnhybWIyNTh4ODUvR3M1NkcxSmRSOFY2OFZ6R3NlTjBqQkNEeUd5Y2MxWTFDeW04THl0ZFdKTWxtNXpKRWUzK2ZhcVdpbnp0WlU5b1ZML3dCQi9QUDRWdS9hdkwvSGdnOS8vd0JkZURtL0RkUE1ZS3ZUazZkYUh3VFc2Zlo5MCtxWk5iZXhGRmZMcUZyNTBQelJuajNYMk5WWm1iSndCN2VtYXIzR21QcGQxSmVXSTNSU0Q5OWIvd0JSUjlwUzVUZWpmS1RqanFEV3ZEK2VWYThwWUhIeDVNUkRkZEpMK2FQZFBxdWhpbjNHelkvV3VzK0RHbmg5WXZMNXVWc1lNS1QwRFB4LzZDR3JqMjNiczg1WTlQMHIwYndaQi9ZWHc2ZWM1Vjc2VjVQK0FqNVIvd0Nnay9qWDFZUzJQaUwvQUlMOWZ0S04rejkvd1RoK0ttcFFUK1ZxV3U2ZC93QUkxWVliYXpTMzdDMllxZjd5UXZOSU1jL3U2L2xnQldJQlI4b1VjQ3Yydy80TzJmamhkM0dpL0NmNGQydm1HenVyMjk4VDMrRkpHNjNSTFcyT2VuVzd1QWZjcjZpdnpPK0YzalA0T1gvN0sxMTRTOFYyZHhENHFTZlU5WmkxVzNoYTN1RGRIVDdvV2NEVEJaUkxDazFuWlJyR1ZqQmJXTGxpVjhrU2lvNms3YU04QXo4dE5rK1UwYnlPVDFvVVBNd1ZGYVIyT0ZWUmt1VHdBUHIwcVFQMTgvNE5WZmdDdW8vRWp4NzhScnlCZkswTFNGMDYwbGZoRE5mVGtaQi92eHg2ZE9Eend0NlBXdnpiL2J3L2FELzRhbS9iUitLSHhDam1hNHMvRTNpTzZtMDVpTUVXRWJtRzBVKzR0NDRobnVSWDYrL3N5emY4TzdmK0Rjdng3NDVqSXROZDhZV3QvZTJVeTQ4enpicG9kRTArVk1kVlpJWUxzZHYzenQzTmZoS3ErVkdxRG9veCtGVkxleFd5SkZudzNwVDdlNWEydW9yaU41SWJpQWg0cFkyS1NSa2NncXc1QkI1eUtyOS94b0Q1UDE3VUlrL1RiL2doRi93VWYrUGwzKzI5NEgrSHQ3OFFQRlhqVHdYNGl1MTArODBiWHJ4dFRTR0pnUzhzRXN4YVczTUVLVFhHSTJDc0xjcXlrTmtmcVYvd1VaLzRMcmZEUC9nbWg4UzlIOEY2dG8vaXp4ZDRyMUswVFViMnowTjRZWTlMdEhkMVJwWkpXQWFWeWpGWWxCTzFjc3lCbDNmbTcvd2FyZkFKdkYzN1VYaXJ4N05iNzdmd1Bvam1OeVA5VmQzcGEwdFdYNndKckNuL0FJRDA0ejhyL3RzZnREK0JmMm1mK0NyWHhTOGEvRUk2NWY4QWdlNDF5NDAyMk9pU0w5b210YkpVc3Jaa0xINVEwTUc4RWNlWXlsZ1YzZzZTazNaTVVZcExRL1krMi80TFAvc1Ivd0RCUjc0VmFoOFAvaUI0aGs4UGFYNGtqV0c1MGJ4dFpTNlR5akxJamk4Z2Q3ZUprZEZkWEZ3ckJsQkdLOEErSmY4QXdhcWZDejQzZUcvK0VsK0FueHl2NDlLdU15V3cxRmJieEpwYzJlVlZMeTBhTW9neU9Tc3JZOWEvSFg0NjIvZ1d5OFZXTVBnRzQxSzgwdE5Palc5bnV0d1dlN0R5QXZFcm9yb3JRaUFzcmJzU21iYWRteFZ4L2hyOFUvRTN3WDhTcnJYZzd4TDRnOEk2d29BVyswVFVadFB1Qi8yMGhaVy9XcGxHRGV1ajhuL1Z4eGxKTFN6WG12MTZIMmgrMEwvd2JjZnRXL0FrVFhHbitFZEYrSnVtd2dzYnJ3ZnFpM1VoK2xyT3NOeXg5a2liOGErS1BpVDhNdkUzd1o4UnlhTDR3OE4rSVBDT3RSakxXT3Q2ZE5wOXd2Ym1PVlZiOUsvVTMvZ2pGL3dXKy9hSzhkZnRnK0NQaHQ0NDhVZjhMSzhLZUpyNjIwbVZOVnNZanFkb1o3aUtCYmlLN2pWSkdhTXlDVnhPWlEwVVVvRzFpcnIrcTMvQlFIL2dyUjhDZjJBdFU4TytIdml4cW1vWCtyYTRxNmxaYUxwMmtEVmJpM3Qxa1pGdlpFWmxTS1B6RWRWYmR2TFJ0dFU3V0lsMDVMNFhmMTBLVTQvYVZ2VFgvZ254dit6N3AwMy9BQVRPL3dDRGJIeHg0d3VMYTYwbnhMNDYwaTgxUzFNa1podWtmVVVnMGpTcHNIa0UyeVdsMXRQVHpXNEhJcjhEb1l2SmhSQjkxUmdmNS9PdjZoZkdmN1pmN0hmL0FBV0MrQnV0L0RHNitMM2gyK3NmRnlKRk5ZM2VvdDRlMXFLZFpGbGprZ1crU012TkhLaU9wVlpVSlhCRHFTRDhEL3RHZjhHaG5pdlNSTmZmQ1g0dWFOclZ2SWZNdDlOOFg2ZEpwODJ3OUZGMWJlYWtyZTVpaUI5cUpYaTd5VHNFZVdTdEY2OWo4MGYyWGYyeE5VL1pVMUt6azBYUXRCbFdiVm9yalg3dDRDMm82OXBRTVlsMFZwbkxMRFp6S0pSS0lVUjVoT1ZsYVJFalJmSXRZRm4vQUd2ZGYyYkhjUTZjWjNOckhjT0pKbzRkeDJLN0FBTXdYQUpBQUpCT0JYMDcrMGIvQU1FVy93QnFQOWx3WEUzaVg0T2VLTlEwdTNMRTZwNGNWTmVzZ2dKL2VNMW8walJLUU0vdlZRZ2RRSytXN2tmWnJpU0dRTkhjUXNVa2lkU2pvd09DQ3A1QkhvYW4yaWtySUpVM0hjL1hyL2cwby9aNGJ4TiswVjQzK0kxemIrWmIrRWRFTnZha2psTHk5a052YnlyL0FOc0lkWGpQL1hRVitmOEEvd0FGU1AyaC93RGhxei9nb2Q4WVBIVWN5M05ocVhpU2V5MHlWVzNMSlkybUxTMVlmNzBNRWJmVmpYNjlmOEUwTDl2K0NiMy9BQWI0ZkVENHRaanNkWThTV0dvNjNwVTdJd0lkRVhUZFBHUU9Va3Z4TmNJZWhqdkF3NE9hL0EyR0R5clZVWCtGUURWU2V0bDBCS3l1ZFY4SC9nVjRpK091cmFwYjZCRHA4ZHZvTmlkVDFiVWRUMUdEVGRPMHExRWlSQ1dlNW5kSTR3MHNzVWFBdHVlU1ZFUU16QUhOK0ozd3kxajRRZU9Menc3cnNOcERxVm1rTXpHMXZZYjIzbWluaGpuaGxpbmhaNHBZNUlaWTVGZEdLc3JnZzEzZndGK0wvaHZ3ejhOdkhQZ0h4bEhyMFBoZngzSnB0NCtxYUZGRGNhaHBsMVlQTTBKOGlaNGt1SVhXNW1WNGpMRWQza3VIUGxsSDh3MXVDeGkxdStYUzN1NU5MKzBTQ3plN2pXTzRlSGNmTGFSVUxLcmxjRmdyRUE1d1NPYUdySW01Nzkvd1NaK0gydC9Fdi9nb3I4STlQOFBYVTlqcXkrSnJCNGJxRWZ2YlFHNWpqZWRQZUdOM20ra0pyOW52K0Rpai9ndHo4UnYyQXZpZjROK0dYd2J1OUgwUHhOcTJtTjRpMXZWcnZUSWRTa3RMWnBuaHRyYUdPZFdpVXNZWjJkbVJtMitWdEtjbHZqbi9BSU5OZjJjditFOC9iTjF2NGczTUphMjhBNlJkVDI3NC93QlhkengvWW9oOUpJYnkrSTk3YjJOZktmOEF3VzIvYUQvNGFZLzRLby9HZlg0N2p6OU4wZld6NFkwNHErNlB5Tk9WYlBjaEg4THlReVM1N21VbnZWdHRKUitZS0sxWjlvL3M0ZjhBQjRQOFZmQk1rTnY4VVBoajRQOEFHMXVtRmEvMEM2bTBHK1BxekJoUEF4NjhLa1k5eFgyMzhOUCtEa0g5alg5dER3UnFIZy80aTNPdWVDTEx4SGJQcHVwYVg0MDBWcGRQdm9wVUt5Um00dEduVFlRU04wbmxIdndjR3Y1dmZDWHc0MXI0ZzIydlQ2TFltK2k4TTZYSnJXcGtUUngvWmJPT1NLTjVjTXdMNGVhTWJVM044eE9NQWtadXBhRmY2SERadmVXVjVZeDZqYnJlV2huZ2FJWGNKWmxXV1BjQnZqTEs2aGx5cEtzTTVCd3BUdnBKRXFEV3NXMS9YbWZ2bjQ1LzROaGYyVi8yek5HdnZFMzdPL3hxdk5GZ2xQbWhkTDFhMThZNk5hNSs2aEFrVzRqeWVQM2x3N2NkTTE4WmZ0R2Y4R28vN1VYd2RFMTE0UDhBK0VIK0xPbkl4S0RSZFdGaGY3QjNlQzlFSzd2OW1LU1ErbWErVS84QWdsSC9BTUpkSC93VU8rRXYvQ0NYMTFwUGltZnhGYVd0cmRXOGpvRWFlVkxkZk4yRWJvQzhxQ1JXeXJJV0RBcVNLL2V6L2d2TC93QUZ5OVkvNEpjYS93Q0RmQnZ3NzhOK0dmRVhqanhWYnpheGNONGhXNGtzdEswNUpURkgrNmdsaWVTU1dSWlFDWkZWQkEyVmZlTnNTcHF5Y1hhL3pOSTFKTjJray9UUS9uTCtQSDdLM3hPL1piMVpiSDRsZkR2eHI0Q3VaSEtSL3dCdTZOUFl4emtmODgza1VKSVBkQ1FmV3YzVy93Q0NJWGgrVC9nbnIvd1EyK0pQeHkxTFQ1clBVdFkwZTk4UzZldDFFMEVsN2FXVnBLMWlDR3dkc2w3UGVDTnVqeHl4T1BsY0d1Sy9aMi80UElkTnZMU1BUZmpCOEdyNjBTUUFYT29lRGRUVzVoZjMrdzNoVTQ3NE55MytQMmpvUC9CWUg5aTMvZ3BUOExkYThCNno4VlBEMXZZK05OUGswelU5RDhYTk40ZHVKWXAxS05HSnJnSkVaT2ZsTU16RldBSUlJRlAyYytWcFdkKzMrVzVQdGFmTW0wMTYvd0NleC9LeXNrbHpCNTA4alRUekV5eXlPZHpTTXh5U1QxSkpQWHZYY2ZCNzlwVHhWK3o3NFQ4VzJQZzYrbTBEVmZGeVdVRTJ1V04xTmE2blpXOXRQOXA4aUNXTjEyTEpNa0R1ZVcvMGRBQ0FXeit5MzdRLy9CbmxwZml5MWwxLzRJL0hHYjdIZkF6V2RuNHZzMXZvSjg4NS90S3p4dUI5UmJOMTZuclh3TCswbC93YnRmdGVmczF4M1Z6Y2ZDeTY4ZGFSYm4vai93REJkM0hyUWxIY2kyakl2QUI2dEFCVSswNWQ5RFQyYmw4Tm42ZjVibnpoKzEzKzBmZS90VmZHR1B4UmVOcWhGcm9XazZKRWRSdS90ZDNOOWlzSUxlV2VXVEEzU1R6eHpYRG5uNTdodVQxcjc3LzROUlAyZHY4QWhaZjdmZHg0eXVJV2ExOEE2UmVhbEZMdHlwdURHdG1rTGY3MzlvR1ZmZXpQcFg1aStLZkRXb2VCL0VOeHBPdTZicUdoNnRadjVjOWxxRnM5cmNRc096eHVBeW42aXY2QXYrRGJid3hwL3dDeGovd1NvK0oveC8xcTN6WjNNTjFxdm1FWVRVTERSN2U0dUdLSEhlNXVMcTFiSFY3TUFad0swakxlWms0dTZoOGo4MVArQzZuN1FIL0RUSC9CWEg0dmFsRmNOYzZUNEx1WXZCMm5LVDhzSzJDQ0dkVkk2cWJ2N1UvdnZyNDIxSUNKbVp2dXFwSklHT2xiRm5yMTc0d2wxTFd0V3VKTHpWOWN2SnRRdmJpVDc4MDBybDNZKzVaaVQ5ZnBucFBnbHEvZ1B3LzQvanV2aVI0ZThUZUtQRGFJSkRaYUZxMEduWFRTckxHNDNQTkJNclJPaXlSTW9WV0htaHcyVTJQMFU2ZHFhVEhPV3JramwvaXo4TE5iK0N2aisrOE0rSkxWTEhYTk5XRTNkc3N5VEczYVdDT2NJeFFrQ1FMSW9kU2NvNFpXd3lrVjFYN0ZmdzcxcjRyL0FMV0hnSFFmRHN6MnV2YW5yZHBhNmRkS29Kczd1YVpJTGFicHh0dUpZZWVvNmprQ3VmOEFqcDhWOVMrUGZ4bzhYK085Y0VNZXJlTmRidmRkdlVpSjh1T1c2bmVkMFRQTzFTNVZmWUN2dnovZzFzL1ozYjR0L3dEQlNmVC9BQkhjUStaWStBYkM3MXVYY3VVZnk0dklRWi92TGRYbGhNdi9BRnh6MEJyT1B4WEpxZkNmcE4vd2NwZjhGaC9pRi93VHdzdmg5NEgrRHVxYWZvdmpmeDBidlY3L0FGZTQwK0MvbjB2VG9IU09JUlEzQ1BDV3VKRE1DN28yMWJkZ29CYmN2d2oremwvd2Q3L3RBL0N5YTF0L2lSNFA4Q2ZGQ3hoR0pMcUNKL0QrcVNIMTgyQVBiajhMWVY0Ny93QUhEUHgrSDdTSC9CWHY0bCtUY0xjYVQ4TTdLMDhGV0xLMmRqVzZHUzZVL1M4bXV3ZnBpdmk3d044S3RhK0xtdGFsWjZEYVIzVTJsNlJmNjdkbVNkSUk0TE95dHBMcTRrTHVRdnl4eE5oYzduY3FpaG1aUVZUaStUbi9BS3NWT01lYmwvVS9lVFNmK0RnWDlnWC9BSUtFUjI5diswRjhKbzlCMWd4Qkd2UEYvaEczMTYzZ0pQM0lyKzFXUzZVZTVpaUEvT3Z2ZjRZVGZzMy9BTFpmN0huaUg0Ty9CM3hkOE9icjRlYTE0WnZ2RDh1bGVCTlF0RWswZXl2SVpZNVdXMmorYUJ6NXp1VEpHQ1hZczRZazUva1IrSVh3cjhTZkNqVnJTeDhWZUh0YzhOMzk5WlE2akJhNnJaU1dkeE5heTVNVTRqa1ZXOHR3Q1ZiR0dYa1pCQlBYZnNiV1BpYTQvYWw4RGY4QUNFelQyZmpUKzE0RjBLNXR5eVRSWDd1SXJUWXk4cVd1SklVQkI2dUtpTk9EZHJXdjJKbE9wRmMxOXUvOWY1bjZGL3RML3dEQm9kKzBUOExwTHk0K0dYaWp3SDhWdEhoUCtpMnJYQjBMV0pSN3hYSCtqREh0Y25Qb0svUGI5cGo5Z2I0Mi9zZVR5TDhVZmhQNDY4RTI4VCtYOXZ2dEtrL3M2UnNnQUpkS0RBL0p4OGpucUsvcEUvNEw5ZjhBQlp6eEIvd1NyOEsrQnRGK0gramVIdGUrSVhqKzV1NUluMW1LV2F4MHl4dFFna21NVVVzYk5KSkpLb2pHL2FCSElTR3dCWHhYK3p2L0FNSG1YaVBTVEZaL0dINEw2VHFrRWpiWjlSOEdhcEpZc0U3L0FPaDNSbVZ6ZzlQdENENmRvVUp2Wi9mL0FFalNWUmJ5ajkzOVA4RDhMd0VtKzR5dFg3Ni84R2Vmd0tzdmh0OEQvalI4YlBFQ3gyZW5ib2REanU1Umcya0VFWnZyOG5qN3BpT252L3dBMTNVSDdVdi9BQVNZL3dDQ24xMUhKNDE4TStDZkFmaWpVSE1rdjl1NlJQNE52R2tQVnByK3hkTFdRLzhBWFM0YlAwcjlCZkEzN0dmd2l2OEEvZ25kcnZ3WCtDODJqK0gvQUlXK0t2RHVwNkRaMy9odStHcVJRQy9nbGlsdVJjR1J6UExtVXR1ZVJpY0tNZ0FBUDM0eGJhSi9keWtsZnJyZlJuOGx2eFcrTVdvZkgvNG5mRUQ0a2FwdWoxUDRqK0piL1g3aE4yN3l6Y1hEeWxSeDBVdVI3REh0V24reDU4ZWRCL1puK01HcWVOTmIwbDlldXRQOE02dllhSnBwRXEydDVmM3RvOWd2MmlTR2FLYUdKSWJtNGw4eUZ4SUhpakNsU2Q2L1dmN1J2L0J0UisxNSt6YlozRU9rK0I5RStMSGh6VDFaMHY4QXdmcWlTWEpUY2NBMmR4NWR5MGhCNVdLSndPZm1QVS9CL3dBV1BocjRrK0MvaWR0RThjZUZmRlBnZldsWExhZnIrbFQ2ZmNEL0FJQktxdCtKRmRDclUzQlFnOVV1b1NwenU1TmRkMS93RFEvYU8vYUNuL2FCMTN3ODBlZ2FUNFUwSHdmb2tYaDNRZEcwMlc0bmgwNnlTZWU0Mm1hNWtrbmxkN2k1dUpHWjNJQmwyb0VqVkVYNm0vNE52LzJkditHamYrQ3RQdzFTNHQvUDB2d2ZkTjRudldBeTBBc28zdVlIK2h1WXJlTW4wbVBxQlh4QkxBc2d6R3l5RDFWczErNm4vQm1mK3p0RnBWbjhaUGpCcWNiVzhNZHZiZUdMSzhZNGpWSGY3VGVLZmRCYldUK2dFdzlhelYwM0prU1Ywb3Jyb2VNLzhIS0h4OEh4bS80SzZYL2gyS1pwTk4rRFhnNnowWFprZVd0L2VnM3NyakhmeXJpS00rOE9PdGZuSDRoS1hFMjQ3bTV5UGY4QUx0L2g2WnIwWDQyZkhHWDlwdjQ5L0ZqNHJUTk1yZkV6eGhxT3RXeVNmTTBOcTl3LzJlTG5uRWFIWUFleWdlNDVmNFpmQzI5K05QeFkwUHdyWTNGcHA5MXJsMklXdTd2Zjluc0kxVm5tdVppZ1p2S2loU1NWeXFsdGtad0NlRDZHR2p5MFZmcnI5NFZKZnZIYnBwOTJoOXlmc08vdGsvRGo0MGZIU3owUFNaZkVVT3Vhb2x4SkRiWDFnRmpiYkV6Tjg2dXlnaFFUNzRyYS9hSHZ2QWQvOFcvRUZsZmVMdkRGcnFWbmRlWGMydDFlcGJ6UXY1WWJCRDR6OHVDTUU4ZlN2aVAvQUlKRDZjK21mOEZEUEFxelNTQnBEZW9xODlEWnpEbjBITmVvZjhGRmZnOWNlUDhBNG9mR2pWck9QeWJ6dy9yOEY1RHRmWjU2QzJ0NFh5ZlVic2puK0UrdlA4aDVwd2ZsK0c0dFdDbzFwVTRPaEdWN3ArOUtxNGRWdCtYYzRxMkhndVdLMjFPd1BpandyNFIxMVgwWDRpZUViTzhWeGhFMWVQNXZZa01RYytoNDVydExIOW9NUlNMRDRpMDFmTG15c2VxYVM2M0Z2SUQ2cXBQWC9aSjY4TFg1dTJtcmMvWi9FQVVPRzJyZHhNR2tpSCswRjRkZWZyOWVsZGQ0TytGSGlqeHI0Z2gwM3duWjNuaUs2dUFYaUdsbGpJb0EzRW5HQ3VCeVMyTWZ6Kzdud1BUb2U5VXJ2VHEwcmY4QWdTYVgzM00vWnlpOUQ5ZS8yUFlkUDEvV2RZMVRUTlF0OVJqczlNbEt0QktEdFp5RitZZFZPQ2VDQWE3ZTRLMlZqY1NTY2NFREo0RmZOZjhBd1JCK0h2aVRRUEQzeGd1UEZqNnN1b2FhMWxwMGR0cU9UTmFsaEpJd3kzSno4dmZCeG12cEQ0a0xKWmFVeUtjczNBd09vNjEvTkhIeWxIaUtlQ2NsSlFVVW11cWF2K3R2a2RWU2xhRVd1djZubDFocEsrSi9pRGJ4eURNS3Y1c2g5RkhOZVBmSFR3TDRSK01IaXZVdFQxclFmdEU5eEwrN3VvN2w0WkNpa3FtY0hiamFCeGl2YTBNbmgzd3pxMTJpaHRRMVFEVHRQUmlBODhyNUdGR2VTRjNIQTlEV1o0SitFeStHVEhOcUVhWFdyZmZFWUpNVnA2QURvekQxUFRHQnp6WDJIQ21NaGdxVThYSjY2UmlrOWROVy9TN1MrUk5hVWFjVXBIeTlxbi9CTmp3M3E5N2IzcmFucjJrNmM4b1o3V1JZNVpaa0hVS1NxbE04NFlxM3JnMHZqVDlocjRmNmRBMDF2cERXY1lpNDMzVTArOGpqb1g2L2tNbm9LK3R0YjAyRVJ2SmNaWVJqbGp5QWNkczlldjZWNTM0ZzB4dkdtcGZaWVVmeWYrV3pIR0FvemtzZjgvblgxRWVMc2RXa202MG9yWkpOcjh0L21jOEtrcHZSV1I4VWEzK3lIYitKYi83Tm8yaHJJd2ZDUEhQSW0vays1SCtHUFFWbUg5amUxMCtNdGQ2dFBkUjJ6RU1tbjJiM2doSUlKVXlmS21lZTJjK3ZhdnRqeEhwR29hSGF0WTZCYWlLM1hBbG1aZ3NreDZIQjdMK1BQNGNlWitOUGhUNG84VkR5NUoyUjVpY0x5d0djL2xqL0FDSytvaHhMbUZPS2pPcnlyejFmNDMvUTBrckxSL2llTStDZmlOOFB2MldKN3E2K3g2cnJGOWF4c01YY0JodUo1TWtLaWpIbG9nNExOdkp3VGpKQURlcGZHbjlxdng1OEVQaDk0TjhiM2wxcEdqYVg0MDhPelhtajJHbTZaNXR3dDY4Zjd1RzRsbVovbGpCaGxMSnNKRWhYYWNBbnp0djJRdEt2L0ZMZjI0MTlmWEZrNUFpa2NyR3dCeTNUSHluMHorZlN2b3I5cmY0SzIveDAvWVExenlvZDExNFV0eHJlbkdHTXlOQkxiUi92WWdBTTdXZzh6Z2NaVmY3dGNXTXpES0pabGhQYVI5cTZrclZKUzFzbXJSNVU5RXJ1N2RyMnVreXFWUDNiU1B6ZDhUL3RUZkV6NGhXVTl0clh4QzhhYWhheWtDV0NiV2JnMjhtQUFNcHZDNXdCMjdWN1ovd1I2bnNiYjlzNkd6bG44dWJXTkExQzF0Z293R2xFWWxJUEI0OHVLUTlSeUJ5ZWgrVzdhemptYmFyYmhJU0ZKVTdSNzE5TWY4RWViWnYrSGd2aEdCOXJOSlo2ckdQbnh6L1oxeWNlL1E4SHYzcjl1emFoU3BaYldqU2lvcFJlaVNXeU5zVEJld21sMmY1SDZ2ZkYzVFBMK0hHa044c256RnNmM2dDUlg1Uy84Rkl2QytvYWwrMG0wZW4yTjdKRzJrUVhiN0kvbFlBVEVzVzZjYlNCN2pqSnI5Y3ZqTlp0SDRGME9GMUprYmQxSFE1SDVkNi9Qbjl1VHdHM2l2OEFhVjhPYWJhRzgrMjZwcDFwYVBicGxFa1VTemxBeDNmTnk3RUxqSHlESjRJcjgwNFB4RXFPSjV2S1gzdG84ZkpZdVZSTDFQME0vd0NDRVBnL1VQaGwrd2xaRFVkU3VycXp1cmhwYmJUN2dsbHRrMnJ1S1o0VldkbTRIQkliMHhYMmdkSnQ3cFliaXhtV0dXWmR5eE0vTEVnSEE5ZW8vTVY1ZjhFUEExcDhLLzJlTkI4T1dhK1hEcE5oRHB3SmtNZ2tkV1pwWEI5RE04aEdjL0tCa2sxbC90cmF3M2hmOW1iWEx4RE1zbW4vQUdlV0l3bmJJaFM1dHR1RGpJeGpKOXMxN1hFZkFHVzUxRzlXUEpWL25qdmZ6NzYvUHpQcUpXU1o5Q2VCL2lOYytHcjViZThWdkpZNElKcjEvUk5hZzFlMFdhQ1JaSTJBNUI2Zld1R0hnK3k4WDZCYnpzdmx6VFFwSnZIcVZCcmwwSGlENFNYNW1DeVhWaVd3Y0RjQ3VhK0Z3T1paN3dPL1ladEIxOERmNDRYazZmbTF1bDNUK1Q3enkzMlBkb215Vi96bXJVUEg0MXlmZ1g0Z1dQakcyWHlXMlRxUG1pWS9NUGNldGRQQWVsZnVHVzVwaGN3dzhjWGdxaW5DV3pXMy9EOTA5VVE3N0Z1TCt0V0VYUDhBbnBWV0Y4VmJpL2hyMEJraUpnLzFwNnBqL09hRUdGejdWSWlldEFHTjRrOEI2WDR2ai8wNnpqa2tYN3NvRzF4K05lZGVJdjJkNWJGbmwwMlkzRWZKQ0hBZGY2R3ZZQU0wcFFWOFR4TDRlWkhuamM4WlJTcWZ6eDkyZnphMytkeTR6YVZqNXN2L0FBazBjN1IzRVpqbGo5VjJzS3FwWjNlanNwWE15ZHg3VjlJYTM0WnN2RU1PeTZ0MWs3QnVqRDhhNG5YL0FJTnl3c1hzWlBPWCs0eENzUDZHdnhET3ZDZk5zc3ZVd2I5dlQ4dmpYckhyOG0vUkM1WXQzV2pQSzdIWHBMU2Z6b1pIdHAxNUJVN1NLOUQ4TC9Hc0pISEhxaWx1eGxRZFBxSzViV3ZCeDg5bzVvbWlrVDIya1ZnM21oM1dub2Z2U1JMM0hXdmlzbDRvemJJNjhwWUdUWGVMMnV1OGUvbXJNdVdueG4wRllhbmI2eGFDYTJtamxqYnVwNlZEZXZqOHE4SjhPZUxyencxZXBKYnl5UmQyVWREOVJYcEhoNzRwV3V2UkxIZFl0Ymc4QW43ai9RMS9RWENQaXRsK2FXdytPL2NWdXpmdXYwbCtqKzlrU2paM1dwZTF5NDJLMWM3Y1RaTGYxTmEydVM1NzFnM2tvUkdMYnNZSk5mcGxTVnpxcHF5Tkx3MEQ1TTBuVHpIQ2o2RC9BT3VXL0t0RjV1RDkzbm5JcXRwOFAyU3doalBEQlJuM1k4bjlTYWM1d3VlUGxyMGFjZVdLUnl5bGQzRDdRWW0zTHdRYzhmNS96N1ZUMUQ5M2MvYVlGeHV4NXNRNk43ajNxV1E3anlmdTlTYWdkdHBOZVZuR1RVOGZDTHU0MUlPOFpyZUwvVmQxc3lWdmNGWVRJcnI5MWhrSEhhdXc4U2ZFTFQ3VHdQcHNJbmpoWkxaWXlwSUJEcU1OK29KL0d1Tm1jc0FuemJSMHlLcDZocDF2cXRzMGQxYndYRUxZSldSUE1YOGowUEhXdld3dk9vUlZmV1Z0V3RGZnVrVEtOenhyOXNUOWhyNFAvd0RCUUR3eGFhVDhTdkRzZXNMcHp5U2FkZlcxM0paMzFnMGdVT1lwb3lEdGJhcGFOdDBiRkVMS1Npa2ZuVjhlZitEVGJRdFNTZTYrRlh4ZTFUVFpOcE1PbWVMZE5TOGpadW96ZDIzbHNxNC82ZDNQdlg2d1MvQyt3aWRuc1o3M1RXUFA3cWN5UmdqL0FHWk4zNURBL294ZkQvaUxSem1DOHM5U1JlZ2tEUVNFRC92cFRqM0l6WFc2VktYd3UzOWZjWHpQcnFmemlmdEFmOEcvUDdVM3dEV2U0aitINitQZE5oLzVmUEIxNnVxTkovdTJwQ1haL0NHdm5qNFRmczMvQUJCOFMvdEtlSC9oL1plRC9FbHY0KzFDL1czc2RJdk5MbnQ3bExua3h0TEc2aGtpUndHa2RnRlJGZGlRQWEvckRYeHRlYVIveUZOTnZyTmU3bGQ4ZkhjT3VWL00vaFczcEhqNjAxeTNWWWJ3eUlWSy9MSm5BNE9QcDA0OXFYc0trZFU3aXZGOUxINUJmOEhPWGkvVGYyZXYyT2ZnYjhBdkRMeWYyVERJaGpBYmFXc2RIczB0TGNPUDl0cmhYeDZ3NTk2L08zd3A4SmZnTDhUUERiYVJZK0lmN0gxKzV0ZEVoMHkvYlVKRW1rdXBZMmd2VnVvTHRZYmRXKzNYVm1TWVpURkZhVzF5Nm1WNDJaLzZGUDhBZ29EL0FNRXh2aGovQU1GSy9CZW5hYjQyYlhOTjFIUnpJMm1heG8xMnNGNWFMSVVNa1pEbzhja1R0RkVTanFjR01GU3A1cjh1ZjJnZitEVFA0aGVIV251dmhoOFVmQ3ZpeTJYY3lXSGlLMGwwZTcyODRSWkl2UGlkdWd5M2xEbnRVOHppN1NYOWZJT1htMVQvQUsrWitWZmptWFI0UEh1dW53dzE4dmgzN2ZjcHBKdkhEM0pzakk0aDgxZ3Fobk1XM2NRb0JPZUIwckhZN1F4UGF2b1g5b2ovQUlKUS90Ry9zdHh6WEhqTDRRK0xvZE50OG1UVTlMZ1hWN0NOUjNhZTFNaUlQOThxZmJ0WGhuZ1RUN2p4TDQyMG5UdE9zNU5VMUsrdklyZTBzSVl6SkxmVHM0V09CVUhKYVJ5cUFBZFdxWXlVdEVUS01sdWZ1Ui93UzhsWC9nbnAvd0FFRi9pbDhYN2hsczlaMXFMVXI3VDVHR01TMnlmMlpaUms5MU9wL2FuVStsemtkZWZ3b2lqOG1KVnp1MjhIK3RmdHYvd2NIYTViL3NiZjhFcWZncit6N3AxMUg5cXZXc05NdldqNlg4R2syc2IzVXA5NUwyUzNsSjdrbjhQeW4rSEh3TjhLL0Z2NGQyR282ZnFIaXF6MXEzZTV0TlZzTEsxdHRjbVYwVzNlRzhXMldTM3VJN1IxbHVGWW90eTBiV3VTVzh3QmRPVnllZ3BXaXJNOGdMZm5ublBlazgwS1A4ODFKOW1nbHNwcEk3cnpKb1plRUVaQ3ZIL3owREgrUkhROWVvcHQ0c04xcGtOMUJINU93aUdlTU16WWNEaCtlY05nK3dJUEFCQXFPVmlQMFkvNE53dkIyaTZIKzA1NG8rTUhpeVpyTHdsOEYvREdwK0s3KzgrenZPTFYwdHpaeERhZ0xzelJYMTlJcXFwTE5aNEFKeFhnMy9CV2o5clRSUDI1L3dCdmp4MThRTk4xUytsOEwzaHM5TThNbVdBb3hzWWJjTDVwUnVWVnBSSTVRNFlHWnU2a0g3Ui80SkZlSDlCK0RYL0JFNzlwVHhmNG9WbGkrSUdrNnRwTG9NQ1dld3RiQ2VLTFpuK0kzbDdlS0QvZVJmU3Z5RHRHYTZXQ0hLamE0NUp4OTc1VGsrZzYrM05YTG9nNkUwbzVNY2lyOHB3UWVlYTlkL1o0L2I4K05uN0pyUkw4T2ZpcDQ0OEkyY0xiaHA5bnFzcmFkSWY5dTBrTFc3LzhDak5jdjhHLzJhL2lGKzBsNGp2Tkw4RCtEOWU4VFgya3hHVFV6WldwYURTWWxJUXpYVXh4RmJSQTRCa21aRUI2dFhkK0p2MlBQRG53dThJNmxMNHUrTVBnaVh4ZEhiUDlpOExlRFEvaXU0KzAvd0FDWGQ5YmxkTmhpSis4OE4xY1NMeis1SjRLWE10WWcwbm96N2UvWnUvNE96UGp4OE5aTGUzK0lYaFh3UDhBRXl6aUdKTGlLTnRBMVNUL0FMYTI0YTNIL2dOWDNGK3k5L3dXRi9aQi93Q0N1SHhnMER3WDhRL2d6cGRyOFFkWmRZdExYeHQ0WTAzWExXNHVEOTIzaTFEWXpobU9GVVN4eEs1S3FNc3dVL2dCcFB3TzFyeENaNDlMU1RVTGkxdC90VXFSUXN5cEh1S1pMaktqNWxJNTQ0SkpBQk5mVS84QXdiLy9BQUdtK05mL0FBVkgrSFZ2TERNdHY0VDFOTmV2VGdocmY3QnV2MDNlelRXY1VCLzYrQU85WHkzdDdSZmdUckg0VzBmMGVmdG4vc08rRy8yNi93QmxQeEY4SWRXa3ZORTBMVzdTQ0NHVFNJVlZ0TU52SkhMYk5IRndteU9TS1A4QWQ0Q2xWMi9Ma0VmaHYrMGIvd0FHblA3UTN3cmt1Ymo0ZitJZkEveFUwK0gvQUZWdUxrNkZxc2dIckRjbjdPcDloY21xL3dEd2MwL3QyZUxQaUYrM2xMOExkSDhUNjFwL2cvNFkyRm1zbW4yVjQ5dmIzR3FYRVF1WkxoOWhIbVNKRk5ERXBiUGxsSEM0TE1XK2MvMmMvd0RndVIrMVgrekdJWU5EK01YaVhXdExpSUg5bStLZG5pQzFLaitCVGRoNUlsLzY1T2hIcUt5NVUrclg1R25QSmFOSm5rUDdRLzdEUHhtL1pOWm0rSlh3cjhkZURMVlgyQy8xSFNKVjArVS85TTdwVk1ML0FQQVhOZVVMSkhLR1pXVmg3VisxZjdPSC9CNEZyMWpIRnAveGQrRHVrNnBiekR5N25VUEIrcHZaT1VQQkpzN295cklmYno0eDlLOWwwbjlxRC9nbFAvd1VkMUNLYnhsNFI4RGVDdkVWM0o1c2llSTlJbjhHM1VqK3N0N3AwcVd6NS8yN2hzMC9aejZXZjRmZ1R6dzYzWDQvaVFmOEVKck8zL1lFL3dDQ0szeFUrTytvUXhyZFhOdGZhdFp1eEFXOGcwdTJrRUVPYzRKT3FUNmpEa2Rma0hXdndCbXVyaS9FbDFkVFN6M1YwN1RUeVNObHBaR081bUo3a2trNXIrdWo5cEQ5aXp3TCsyNS93VFYxL3dDRFB3NjFuUWZEL3dBUDllMFdEUzlEMUR3eVlyelM5T0Z2UEZjUUJQS2ZaSkdKSVUzZ1B1Y00rVzNObXZ3Ti9hUy80TnJQMnMvMmZaTG00MDd3WG8veE8waURjNHUvQnVwcmRTRURvQmFUaUs2WTQ3Skcvd0JUMXBUbGFYdmFGUWp6UjkzVStZZjJJZmk5NE8rRFh4ZjFhNitJRnJybW9lQ3RlOExhdm9lcVdta0ZWdmJ0WjdWdktpamQ4ckVYblNGUE5JWVJoaSsxOXUwOFY4Y3ZqWnJQN1EzeFIxVHhacjYyTnJlYWdZNG9iS3doOG14MG0xaGpXRzJzcldMSjhxMnQ0RWpoaWp5ZHNjYWpKT1NhUHhKK0hIaVQ0TytKcE5FOFllR3ZFSGhIV29lWHNOYTA2YlQ3cEI3eHlxcmZwV0ZHbTg1WEIraHA4eWEwRTR1THN6OVB2K0RVejluWC9oYUgvQlFXYnhqY3diN1B3RHBOenFNYk1tVWxsMkMzQ2Y3eXlYZHRLUGVIMnJ4di9nNEgvYUZIN1IzL0FBVnErS3R4YTNIMnJTdkJNc0hnMndIM2xqK3d4aExsUWVtRGVOZHQ5R3I5TVA4QWcybDhGV0g3SFgvQkw3NHVmSGJYNFBMdDVvcDlVbTNEL1cyV2wyVXQ2em9mU1FYSWpJSFZyVURuQXI4RnZFSGlQVVBIMnI2bDRnMWk0YTUxanhEZlQ2bGZ6dDk2YWVhUXlTTWZxekUxbzFxbzlrS096ZmNaOE8vaDM0ZytLM2pheDBEd3g0ZjF6eFJyZDl2TUdsNlBZeTMxN2RKSEcwc3ZseFJLenR0aVNSMktnN1ZSbU9BQ2F4OVVzcExMVWJxM210NUxXV0dWNDViZVZHVjRHREVGR1Z1UVFSZ2c4Z2ptdnB6L0FJSm4vRUR3WDhMZkYzeEcxRHhScTNndlR0VzFUd20yZzZCQjRzbTFhMTBtNWE3dTdaTC9BTTI1MHhEY3dIK3psdkkxWldUTFhBR1dBS041diszZDhXZE4rTy83YVB4VDhYYUpxazJ0NkZyM2lhOW4wbS9udGpieVhWaUpTbHM3SXdENU1LeDVhUWVZMk4wbjd3dlV5alpJTkwyTysvNEpSL3REZkZUNElmdG0rQWJiNFcrSk5lMHUrMWpXcmV6YlNMZS9tajAzVzJsY1J4MjExQXA4dVdPU1Y0MElaVGdzQ01FQWoraDcvZ3REL3dBRnJkQi80SklXSGhDeHQvQjhueEE4WCtOcHJxV3owMXRWR20yOWpaUWJRMXpOS0lwV0paNUZSSXdnM2JaR0xMc0N2K01mL0JyL0FQczYvd0RDN1A4QWdwdm9lczNFUG5hZjRCczUvRU53ckQ1U0lBb2ljSCs4bDdMcHh4Nk1hei8rRGwvOW9iL2hmZjhBd1ZxOFlhZkRJczJtL0MvU2JId2hhbFc0RWlLMTFjajZpNXVwa1BmOTJQU3FsSjJpaVl4VGNtZm9INEwvQU9Eb0g5bEg5c0hTN1BSZjJodmd0ZDZTdWVmN2EwU3k4YmFOYm4xeTBhemovZ05zYSs0dkJ2eCsvWlYvNEtSL3M1YXQ4Si9BbnhJK0h1cmVGL0ZXZ3krSHo0ZjBQVUlkSjFHenNwSXpGc2dzSEVjME93SDVCNU8xU0J3UmtWL0l4SHA5eGY4QW50YjI4MC8yZU16VEdPTXY1VVlJQmRzZmRVRWdFbmdaSFBJcXF3V1ZsNFZ0cDRKL2gvd3JOcUQzWDNGWG1yV2UzZlUvWkw5cFgvZzBGK01IZ0c4dTdyNFRmRTd3ZDQyc2N2SW1tK0liT1RRTlF3U1NzYWxmTnQzSUdCdVo0VlBYYW80cjgvZjJtdjhBZ2xaKzBmOEFzcUM2dVBpSjhEL0hXazJOb2hNbXM2ZFpuVTlNaFVjWk4zYUdTQmZvemc0N2NWM1gvQk12L2dxNSswYit6biswRjRIMFh3dDhSdkduaUh3OWNhbkRheWVFZFQxS1RVdE8xR0VuNXJlT0djdXNMT28yaDR0akFrWVlkYS9vby80S3EvOEFCWHI0Yy84QUJJL3dwNGV2dkZ1bmVJL0VtdWVMN3U1dHRFMGJSZktXZWRMY0laNTVaWkdWWW9rRXNTNXd6TTBpaFZJRHNoN3lTNVphZVk0MUUzYVVmdVA1SGJyWFlkWXZKcHQxdkhKSTVjcEdpeG91VG5BVUFCUjdBWUdLL2ZUL0FJTmFmQW1sL3M0L3NDL0dENDZlSVBMaTB5TXllYk5nWlcxMDIya3ZydDBiKzZ5VDJ5RWRuczJCNVd0aGYrQ3NYL0JNdi9ncFZkN2ZqQjRCMFh3cjRpdm1WSkx2eGg0Uit5WFVybi9xS2FhMGo3ZjlxV1dNZW9GZmZmaHY0R2ZBL3dEYW0vWUc4UWZCL3dDRCt0K0RZL2hWclhoNjg4T1F0NEN2N2E3dDlKaXVvNUZkMThsbUhtRnBYa2J6U1dkeXhja3N4TDVwOHIwKzRPYW01Slg2OVZZL2t1OFFmRVBVZmlyNGk4U2VMOWF1UE8xenhucTkzcm1vUGsvdko3aVpwcEQrTE9ldnFQZXZXdjhBZ254KzNCYS9zRytQdkVYaXlQdy9kYS9ybXNXVnJva1BsM0l0ZnMybk5md1hHbytYTVAza04xSkRiSkZCUEhob1dsYVFFTWk1K292MmovOEFnMVYvYXArQjA5MWNlQno0SitMMml4U01ZRjBqVWhwbXBDSWRHa3RydnkwRGY3RVUweDdaTmZCWHg2L1o0K0pYN0xXcy93Qm4vRS80YitOdkFGNU14amkvdHpTSjdOSnlPcGllUlFzZ3gvRWhJN2ppdDZlSXAyU1g0aEtuTis4L3cxL0l5UGp4Y2FiZGZHanhaTm8zaWZWL0cya3o2eGRTV1hpRFZvcEk5UTF1QXlzWTdtNFdRbHhNNkZXY01TUXhQSjYxOXcvOEd5djdPdytPZi9CVFh3dnFGeGEvYUxId1h2OEFFVndHR1YyV2FtU05oL3RKZnZwWi93Q0IxK2VSdUk3b0JvNUZrOWdhL2V6L0FJTkh2Z3RhZkMzNEYvRjM0eGE4a2RycDhNY0dsSmRTRGExcEdrYmFqcURaNmJHdGpwRDUvd0NtWnJOYUp5N0lpcGVWb3JxejQ3LzRPVXZqeC93dmYvZ3I1NHEwbUdaWnRLK0V2aDJ3OE1RRkpNeHRPeWZiTGo2TXMxMjhUZEQrNEhwWDU2NkY0TTFiNGllTXRQMFB3L3Btb2Ezcm10WEtXZGhwMWhidGNYVjdQSWRxUlJ4b0N6c3pFQUFBbXV6K0tQeGl2UDJndmlwOFF2aVJxVzZIVXZpSjRrdjlkblFuY0l6Y1R5VEJQb3U4Z2RzTHdLNlg5Z1h4ejRiK0hIN1I4bXQrSXZFMm4rRDNzL0RldVcraDZ0Zld0MWNXZGxxOXpwbHhaMlVzMzJXR2FaRmlsdUJPSFNKOE5BdVJ6a2JRcDJwUlQ2NmxWSmU4MnR0djBQQjFZRWR0dU1naXZXdjJJL2pOOFJQZ1IrMFg0YjFiNFY2M3JXaCtMUmVMOWpUVGJ1V0FhaktBU2x2S3FFQ1pKR0FReHVHVjkyMHF3SkI4eDhWZUhvL0NQaVRVZExpMUhUZFlpMHU1a3RZNy9UM2Q3UzlWSEtDV0ZuVkhhTnNibExJcElJSlVkSysxL3dEZzNML1o1WDlvai9ncXA4TzQ3bUQ3UnBmaGE5SGlDOTR5WWhaSzk3Qy8rNmJpMmdpYlBINzhEdldWTnRTdVJWdHl0SDcwL3dEQmEvOEE0TEgybi9CSS93Q0czaE5yUHdyYStOdkhuankvdWJYU2RNbXZXczdPQ0cyUkd1YnFWbFZuS3Ewc0NMR05wYnpHTzRiQ0crTWZoLzhBOEhhL3dQOEEyZ3ZDN2VGLzJodmdIcVVHbDNXMktkTFpiUHhacEV1ZUdlUzJ1a2haRjYvS29tT081cjVML3dDRG9uNC9MOGFQK0NzVW5oZTNtZVRUZmhENFN0TkprajNmdXhlM1c2OW1kZjhBYTh1NWdSdit1R08ySy9NWFdFVVN1M3loZVRub0FLZE9tblQ1bXVwVW84c2tvdlZMYy9vT2ovWXIvd0NDVHY4QXdWR3UvTjhDK0pQQ1hnUHhScWtvVllOQTEyVHdqcUR1ZjRJdE52MUVEZjhBYkczSTl5TVY5L2ZDci9nbVQ0Ti9aVi80SjYrS3ZnSDhKWnRTOEwySGlUUk5Wc1k5Y3ZwZnRkOUpmWHRvMXNkUW5kUWdra1VlVmdJcXFFaFJWQ2dDdjVCL2kvOEFETmZoYjQyZlFaLzdaVy90TE8wZlU3YlZ0R2swbTYwKzhrdDQ1WjdWNEpXTDRpa2RrRWpiZk1DaHdxaGdLOW8vWVA4QStDalB4eC9ZNCtLUGgxdmgxOFEvR05scHRuZUxOSjRjR3BTejZQcUVhNWFTS1N5WXRDMjVBeTVDYmhuS2xXd3d6alJnL2RXbDlQSWNxMVNQdnZXMnZuL3dUMkQ0NGY4QUJIWDlxejlpM1NtMDN4TjhEdkUvaWJRZExNa2NldmVDd05mdEpvMUpQbmxJTjBzU2RXek1zWjlRdGVGZkI3NDZhVjhMUEYrdFR4eHdEVnIzUWRYOE9HRFV6Sll6YWMxL1pUV01zb3p4NWlSenlBS2NnNVBRNEkvcUwvNEtxLzhBQldMd2ovd1NhK0JHZytLdkZtZzZsNGk4VGVLcjcremRGOE9hYmR4d3lYTTZ4ZVpjTzh6NUVkdkNDcXRJcU8yNldJYk1NV1g0algvZ3ZmOEFzRS84RkU3YUhTLzJnZmhRdWo2bExINUJ2UEZIaGFEWElZQ2VNUVgxb0h2SS93RGVFVVdQWEhOYlVzUlh0WldrdHUzNWY1QTFTMGswMTE3L0FQRGZlZms3L3dBRWUvQm45b2Z0VStEdFRqVVNTMnQ5ZExkTWNFeHI5a2ZhUG9jL3ovRDZFL2FvOEszV3NlRHYybDc2MVF5ejI3elM3U3VjSkdWSmJqMFZDZndyemY4QTRJOGZDNmJ3VCsyVGF0YjMwbHpaM21tM1puZ2VQK0pJeVVmT01jRWtmUWtWOWVlSC9EcWVIdkZmeEtmV0xIN1pZYTE5cUVzV2NMT2tyTXVPbm8zTmZ5WHhMbThJY1hUeExhY1lVcWI3YWM4cFcrOVc5TEhOT0tsVFRYVy82SDRzYUQ0Wm04VWE5YXd1czBqWEVpcklHSEs1UFQ4dTNYSnhYNlgvQVBCT3Y5bXFiNFpmQlRXUEcwOXUwV3VmRWJVNXJlMExSa0ZOUGljcEdBQU1nUEpsajIyb09vcXYrengvd1RjOEdyNHR0Wk4xOWViWnQyK1diTzNubklBR1QyL3p6OVkvdHU2VmNmQy80SmVIQjRaMDFQc09qc2xrMGNVako1RUpYQy9kNTZqazk4MTlCeE54dERNb3h3ZUN1b3lhV3VpZHRiZW1pKzZ3Vm9PVkoyMzArNjU2ZjhJdkRGdjRJK0NMV2NPMXBMaTVJbGNTQjJMS280SitwUEI2WnJrUGlnbVlrWG9NSElBNDYxci9BTE13Sy9zeitFNDJnOG1hNkV0MjZFNUlNalp6bnFUakhYNlZSOGFSZmJkWkVJK2JMYmRnR2NuTmZ6RlhvdFk3RlY1ejV1V1ZyK2FzbjkyeDN6cHYzSWVTS2ErSElMYnd2cDQreXh2ZnJ2bGprZGVZTncya3I2RWpJejF3U0t5ZFF0TFBTSXkwa3A4NWgvQ01sajZkUHcveHJzZmlQcTF2NFQwcUszMjdybU9KVjJBOG5QYXZEUEgrdm5SOUMxRHhGcmw5L1ptaTZldTY0bUlPMEtlQXFnSDVtUFFBWkpKd0srbnlxbjdLbFRwMU5aeTE1VnZkdmI1czhiRkoxS3piZWkwKzR6UEUrcUhYYnk2UG1RMnVuV1lhU2U1dUpCSEJiUnJrc3pNVHRVQURKSjQ0NXI1dThVZjhGWnZocjRHOFJhaG9lbDZCci9pRFQ3ZVh5bjFlemxpaFM5SUozZVVqYytYNk1TTjJlZ0hYeVA4QWJLL2JOdlBqTllYWGhyUzRadE44R000VnRORGVYZGFudENzSnAzVS9LdWNGWWhrREh6WjRKK1Y1L0RNRFdFMTNwcHVKR3RHelBDL3pzc2VDZCtBQVFvSUlicUJ1VGtad1A2STRKOFBhRWFYMXJObDc3MWpGUFNQcTF2TDhGNXZhOE80UzBXeCtrbmd2L2dxSjhGZGR1clNQVXJmeHJvc2wwcFlQUHBTWEVhTXBQeTVoa2R5Zm9uOFE2ZGEzdFovNEtzZnMrZUZZTjBOeDRyMXlYL25qWTZHWTJRaitFbWQ0Z09uYk9NL1d2ejk4SStFVnZ2aFpjYWxIRzBsM3BiYnJhWVhDd3gvdllKZDBpczR4aUtSRURZNy9BTVhLZzhIcEh3OWt2OWVodFJjcGNRdGg1WmtCNmM1VWJzREpJMmpubGlCMXI2eXB3WGxPSWxKMUhOS082NXRQeXY4QWlhMDhQR3EzYStub2ZwUjhML2pmb2Y3V09uWFhqVFJkSmJTZnM5NjFqZGFiTGRMY1hGdUZBTWNqNEFBRWluSUdNWkRBRnNHdm9iOW55T0R3M1A4QTJkZktKTk8xcUo0OW03T053S2xUNkhERWZRMStWdjdOUHhKdGYyWHZpZHFHc1d1dFcrb1h5eGZaN3ZUZCsyeXZZVGgzUVNwdVYyQUEyc1NoUndUZzQ1L1NENEsvSER3cjhjL0I4Ti80VnZEUHRSSkx1d2wvZDZobzdra2JKWStvTzRFYnhsV0hRODRyOGY0NDRYcVpmaWZhNGVMZUdlejE5enFrL0pQWjlkanRuUmNZcEg1NS93REJRdjhBWlB1UDJWZmpEcUZrMXdKTGJYajUralQ3VkgyMnpZbmNUakdKbFpTSk9NWmJqaGhXbC93UnEwMlM3LzRLSCtCWkk3ZU5vN2UyMVdTVnR1NGovaVYzZURrK2h3YzEra254MS9aVjBIOXUzNExTZURmRU0wT2xlSnROTFhYaDNXV1hjMW5jWXhodTdSUGdLNmQ4S2VDb3I1TS80SS9mc3llS1BnTiszMzR6MEx4aHBiYVpyWGcvdzNlTk5HV3lBWlpiYTNTUkhIREs2U3VWWWRRRDZrVitrOFA4WFU4ZmtsYkM0aVgrMFFnMUpQN1VYb3B4N3A2WDdTOVVjZUtyV29TYjNzL3lQMFArT3FOZjZmNGJReHFyU0puSTZkaWZwME5lRS9zeC9zdHorTy8rQ2xIakR4eHJtbHRkNmY0TUZqcHVtcEtwVlpiaVN5Z2RXemtmS29hVnlCMVdJak9UeDlOZkYzd3Mwa3VpSysxWS9JVnVSbkF3M2Jqbi9EdlhwL3dwOEZ3K0RyeldMejdMYjIvMnE2ODk1QXVHbGs4cU5DekVqTzFValZWQU8wZk54a21zK0RaUmxpSlFodEZmcWp6c2ppK2QzN2ZxanJaN0pMYTJzOVB0MVl4MklUYVpmbTRDK1dNazlXNUpKNzgrdGVUZnQzNm0ybmZzNCtJVEhDdHhKSWJlQ09KbHlybHJxSURPTWRpRDI2WnlBTTE2Zm9rczE1ZjNGd3JNc0tia1ZUMCtVL2UvWEE5aFhrLzdYbGkzaXpTUENQaHVBRXQ0ZzhUNmRDNHlSbU5KZk5icDFIeUx4bkdCNlpyOUxveXZOTStsbEgzZFQ3YzhFZnUvRDlrcmJ0eXdScVNlNTJpdWdqaldkU2tpcXl0d1ZJNFlHczNSN2RZck5WVmNLcElISGF0YTJqd2E2WjJrdVY3RUhHK0l2aEU5dGQvMmw0ZmthMXVvMjNtQUg1WC9BTjMwK2xhSGc3NHhSL2JWMDNXMSt3M3luYnZaY0t4OS9UNjlLNitGZG52V2Q0citIK20rTmJmYmR4QlpsKzdNZ3c2L2ozcjgweGZCZUt5ekV5ekxoV1NweWs3em95L2hWUFJmOHU1ZWEwN29jcWlhc3pwN1pnd3oxRERyVjJGczQ5YThyMHVQeEg4S0pBbUpOYTBOZlEvdllSN2Y0ZEs3N3dwNHkwL3hkYStaWlhDc3dIelJuaVJQcVA2MTlSa25GTkRHeitxMTR1amlGdlRuby9XTDJuSCs5SDUyTStWclUzbDVYOEttQTVxR003UlV5Y3RYMVFEbEdGcDFCNlVLTS84QTFxYXQxQU1ZRkFCYXBBTW1qSFBRL2xUMEF6OVcwSzExbU1yY1FySjZIb3cvR3VMOFRmRE9XQXZKYUQ3UW45eitJVjZFNjVGUnN1Ulh5dkVIQnVXWnhCckV3dFArZU9rdnY2L081U2swZUY2dDRLanVUdGtVd3pkQWNZSXJsZGI4T1hlbGY5TkY2QmxyNksxdlI3ZlVvOFRRby9ZTmpuODY1WFZmQzF2YkQ5emphUDRINXorTmZoWEVIaE5qY0xDVTZiOXJCZFZwSkx6ajF0NU4rZ1BWKzdvZVNlSFBIbDFweFdHN1pwb1FBQUcrOHRkWll6UmE1SkY1TGVaR1pCdUE2Z0RrNUh2ZzgwenhMOE1ZdFFWcElWOGlRYzdlZ1B2WEhOYWFoNFV1VHVXU05rUERBNHdmYXZHNGQ0MnpyaHljY1BpVTYySDdOdTZYYUxlcTlIcDZGUnFPS3N6MU9Sd1NSeC9uL0dvbWZKOVIxK2xjeG9QeElTZGR0NE1kQjVpOXZxUDYxMFMzRWR4RUpJM1dTTnZ1bGVRd3IrbWVIT0xNdHp1ajdYQXp1K3NYcEplcTdlYXV2TXp0WWJQSnRIWGpQRlF2eVBtN0huQW9rY2NxRHlwN2RhakRxejk5MmNjNDYvOEE2NitsQWNaY2JmdSt4Rk5SZ0QxN1orbitmOEthWnRuM1R4amdEOEtidTNEayt2R0tBSjF4dDdaeG5JUFQyL3o3VXF5Zkx1NUlJUEZRbC9MSDN1LytmOCs5TSswYmd1Q3VEM3htdEFMcXpiUG02SEhHS3p0WThMNlpya3ZtWFZqQkpKbkprQ2JaTSt1OWNIOWU5UEY0b1hzeHo5M3VhejQvRkZyZFdjZHhiM0VGeGJTQWxKSVpBNnlEb1NHQklQSUk0N2oycHFUV3d5R1h3RC9aNytacCtxWDFyeUNJcGlMaUlmVE9HSDRzYVB0bmlEU1dPYldIVW8xNUJ0cFBtQXgvZGJBL0luNjRxT2J4cERIS3FOSkd1NDdOekg1Um5nRSsxZmxEOFhQK0NoM2ozOXI3L2drbjhaSjVOU3V0QitNM3dMOFRRSFYzMHdteXVObHZxQ3ZIY2hJeUJHeXhDNEJVWlV5YWU3WXdjRGVOVnY0dFJPTmo5V1Q4YWJIUzUxRjhadE5rYmhWdUVNSko5aWNmb2ErWnYrQ25QN1YzaHY4QVlsK0M2L0hQUWZoMzRDOFgrTTlKMXV3c1h2N3ZTNHY3UWl0Ymgyam1NZDRxaWFKMlVlV3I3aWdhUmR5c3ZCbC9ZVi9iRUg3YzM3SC9BSVI4ZUJyZHRUMU8xTm5ydHJHQVk3WFU0RDVkeW16SkNxekR6VVUvOHM1by9XdkpmK0NtbndWSHhaL1pZOGZlRkZzSTRaOVowcVI3SXd1MEtQZFFzdHhiZ3FwMjh6UlI5czlhS2txVnJ0YWxRakszdXMrSlArQzRuaTdTZjJ6L0FOdEw0SDNVbml6VXRNK0Qvamp3YnB1cjZaci9BTm1OMWIrSElyNjhlMmx1SllDNktOc3YyVDdRQXdjQUtwK1pGV3ZHL3dCb2ovZzNqK08vd2h1TGlUdy9KNFQrSVZuQzUycnA5K0xHOENEcXp3M094TThZMnh5T2M5TTF6ZndMR3VmdEsvRHZ3WjhQN0hUOVExOWRCdjdpMXNiZXpzWnIyUzEwTHhEQzBkNUlzY0tzOGlhZGZ4R1VmSmdTRW5qR0svUmI0QWY4Rmp2aGw4S1AyTS9CYS9HZlhwSS9pQnArbnlhUmU2VHAxdkpxV3A2aE5aVHkyVDNBMmZ1djNoZ0w3NUpJMVptYkJPQ1FleFV0WXl0L1gvQnNaeHFKZkdqOFJmaVA4R1BHdndOMXRiYnhoNFU4UWVHWjJabzFYVTdDVzNXWS93Q3l6QUs0NDZxU0t6ZkNmZ3ZXUEUwZDlMcCtqNm5xbG5wclF2ZlBiVzd5SmJMTEtzVVprWURFWWVSMFJTMkFXZFIxSUZmZlA3YkgvQmFYdzk4YzlIdXREOE9mQi9TYjdTV3ZJN3VLZnh2ZU5mZ1BIaG81VXNMWXh4SXl0L0JOTmNvd3lHVWhpdGVLZnM0L3RBNlo0cDhVZkRud244U3RkOFJ4L0IrZWJVTERVdExzdFdtdGROMFhWTG9YQnRkWkZsQXlSS2JhNHVJSnNLaER4Mld6YXdHdzR4aStyQ1ZyNkgzcjhhdkMvd0FOZkVuN0FmZ0g5bVB3aDQvMUx4TjQ4dGRMc2Y4QWhKZEgrR3VnUytOdFVrbExtOXY0b3hhdWxvVDl2ZHMrYmR4NFZYSkRjQ3ZrNzlxcjlqblIvd0JoUzYrRzJqK0p2ZzlySGd1NDhaNm5CZldtdGVNL0VjR3RhbkxiMjl4Q0xpTjdTMTh1eHNvbUVxbDRibUc4a0c3QmtBelg3Si84RTUvK0NrdjdQL3c0L3dDQ2NYZ1BYdkVuaXo0Vi9DSzZ0ckJkUDhVYU5iSmE2VElkWHQzYTJ1SkJZMnloNW1sa2lhYmRGRzVLdVNUdzJQeCsvd0NDL3dCL3dVdjhMLzhBQlJuOXBYUVYrSGNkM2NmRDc0ZTJFOWpwK28zVnM5dE5yVjFQSXIzTnlzVGdQSENWaWdSRmRRNTh0bllMdkNKY200enZaVy9yK3RnNWxLT3Uvd0RYOWJua2Z4dStMWGlmeDc0czhlNlQ0eThxYlZkRkkwYlRwVGJ3UjIwUXNKTHFSWXJlM2pWWVk0eWhtOHRiYUpJa01wT0F6cTFlRTJHc015cW9QeUtQbFRvbzY5aDBySzFieHJxR29hb3QzY1hyWEYxYkdJSktjbG1NS3FrWlBHU1FxS010emlrMGVGMDArTmlHSHpGbERER1Y0eCtmTkZTcGNtTWJiSDJOL3dBRXlQRVM2NzQwMXZ3dVpvWUdraVRVN2VSbE9XVkdFY3E0NzQzeE1QVERIdWEvWHovZ2s1K3hmNGQvWnMrTWZ4UitNY2swTmpEcW5oeUczYk9GU0paWlBPdkppb0h5Z0xZV3B6azVMU2NEa3QvUGI4S2ZpRnJud3o4YzJPdWFEcVVtbDZwYlpTRzRUSEc1ZHVHQnlDdk9DRDJ5Sy9TWHhyL3dYeTBueE4vd1R4OFhlQjdYd2pydWgvRVR4RjRadWRCa2x0cFk1ZEtDWElFTTB5dVhXV01pTXNWWFl4RFlHOGpEVjFyRUtXSDltOTBZU2kxVzV1alB6ZjhBMmt2alZkZnRJZnRFK1BQaUJlZWFManhwcjE3ck94emt3cE5Nenh4L1JFS3FCMkNpdU9EYy93QjczRlY0eHNRRHNCZ2MxTkdhNFk5amQ2a3E0QzU5T3RQRFpYbjhhais2S2N6SGJtcUs1bWROOEovak40dytBbmlYKzJ2QXZpenhMNEsxZ0FEN2JvV3FUYWJjRWVoZUZsSkhYZzVGZmNYN092OEF3YzdmdFdmQXNRMit0ZUl2RFh4UzAyRUtua2VMTklWcmdLT0RpNnRXZ21aaVA0cEdrNTZnOUsvUFJ2OEFnVkFPRFQ1MmxZemNVK2grOWZ3MS93Q0RyMzRJZnRGZUZsOE0vdEEvQTNWTGJTN2pDVEpESGFlTE5IWWtZTHRiWEt4T2kreXJLdzk2NmZTZjJJLytDVmYvQUFVdDFOWnZBdXYrRmZDWGlLK2tBK3g2QjRpbjhKMzByWis0bW5YNEVmdCs1Z3h6d2VocitlNE1RQlNqRWlGV1ZYWHJoaHVwY3NKUFZmZG9WRnpTc245K3FQNjZmMmsvK0NibWw2NS93UzI4VWZzMS9DYzIvZ0hTNzd3M0xwR2hOUEpMSkhHN1MvYUNaNUR1a1paNWQvblNZWmlKcENGUEMxL09UKzByL3dBRVhmMnB2MlVqY1NlSmZndjRxMURSYlpueHF2aHRWOFFXUWlHY083Mmhkb2xJN3lwR2ZWUlhuWDdPSC9CUjM0Ny9BTElodDQvaHo4WFBIZmhXeHRXM3Bwa09xdlBwWlB2WlRiN1p2eGpOZmZQN04vOEF3ZDFmSFA0Y05iMi94RzhFK0JmaVhhd2o1cnExMytIZFVrUHFaWVJKYjU2ZExaYUhIVzhKZmVnakpwV2xHL296OG5aSGpXNWtoWm1qdUl5VWVPUlNqb3c0SUlQSUk5S2JKRjlUMit0ZjBGUS84RjAvMkFmK0NpdG9sbDhmdmhiSDRmMWFhTVJ2ZStMUENrV3JMQ1RqSWgxS3hEM2NZLzJpa1g0Vkt2OEF3YnFmc0wvdDR4TnJId0crS21vNldOcXU5cDRQOFhXdmlDMXR3ZWYzbHRjZWJjeE43UEt1UDd0UytkYnI3dFN1ZW05TDI5VEYvd0NEVDc0UjZaOEVQMlMvaTE4YWZFbXl4MDNjTFdXNmY3OXBiV3NCdjcyUWY3RDI3NmMzMWhOZmhwOFdQaWZxWHgxK0ovaXp4N3JBVWF2NDYxeSs4UVhvQnlCTmRUdk8rTTlnemtmbFg5Vm54RS80SnRyOEovOEFna1I0MC9adStETjVjUTMxOTRTMUhSdE92dGJ1Rk54cVYxY3EvbXRjeXFxcURLck5DQ0ZDeFJtTlFBc1lGZnpHZnRML0FMRVB4aS9ZN25tdC9pZDhLZkhmZ216dDVQSWl2OVEweDIwK1lqb0k3eU1HM2s3Y3h5TU0wK2FQUHJwcG9FWXZsdXU1M24vQk92NDdlQS8yZGRCOGVYdmk2N2drUHhCdU5LK0hlcDJIa05KY1IrRnRRZTRrMXkrajQyckpDbHRaS2h5RzN6Z2dZVTF4WC9CUS93QU02TDhNZjJqVitIdWd5YURkV1B3dDBMVFBDVnpxR2xLaGcxWFVvTFpaTlR1Zk5VZnZ0Mm96M2dXUnNueWtpWE9GQUhpNGtodVUzUnlSc3ZYcjFxRjdjTDhvRzBZNEhwVnlzMVltMXY2L3J5UHVqL2czQi9aeS93Q0dnUDhBZ3F0NERsdUxVWFdsK0M1ajRrdTNDN3ZzN1dpdGMyNzg5bXVJWUlqN1QrNHJ1ZjhBZzZsL2FGLzRYUDhBOEZVN3p3dmJ6TkpZZkNudzNaYUh0QitRM1U2bSttWWY3UUZ6RkdmZUhIYXZyZjhBNE5BL2dKYStFdmg3OFcvakZxL2wyMW9GajBHM3ZuRzFZWXNpNXZWWW4rNHR0WlNlZ1dhdnh0L2FjK05OMSsxSiswWDhTUGliZUxJay93QVFQRTEvcm9qZGlmSWpudUpKSTRoazlFUXFnSFlLQlNsRzhsSHNyaERaeTc2SGxjMHUwODQ2NCt0WC9CdmpMV1BoejRtdHRhOFBhdHFtZ2F4WlB2dDcvVGJ1UzB1cmR2VkpZeUhVKzROZlpmOEF3U3NzL0J1bDZONHUwblVQRTNoVFNmR0h4azBYeFA0SWp1ZFp1Rmp0ZkNlangrRzcyNnVOUXVXSVBsZWZldHB5UnVvTG1LenYwQVBtS0Q1di93QUZMUEQzZ0h3NzRsK0VVZnc1OE9EdzM0Zm0rSE5wT3Ztd0xGZjZ3RzFQVS9zK28zdTBrRzd1Yk1Xc3NtQ1ZVdHNUNUVRVW5DVVZ6Q3Vub2UvZjhFL2YrRGliOXFiNEcvRjd3bnBldWZFRFZ2aWw0UGU5aWkxRFJ2RTBTYW5kWEZ0bjk3NVY0MkxwWkJHR0treXNvSUJaSEFLbitoei9BSUtOL3dEQlJmNFEvd0RCT1Q0Tnc2cjhZcjI2bTB2eEpkdnBWaG9GcHB3MUs4MTF3QTBxSmJzUkd5SXBCa2FSbFFia1hKWjBWdjVuL3dEZ2dSK3pndjdUSC9CVkg0VjZYY1ErZHB1aTZySHJsNEdUZkdZN01OZU5HNDZiSkV0cElqbmcrWUIzcjZqL0FPRHJ6NCtuNHUvOEZLOUI4QlF6aWJUL0FJUytFb2pkUmRmSzFEVVdGeklmcWJZMkovNERWZkVveGZYOHY2UXFjYlNiajB0OS93RFRQcmVHMi80SkgvOEFCVFMram1lRDRlL0Qvd0FUWFM1OHRqYy9EKzVSeWVtUDNWaE5JVC9kTXBPUnptdnZ6Uy8rQ2ZIdzc4Sy84RTN2RW53RitFTWR2NE44RCtMUERHcTZKWTZsWnp0cU9IMUczbGlrdlhtWnkxdzVNdTRuZnlvQ0tWUlZDL3lGYUg0SDFYNGdlSzlQMFBRZEwxRFc5YTFtNmpzckRUckMyZTV1cjZlUnRrY1VVU0F0Skl6RUJWVUVra1lGZXErSC9Hbng3LzRKdjY5WXllSC9BQnY0bitGK3JhbnVtZlQ5QThZUkpjTDViTGxiMnl0YmhtaUpKR0k3dU5kK0d3cmJXd3BVb3E2V2hYTlV1bmUvci9tZTdmdEZmOEc5L3dDMS93RHNxTGRidmhUTjhRdkQ5aTJJdFQ4RVhTNndKMTY1VzFYRjZBUDlxQmZxYStMdkZtbjNYZy94RGNhVHIrbTZwb0dzV3JiTGl5MUswZTF1SVc5R1J3R1UvVVYrb1A3RC93RHdkUy90RmZEcjRqK0g5SitLTS9odjRuK0U3aThqZzFHYTYwbU94MWlHQW5EUERQYUNPTXVxOC92WW56amtqTzRmdWwvd1VVK0pIN09md3MrQ0ExLzlwcTMrSDF4NEtGMGxsYi84SlpvU2F3WnJod3hXS0MzTVVzelM3VlpzUklXVUt6SEFVa1BtcVJTMVRYOWYxc0VaUmVqVFQrOWYxOHorTnVhM0VzZTZObGNZNmcxKzVYL0JuYit6dkhwRmw4V2ZpN3FTcGIyOE5wRjRkdEx4anRWVW1tRTk0cEo2YkJZMmovU2F2VXJYL2dqaC93QUV6UDhBZ3BaZFF6ZkIzeDVZK0Z0ZXZ5WlJwL2czeGdMZStrSi92YVhxU3l5eGovWlNLTVY5dC9EMy9nbDFvSDdKUC9CTmJ4cCt6NzhIOVUxYlNyanhKb21yV2tXdmE1UDlvdkpkUXZyVnJjWGx3MGFJUDNhK1NnRWFLRmpoUUFFZ2t4S2JpbmVObllJeGhPVVVwYVgxUDViUDJpL2pqY2Z0VC90Ri9GTDRwWEJtOHo0aWVLYi9BRmUzUi92UTI4azdtR0w2SkdWUWV5MTU3NFUrSG11ZkZEeFJIb25oN1NyN1d0V3VrbWxpdExXTXlTeUpEQzgwckJmN3FReHlPVDJWR05lOGZ0RS84RXlQMmp2MkpMRzZ0UGlGOEUvSFZsb2VsNVp0ZDB1ME9yYVFFQndITjNiaDRWejF3N0szUEtnOVBJZmgxOFJmQittYUQ0cXQ5UThPNmQ0azFYVzlMT25hVmNhaGR5d3hhQks3cjVsMmtDQWVmT0l3eVJCM0NSbVF1VWtLb0Y3YWNxY3FhaEI3SW1wektmTkpiczRXL3ZKdFV1M3VyaWVhNm11RDVyelN5R1NTVW4rSm1PU1NmVTgxOWRmOEVHdjJjaCswdC93VkorRk9qM0VDeWFmcCt0UmF0ZGwxM1JpT3pWNzUwY2YzWllyU2FMNnlBZDYrVzlRMEloTnkvTXAvaVhvMytjViswSC9CbmIrelY5citLL3hLK0pkMUR0T2o2VEZvOW83cDhzalhzLzMxYis5R3RoY0tjZHJuME5aeWc0dm1JcWF4c2VkLzhIYUh4NWI0di84QUJSL3dYOE83ZWNUMkh3cThKZmJMcEIveXcxRFU1UE9rQit0ckZZdCtOZms3cTJuc2JubFFxNTc5aFgwNSsydjhhdjhBaHI3OXZINDQvRktPNCsyV0hpenhmZVE2UE5nbnpOTnRtK3oyZVA4QXQzaWhHZmIwNHJ5YndwOEd0ZCtLdmp2VGZEUGhuUjc3WHZFT3MzSzJtbjZmWXhHV2U2bGJIeXFCMjRMRmlRRlVGaVFBU05hRkg5eW0rdXYzbDFwZnZISHRwOTJoOW8vc3ArTzVmZ2hyV3JlTlBzU0dIU2RNbnNyVWREUGN6cHRpVEdjSEhMTVJ5RlUxOVVmQW5RZkVuakQ5bXZUZFMxNjEzNmhlV09ZN2t0dWVlREo4dHBPT0hJd2UvR0srVWYySjlHOGJmdEl2SjUzZ3ZSZEo4SzJ0d1k1ZFJ1ZFRhRVR5N2Y4QVYyOFpCODJRY1p3Y0RKQlBhdjBzOEY2c2RFOE5XK2pYMmx0RGEydHN0cW0wZFVSUUIwOUJpdjRoNDZsR2xPVk9TaXEwcmEzVHNvcDJWMWRidHRyejlESEJ4bFpON2Y1bmhId2kwbi9oRzllajh5UmZORGZkUFlkUDgvNFY3bDQvK0dWdjhjdmhmNGk4TjNFMDF1TlUwOTF0SjRtS3lXODZqZEZJcHo5NE1CWG52alB3VzJpK0pmdEVDL3VtYmVqWTRJTmV5ZkJxUmJ2U0EzL0xaZVJ4K244Ni9QTVZubUlyWVYxcU9sU2xhUytUVjErRmp1alRTbnl2Wm5EZkM3VGIvd0FOZkNqd3pZYW94YlVMSFM0WTdwZ29YOTRFRzdnQUFjZzF6OEJOMTR1WmlGYll4WVlKeHhYclh4UzAwNmJOTlA4QXdUSjV5RUx3MmY4QUErbnJYbFhoNS9zVjNxRjl0VnZzZHJKTGduZ2tLY1Y4emhhdFRGcjJlenF6Y3Y4QXdKLzhFNks4clZlZnNqaFBGMnAzbW82bmNheHFkdkxMQzdrVzhDU0FQTnp3QVdJQ3JqR1QyR2V2ZjVJL2JVK0JIeE8rT2QydC9wdXNYVTJtUXhQR21qeDNLeHJZc2NsWm9rM1lZakFWZ2ZtSzU1d1NCOUVOcU0zalBYcHByaG11RWprL2ZUTWNLQXBBTWNRNmNjalBSZmM1QnMrVk83K1hiMnNjZTFzSVNtOHFCNmx1TW5IWUFmVHBYN2h3elJlWFYxakkyYys3U3Q4cjdldi9BQXg4WldydHl2OEFPeCtYZXRmc2hlT1BDdW94TjR3MCs0bXQybThsUDdQdHBXTi9MODJFOHdoVVhKQTZZSjNZR09vOGtzN1pQQlBpRkxqV3JXYUpvYnR2T2p0bjh1V05TZHJLTVlJeHp3Y1k2SHVLL1kzeE44TTczVWJYeVp2TldPUU14YVNRcUFmb1B4NEdPUFRwWHluKzNENFI4UDhBaC93L0NtcjZ4RE5OY1JOYnBha2dUT0RuaFJqY2V1Y1lyOWl5WGpoNGlzcUZTS2JsWldqZlQwU1JyUngxL2Q1ZCt4OFgzbnhaZngzNFdnOEwrWERvT2t0T1o1UExKbDgrUm4rVGV4KzZxWlk4WVVuSEF3TVkra2VEZFdzOVNqZzNTV3NPVzhpV1Q1b04vVWJ6eUJrQSsrYTUrNGgyYWI1VUtUdTBjempwOThjWUpIYkh2MHppdlZQaHo4TzljdVBocnBPdU5HdDFwc2wzTThtMlZBeVFSNFV5TUNkeEFiZXYzVGhjbis2UitrMStURHc5eXlUZXo3dlg3MzVuMVdFb3grR0s4LzhBaHpsZkQrbXpEd2xkWHRvbGlsN1orZEpKTEl5aHJaQW1VQ0FqNTJmSjJubnB4empCOElQamY0bytCL3hGc3ZHT2gzMHphdnBzbVhsbnpJczZ2bmZGTHo4eU9vSUlQc1JnZ0VWcDdpMDEzN2ZIRkpORkkwZm5JclNneG5hd1VBRURyZ2tEUFhqcG1zYTB1N1cwaFpWVS92NHNQazUydHdlaCtucjM2MXBMRHdyVTUwNjBWSlMwYWEwYWExVDdyY0o3cEo2SDdSZnNlL3RrZUVQMndvcmV6MFYvN0Q4WVdkbXQ3ZGFGTys2WlZ3QzBzRDlKSWdXeGo3eTl4Z2duNms4SjZCcHV2ZUl2N1N2TE8zdHZHRFdDYVgvYUJYYWJ5MFdYekJFemV6Y2pQMHpYODdPa2ZFbHZCdXUyZDFwZDNxMmlYbGpGbTMxSFRwakhmUXk1emtPTUVMMEcwRURBeG5rc2YzSS80Sk1mR0x4VCsyZCt5V3ZpRHhsYzJ1b2FyYTZ4SnBOcnFOdmJtQjdwWTdlM2tNampBeSsrWmtKVlFQazZ0bk5mZ0hFM0FWVEpKckg1ZEoreXY4TCtLRGZTTCsxRi93QXIxWG16aXhsT2s0TlRlajNQb1g0aDJNa3ZqL1NiUGJ1aGpqaWpaWFhKUHlvQ1B6Ykgvd0NxdTM4WWFnMzJnVzhiTDVrejdBTVp3QWZicGdEQUhIZmppdUxranVmQy9pYTNYVXJkdFNqMDg3bGxoSkw3UWY0aDNIeTlmYnJXOXBUcnF1cVRhcTBpelc2aGlvVS9keVJ3UjFIUDlhOXpnWE5NTzhSVmhWZkpVbGEwWHBmZmErLzUrUm5sdEZVNVMxTnhWK3dXTU5xbzh2YUFuQXh0OVIxNm5yK0hhdkk3R1dUNGpmOEFCUWY0ZTZMRHpENFhzYnZXYndrbjVIZFFrWVhIWGNxVEtjOFlPTUhkWHFtb2FncGprazNLbTBicEIySEhIQjlDRGs5T0NmU3ZPZjhBZ2xqNFZtK0tYeGgrS1B4Y3VKVm5zOVp2WTlDMFJneFpUWjIyUnZYMDNrQndSOTRTZzlNVit0NGZmbVBVbGQ2SDNQWVJiSUZYUEczTmFjRWZiOGFyVzhIVDhzVmRnajJBQ3V0YW1SUEJIdVg5UlZoRTUvM2pUSTQrbit6MXFhRk1tdERCazFzaXV2UFAxNzFnK0lQaGZiNnBlTGZXTTBtbDZsR2R3bWg0REgvYUhwWFJScmhxbWpIM2Z3cnpjMHlmQjVqUzlsaklLU1dxZXpUN3hrck9MODAweW96YWVoRDRXYlV2N1AyNm1zUDJpTmlvZUw3c283Tmp0OUsyRjRZVlhnYkZUUm5qL2Rydnd0SDJWS05QbWNySzEyN3QrcjZ2ekd5YjYwOVB1OFZFalpGU0kyQjcxdUE1Qm4vOVZPMi81eFFXK241MFovem1xR05LMUdldjRlbFNQeVA1MUd4K2I4S0VoRk8vNFN1WDhRVENOVDlmV3VpMVY5cVZ4dmlTOHczV3NaN0ZVOVhZeTIxK1d6NGI5NUdPTnJkdm9hdExwMXY0a3RWWWJSNXd6NWNuWDhEWE42bmROS3l4cC9ySkNFVVo3bnAvT3QvSWdRUnJuWkdBb0E5QnhYeTJhY0k1Zm1sM1dqYVhkYVA1OUdhVlVqa3ZHSHdwa2huYVMxenVYblllRGoyTmN4cDJ0Nmg0VHY4QXkyTExGL0ZHd09QZlArSXIxSmRja2lpOHMvdkZ4eHVIT1ByVlRXTExTL0VkbnNtVlZadjczOURYNGxuM2h0bTJVVi83UXltVDkzVk9MZC9tdC9YZGR6T09oajZSNHJ0ZGVnWGEzbHlZSDdzK3YreWU0K2xXek1vUE83UGZtdVY4Uy9EVzQwdjU3Tm0yNXlwSDg2cDZkNDZ1TlBrVzIxQWJncDJpWHVQci9qWDFuQ3ZqQlQ1bzRIaUpLblUyVTE4TC93QVMrejY3ZWdTdDBPeWFUNWpudnhrNHdhaWE2M1AxSCtOY3ZxZmpCYmZKT09uQkhjZXZIK05mSmY4QXdWLytOdmpMNFkvc2JYdmpmd0RxMTFwL2lUNGY2M3AzaUlMRE15eDMwRVUvbHpRVElwQWtoWlpkMGlQbFNpTjNBSS9jcWRhRTBwUWQwOW10UTVYYlErd1ArRm42SlA0cnZ0Q3Q5VzA2YlhOTnQ0cnU3MDZPNFZybTJobExDT1I0ODdsVmlyWUpHT0tqdnZHc2NUYmR3NjhWK1RQN1ZIN2RHbmZEYjl1WDltbjlwYlI3NmFENGQvRkh3My93aS9pV0l5ZnVyUzFsZFpnMHVQNDRXblZpUDcybXNQV3YwcTFEU3JpOWdtaWR0c3FrZzRQUTlQME5iU3Vsb0VWM1BtbjR3ZjhBQlFieEIrejkvd0FGYi9CbmdMeEJmZWQ4TS9pdDRZaXR0T2hrWmZLc3RYam1uVmZMT0FRMHBSWW5VazdqZDI1SENBVjQzL3dSVi9hRTFMd1Y4VmZqWCt6WnIxOUpjM1h3NThRWHVxZUhHZGRvZlQydWpGT3FEb0k5NzI4NnFPOTVJZTFlZS84QUJlMzRMK0pmRTN3NDhGK0tOQmcxSzc4VmVDZGVSOU9hd1JwTGtwY0ZBVEdpQXMwaXp3MnJEQTR3YThQMDc0eXY4TXYrQ2pud2gvYVF0TlY4T3gyZmpiVGROLzRTUFJMYldyZVRWaUxpeWUzdXNXU3VabGpTRkVkWkpGUkdaWTJVbnRwVGZOcDh2OGdxUlVOZm1mc3g0N2gxS0xTSHVMVnQzeWt1Zy9pL2wvbjlQeDE4UlhNM3dQOEErQ3dQanp3UEtrMXg0Wi9hUzBxZlQ3NnhpVjJOeE5mcElDZGc1TWpYYXpxQ08xMDNyaXZUUDJrditEbmUxYUc0c2ZoTDhPV3ZBZUl0VzhXM0JqamJ0a1dkcys0OFpJSnVGNUl5dlVWK2ZIeG0vd0NDa2Z4WS9hQzhYMnQvNHk4U0xmNmJhM1J2VTBlMHNiZXowMXBQTGtpVm50NDFWWmlxVFNKbWJleFNTUmQySGJLOW5hVzRuVnVySSs2UCtDVUg3V21uL3dEQkt3ZkVUd2o4WHJxVFR0RnVOTHRQRUlzdE4yNnRjYWJxTWR5K25QSExCYnM3VzhsMUVsdElSYytYdEt4QTdSSkdXYisxei93Y29wNDl0YnJTL2hyOExiVVdEL0ttcGVNcGpKSXluL3B6dFhBUmg2bTRjSHVwSEZmbGxEcXNmaHA5VHM3ZTRGNXA5eVRBQ01wNTZnbnk1U1BZNGJhZStPNEJGT0Z2TUh0MEhQV3RIVXNrbC9tWlhhNm4yUit3RDhYTFA5b2Y5cXZSZitGdzZQcE9vZkMvVUx5eDhNYTFaNlBaUitIOVBzbzdtUzdrc2thRFRoQVRDYjRxemxnd1lzZk1MTTZrL3B0NFArRlg3TWVoZnQ3L0FCQStCUHhPK0Z2ZyswOEQvRXpROUU4UWVBVjFIUzQ3ZVBUcmdzMWhlV2RsZXdNSmJWWjV6RktnaWxSUzVZL2VjRi93VDhOM3VvYVUxOUJZdGVOL2ExcWJXV08ya0tOTGlSSm8rbjN0czBVVDdlcEtER0RnMTlPZkgvOEE0S1YvRVQ5dkw0eGVBNXRjOFEyL2hmOEFzT0diUjVOU3ViYUtIVDlEZ3ZvWTRieHNLalNiRldFeXFDWGszcVRHb2JhdFRkVzFLanBxYVA4QXdXci9BT0NiRnQvd1RKL2JGYndmb3VwWG1xK0RQRStrUmVJL0RjOTZ3YTdndFpKcFlYdHAyQUN2SkZOQkl1OVFONkdOaUZMRlI4Y05OSnAwNnNHa2oya01KRU9DQ09SZytvcjdaLzRMa2Y4QUJTWFR2K0Ntdjdic25pend4WjNkbjRIOEphVkg0YThOdGVSK1hjMzF2SE5OUEpkeXBraEdtbW5jaGVDc2F4QmdHRFY4Z2FkcXQxcFFtK3p6UEVMcUpvWmdPa2lOMVVnOVJVTFFHZFY0L3dEajdyWHhvMHJWRzE3eTlXMURVUEVWejRtdWRYZTFTQzZsdnIyT1A3V0cyZkxza2VFUHRBSHpEZGhjbGE0M3pXOHZrbkhiUFkwcFJRNmxSdHh4dEF4elNCUG0vVUgxb0pIenp4M1Z1a2NrTnJ0aEc3ZUlFRGtmN1RZQk9QYy95RmZxL3dEc1FmOEFCcVY4VVAya2ZoUG8vakw0a2VQdEwrRXR2NGhzb3IrdzBYK3huMWpXSTRIVUdNM01abGdqdDJaQ3JDUHpIZFF3VjFqWUZCK1V0dTMyT2FPWVJKTjVMcko1YmpLeTRPZHA5ajAvR3Y3VnZncDhZdE4vYUQrRGZoTHgvbzVoYlNmR3VqV2V1VzNsVENaSTF1WVVsOHZlTUJpaFlvVGdjcVJnSElvNWRMbEtWaitlWC9nb04vd2JEZkZMOWpUNFU2dDQrOEcrTE5KK0xYaGZ3OWJ2ZTZ2YjIybXk2WHJGamJvTjBsd3RzWkpVbWlSUVdmWkw1aXFDd1JsREVmbXRxTTcydDMrNi9lUjNRU1pTQm5KT2VuWCtJT1BYSEhyWDl1RmpGR1pFYTQyZlo5d01nY1pVcjN5TzR4bml2NU1QMnlmK0NYZnhkL1oxK0Urb2ZGalhQaG5yM2d2NFozWGlxWFROSWJWaEZiM2lXMTA4MGxxSHN5MzJpRkZTSGJ1bVJGTFNxRnlUVXhmTEt6Wm8vZWpmc2ZJTXFwRGRTUkJodVU4QW5uSEJCL0VFVk5HaHgvT3YyMi80TjBmaEI4RC9BTnZmOWtqeHA4TGZpdDhOUEEvakRXdkFlcHJxT25YdDlwNkxxWjB5L3dCeE1hWGNlMjRVUjNVVTdmSzR4OXBqR0J4bjJ6OW9UL2cwcStBL3hDV2U0K0hmaXp4NThNYjZUL1Z3Tk1tdWFYRjF4aUtmWmNmbmNuZ2V0YXlqS0QxV2hsSGxsMVA1NEZqd296K2VLUmt3RFg2YmZ0Qy84R3FYN1Nud29rbnVQQk41NEYrS3VueG5NY2RqcUkwalVtWDFhRzgyUWcreXp1ZlN2aFA0Ky9zamZGTDlseTlhSDRsZkRmeHY0RzJ2NVNUNnhvODBGcktmK21jNVh5cEI3b3hCcGM4ZHYrQVg3Tm5tWlREL0FPelJ0NHorT01WTEhHc2lCa1pHVnVoRFVodGlwNk5WV0lzUm1oZXY2VTd5T0I2SDlLTnVQbS9HZ1dvM09QOEFkeDBweGt6L0FIcUNQLzErdE5LY2Z5L2xRR281WmVmeHhWclROWXVORTFTMzFDeXVMaXp2clZ0OE56YnlHS2FGaDBaWFVobFB1Q0RWUUwxK3RJelVYdHFQeVo5aWZzNC84Rjh2MnNmMllrdDdiU1BqQnIzaVBTb0NNNmQ0dGpqMStGMUg4QWt1UTF4R3Z0RktsZmZmN09YL0FBZVA2Z2tNV25mR0w0TTJkOWJ6ZnU3dlVmQm1wdER1VTlUOWd2QzZ2OURjcVA2Zmg1Skp3ZjVWRzl4UTZsOUhxUnlMcG9mME9INDkvd0RCSi84QTRLZW5kNG4wUHdQOFB2RkdvWmtaOVcwMlh3UGZwSXcrKzk1YU1sbksvd0QxMG1rQkk1QnJtZmlqL3dBR2cvd3IrTHVqUStJZmdoOGVOZTA3UTczOTVBZFR0TFh4UHA4Nm4vbmxkMnIyL3dBbzdaRWg5VDNyOENWdWlEWFlmQm45b0x4eCt6eDRrL3Rmd0I0eThWK0I5VU9OMTE0ZjFhZlRaWHgyWm9YVXNQWTVIdFU4dFBwcDZmNUZjMCtydjYvNW45U0dsLzhBQk5qV1AyTC9BUGdpL3dERUg0RS9DYlVKdkZuampVZkNlcndwcWMwU2FmSnJlcFhWb1lHS0p1S3dueVZqaGpET2NlWEdYY3NXYy95Ly9FajRmYTE4Q05lazhLK05QRGZpWHdYcmxnVEc5bHIrbHk2ZGNnQW5CTVVneVAxSHVldGZjWDdPUC9CMHIrMWI4RWxodDlmMXp3cDhWTk9qd3ZsZUt0R1Zia0tNWnhjMlpna0xFZnhTK1p5U1NEMHI3aStIUC9CMkI4Q2Yya2ZDYStHUDJndmdicTFucGx6aFpvNDRiUHhkb3o1NFozZ3VWaGtRZGVGamxPTzVyU0tsR1hOQnArb0thdHl5VDlWL2wvd3grQnR6WlIzYU41YlJ5SndlRG1xK3BQY1hqeHRjVFRUdEhFc0tHU1F1VVJSaFVHYzRWUUFBT2dBd0svb1RIN0JIL0JLLy9ncDVlYnZoNzRyOE9lQS9GR3BTZkxCNFo4UXllRjlSZHY3aWFacVNHTDJ4RGI0OUQwcnhqOW9qL2d6UzhaNlZjUE44S1BqWDRkMWkzbGJkSFllTk5LbjAyU05QK3ZtMUZ3SkQ3K1NnK2xSSnRmRkZvcGNzdmhmK1paLzRNM3YyY2Z0UGpqNHFmRks4aDhwZFAweURRck9hUWZKSWJxZG1ZZzlBMFFzWkFlKzI3SFkxK1puN2EzN1FyZnRYZnRqZkdYNHBmYUpMaXo4YStMTDJiVFpEeXk2Zkc1anMwK2kyNnhML0FNQUZmME5mczBmOEU5L0Yvd0R3UzYvNElxL0VyNGYrR3JxMzhZZkYyKzhNYTVxenphSERKNU54ckV1bW1DM2l0QTZySzRRUXc3U3lxMGtwZHRxZVp0WCtZTzFudDlIc0YwYWR2c3Q5cHNqUVR3enEwTWlTQmlHQlZ3Q3BCSFFnRVk1QVBGYTBtblY5RVNvdFF2M2Y1ZjhBRGtEM0RXbDJzME0wME0wTGlTT1NOeWp4T3B5R1VqbFNDQVFSeURXMThadmpCckh4MzhZZjhKRjRnVFRaTmVtdG80TlExQzJ0RnQ1dFpsVXRtOHV0dnl5WGJnZ1NUQUJwU2dlVGRLMGtqNlBnandwNFIxUHdyNHd2dkUzaVMvMG5VZE4wMVg4TzZaWmFjMXpKcnQ5SktxaFhsNGl0N2VKTjhranNTN1lSSTBZc3pKd2x5Tmc1L3dEcjFwVnZzd2p2YytuL0FQZ2kvd0RzNGo5cXIvZ3BkOExQQ2MxdXR6cHphc2w3cUVUTDhrdHBDZk51a1BvVGJMT1I3clgzbi93ZHQvSHB2aWIrM0I4TS9obERPSnROK0h2aFc0OFIzOGF1ZHEzdW96RkZSbC92TERhMjdnK2s1eGpKcVA4QTRNN3YyZC8rRXIvYUwrSTN4SG50MWxoOEs2T21uMnBjY3gzVjIvbHd5b2ZYeVk5UmpQOEF2VjhWL3dEQlNmNCtyKzFIL3dBRklQMmdQaUJEY1IzVmhxWGlxYlJ0S21RNVdheXNBdG5idXZzOFVFYmZWalVVNDgxU01mbi9BRitBb3ZTVS9SZjErSjh4YWpwUDJ6VTRZWWxYN1JKS0VqTHlMSDg1YkF5ekVLdkpISklBSFU0Qk5mUm53dy80S2hmdGJmOEFCUG54ZmUrRk5MK0tmeEU4TVhuaHVkcks2OE82OUlOU3RiRmw2eC9aTDFaWW8vVUZGR1FReW5CQnJ3ZlRkZWc4TytLclBVTG5TOU4xNkd6bUVyNmZxZm5mWmIwRCtDWHlKWXBTaDQ0U1JTY0FaeHdiZjdRWDdRM2lIOW9YVXREdU5laTBPM2g4TTZYSG9lazIybDZaRlpSV1ZsR3p0SEFDbzh5VlVMc0ZNenlNcTRRRUtvVWJWTHJaaTVWTGRINnkvc1cvOEhmdnhHdC9pQm9PaC9HYndENFExclJiKzdoczdyWGZEWm4wdlVMUkhZS1oyZ1pwWXBtR2M3RUVJUHF2V3YxZC9ibi9BR0tmMlJmaTE4Tzcvd0FaZkh6d1Q4SDdmUTVsak4xNHIxbnlkQ3VENW1QTEIxR040Wjl6NUcxZk55U2NBWnIrWEQvZ21OK3pxZjJzL3dCdm40WWVBcEkzbXM5ZDF5Mmh2MVFaa1cwTWlyTzYrOGNiUEo3Q01udFg2bWY4SGhQN1Frbmkvd0NPbndWK0RWamNPbG5vZW0zdmpmVmJWVy9kUEpOSWJTejNEcHVqVzN1OGM5TGcrb3p6Vkl4bHlxMnJZVStaVGx5dXlTUFRQRVAvQUFheS9zdC90YmFMY2VKUDJjL2pycm1pV2NyZzUwblZyUHhsbzFzRGtoQXF1a3cvN2FYREd2dUQ5akQvQUlKanpmOEFCT1gvQUlKNStNUGhYOE8vRlUzaUh4MXJ0anFWMG5pVFVyWmJGWjlXbXMvczlzNnhJWEVFRVJqaHdtNXlENWprbG5OZnlxK0hQRU90ZkRYeEhEcm1nNjFxV2g2dFlqTUYvWlhMMjF4Yjk4cklwREo2NUJIOHErL3ZCbi9CYWI5dWIvZ243cWVrNlg0NDF2VzlTdGJxM04xYWFiOFF0TS90RDdaR3JGSDNYTEVYZTVIR3g0eGNLOGJEREtweUsxbGhYYmxVdCs1U3FUdXBOSjIxN2YxOTU4a2VQZmd0NDIvWWNNSGhQNHVmRDd4djhPNzIybGVCSjlYMG1TTzB2WFVuTFFUak1VeS9ldzhiTXBCeUd4elZMUmRYdE5Sa2t1ZEIxbjk1TkZMQzcyZHlZNVRGTEcwVXNaMmtOdGVOMlJsNk1ybFNDQ1FmMlIvWlUvNE96dkR2eGExZlRmQi94citGTnZwV242N0ttbjN1cTZOZWZiTlB4S1FoYVd3dUZKOGtaeTM3K1FoZjRXSXdmc2Y5cHY4QTRJSy9zYy90TDZOY2Exckh3cjhNK0VaNUlEY2pYL0NWd2ZEdmtLdzNlZmlBcmJObklPNldKZ2M1clg2eFdwSktjVTE1YWY1bWZMU2xLeWJUODlmNi9FL0dmd1I0Z2srSG43UFhoM1NYdDVtdXRKdUxtQ0VTRERCUktXNUs4WkJaaGtZenQ3ZEtyK1AvQU5yTHgxNExUVFo5RDhSZUl0TnMzancva1RDVHlTdUNHMk9ySXk0SkJVcWVuR0R6V2Y0VjhaZUhmSC9oMjQ4TzJPdksrcWFrL24yTm5Ld21rQWpVdElGY0VrRWdBN1c1SlE5NlBCdnd2MVQ0c2E1WitGYlN5a2sxSzV1Rml0L0xKOHlKajFmUE9BdWNuUEdBZTNGZnlGWDVJVjNWeHNVOVcycExTenZyWjlFN25CR1V0b3ZWOXU1OU8vc0cvdENlTlAyb1kvRUdsK0piZUhXckxTWW81N1RYcmF4UzBSbWJob0pZMUp4SjNHTUFpdnAvNFZSLzJMZXRESnVYZ3BnSHJYTS9EandEcG43TXZ3NDBud25vNnd5M0ZtQTE1TkRFRmEvdW14dmtJSGNuZ2VncnFZSHQ5WnRwTC9UNTdkN2l6bEVON0RDKzgyc3ZERkRqb2NFY1YrSlk3R1lXcG1kWEU0ZWtvMFphSkxaMnN1YTNTL2JUZmJjOStuNzBlUzk1UjNmOWRqcC9paEQvQUd0NEl1RmpIN3l6K1pjajVpdmNmMS9Ddm4veGc5eHBId244WFhWdXArMFI2UmN5cmpxQ0FvQi9VMTlLZUVuajFqeXZOeEpIT3V4d3c0NUdQOC9TdktmaTc4T281ZkJ2amJ3eHA4MGNPcDNHalgxckV4VTVnYVNNK1VUNnJuQjQ1R085Y21TNFp6emVOT1h3eGQvSlJzMm45NU9JamVpNWVWajUzK0JuZ3c2dDRBMEs0RzVtbHNvOHV3NUl3RG5wNm1qNG9mdEdlQi9nMXFOcm9yM3gxZnhQcXQ1OWpzOU8wOVJjM3Nsd0ZCMkZGSjh2QzRKYVFxcWprc281cnovOXE3NDlTL3NTL3NFYUhkUVM0OFEzbW4ybWlhZFBqRzJjd2dQTmprL0pIRzdBSCtJS0QxTmZQZjhBd1NnOEcydmlENFplSi9HRnpZemZiYmpXWmJQVHIrNmZmTlBJOENmYXBOeDVEWWNMdUdjaVZ4bnJYN3pnY25XSXdkWE5zVTM3R0V1U0NXbk85cjNleXYyVjk5ckh5OE1KR1hQT2I5MlA0czlLL2FDK01Qakx4UjRhdkpQM25oMnpYQzRFMitXUW4rRWJmbHgweU1zT3VLK0tmMmgvRE11aGFQWUtseGJ6YTk0akVrMXpkMzl5STNodFJ3RVVzZU43YnVCMmpQSE5mY0g3VU5nMDM5bitINFZDdGNTS1hqVTQ2a2RQekZmQi93QzBycTF4OFR2MmpiN1F0TFZiZTUwT1U2RmJ5VDdCR2JlM3lIWVB5UnVtKzBObnJoa0hZMTk1d0xHRXF0NlNVWXhWMytTdjEzdTkraDJaZmgrYVY0cXh3T2dYTDZETzBzZHZIY1cxcVlsZVBMSkhPMlYyNzJ4bG93RG41c0tjY2puRmVnWG5oZC9CM3dZMVMxdWY3UXQ1OUsxRXdYRnBmenBMSERMdmtqeEZ4amE2S0dEQUFFcVFNZ2JqcmZCdjRKNld2Zy9XOVM4U1gybHlXZHZJMHR0RkJOc2Y5MEFaUkpOZ3FBcXNnOHNEY1M3RWxRT2MzNDFlT1k5UzhUWFBoRzBzN2pWaExCRzhyUlRsVE1zVVRTTDVRNmZNR2xjQWpKVmtBR1FLKytyWWoyOWRVcVN2WjNiOGxidnAxZjRIMWxPaXFWUG1rL0plcDVCUDRvMCt6QnQxMCt4M2NGcG9ZUS96WUdmdlk2RUQyeVd4d2FwYW5xRnZmMzBWeFpxelhHQTAzMmhBUE5ZSHY4eEhQNGZTcEpOSHRkVjhHWG1wUnVzTjVwOXhGQ2JaU1Aza1Q3ajVuVExFRVlKSFQ1ZU9wSHNIN0ZIN0RldWZ0UGVLSU5RdVZmVFBDZHJNb3VMdHp0YTV5ZjhBVnhqcWM5TWdmU3ZmbE9sU2k1eWRyZm1lYjcwbWtVLzJSLzJPdGMvYTgrSmNOcFl3eTJmaHUwbHplWDB3UGx4SUdIeWJ4MVBJSEhQdG5pdjZHUDJHZmd2cHY3UC9BTUQvQUFyNGYwMjNqczdLM1dXK0NjQTRCR1NjZHlJd2ZiNjE0LzhBc3Qvc3U2UjhHdkNWalk2ZHBzT20yc1F4QmFpTUNWMk9jRnhuQmZCeVNUZ1pJd0RsajloV25oeVBUTENWSkFvYTF0STdMSFlNMkZZanAvdCsyQjByNERqU3U1MEtjWmRaWHQ1Slhmek9ITXJLS2gzZjVGRHdacFhtNnZxMm9DUldrajA4b0NXN3lLVjQ3N3R4SE5jdGNXRnZhZUpJNHJOWTdOWXNCNWVpa0R1Mzk3MDljK2xkL0ZGL1lmdzN2cm1PTm81OVV1bzRJbVljSU1tUmpqMjJqZ2R6ampQSG0zaUpyZlIvTXVMcVJSYXdwNTA3Y1pDZ2phUGNrL3lybXlmSmNQaThwVU1SQlBuYmE3clhScDdwOW1qYkw0cmtiZmM4VC80S0kvR2U1OEMvQzgrRmZDYk4vd0FKVjhRcmxkRDBxS01abFJwZ1JKSUJ3ZjNjSWtrK3FLUDRoWDIxK3g1K3ozYS9zMi9zK2VHZkNOckdxdHBObWkzQkhPNllnR1RudUFmbEJQTzFGcjRwL3dDQ2QvdzBuL2JaL2EwMUw0MzZ0YnlONFI4SE0rbWVFSTVNN2JoemhudVY5bStSeC9zcGJua013cjlNTEt6OHVKVjR3UHdyNzdEMGZaVTQwNzN0MzMrWjF5ZW5xTnQ0Y0RQTlc0YmZpbndXdTBWWWpqNTk2NjRveVlrY2ZQNjFMRkZsNmVrUWJyVDFYQi9XcU1RQitiL1BGU29OdE0yWVhuK1ZDUDhBTGo4S0FMVVRZRlNvMlQ2YzFYVitNaW54di9Qbk5WRTBMU3RqL1BXcE03VFZkSDRwNGt3TTlxb0N3SDUrOW44YVhmbjEvR29kK2UvNlVGOXZjZmxWYUEreEl6KzlSVFRZSi94cGp6REZVYisvVlZPRFJ6QVU5YnZOcUhucHoxcnozeFBxdWJodVJXNTRzOFNMYlJ2ODMvMTY4VitJWHhlMHZ3N3JHbTJlb2FoRFozV3VYSnM3Q09Rbk4xTUVhVFlweGpkdFJpTTljWUdUeFhMV2xwWTFveDF1enNkQnVmdC9pS1ArSmJkR2xiK1EvVWcvaFc3ZGFncFBCSDlLOEcrR243VE9rNnA4YmZGL2dOa3VMYlh0RDAyeTFnR1VqWmZXYzdTeG1TTHZpT1ZOamY3VEo2MTF1cmVQZkpXUjl6TEh6eUtxajdzRTMxQ2QzS3gwbDU4U05La20xcTN0YjIzMUhVTkFBVy9zYlNkSmJxMmthTHpZNDNRSEt1NkVGQTJOd0lJNE5jRjhILzJtdEIvYUorRC9BSWY4YmVHWnBwTkc4UjJwdVlGbUFTYUFxN1J5UlNLcFlMSkhJam93REVCa09DUnlmajc0My9INlQ5bWYvZ3B6NFQxdjdUSkQ0ZCtOMmd0NGIxREgrcmkxclQyV1d4dUc1QjN5UVNOYmdkL2ZGY3Avd1REK0pDL0RqOXBENDYvQWVaaEhZNkZyaitOUEMwWTRWZE4xRW84c0tEL25uRE0wUTQ2dE85ZGlzNDNSRnJQVS9RTi9qUGNhQXpxWkVhSWN0SEw4eXNPZnkvQ3ZHdmd0L3dBRkVQQlB4dDhUZkVydzM0cTBTNDhLK0p2aGpyVGFmZngyN20rUzd0SkkvT3RMK01Lb2tWWjRnekJOckZTcEdXNEo3RHhYbzl2ZmFaODdiU0JqSitYSGV2ejErT2ZncTQvWjEvNEtkYUY0b3ZyNjAwWFFmaVg0WXV0UDFTVzluRWFyTllBVFEzVEtNeUZSRVBMOHdLVkFWaG5OZkc1OXdIaytlWGpqYUNjbmYzbzZPL20xdjh4dmxWbmMvUmY0YytML0FBMzhjdkFrUGliNGVlS05DOGRlRjdvc0lidlNidGJoTnd4dVVnZk1qcmtBcXdETDBJN1Y1ciswbjhGZitGby9EcnhCb1pXU2F4MXl3dUxDOXRDZjNqUnl4dEc0VVkrWWxXWWV0Zm1qK3pCL3dVRThFLzhBQkxLOStMdW0rSDlXYjRrZUROYThSUjZ0NGZmUXRzY1ZoZVRSbno0RDgyR2pTTkxkZCsrTXNJMXdvYktydWZENy9nNkIxWFV2aU41ZmovNFgyRjk0TG4rVXk2VmRsZGJzc243NnMrSXBWeC95emZEZjlOVDByODdqNGZjVThLSjF1RjhYOVlvYnZEMXZ4NUpyNFgyV2lmVzRvVmxzMGZQQ2ZDNjVzLzJCUEdId2IrTG5pRFMvaG5ySHcyOFh3M0doVGVKa3VvZDhVNnZMKzd0NFlwYm1WSFNTNWtVeHhNQ0xsV0pBNXIzbHYrRGlyVXZndCt6dDRIOE1hZjRGL3dDRW84ZjJQaHV5aDFUV3RYMUlKcDhrNnhLdm1DS0hNdHdXVVpjbVNIRWhmRzVkckgzRDRoL0duOWhIL2dxenBjbW42LzR5MDN3ejRnZHhKRmQ2NEc4TWFyR3lxeUkzMmxzMjArRmRnRWtkL3ZmZEJyai9BQWYvQU1HeFhoclZmaXJwbC9ySHhUMXJ4UjhLYmlJMnlUNk8xcGFhcHA0d1BLZjdRVXVMZTRpVThNQXNUWWZjQ2R1eHZ1c2g4UmNQaUdzTG1tR3E0U3U3TGxxUmJpM3Q3czBuRnJ0ZXdwUjVuN3IvQUVaK2QvN1NmL0JXVDQ5ZnRORzhoMXZ4N3FPa2FSZUJvNU5KOE8vOFNtemtpWVlNVW5ra1N6cGc5SjVKSzhMMUg0Z1QzbXE2ZHFpVHp4NnBZMnFXanVRQ0pralFSSU1qQjIrU2ZMeDJWRlhwMC9SYi9nc0ovd0FHNlhpYi9nbmQ4UExqNGxlQmZFVjU4UVBoYmFTb21xZmE3WllOWDhOZVk0UkhuQ2Z1NTRDN0lubklFS3M2aG8xQkRIOHp6NGZ1cnVWRnQvTGtaMkVZVXVxc0NUaitMSEhQWG9PK0svUlBhTm1mTFljdDUvYUY3TElJNDQvTVl5RkU0VmNub1BZWndLdWFiNFd2dkZPcVc5anBkbmVhaHFGeWNRMjFyQTgwMHA5RlJRV2I2QVZWMG5TcHJacEZlTU5PNEN4SUhCeWMrM0hQK2UyZjdBZitDWlgvQUFUVzhEZjhFdy9nQnBmaFh3dnBkaWZHRTFuRC93QUpaNG44aGY3UTE2KzJnekV5L2ZXM1dUY0lvQWRxSUFjTTVkM2wzR3JkVCtRRHhONE0xendScXphWHJHajZqcGVvRmQ1dDd5MGVHYmFlaDJzQVIzN2NFSHVLbWp0bWdpalYvTDh4UmhqSGphZnhIQjZqbjFGZjFVLzhIQTM3Rm5oUDlybi9BSUp2L0VYeEJyT24yZjhBd21Yd3QwTzY4VmVIOWNNZittV2YyUkRQY1czbWZlYUdlRkpFTVpKWGVZM3h1alVqK1dGTEJpZHUzYzVQK2VLbU4rb05MZEZaSWo5TnZIb2MxTmNYTTl5ek5KSkpLMGgzc3pNU1MzcVQzK3Z2VC9KM0E3MWJkNkhqRkw1UHk1K1g1ZXVPZnpxZ3N5QUtDaWpIdm4xcDVoeEdHT1c2WUhwL24vUHRjdGRPa3ZieUdGWTJrdXJxUVJ3UXFDMGs3a2dCVlVjc3hKQXhqSk5mYW43SnYvQnZoKzFQKzFkSGEzdHI4TzVQQW1nVGtGZFc4YnpOb2NXMGpPOWJka2E4ZFR4Z3BibFQ2K2hzTlJiUjhSdzJMTWNzckxqbnBXbG9IaFc0MS9WTGZUN08xdUx6VUwyUllyZTN0ME1zMDc5QXFJb0xNeHowVUUxKy93Qit5bC93YU4vREh3T2xyZmZHUDRnZUl2aURmUjdXazByUVUvc1RTOGpxanlrdmN5ci9BTFNOYm5ucG12MG4vWnAvWW4rRWY3SEdsZlpmaGQ4T3ZDZmdqY25seVhXbldRKzMzSzlNVFhiN3JpWC9BTGFTTlFQM1Vmemcvc3BmOEc1WDdVSDdUSXRieVR3T1Bodm9kd29KMVB4dE0ybE1xazg3YlBhMTRjOEVaZ0NuKzhPdGZ1bi9BTUVsZitDWmZpWC9BSUpuL0J1NDhJYXQ4WXRiK0lXazNFalhOdm9wMHVPejBuUTVwRzN5bTAzdExjQU94WXNQTVNObVpuOGxYWm1QMTBCeWMwNmpVbHkwdFlhcWhFeDJIU3ZFZitDa2Y3S3EvdHQvc0hmRlg0WHJESE5xWGlqUUpqbzRmZ0xxa0dMbXhPY0hIK2t3d2drYzdTdzcxN2htaFpHaWtWbE8xbE9RZlEwTlhWaFJkbmMvbFQvNElCL3RVSit6Ri93VXg4RExxRjFOcCtoK1BDM2czVmc3bU1wOXNaQmI3dXc4dThqdG1KUFJRM0E1eC9VQXVuM2RxK0Z1RWtBT1FrOGZJUDFIZjhLL2xuLzRMcS9zeVRmc1VmOEFCVnY0bWFUcGF6YVZvL2lTK1h4am9Fa0I4cmJiNmdUY0h5OGRGaHV2dEVJeDAreml2NlNQK0NmMzdWTVA3Ylg3RjN3MytLVWJSZmEvRitpeFhHcEpHTUpCcUVaYUM5akE3S3R6Rk5qL0FHZHA2R3VoVkhLbW4yL3IvTWh4VVp0ZC93Q3Z5UFdFMUc1dGgvcEZteDlXak84SDhCeitsUy9iTEhXTEdlemw4cVMzdUZLVFc4eWhsbFU4RlhROEVIcGdpcks4WVBIdG1pV0NPNUdKSTFrQTZiaG5INTFGMDkwSEs3M1RQbGY5b24vZ2g3K3lyKzFHWkxqWC9nMzRWMG5VNWR4T28rRjBidy9kYm15UzdmWkRISEkyVDFsUjhucm12Zy85b1gvZ3o0OFA2Z3R4Yy9DVDR5NjFvNzRQazZYNHYweVBVSW1ic1B0ZHQ1VG9CN3dTSHA5YS9aVWFSSEgvQUttU2FFazluM0Q4am45TVZLb3ZMWUQ1b1oxeDMvZG4rb3FQWngrenAvWDNHbnRKZGRmNis4L2x5L2FOL3dDRGN6OXJQOW5WSjUxK0hNZnhFMHUzR2Z0dmdxL1hWR2Y2V2pDTzdKK2tCcjR1OGIrQk5ZK0dQaWViUS9FMmphdjRaMXExYmJOcCtyMk10amR4SDBhS1ZWY2ZpTzFmMnhMcWFwL3JvWlkvZGwzTCtZT0t4ZmliOEpQQmZ4LzhNTm8valR3djRZOGFhUElNR3kxelRJTlN0L3dTWldVSDNBbzk5YmEvMS9YUVBhUWU2dC9YOWRUK0tYN0dUMC9FNXpVYldyRDVkdnpOMnIrb0Q5b3IvZzJOL1pSK092blhPaitGOWUrR0dxVEZuKzArRTlXZUdFc2ZXMXVSTmJxby91eEpIMVB0WHdiKzBQOEE4R2dIeEk4TE5QZGZDcjRzZUV2R051dTVsMC94TFp6YUxlRmV5TExEOW9pa2J0bGhFdlBham43cC9tVmFMMmEvSS9HOW9UK1E3Q21QSDEvTE5mVUg3UnYvQUFTQS9hWS9aWVdhYnhwOEZ2R2tXbTJvTFBxZWoybzF2VDFVZnhOUFp0S2tZNy92TnA2Y0ExODBPc1U3c3FTS3pLY012ZEQ2R25GeGV3U2cxdVp0d21NOWFxeUhuL0d0U2V6WUNxczFtd2FwNVdabFhITkhTbm0zSU5KOW5iUDhYNVVnSHd5YldxN0hjWkgzdmZyVktPSTdoVThhc3RWRUM1dlM0aTJTS3JMNk1NMTlTLzhBQk5mL0FJS0dmSFg5bHY0KytEZE8rRy9qcnhkTFl6YWdsdkY0UW0xT2U0MFRXSGNiVnRuczNab3N5TVVqRElva1VzTnJLY0d2bEFuWU8vcFgzUi93YmtmcytIOW9YL2dxNThPVm1nYWZTL0NOeTNpbS9IL1BOTEJEZFFOLzRIUldLSDJscmFFck1tb2s0bjcrL3dEQlhuL2dyNTRIL3dDQ1IzZ2Z3M2VhMTRkMWJ4cDRtOGFYdHhiNkhvVmpkSmFDV0syOHMzRTgxdzZ1SW8wRTBTakNNenRJQUJnT3kvR0Ivd0NDNC84QXdUMy9BT0NqVUMybng5K0ZjZmgzV0xpSVJQZitLdkNjZXFlVm5qYkRxZGdIdTQxNmZNVmlBNzRBcjRUL0FPRHFYOW9zL0dQL0FJS3MzWGhlM25hVFQvaFQ0YnNOQzJoZ1l6ZFhBTi9PNC8yc1hNVWJlOEdPMWZuQzBuQ21zNmNZeWo3eXVWSzhIYUxhUDZBTlMvNE53LzJLUDI4ZEt1dFYvWnQrTkYxb04xNVljVy9odnhMYmVLOVBzU2NFZWRaeXY5clEvd0N6SmNJUjZWOGxmdEdmOEdrbjdTdnd6dXJpVHdENGcrSHZ4VzAxV3hDaVhwMExWR0dlcnhYV0lGNEk0VzRidjE3L0FKY2FmcWx4b3VxVytvV2R4Y1dkOWFNSGh1WUpHaW1nWWRDanFRVkk3RUVZcjY2L1p3LzRMNi90YmZzdytSYjZSOFl0ZThUYVZBeTUwM3hlcWVJSUpGWGdJSkxvTmNScnowaWxUb1BTajJmOHJhSHpTVzZUL0Qrdm1mdUYvd0FFeWYySXZpRC9BTUVnZitDTzN4SU45cDlwcUh4amJSdFo4VnJwZWtOOXVhM3VvYkdSckt4V1JBZlBjU3EwaDJBcUh1V1JTNFVNMzgwUGdyWExXUHdyYldjYzhja3loaklva0FabUpPVHo5YS9hL3dEWXUvNFBCYm54VDQ1MEx3LzhiUGhYcE9tMmVvWEsyOXo0bThKMzhzY2RnRC95MWF3dVBNWmxIVnRseHVBenRSamhUK2lQN2IzL0FBU1IvWTkrTjJoYXg0dCtMM3cxK0hQaDlJU1p0UjhXUTNZOEx2SEpJd1VUVDNjTWtLU096TUFHbjNobUlIT2NWVVpUcHk5cHZmVDdoUmNISGtlblg3LzY4eitWWFJORDBmV0RyWDl0YTkvWUpzOUxudTlQQ2FkSmVmMnBlb1ZFVmw4aEFoRW01eVpueXFCTUVISUZjWGZjSHYxSXdldGZ2RjhYditEUVQ0ZWZGSHcydmlQOW4vNC9heGE2WGR4dk5hUjY1RGIrSXRNdWllZ1M5dERGc1FkTStYS2ZxYStGZjJpLytEWmY5c1Q0RFN5eldmZ1hRdmlocHNTNzJ2ZkJtc3BjdDlCYlhBaHVXUFA4TVI2ZGU1cWVJaTkwMENnMnZkYWY5ZGoyYi9nMEkvWnovd0NGZy90eCtKdmlGY1c1a3RmaC9vYzdXOG9HZkp2TGhmc3FLZmFTQzR1aVBVd0gwcndmL2dzVDhjLytHbXYrQ3VIeDg4VHh5Tkxwdmg3V0Y4RzZkbHNxSTlNalcwa0tIcHRlYUdTUWR2M21hL1hML2doTCt4NzQxLzRKTS84QUJMcjRuZVBQaU40VG4wWHg3Zld0NzRtYlEvTVdhOVd4MDZ6bm50WVpsVElXZDVwTHR0Z0xNcVNRcTJIREtQNTcvQUdzeitJdkQ3Mzk1ZEc4MVBWYnFhOHZwMmJjOGs4cmwyZHZkczUvenplSHRLc3JmWlg1L3dCTW5WVTIzMWY1ZjBoMTFaR2FPUXFvKzZjZHM4ZC9icFhZL3RCL0dtYjRzNmhwV25XY05wcC9nL3duQWJEdzdwdHJwVnZwYVF3aFVXUzRtaWhaaEplWEJpU1M0bmtrbGtrZkdaQ2lScXV2OEdQQy9oRzgxeSsxbnh4ZFJyNFo4T3dMZVM2UkJkK1RxUGlXVXR0aXNMWmhreGlSc3ROY0FZdDRFa1licGpCREx3ZmpEVmpyM2lDKzFGck94c1d2YnFTNU5yWVJHRzF0aEk1WXh3b1MyeU5jN0ZVa2tLQU1tdlJrak5iWE9yL1lyK0NGMSswYisxMThQUEF0cjVubStJOWV0TEFzZ09JTjh5SUpHOUZWbVZqN0ExK3VQL0IydiswSkxhSjhGUGdGbzF4OW4wTy8rMCtMdGQwNkkvTE5hMnUyMjA2TjEvaWk4ejdVZGh5QzBVWndTb3g4eWY4QUJySjhBajhUUCtDa1VuaXE1aFJyUDRmYUpkNmtoS0hhOHJoYmRWSGJjcjNNVWd4L2RyaVArQzRYeDJYOW9uL2dzSjhZTDZHNUZ4cGZnRkxMd0pwL1ErVjlrakQzaUQ2WHJYUDRIM0lyaHFMbXF3Z3ZVMHAvYW0rbWk5WC9BTUMvM0h4MTRLK0o5djhBRVQ0Z3c2RDREMFBXQjRrdnBWaTBlN2ttUG1QSWNibWVPTG1NQlBNSllQaFZYSndNaXYyci9ZMitCOTEreWg4Q3JHODhZYXBhK0l2aU5xVmlvdk5UOHBFK3h3c053aVU0QklBT0N6SGMrTXRqT0I1cCt4UCt3ZDRCK0FFRGVOYmZ3OVlhVGJ3UUJVdmJoRDlvdjFVQTd5WExHT0VZQjJnL09RQ3hQR003OXJIOXA3UmJyUjVkVzhVYTlENGY4RXJJWTQxbGtLWEd2dU9TaUtNc1l4M0NqTGZUcC9FUEYzRWo0cHgwTW95Q2sxUmkvZWs5Wk45bHUwdjdxYXU5N2JLZjNXSHAzaXRYL1g5ZFM3OGN2Mm1aTDk3Mkh3dHFTMk51cFpML0FNUWxkL2w4Y3hXWVAzbngxZkJDOXM4R3ZPdjJMUDJ4N2I0WC9HeGZCME5qZTNHbGVMSlJhd3dsdk9tbXUyZGMzRXJIbkpUY1NjbmpIWHQ4d2ZHLy9ncFQ0UE50NVBoM3czcUdyVzhLcXFUWGR4SFl3cjFBRWFBT3pkVDFDNDVxai93VHAvYWtrOGMvOEZDUGgvSGZlSGRMaHNidTlhQ01XOXg1a2tjaGdmWWQ1SVh0MDJnMTlUTHc3cTRUSThTNVlmUlU1UzFhVGJqRnRiYTZOZHZTeGpsOHExWEVSYTBqZTN5UDI1MHlDYnd0clpUNXZKWnN4bkhTdW04WGVGSU5XYVBXdHY3eG8xaHVNZnhLTTRKOWVwRmN4RHJrSzZqZFdkN01xeHMrSVpIYmFFZlBUOGE2L3dBT1N2TEhKcDl5Mzd1VWJPZWg5RFg4NVpGaUh5ckdxK3FzMTAxM1h5MGFQZnhORmF4Nkg0Ny9BUEJ3VDhQZFFoMXI0VCtHN0tPNnVIay90S1dDMWoyaEpXQnQwSExFY2hSMHdlQ2VtYStrZjJUZjJmditGSGZBRHdmNFpuZ2EzdXZEZWtKL2FFTE9yTWw1S1RQT3JNdkJJbGtaY2pJd3ZCT09mbzc5dUQ5aTNSZjJpcHZBT3U2dXYrbWZEVFhvOWVoOHNBdE1zUXpKQ2Y4QVpmYkVUL3VaN1Z4UGpqVkk5RzhDM2wweEJrdWk3c3pEazk4Ky9iNlpGZnRqNHNoaXNsd21WVWRPUnljdjhUazdmZzM5NTg1akthcDB2WkxlN2Y4QWwrWjRGYytHcmZ4bDhmTFc0a1JHdDdlYmZJVDZMMVkrd3dmeXI4bzllOFJMNFgrTHZpN1Y5ZTBtV3hONXFkOWJSMkVKWDdSYU84KzhwOGhDRGFEdHozQkpYc2EvVFg0dmZHdlJmMmRQZ1Y0azhaYTQxOGY3VUEwU3pGbTZyY3RQY2gxM1JPNEtxOGNZbWx5Umo5MTdpdno1OFA4QWp6d1A0QThTWDNpRFI5WmgxalRiZUM1RmxwV282Y2tkNUpQSXJJanlTTXJDVEdRKzdjV3lBRHppdjF6Z0dqS0dIcTFGQnVNclJWazliWHVyOU4xdnB2cnVlaGdLY1lwTzlyZjFzT2cxN1QvR3Znait3ZEFoMUdHTzZ5MDlzYktOWXJjdXI3bmxtOHhtM2hRQ29ZdGpiL0NGSUhuZmo2V0ovaUhaYWhvOTVjNjFxRVlqTWJSTUpIbm1qTzBFaE04bmFPUDd1QjlQUy9oZjhFL2lQKzFWcU4xZFcrbERTZEJrbmFWMm1Ia1cwS3UrY2tZQmtJT1B2SGs4OThWOXpmc2NmOEUzOUQrRjhLYXBIYjI4MnBOZ1NhdGZXNTVCL3dDZUVNaERsVGpxMjFDT2ZtNHI5RG93OWxKdGI5dDk5N3M5S3BVZFJMOC8rQWZOMzdFZi9CTFRXdkdtb3dhNTRzaXY3V3h2K1k5R1ZjTmNxVnlmT3p3RUJKUFBBeDFKNHI5Ui9nbjhDdEgrRE9tMnU2RzArMFdjQVNPS0ZOa0ZwRm5vdWU0eGd1ZXVDQlhXK0ZmQ1Z2NFA4UG84a2t0cmFuQ3ROY1lhNXVUbmpuanJ4akE2bmhRSzB4NFN0OWR1cG85YW1tdExHM21FZzArMmxSN3lac2N5WFRFbnlnQmppVEI3SGJnQnI1VzVlMHF1Ny9CRXhqcHl4T2srSFhpS3o4Uy9FdlNkSDAwL2JKcG0rMFhjaVpDUVc4WTNzZjhBWkIyN1J1K1lsaGp1UjdWcXU2SFF2TFhtUzh1dCtmWkFRUDhBeDZRbi9nTmNqOEhkSjBsdjdYdmRLMHUyc1k3T3dTMmpraWp4NXU2VEl5M1J6aFd3M0p3M3BYWVNhZEpybmkreXN4L3E3ZFZqd0ZIM3NrdCtySDhxL00rTHNaS3BqVlJYMllwTDFsL3dEdzhjcjFsSHN2ekt2eFF2bzlGOE5hUFl0OHZsUVBkRmM0WjNmQ3JucjJYUC9BdmNDdmkzOW9EVXZFSDdYbnhjcy9nWDREdUYvd0JNa1YvR09wSUcyYWRha2IydDl3UERNcEcvQnlGY0tNTkpHYTlJL2JOL2FGMXp4SjhacHZobjhMbzIxbjRnYXc0dElqQWdraThQVzRYWUxpVWZkTWpLcGFOR0lHQXp0aEVaaDlOL3NHZnNMYVAreHI4TVBzWWsvdGJ4VnEvK2s2M3EwckdTYThtWWxtRzl2bUs3aXhMSEJkbUxFRDVWWDlJeTNDZXhvd3BMN0tTKzdxZWxSaW8wMHVuOWFmNW5vUHdNK0MyamZBcjRaNlQ0WDBHMVcxMHZTSVJERXVBR2ZxV2RzRDd6TVN4N1pQR0FBSzdxMnR0Z3AwVU8wZE1WWlJPTVY3RVkySmxMcU5TS25oTUg4czg5S2tVWk9CVFIvd0RYcWpOeXVPSFduZmRYL3dDdlNBcUY5NlJuL3dBNW9KQW5IMUhGTkxZcGpUWUZSTmNjMEFXdk94VGhQZ0QvQUJxazl6Z1ZHYjdqcit0TW8wMXVzVTc3YVA4QUVacklmVU5vKzhLcnlhMG80M2RQZXI2YWpPaGE5R092U29aTlJDY2JxOFAwbjlyTFRmaUI4VVBpbDhPOUEvZGZFRDRjMnR2S0xPOElJdkJkMmdtdExoRkJCYUV5RVJzUjBJd1NDd0ZZUDdFUDdiR20vdHBmc3BlRC9pTllvdHJOcmxvWXRTdE00YlQ5UWhZeFhVQkI1WGJJckVBODdXWFBXaGQyTFZudWZqajRoV3ZnYndqcTJ1YWcweTJHaTJjMS9jbUtNeVNMRkZHenVWVWNrN1ZQRmVIZkhYOXZmd3I4S2ZCZndyOFdHNHQ3M3dUOFVOYnN0R2gxcno5c2RuOXVnZDdTVWpCRzFwRkN0dVliQnV6a2pGZDlxM2l1M3VMV1NPNlNPNXRaMUtUUXZ5c3FFWVpHOWlDUWZyWDQzZUE5Q3Y4QTRoLzhFOS8ycy8yUHRXbG51UEZId04xdTgxSHdjN3NQdEZ6cC93Qm9PcGFjWXVwM1BORElDdzRDYWhHdkdhbm1YVXBSUDFoK0kvallXOFV5czN6S1N1Q2U5ZkRQL0JWN1dkVTFqOWtMV3ZFSGgyUmw4VWZEcTh0UEdXa3NvKzVMWVRDV1RPRHlQSTg3STcxSCt5NyszZ3Y3VVA3R1BnVHhuZVhzY210YWhwYVd1c3M3NGIrMGJmOEFjM0xONmI1RU1vSFVMTXZibW5lUE5iaWJRRjFMeGkrbitIZkFsMHhqdk5TOFJYY1dsNmZQQ1IrOGpXU2RrV1F1cEs3WTl6SGR3TTF3eWxVZFZLQ2JhWjB4NVZDN1o1SDhjZjJ1TkYwNzRzL3MwL3RFYUZNc1Bodld2K0tQOFJNU0JzMHZWVldXTHptNjdiUzdWcEQ2T1NPK0svUUl5eFBwekxNUXZVRU5qNVQzejZmalg0TWFqKzBOOEt2Z3Yrd040aytEbXVhNTRpK0lWMWZhbnFVZmh1NTBPMWpoMDIxZ2h1dzFyY1NYTndkN2hwb3pjZVVsdUNZNXZMTG9Ua1cvMm0vK0MzUHgybnVXOEkrRjllMFR3Wm90amF4V2tlbzZCRUxqVU5VaTh0ZHN6MzB4a1paR0h6RnJjUTRZdHdNWUhyckMrNzcyaVh6MGY5ZFRtOXQyUHZIL0FJTE8vREpkWC9acC90V0xXZEU4UGExNFgxSzM4UitINWRWMU9DeGE0dTdWaTNsMjRtWmZPbGVOcFZWRXp1ZmFEZ2NqeC93eDhaUERmajM5dHZ3bjhYUGh0cWY5cWFsNFZoc3ZCUGpJYWd3MHZSckwrMW5raHNsZDJMMzBrVWQ0NFY1NDdONFZBaVBtTVdRTitUZmp2eGZyWHhJOFJYV3RlSXRYMWJ4QnJGMlMxemZhbmR5WGQxUG51OHNqTTdmaVQxcUM2OGIzMnBYdDFkeVhjMGQ5Y3dyRkpjUlMrU1pBckJodjIvZSs0bUIyS0tlb0ZhMDZkT0cydnIvWDUzSmxLVDNQNnQvREg3Q3ZpcngvSS84QXdzYjRuYXlxcVFyYUQ0QnRqNFpzajFCU1M5WjU5VGtidHZndWJVSC9BSjVqT0svbm8vNEs0M1hndjRiL0FQQlVUNHRXUHc1czdKdkNPa1gxcm96V3d1SmJtSzdudHJPMWh2a2tsa1pwSlNieUtmZTdPek13WTdpVG10TFhmK0M0djdWL3hKOEtYV2szSHh3OFdwcDl4YnBGZFBZUTJtbTNqNzB3NE56YlFSejhsWDVEZzRQSk9UbjVrT21RWFd3U3EyMW0yN1EyRHQ2Y0hzZmZCcW5MVzZaUzJNU0hVTGpTOUxraWhudUYwMjhkQk9wTzFaeW1kdkhRbFN4T2UyYWZaVy8yaTNqWXI5N2o2SHBUZFErSHR6R2tNa0Y1WjNDeU82S3VXU1NKVjJrTXlrWStiTFlDbHVWYnB4blhYVGZzbHJIR3VBc0E4c1o0M0VBRXRqM0p6anRuSGFwZHliR05kK0hsMUJTdm1lVEpnbGQvQ3VSMko3WjlUd081QXlSK2ovOEF3UW8vNEloL0YzOXB2NHRmRDM0djZzMm4rRy9nalo2b3VxM0YrdXNXMTFONGkreDNPSHNJN1dHUjVJM2FXTFk3enJHSTB5NjcyQ0kzNTZTV21mbUxNb1k1QXgzL0FNNXIxLzhBWlkvNEtGZkcvd0RZZFhVby9oUDhTUEVQZzIwMWdpUzlzYmN4WE5qY1NZQytjMXRPa2tQbWhWVmZNQ2I4QURkZ1lvNVU5eG45VW4vQlIzNHMrQy9ncCt3ajhYZkVIeEZtdFlmQ1Z4NFYxUFRibUM0WUwvYXNsMWFTd1IyVVFQM3BabmNScW81eTJlQXBJL2pwK3ptSzNqUjhiOW9EWkhVK3Y0MTZWOGVmMm92aVYrMWQ0bS90YjRrZVBQRnZqalVUTTB5UHErcVMzTVZzNzREZVZFeDh1QVlBRzJOVlVLQUFBQUs0TklGTWYvUE5nRC85YWpyb0tOK3BCRmJtVlNmbVhzY0hHMzNyK25yL0FJSmUvd0RCZUg0TS90UGZzdjhBaGxmaVI4VHZDbmdmNHA2RHBzRmg0b3RmRkdvd2FTdXBYVVNCSHZyZVNRcERLayszelNrWjNSczdLVkFDczM4eVVRS0VuekZXVDdxa3RqSi91ajF6eHgrSHBYMXIreWwvd1JBL2FiL2JCTnJjZUdmaGJyV2grSGJqYXlhNzRwSDloYWN5SGtTeG1jQ1dkUDhBYXQ0NWZwVFVrdmlEa2IyUDBWLzRMMS84RjcvaDc0OC9aNDhSZkEvNEg2NUQ0MHZmR0VZMC93QVQrSnJJT05Oc0xIY0dsdExXUmdQdEVzd1hZOGlCb1ZoZVFCbmR2M2Y0YXlXN1BjeFJxZHp6RUtpaGR6dVNlQUFPL1FZSHQ5Sy9lTDlsYi9nMEs4TTZLc0YvOGJQaXBxbmlDNis5TG8vZzIyR24yaW51clh0eXJ5eXIyK1dDRmgyTmZwVit5cC93VForQlA3RTBVTC9ESDRXK0UvREdwUWdqKzEvc3h2ZFliSXdjMzF3WkxuQi91aVFMendCUzV1eFdpM1ovTm4reW4vd1FlL2FnL2ErU3p2TkUrR1dvZUYvRDkwRllhNTR4Yit3N1BZM1IwU1lmYVpsOUdoaGtHTy9OZnBkK3l0L3dhRWVCZkM1dGRRK05IeE0xenhoZEx0ZDlIOEt3alNkUFZoaktQZFNoNTVrNjhvbHUzdlg3R3ZtV1RjemJtYmtrbkpOSnU1cFc3aHo5anlIOWx2OEFZQytDMzdGRm1xZkMzNGFlRmZCMTBxZVcycFcxcjUycVNxUmdoNzJZdmN1RDZOSVJ6MHIxNDkrZHpmWHJXVDRyOGU2TDREVzNHdGFwWTZiSmVIYmF3enpCWjcxdjdzTVgzNVdQWlkxWmoyQnJJUHhBMXJYdDM5ZytGYjVvL3dDRzgxMlU2UkEzKzdFVWt1c2owa2dqQjdOUm9pTlhxZGFDS3lmRlBqelJmQlU4TU9xYWxhMmQxZEROdmFGdDkzZGY5Y29GekxLZlpGWTF6UGlYU3B0TjBaOVI4YmVPbTA3VEVaSTVFMDZRZUg3TGU3QlVIbmVZMTE1ak15cUFseW9jc0FFSklGWm1qZkVmd1Q0QjhVMi9odnducHVuM0dzYTlwVUd1MlVlbUNHS1B4SGJ5UE5ueWJza1IzTjE1VnZjVEJIZmRJa2JOdjJpUjBOUjJPa1BqWFh0ZkIvc1B3M0pEQzMzYjNYWi9zRWJLZjRrdDFXUzRKSDl5WklDZjd3cUs2K0d1bytLN2FTUHhENHIxcDQ3aERHMEdoTTJpVzhXUmplalJ1MTBHQTUrYTVaQ2NmSUJ4Vjc0VWVNMitJM3d2OE9lSXBMZExXVFg5TXQ5U01Dc1creitkR3NnakpQSlpBMjBuQTVCNEhRZEJuSnh0L0NuWVJpL0RYWGJyeEY0STArNDFBeHRxa1N0YWFqNWFCRSsxd08wRnh0SFpmTmpjai9aSXJlcmp2REdxV3VqL0FCZDhSYUhIZFc4a21wd3hhNGtLeXFaSXBBRXRybFNnT1ZVYkxSOGtETDNMMTJOR3ZVSG9makgvQU1IaUg3Smc4VWZBMzRZL0hEVHJmL1R2QitwdjRTMWw0NHlYYXl1dzg5cEl6ZGtpdUlwazUvaXZSWG52L0JxOS93QUZKZkNQd3IrQ1B4QytFdnhDOFVhZjRkdGRKMWFMeEhvRTk4SlZ0MWl1WS9LdkZlWGFZN2VHT1dHM2JkS3lKdnUyR2R6QUg5ZS8rQ2cvN0tNSDdjZjdFZnhQK0U4aVF0ZGVNdENtdDlOYVU3VmgxR1BFOWpJVDJDM1VVQlBUZ0VkNi9scS80STNmdGh6L0FMQlAvQlJQd1g0ajFVdnAraTZoZE40VzhUUnprd20xc3JwMWlsZVFIQkgyZVZZNWlEL3p3STR6a1hSK0xsNy9BTmZtS3A4S2wvWDlXUDYwZkJuaS9TZmlENGRnMWp3N3EybDYvbzkwTjBOL3BkNUhlV3N3OVZsaVprYjhDYTFGUHk1cnd6WHYyWlBBMnRlSWJqVkc4TjJlaStJSGJNbXNhRkpMbzJxbGhucmVXYlJUSHZ3WElQZXRUVGZCM2pmd2x4b1B4RXZyNjJYaExMeFhwc2VyUklQUlo0VGIzUlArMUxOTDlEVEtzdWpQWkY5K2xTQUhkL2hYbDluOFh2R0dnYlYxN3dDMTlHdkgycnd4cXNkOXU5V2FDNVczZEIvc28wcCt2ZlkwVDlvendYcTEvSFl6YTlEb21vekhiSFk2N0RMbzExS3g3UngzU3h0SjZaajNEM3FlWHNMbGU1M2k4LzhBQXFqbHM0cFQ4MGFsdlVEQi9NYzAvYVkxWHNHR1J4MUh0U2h0Mzh1S1dxRU1TMWtoWDkzTklQUU9Od0g5ZjFxUlpwa0dHaldUM1J2NkduSmpqSDQwN0hGUG03azhxWWtGOHFTS2Qwa0xkaVFWTmVUL0FMUnYvQlB6NEkvdGZKSzN4SytGZmdieGpkVEx0YS92ZExqWFVWSCt6ZHhoYmhmK0F5Q3ZXaTJSZ2pqMFBlZ1dxZzVYS2Y3cHgvOEFXb2NZeTNDUE5INFdmbGYrMFQvd2FNL0FINGlyYzNQdzU4V2ZFRDRXMzBuTWR1MXdtdmFURi8yeHVOdHdjKzkxK0ZmQXY3UjMvQnB6KzB0OEtaYmk1OEVYbmdUNHRhY2h6SEhwK28vMlBxVEw2dERlYklRZStGdUhKN1pQWCtreU5wSS8rV2diL2VIUDUxS3QxZ2Z2SXp4M0hPYU9WOUgvQUY4eXZhdjdTL3I1SDhYSDdRWDdHM3hVL1pUdi9zL3hOK0cvamp3RzIveTFtMW5ScHJlMWxQOEEwem5LK1ZKOVVZaXZPNGROVzZWV2llT1JXNkZUbXY3anBvcmZWTEdhMW1XT2UydUZLU3dTZ05IS3A0SVpUd1FSeGdpdmxIOXBEL2doVCt5aisxSzgxeDRnK0RIaFhTTlVsREgrMHZDOGJlSHJvTTNWejlqTWNjamM1ektqODlRYU9hUzNSWFBCOTEvWDlkRCtTRjlHWlI5M3A3VkZOcHhUbm5wMHI5N2YyaWYrRE8zUmJrM0YxOElQalhyZWtzRlBrNlY0ejB1UFVvV2JzRGQyM2xPaTl2OEFqM2tQSFh2WHdUKzBoL3dic2Z0ZGZzOGZhTGh2aGpEOFJOTHR3VyszZUJ0UlRWR2NjL2RzMkNYYkhub0lhdFZLYjMwS1VmNWRUNEJsZzQrbGZ1Wi93WjZmQVMzOE8rSFBqSjhaTlh4YjJWckJiK0dyVzhrNFdCV1AyM1VBVDZDS0hTM3o2T2UySy9Gbng3NEsxTDRaK0pyalJmRkdrNng0VTF5MUpXYlQ5YnNKYkM2aVArMUhLcXN2NGdkSy9mUFJ0R3VQK0NYMy9CcXY0cXZwN1dYU1BGbmo3UUxpVXhNcHQ3b3phN05IcDlxeERZWlpvOU1hMmRnY01wZ1lkUmluS3lnNVJabnk4MGxGL00vQ0Q5cWI0K1hIN1VYN1VmeEgrSlYzdWptOGYrSjlSMTVZbkp6REhQY1BKSEVQWkVaVkE3QlJYQ2g4ZjU2VjlrZjhFM2ZEL3dBS1ovaGxybmhuNGlheG9GNUw4UU5ac05IWFE1ZE5sVFViWkxlYUdZenhYc2JOSW5td3ZkeHBHbHRMbTRXM0FkSGJhM3p2KzFIRHBaL2FFOFdRNko0ZjByd3ZwK24zNTA5ZE4welZCcWRuSExicXNFMGtWd0VqV1JKWm81Smh0UkZBbDJxb1ZRS3IyVGhGRDlwek5ubi9BTm94d0QrdE5NdlNteXBzejIyamNUMDJqT09mekEvRVZHM0E3RWRqV1lqM3ovZ21OK3p3UDJzdjI4dmhqOFA1WVd1TEx4SnJ0dGFhaEdCeWJGcEZXOFlkc3BhbWVUL3RuOWEvVFQvZzgwL2FqdXZFSHhoK0Vmd1p0YnFSTk4wclRianh0cXRxcmZ1cHJpNGxrdExUZVA3OFVjRjBSNkxkSDFGZWIvOEFCb1oremkzeEcvYnY4UmZFQzZ0dk5zZmh6NGZ1SnJlVWRZYis2QXM0UHdlM24xSDhZaDZWOGovOEYwdjJpLzhBaHAvL0FJSzFmR3p4RERjTmNhYm8rdUh3eHB4MzdrRUdtb3RrV1QvWmtraGVYNnlrOTZLbjJZL01LZThwZkwrdnhQbnY0Ti9Idnh2K3psNG0vdG40ZStNdkZYZ1hWbUFEWGZoL1ZyalRacEFEa0t6UXN1NWZac2oycjd5L1pzLzRPbi8ydFBnWVlyZlg5ZThLL0ZUVG8xVlBLOFZhTW91VlVZenR1YlF3U3N4R2ZtbE1uME5mbSt6Wk5kQjhLZkVtaitEL0FJaGFYcWV2YUtQRVdrMmNwZTQwOHloQlA4akJUeUdWdGpGWDJNQ3I3TmpBcXhxazNleE1vcmMvb1YvWTkvNE82L2hiOGNQRm1sZUcvaWw4TnZFWHczdXRXblMwL3RXdzFHTFd0SmhadU44d1pJWjQwejJqU1k4OSt0ZS8vdEtmOEcwMzdKSDdUT28zT3NXZmczVXZodHJtb1A1N2FuNEUxVTZjakU4NVcyZFpiUlZQWDkzQ3VhL24zK0dYaGJ3UCsyNSsyVDhKZkEvd3k4RXllQjQvRU9yeFdWNnl5dkk5ckpjM0VVVVNnK1kzbVJXN2tTTE13V1ZoY01yNUVTRS8yQ1dHbDIyaldFTm5aeExEWjJzYXcyOFMvZGlqVWJWVWV3VUFmaFJWcHhTVDYrWHlDRlNTZGxzZmcvOEF0QWY4R2pueFE4SHRQZGZDSDQzZUcvRjF2dUxSNlg0MjB5WFRaMVFad291cmZ6bGtZK3JKRURubkZmRFA3UWYvQUFTWS9hcy9acDNmOEpsOEFmR2w1Wm9XMjZwNFZqVHhGYUZRY2IyTm0waGlCLzZhYkQ2aXY2eWlweC85YWdGb1R1WGNENmcxTWExV09pbDkrcHA3cjNYM2FmOEFBUHlmL3dDRGJ6OW12V3YySVAyRy9pajhYZmlENFY4UStFYmpYQTJvSnAyczJEV2QvSnB1bXd6enRPSVhBa2pTWXlNcWhncGY3TXJnRkNqSDhNL0QvaS9VL2lIUHFuaTdYSldtMXp4anF0M3Irb3lIS21TZTZtZVdRL2lUbkp6MTlCWDlrdW8yRU9zV00xdmR4UjNOdmN4dEhORktvZEpWWVlaV0I0WlNDUVFlQ0svTUQ5cGYvZzA5K0FueFUxVFVOVytHZmlieDE4RzlXdkdNa2RwcDA2YXRvY1RrNTRzN2pFZ1hQUkZ1RlVEZ0FBQUM2ZUljYXZ0SksrbHRDZlp4Y09WTzJ0LzYvRThyMW5Ybi9hWStKV242QkU4bHI0Umh1RmprOHNiUHRnVHNQUlFPbnJ3ZlN2eHAvd0NDczJ0YTAzN2UzeEUwTFdwNW1zdkIrcnphWm8xbXJIeXJPeUJEUXFnN0ZrWldZOVNUN0N2M0ErRmZneVB3RjhRZEpKMnJFczVpQUk1SGJKK3VjMWlmdGMvOEVBZkJmN2VueFQxcjRrUnlhM2FhNXJDUXJkdGFQYm1PU2FPRll4dzgwUkdVUk9mbXljOUJYOGNlQm1ZNGZEWnRWd2poOWg4dTE3cHB0K3JUZC9RVk9qT3BQbWU2ditOditHUDV6bXVFU3oyb3ZsTmxpLzhBMDBCeDFIYkdQMTdWOXMvOEVCZmdyL3d0RDl1TzMxeTQrem15OEM2Zkxxa2diNzd1eW1PTUwyN3NlZlFWOWkrT1ArRFUxdEw4eHJQWFBFa2thNVlmNkEwallIYjkwMGc1NjU1eDlLOWQvd0NDYi84QXdTd20vd0NDY3A4WjMxeGR6YXBkZUtJWWJhS2U0dG50MmpqakxaMmgwVnVTVG5HUjA2ViszZUpIRU5QRGNOWXlVVTFKd2FWMS9OcCtUWjZtRXd0UlZWSjlEdWZqbjhXdEgwN3h0cFBnT2UraHRmRVhpaTNudnRLUXliSG5hMktzeXI2bkJCd09lT09oTmVxZkJENG55L0VIdzFISGNmdWRhMDhiWlYvNTZnRGhoK1hTdm4vOXEzL2duMTQ1L2FIL0FHblBBUHhCMEc5MURTditGZXhCOVBNT21UekxjczdLMHFzNjRCVjFBUWdIcGtlMWVpZU5mRHVzZkIveEpEcW4yV2ZUN2xpSlJGS25sc1ZQVlNPY2Q4Y25pdjVYekhnMnJsV1JZT3FrK1N0RzgzL0xOdHRmZkd5MzNUOGhZam5qUDJyV2owK1hSbjB4cDhhK0o0MTh3cisrUXh1RDAzWUk1K280L0d2amo5dFcwWHdMZEhRWTQvTGp6bUlIK05HSjJqOE1ZOU9LK25QaG40M3R2RmVpUTM4RGJJN2ppYVBQTUVudlhLZnR1L3MreWZGRFFkQThTV2NZa24waWNSM29VWk1sdTNHNy9nTGMvUXRYelBEK09kS3M0VjkxdjExNlAwZmZ1YzJLdzN0RkdVVDh6UDIzUDJNUEYzN1Y5MzhQL0RsanFWaDRkOE02WGJ5NmhkWEY1SVA5SnVabkVhcEhFTXZJeVJvZnVnZ2VjZVJ6anAvZ0Yvd1JiOEkvRHU0dDdxV3h1OVV2bzAzZmJkWmphSkN3QXdZN1lIZjF6MUs4WXhuditobWhXbmgzdzIwbjlqMk4xcUdvUW9rVHlhYnBqcTgrQnRBYWZieXZvQzM0VWFwTnIwMDhpMk5uYWFPakxqWkppZTVMY2pJVkdLNTRZSExEQnhrak9LL3RyaDNDdkI1YlJ3azVYNVZyYmJtZXN2eGIzWjJVOEh5UnRiWHpQSmZBSDdLMm1lQTRiV2E1VmZNZzJMRkpkS3Fxclk0YUtCUnRRNEE1UHo4bkREdjJzVXVtK0hkVVpyZTFrdUxxUDk3Y1MzRWUrU0lkTndRa0twSUJDN3lpa2o3MVc3andyZFhObkROdXVOUW1rT042c2k0emdGc2htSVVaSWI1d3VNOWVGTnJTL0RLNmdZTFdHeWp1ZkpreDVkdGIrWXFPVG5IR1J1OWVuSE83T1FQZmpKMjJzWEtLWFU1Q3oxWFVOWDFoUkZkTll6SVJKdWluMzNYUFlPRTh3UmdCdUlvMXp1TzV5dUF1NXBQaGhZcGRQanRiZWFhUnBBMjRLM01yWnlRcHpuSFQ3NEhQM2VLOUo4TS9DQ1N4dFBPdld0ZExpVWsvWjRrajNBZnhjSWZMR2NaeWNrRURyaXVRK0wvN1luZ0g5bm90WVFYRnhybmlOZ3NTNlhwaWZhNzVpZUY4ekdGaFVzY2JwbWpRZTU0cStWc3lja2oydjRUZUVwdkQzZ21iN1MwZm5hamVBdHRJSUNJb3owQUdkelAwSFRHU1RtdHV3MGpWNXRJMW02OFBRTExyelcwdjltK1lRcUxkT0NzYk9TQ0FxTVF6Y0hDZzhIcFZEdzNxR29ENGRlRy83UnRHMC9Wcnl3VzV1N1JuM3RhU3pEZTBSUEdXUVBzSndCa2RCWHNmd2k4THJwR2dySXluekg1Skk3bmsvcGl2ekhMY1AvYUdleW12aGpLNzlJNkw4VHhKZnZLOHI5L3lQTS8yS2YyRVBEdjdJSGhLVHlaRzF2eGRxdzh6V2RkdVFXdUw2VnNGOEZzc0ZMREpKTzVpQm5oVVZmYjVJZHAyKzlYREhpbXN1MDErdlJqYlk3cFR1VnhEeGozeFRsWEhQclNqcFRIbUNqOEswTVJ6TmdacHZtRlIycU43dkMxWGx2ZWV0QUZwNThaL3BVTDNPMEdxY2w3dSs3ODNzS28zZXRLamZoNjBENVdhY2wwQi9GOUtyVDM2cDM0NzE0cisyZCswUnFuN09uN0tmeEE4ZmFIWVdtcmFuNE4wZWJXRXRMbFhhR1dPRWg1dHdSbFk3WVJLd3d3NVVlNHI0MS9hNy80Sy92OEFEN3dmK3l2OGZQREY3TTN3ZCtJT28zV2tlTWJTUmlSWkNZUTd0eXFSdW50VGJha0IxQmUzd09ISkxVVzloMlAwbnV0YjJyMTQ3VjRKKzFWKzM1b1A3SmZ4aitFZmh6eFBiK1RwSHhZMWFmUUlkVzNuWllYdjdoYmRIR01CSkduNWNrQlZSbTZBMTJ0LzQwVERmdkZiRFl5cmJnZmNlM3ZYd0ovd2NSL0RhVDQyL3dEQk9MV3RTc2ZOL3RUNGM2dForSjRURWYzcGpCYTBuQTdnTEZkTktUNlFaN1VveVY3TXF4OUhmQy85dWpWb2YrQ2tIeFYrQmZpeVE1ZzB1eDhYZURMaDBTUDdScDd3eHgzTnVNQWJqSFA1bU01YjkxTVNjQVY5QVhuakRjM0Q0UFhHYS9FejlwbjlzUzQ4VmVFUDJOZjIxckh6SnRhOE8zQjhLK1B2SlhNbHhHUklsMm9VZmNEZVhxakxuT0Jkd2RlTS9xSEY4UTMxcXkrMmFmSjlxMDhJSkJlb3dXMVpDTWgvTkpDQlNNSGs5TUhwVGQyMVpCdHVmTVA3ZXZ4T2wvWTYvd0NDdXY3UDN4cWpsZTM4TC9FclRwL2haNHNkU0VqUXRONXRqUEt4NmJaWjQzejEyV0xEaXNyOWhmNGpTZnNtZjhGTC93QnBINEhYUmt0ZkRmaTdVVitKL2hKU3V5M2lONEFiNjNqQjlDeXFxOWhwOHA1NU5lV2Y4RmpmMnVQZ0g4WnYyZXRRK0hXcmZFVFJOYzhXUjZwWmFocGRqb0lmVUZ0cm1PYlk0bXVVQmhnQmdsdUVKM0ZsOHdIQndBZmpiOW9ML2dzajRoOGMvR3hmRlhoSHcvcHZnVHhaNFYwU1RRZE0xelVESHIycDNxRjJKbWthV0lXNnpzSGxFYlJ3QUl0NWM4bmNoVHBqaDVOZS9wL1duOWFFOHk2SDd0ZU5QakRhK0dQQ3QxcldxWDlqcE9oMmcvZmFucVZ6SFpXTUdlbStlVmxqSDAzWlAxcjhwZjJodjI3Zmc3OE1mK0NpZXNmR3J3ZjRxdWZITGY4QUNGblNQRTJuK0ZFS2YybmN4U2hZRk56Y1JpSm8vTFMzZHBvVmtFWXNGSHplWlh5bDhKLzJIZjJ2UCtDdDBFbmpiU2ZEUGp6NHBXaVNQREZyMnZheEJhMkpaVGg0N2VlK21paU8xdUNrQklVakJBeGl2RmYyc3YyTFBpOSt3bjQwaTBENHArQ1BFSGdYVXRTaGMycHV3cjIyb3hqYUhNRnpFelFUcUN5aHZMZGd1NEE0eUtjS2RLTDcvd0JkZ2FuYTU2M292L0JVYnhkOEFmaHZMb3Z3WXNmRHZ3LzA3WDlXdjlWZWY3SkZxdXVhZUpaQWtWc0xtNFF4eHJIQWtNYXlRd3hTTjVPOHNDMjFmbmI0by9GVHhWOGJmRkVtdStNdkVtdWVLdGN1TTc3N1Y3K1c5dUQ3YjVHWWdEMEJ3SzVHVzZqVXJzWm0rVUIva0NnZlRrL21hMnByWHlaTnUxZ1NBM0ozRlFRQ0FUanFNak5heWxvS01kYm1lK295end3V2MwbTYzaVltTlhiNUl5VGxpTytEem5IVTQ5cWswa0xxVnhKR3NrUG1aM3J0UXJ2RzBraFIwNHdPRCtGWHY3THQ3KzFtamtqdzc3ZkxsVE82TTU5T2pBanRuM0hUbVBSZkRLNmRjR1dRK2EzSVhJSVZUL01uK1h2MkxqNVNXR0JjZXE1MjhqdlQ5VzBHMTFMUjdXRzF0NGJhK1NlU1NlNWFaeUxsR0VZVmR2SVhZVmM1QXkzbUhQUlFMOWxwdSs1YmI5N3NUMFA1VmJ0ck1TRnRxak83R005L3A5ZS8vd0JlZ296ZkQraUpvdHV5K2Q1c2twVm1ZamFuR2NBRDZFOG5ubnRnNTJJMGlVYmZsREQ1amx1eDVJSjY1NEhJL3dEMVRSMlFabVVoTnhZWkI2OGdlNStuYjNxOUhZcXFvbmxrc2VqNUs1NUF6VklaUmt0UkNtN0hsS3JINzRCT2ZwNmNaSjZWSGYyS3dONWdWdHh5U01jRG5vTytPMmZibXJseEVVTGIvbFdQQ25KS3JrZHVBTzUvbHptdm9EOWwvd0Q0SlIvdENmdHBHenV2QUh3cjhSWG1pWFAzZGExQ0pkSzBrb2NBdXQzZE5ISEpqdUlqSTNIQ21oMlc1U1RQbXVXMUZzKzdhb3llZVFjZzg5dmJuLzhBWFZhZUJZNC9NazJSS1QvSDhvL1BvUHo3Vis0WDdLUC9BQWFMTEhkMmVxZkhENG9SeUtwV1Nmdy80TGdPSDlVYlVMbEJqSTRZSmJaNjdYQnd3L1MzOW1mL0FJSlQvczUvc2dheERxWHcvd0RoRDRSMGZXb0NHaTFhN2prMWJVWUNCMWp1YnQ1WklpZS9sc29OVGZzSzZXN1A1cWYyU2Y4QWdqZCswZjhBdG9KYTNuZ240V2E5SDRmdXRwVFg5Y0EwWFNpaC93Q1dpVFhHMHpBZjlNRmxidmoxL1MzOWxYL2cwRTAyejhpKytPUHhWbDFDVGd2b3ZnZTI4bUhyMGEvdTQ5N2c5d0xWRzlINzErMThzajNNbTZSMmtiMVp0eE5Sc054OXZyVTY5V1R6ZGtlQi9zbi9BUEJMUDluejlpUjdlNCtHL3dBS3ZDK2k2eGI4cHJkM0UrcDZ3RGpCSzNsMDBrMGVlU1ZqWkY1NFVWOUFTRnBYTE14Wm02a25KTlp2aWZ4ZHBQZ2pUVnZ0YTFUVHRIczVIRWFUWDF5bHZHN0hvcWx5TnpIc295VDJGYyszeFJ2dkVDNDhNK0Y5VzFSVzRXODFRTm9saUQ2RXpJYnBoM0R4VzBpSHMxR2tkQ2J0bllBL1BpczN4WjQxMGZ3SGFRM0d0NnJwK2t3M1QrWEFidWRZVGN2ak95TU1RWkh4L0NvTEgwckJYd2w0azhTT3Y5dGVLRFl3eU5nV1BoNkFXWWs0SktTWEVwa21jakhEd0cyUEI0cUg0Ump3UGVYV3BYL2cwYWJlM01aanQ3N1ZyZG11cDdndkdreXBKZVB1ZVloSFJpREkyM2V1Y0hpcTE2QzBLbmkvNDQzbWs2YkRjNlQ0UzFxOHRKNzIwc1JmYXIveEo3Tkd1YmlPM1JtV1ZXdTlvZVZNa1cyM0dUdUFHYTAyOEZhOTRoYk91ZUtMcUdBL2VzZEJoL3MySngvZGVjczkxdUg5K0dXRFA5MGRLMnZHZmhPMDhlK0VOVzBLL2FSTExYTEtiVDdoNHppUkk1bzJqWmxQWmdHSkI3RUExUitGdml1NjhiL0QvVE5RMUJZMTFWa2UxMU5JeDhrZDlCSTl2ZG92K3l0eEZLb1BjQVVXMDFIcHVpejRROEFhSDRHa2xiU2ROdE5QbXZNQzZ1a1RkZFhYKzFOTTJaSmo3eU14OTY4YXVmamg0MjhkYU40aTB2UzlKdUxmeERvcTNGanFkdG8zMks4ZlNudWJlNlMwZUdmN1UwYzA5dmQyeWlSSlJidDVkd2p2QkdvR2ZiTlU4VDZmbzEwdHZjWEtpNllibHRvMWFhNGNlcXhJQzVIdUZOUW5XdFcxWlZXMXNQc3NZR0ZtMUdYQkE3TXNNWlppUDlsMmpJN2dkS0Zwc0M3czhpc3YyWHZFbXErUGRXMXJVUEdGM2IyV3FHZTV0OU1MSFVKTkp1cEo5TzFDQ1NDZVRCVmJUVUxhNjh1QWlTRXd6SUZFUk1pdjJPaGZDN3dUNEIxWldrdGJiVnZFY2FJWHVKN2RielVqaTd1YjVYRWNhZnVoOW91N2lRZVhHaUx2QUdGalFMMWErR0pMNFoxTFVieTlKNU1VSit5MjQ5Z2lIZVYvMlpIazZuOE5IVGRNdHRHc2x0ck8zdDdTM1VraUtDTVJ4Z25xZHFnRG1nT1ptYWwvcXQvL0FNZXVudzZmRjA4eS9jTTQ5eERFU0N2KzlLamY3TkQrRmx2Vi93Q0puZlhtb0szL0FDeUwrUmJqMUhseDdkNm4wbE1sYTdaMjhlbkZNbW1odExONTVwSTRZWTFKZVIyMnFvOXllQlFTY3Q0OHRiZndoWWFMckZyRERhV3ZodStVenhReGlPTmJPZjhBY1Q5T0ZTUHpFdURqcjlsRmRpVlpDZDNZOCsxYzlxV3EyUGkzUmJyVDFzYnJXN0hVSVpMVzRFUzdMZVdKMUtNUE5jcWpLVkpCOHN1ZWVsSjhLZFd2ZFc4Q1dLNnF5eWF6cHdmVGRTWlczQ1M2dDJNTWtnT0Fkc2pKNWlrZ0VySXB3TTRvS2V4MFN1WTJERHF2SVBwWDhudi9BQWNTZnNoLzhNbmY4RllQaUpaMlZyOW4wRDRpT25qalNFQndESGZzNXVGVWZ3cXQ4bDVHcWpvcUxYOVlSNlYrU1A4QXdkdC9zVDZqOGNmMll2aDc4VnZET2tYMnJhNzhPZFlrMGJVb3JDMmFlZVRUYjhBcklRb0xGWXJxR05RQU9EZU1mV3BsdW13anFuRStsUDhBZ2tmKzFOSisySi93VDQrR3ZqQzh1RGRhOUJwcWFIcnpNMjZSdFFzc1c4c2puKzlNcVJ6L0FFdUI3VjlOUUFNT04zdDcxK0tIL0JxeiswZGNlRi9HbnhJK0N1dXRjV2R6cU52SDRwMHl5dTQzaWxodUlBdHZlTHRZQTdwSVd0WHdmNGJWajYxKzFjTDVHUDUvNS96aXVxcHZ6THFadzJ0MkxpTmtmN1dldE52OU9nMXZUNUxXOHQ3ZTh0Wmh0a2h1SXhMRTRQWXF3SVAweFRVY2tyeng5YW1qK2MvaGo2MW1VY3ZCOERkRjBWOS9oK1hXUEI4aTlCb1YvSmFXNm5IVTJ1V3RuLzRIRXc5cXZRVGZFTHd5NCt6NjE0ZjhXVzY4bVBWck02YmR2LzI4V3dNUS9DMjdkYTZCRHhuNXV1T1RUNDIzL2wyb0s1dTVrUmZIYVhSWDIrSlBCL2lqUndtTjkzWlFEV2JNbi9aTnR1dU1EMWUzVCtkZE40SitLUGh2NGtTeVJhRHIyazZ4Y1FqTXR0YlhTdmN3ZjlkSXMrWkdmWjFCcXJHTm5xcmRldFpYaTd3Rm9YajJGWTljMGZUZFdWUHVHN3Qxa2FNOWNxeCtaZVFEd2VvQnBDME8rem41U3Y2VTcvSnJ5eUg0WlhtZ01QOEFoSGZHSGl6UmxISXQ3aTdYVnJRK2cyWGF5T2krMFR4NDdZcTVINHgrSUhoei9qODBmd3g0c2dITFM2VmN5YVZkWS8yWUxneXh1ZnJjSUtCMlBTTWJmNVU0WkZlZnhmdEhlSDlQWVIrSUlkYjhHemZ4ZjI1cDdRMnlmVzdqOHkwLzhqWjlxN2JROWFzL0UrbFIzK20zbHBxVmpNTXgzTnBNczhMajJkU1ZQNEdtdTVPejFMUlZXSE9EZ2NaSFNucURHM3lzdy9ITk16eDlhZUcrWTBDdGZjbGp1cEIxMnQrT0trRnhHNStZRmZYSXFFZGMraHAzWEg1MGllWHNWOWU4SjZYNHVXMy9BTFMwL1R0VVd6a0V0dUx5MlM0OGh4MGRONE8xaDZqQkZlWmZ0dWZzVmVEL0FOdno5bmpYdmhyNDcvdEgreE5jYUtjWFZoTUlyeXd1WVpGbGh1SVdaV1VPanFEOHlzckFzckFoaUs5WFVEUFNwQkl5bnIrZFEwaTR5a21tZno5L3RILzhHZGZ4TjhNR2E0K0Uvd0FXdkNYalMwWGV5NmQ0cXNwZEh1eW44TWF5d2llS1IrMjUvS1huUHkxOEMvdEtmOEVnL3dCcHo5azZDNG04Y2ZBL3hyYjZiYkFzMnFhSmJMcm1teG9NL004OW1aVWpYL3JvVlBxTTEvWUVrK2VHWDhxa2ljSys1V1pXOVFjVlNuTmJNcm5YMmw5eC9GMyt6RCsxOWRmczU2TnJsanBtbjJlcVE2MXFPbTZuY1J2ZXkydm5OWXRPVXRiaFZ5bDFaUytlM25XMHFNa20xRGxTdlByMTUrMEQ4Qy9pZDRlOFE2NXJYdzkwaTA4YzJPZzNWbnBNVStsaTJnMUM1ZURVSXJlY0xZQ0sxbHVrbE9tM01zdDdFRWtIMjFGVTR0OXY5UVA3VFA4QXdUbytCZjdZcVROOFR2aFA0RzhZWGs2N0gxRzcwdEk5VEEvMmJ5TFpjci93R1FkSytFUGpIL3dhRmZzMmVPZGUrMitFL0VueFMrSGNFa29NbW5XZXFRYW5aQk0vTXFDNmllWldQOTVwbkEvdW10UGI2V2xIN2llV084WkhCLzhBQnZKb3R2OEE4RS9mK0NLWHhjK1AycVd5bTZ1bzlSMTJCMzQrMjIyazJzbmt3bm5yOXZrdm9mY2dDdjUzcExpNTFXYVM4dkpwTGk3dkpHdUo1WkR1ZVYzSlptSjdra2s1cit0UC9nb2Yvd0FFM05VOFJmOEFCRjN4Sit6ajhEYmVUN1JaNlBZMk9sVzE5ZlJ4M0dycmIzOEY1Y0pMY1B0aiswWEpqbVpwSDJJMHN4enNVa3IvQURBL3RBZnNnZkZMOWsyK2F6K0tIdzE4YytBWkJJWVZtMW5ScDdlMW5ZY2Z1cHl2bFNyNkZHWUgxcU9hTXFqZDdkaW94YXBhZDIyZVR0RVZhZ0tSMUZYelpyZVJmdVhXVGNwT1VPU1BmMnI2S3ZSOEdQaUg4RGwxcTQwdncxby9qZTEwT1JOUjBqVGRXMURRYng5UmludVZpdWJWWkxTNzA2ZTNrdG1zMmt0eEpCTzgwYy9sbEZZR3RmWnUxeU9ZK3F2K0RUbjlubi9oYkgvQlRXTHhWY1JoclA0YzZMZWF5QzY3a2VSby9zaUtmUmhKZVJTcjd3a2psYS9wWFg0bStHVzhmZjhBQ0tMNGs4UC9BUENWZVFMbit4ZjdTaC90THlpTWgvcys3emRwSE9kdU1jMStPLzhBd2FzK0JOTi9aVi80SjVmRzc0OWVKVU5ucDhrenZPMGk0M1dHbFdUMzBzeW5yaHhkaU1qKzlhL1ExK0NueEwrS212ZkhINHBlSVBIbmlTOGt2dkUvaTdWYmpXOVJ1Mis5SmN6eXRLekQwd1c0QSs2TUFZeFV5ZDVLUFpDcHhiaTU5MytYOWZpZjNJdWpSTnRaV1UraEhOTnh4WDhmdjdNLy9CYkw5cVQ5azViZTM4TGZHYnhmTnBWdUFpNmJyZHd1dFdTeGorQklyeFpWaVgvcm1GSTdHdjBLL1pyL0FPRHgvd0FiYVY1TnI4V1BoTDRYOFFya0sxLzRhdlo5Sm1WUjFZeFMvYVVrYzRKd3BpWFA5MGNVZXl2OEwvVC9BSUg0azZyZEg3OEZCai82OWZrOS93QUhVWC9CUXZ4cit5bDhHdmhqOE9QaDE0cDFud2ZyL3dBU3RTdTc3VnRUMGE3YTB2NHRMc2tqRFFKTW1KSWhOTmNJUzhiS3hGc3k1MnM2bjdPLzRKeWY4RlYvaFQvd1ZCOEU2cHFudzluMWl3MURRVEgvQUdub3VzUXh3MzFvcjVDeWZ1cEpJM2pMS1JsWDNMOHBkVURwdS9BTC9nNngvYVBsK0kvL0FBVjgxalFZbldTMStHSGgzVGZEY1NoOXlsNUl2N1JsYjBEYjczeXozL2M0UFNzNVI1WnFNamFrMUpPWGI4OWo5Y3ZqbDhKVytIWHhKMUNGVmtieVp0MEVtTURhVHVVL2lwR2ZmTmZSdjdLbmlOZFFzbWozZkpmUkIrVHlKRTYvek5kVCswWjhJb2ZpQjRXbHZvSWgvYWVueGxsSUdXbGpISlgzSTVJL0VkNjhVK0FPc3Y0UThTUFo3dmxaeE5EbmdBOXgrT0svaVhNOG5yY0Y4YVVzWWwrNG5LOFgvZGxkT1BxcnRmY3pzakdOdVpIMUZORHRyd0Q5cWVPWFdQR09rNmFHTExKdENyN3MyUDZWOUQyZHhIcUZwRlBIeXNxaGhYanZpclJtOFdmdEVhY05qR0d3WGNjcmpCSEkvblg3ZDRxVTNqc2twWUtnL3dEZUt0S0N0MVVwSnY1V1Z6cXdja3FsMzBUWlByWHdWblRTSTAwZlVsczVGaVVHQzh0eGNXOGpBY0U0S3V2UGNFMTRuOGZ2aEQ0czF6U2JxUFZ2RHRuOWxzMHpEcXRwcVAyaFQwLzFrVHhxOFkzRWdmTS9icG5BK3ZQczY1cnlQOXRmWEcwUDRNdkRDMjJiVXJ1T0VFSCtGY3VmMUMxNzNHdVc0TC9WM0UwYTBiUVVMTHlhMGpiNTJPT3RYZksyejQvK0VkM0o0SjhSTmJTZVl0dmNIeTVZOGZkUFQ5T0srbC9CZDJsM1l2WXpiSlk1RnpIdUhCQjdWNExxV2tOZTJjTjdoUmRJZzg1VjZNUjBiOGE5RStHdmlWdFIwdUhMYlpyZmdZN0FkSy9pZWhRbFNxY3NuKzhodDV4L3JWZG1WUmtsYVBSL21KNHo4SCtIdkN1cUdIVnRRMEd3dDd0V2FFWHVxdEM3S1B2WVJ3VjY0REVIbmpKckZ2Zkcvd0FNL0RObkl0OThRdmg3cGRxUjg2SmMyak9GSFJjdStGSEhRcjM3VjZ4SjhMZkJQeDNXeHR2RzNoK3cxKzB0cGQ4UDJrdXYyYVVqRzRGV1U0UFRyNlYxMmlmOEUvOEE0TWFQY2VaYi9Edncvd0NaZ2N5ckpNQ08zRHV3cit5UER2aUwrM2NwalduL0FCWWU3UDFXMHR2dExYdGU2NkdrNU9MNVdmSmZpVDlyajRIYUJlR2YrMmJyeGJlYkI4OXJCY2FoREp0emo1bzFlUEhvQ2NmaFdmcG43VVh4TCtNS3gydndsK0NYaXE4dEpKU0k3Kyt0L3dDeTlQVHFOeFlibC9BN1BxTVYrZ0hoWDRIZURmQThvazBmd240YjB1UmVrbHJwa01Vbi9mU3FEK3RkU1YzZmVKTmZvRWNNN2EvNS93Q1JtNnk5ZncvelB6ODhILzhBQk9ENDZmSERXN2ZVdmluOFRMZndubys3ZkpvSGh0Tnp6THorN2xsM2ZUa1N1cHh5bU9LK2xQaE4reHo4TmYyVWRHYlZ0RzBLRzgxcXpqNDFmVVZTNDFDU1RHMEVQdEN4c2VGSmpWU1ZBQnlGR1BhcHlGNlY1OThjTmNGbnBrVnVHT2VaQ1BVbjVWL21UWG5aNWpJNERBVk1UMWl0TDkzb3RQTGM1NnVJY1lQbDBQTnJTT1R4UDQwM3UyN0xsbU9mVG4vUDFyM2JTTFVhYnBzVU9OcEM1WVo2RTl2dzZmaFhtZndiOE9icnI3Vk12QUFicCtRL1ArUnIwaVM5MnQxeFh6SGgvbDhxZUVsaktueFZIcDZmOEZuSGhhZkxIbWU3TFJtR0tnbHV2VDA5YXBTNm9vL29LemJqeExhaSthelc0Z040c1FtTnVKQjVxeGx0b2Nwbk8wc0NNNHdTQ08xZm9aMVNOV1crMmpKYXEwdW9BcDE5dXRZTjc0aFhiMS9XdmgzOXQzL2dxTHJYN0N2L0FBVWQrRWZocnhJdG1maEQ4U3ROaHM1N3VSVWpPajMzMjJhR1c3YVVqTElobTA3ZXBPRmllWmdDMktjZGRpYkgzbmQ2dXNhN2M4NUk2L2gvaldWY2VJVVdmRE1jZHo3VitXbi9BQVRRL2JUMTc0US84RkR2amgrekI0MzFLNG1qc05jMVhWUENCdW0vZUxzdTViaVMzVHVSTFkzRnZjS0R3djJhYzlYR2Z2M1ZmSFNySjgwbnB4VTFIeXV4VVZwYytKOWMvd0NDay9pbjlyUDRFZnRqZkNlSWY4SXo4WlBnbXVyM09tdFpTbUZ0VnM3RzluWkdoVmNQdVZiV09KdWZtKzJRbkozSEh0di9BQVREL2IvVDl1bjlqRHd2NDJ1THFHZnhEYm1YUmZFT3hkbU5RdGlGYVFxQmhmT2hhQzQyamhmdEcwZmRyODF2MjR2SDBuL0JQVC9ndkxvL3hmVEgvQ0UvRUd4dEx2eEhGdC9jU1dNNFRUTlNWaC95MFpHaml1OXAvaVpEa0NwZitDTzBIaXo5amI5dmo0NGZBNkhTOWMxTHdqTmVUeTZmZFc5dkpjdzIwdG82dGJTT3lnckdKN0c1UWx5UUdaWVY1NEkwbEhtamVLN05mcUN0Yit1aCt2ZmpuVU5OOGNlRXRVMFBWbDg3U05jc3B0T3Y0ano1c0UwYlJTTGozUjJINDErQ2Z3WjBQVVBFL3dDd0IrMVAreXI0bGtqdXZGWHdUMWVYeHg0ZEJCYjV0UG5OdnFRakI2S1kxeWlyOTVyMXp6bm45TFAyalA4QWdwVjhJdjJaaGN4ZU1QaUpvTU9xd2dvMmk2UEovYkdxaGdSbEhoZ3lrTGUwMGtkZmxKOFkvd0RncVI0WjBUOXJUeHA4WFBoWDRCczIxZnhSWngyQ1hIakZHbG1zbU1DUVQzQ1cxdE9MZHpPa2FneHorY3FsR2JKTWhBcWpScWZhMDlmOHR6UG1YMmRUOVJmK0NVSDdXT3BmdERmc0UrRGJpNkZ4Y2EzNE50VDRiMXFRZ2tSeVdJV09PVjVEeGg3WTI3czdIQlptNU9Ld1AydS8rQ20zd0kwRHduclBnbnhGNHVoOGIzM2lpem4wV2J3NzRMaUd2WDF5dHlqUU5CNWtiTGJKSWQ1VUtaUzRiSHk1NEg0aGZFajlxTHgxOFR2QldrZUU5UThYZUtKdkNPaVc2UVduaCtYVVpQN0xzc016WWl0d2RnVWJzRGNDd3gxQXdCOWtmOEd5L3dBQjRmamIvd0FGVTlCdXJpenM3dTM4QStIdFQ4VEtrNUg3cVpJMHRZSmtYQjNTUnozY1RyMDJsQTRPVUZhL1Y2Y2ZlMy9JcVBOSjJiUFh2MldQMlR2akY4VXYyUHZFWHdsOEIrRGZocjRXaThQK0s1TGZ4UW5qWFd0UWJ4TkxybHNMVzVMVzltSWpiMk0yMUlGQ3R2Um5SeHVLbHErQmYybFAydjhBNHpmdERTV2MzeEM4WWVOdFUwWFY0R3VkTHM3NTJ0TlBudGtta2czeFc4WVNCZ3NrTXNSWlZJRHhPTTVCcjlFditDelh4MTFiL2dubC93QUZQL0cyb3plSGIyVFJmaXA0WTByVmhHQi9vOS9xVm9yV2kzTWZtQm9GY1JJNk0zbHlsUzI0S0dZTVB5ejhjL0VKZkdOMXFFTnpZdGF5dHFsenFsbkV0eXN5V2FYT0dsaXlBTS9PaUVEZ0RjNXdDYTZGVWwwMFQrUVNqSG9jN0xiYm94c0NyamdLQjAvem1xS2k1bmVhRllKNXJqZGx3RTNPaFU4OXNqQnJUaERCODhGajJBN1ZQcXR0L2I5MGx4Y0dYemhHc1R2RUFtNVVVS3U3ams3UUJucWNaT1RrbUV4MlA2VnYrRFdMOXBuWFAyaGYrQ2EzOWw2OTVNemZEVFhaUERHbTNDUmlNdlpyYndUeHhNRlVEZEY1eFVNT3FGTWtzR0o5Vy80T0d2aGRwSHhML3dDQ1IzeFV2dFMwZTMxYSs4RUpZK0pkSE1scjlvYXp1WWIyQkpIQUhJUnJhVzRqbFBBOHFTUWtnREkvUGY4QTRJcGY4Ri9mZ1QreFAreDE0YytFZmp2d1o0ajhIM25oMjRtZVRYdkQrbnJxVmhyaG5uTHRkM1FNaTNFZHdGWlZZS3NvS1FyczJBSkN2cW4vQUFWMi93Q0RqVDRGL0VmOWpQeDk4TS9oQmZhMTQ2OFIvRURTcHZEOG1veWFMY2FmcGVtV3R3UEx1SldOMHNjc2toaVoxalZJeU54RE13QzRhbEhTNHBmRm9mZ0EyaFc4ZHpKdGt1dnN2bTc0N1NWdzJCbmdPd3h1eHdDUXE1NjhkSzBSR0xxV1NSVS8xbVNRcTdRTWs4QURqMndQVDhyUnM5eEFaVytZTGsrL3QvaC9rWExHd0xJdTNjVzRYQk8wRDZISHYvbnBVN2xGT1BUWlVseDh5NGJDOFlIMS9Hcm45bW1PQm1NWVdNZk1Xd2ZsL1RqdmlybjluQXR1ZkpBWHNlZzZjanAwNzE5UmY4RTJ2MkdQaWQrMGwrMFY4UGRjOE1mQzN4UjQwOEg2UDRwMHUrMWU4dDdQWnBNbGxEZVF5WE1iWGN4UzJETkVyalo1bTQ5QUQyTnR5b3hiWjl0ZjhFOXYrRFdlZjR1ZkNmU3ZHWHgwOFdlSVBCc212V3FYVnA0VjBTQ0pOU3M0WEFhTnJ1ZTRWMGhrSzhtM1dFc2dLaDNWOThTK1UvOEFCWFAvQUlJQVgzL0JQWDRkeS9FendMNG92dkdmdzF0N2lLMDFlUFU0RWgxUHc2WlhFY01zanhZaW5oZVJsajh3TEd5TzhhbFdEYngvUlZQQzl4ZFNPekJ0N2x0Mzk3SjYxRHEvaGpUL0FCRnBrdGpxVmpaYW5ZM0JVeTIxNUFrOEV1MWd5N2tjRld3eXF3eU9Db1BVQ2psNmsrMDExMlA1UGYyVnYrQ1ovd0FkdjJ4bmdrK0hmd3Y4VWE1cHR3UWcxbWFIN0RvNkRIWDdiY21PQnNaeVZSMmZCKzZUaXYwYy9aaS80TkxOVzFXU0hVZmpSOFRyUFI0MllQSm9mZ3lBM2MrM0hDbSt1VldPTmgwTzIzbEI0d3d4eisycFpwTm9MRWhBRlVIK0VEb0JRL0EvK3RWYXZjZnRPeVBtZjlsci9nanoremoreUFiYTc4Si9DL1JMN1hiVWhrMXp4RXAxdlVnNDZTSkpjYmxnZjNnU1AweGppdnB0M2VkOTBqTTdZeGxqazFSMS9Yckh3cG9rK3FhcmZXV2w2WmE0TTk1ZXpwYjI4SVBIelNPUXEvaWE1bGZpOHV2eC93REZNNkhyWGlUZHd0MklmN1AwM25vLzJtNDIrYkdldSsxU2Zqb0QwcWRFUjd6T3l3Qi9rVlI4VGVKOUw4RTZLMnFhM3FlbTZMcHNiYld2TlF1bzdXM1Vub0RKSVZVSDJ6WE4vd0JnZU1QRTR6cVhpQ3k4T1FubjdMNGZnVzRtWDFWcnU2Umc2bjFTMmhjZG16elhNNnY4TU5EK0YzeG04SGVMYld6a2t1THQ1L0RWN3FGL2N6WDkxRUxvTExheW01dUdrbEdMaTNXMlJRNEdkUXhqcGd2MkRsWGM2cGZpbmNhN0dmOEFoSFBEbXQ2enUrN2RYY1RhVFlEMEprdUZFcm9lendRVEtSZzlLcTZycEhpSzcwbTUxRHhMNHVzL0RHa1dzTDNGMUhveUpicGF4S0N6K2RmM1FaaWlxQ1RMSEhiRUFFL0xpdXprYjMrOGE4ZCtKLzdPdXZmRUR4ajR3VzExMzdINGY4ZmFGZGFQcWoza3d2SmJGSnRQTm9zZGxiR0FDSlZrV0s0TzY0WkdaN2tHTGRNSkVOZW9Sc1hkVThiZUIvZ2RyL2lDNGgwSFdaOVo4T2FNMnRhcnFzbGxOY1hmMkJXQWR4ZjNiZVpkS2k3Mkt4U1NoQWhVaEdLSzJQcTN4NzhhWDN4ZTAreDBydzk5cThOMjkvZjJXci9ZTGY3YlBBbG5laUNXWHp2TVFiNUxhNjA2NmhoaWlrY2dYcXNXTUtxM2ErRmZoajRZK0RNT2p3L2JMdG0wbTN2TEhSbDFDN010eGJXZHpKREpMYVFxb0JraERRUTdFS3Q1YW9pSnRSVlFhK2dqK3g5SmgwM3c1NGJ0OUoweTJCRUVja2E2YmF4cVNTZkxnUlM2bmNTZHJSeGc1SnprMVNTV3dYWFU4WHNQMllQR1h4TjhNYUxvL2pIeEZybW13K0dkV3N0U2l2djdSajFEVnJpL3RyRFVMT2UvdEpwUk1MU09hU2UwdUlrYmM4V3ljYllpNmhmWWRFMGJRdmhicVdyemZhSUlkWDhWWGFhdHFNY01RV1RVN3dXMEZzOXdsdkdDMjU0N2VMY0VEY3BucmtuUy93Q0VjdkwvQUNkUzFhNmxWdXNGaURZeGV4M0tUTm4vQUxhNFA5M3RWL1N0RXM5QWhlT3l0YmV6U1E1a0VNWVh6RDZzZjRqN25Kb0J5YktKMWpVdFJQOEFvZWxtQ00vOHZHb1NlU01mM2xpWGM1eC9kZnlqN2pyWEhlRS9ERnhwSHhlOFRhVHFXcVhzMXJyMFVYaU95aHRDYkczRW1FdGIyTkJHM21ZVm83V1ZnMHJCbnYzT090ZWsxeHZ4Y0g5Z3plSHZGUy9ML3dBSTNxS3BmT0RqL2lYWGVMYTRESG9JNDNlM3VuejJzUWUxTUYyT28wblI3WFFyVXdXTnJhMk1MSGNZN2VKWWxKOWNLQU0rOVdjVmxqeGJhM0pLMkt6NnN3LzU4bEVrZkhVZWFTc1dSL2RMZysxR3pXTlErOU5aNlhHM1h5aDlxdU1lek1BaU1PNEt5RDM3MGlUVmtrU0dGNUpOcVJ4Z3N6TVFGVUR1VDJyS0hpMjN2UDhBa0h3M09xWjZQYW9EQ2ZjVE1WaWJIY0t4UHRuaWxUd25aZWNzMXlyNmxjS2Q0a3ZYTTIxdjd5SWYzY1ovNjVxdGFqQTUzTVMzUFdnRExFR3JhZ2YzazlycGtmUXJiSjlwbTlpSkpBRVgzVXhOL3ZVVzNoS3h0N2xKcFkzdmJtTTdrbXZKRGNTUm4xVGRrUi9SQW85cTFFNUpxRFZOUnR0RnRoY1hseGIyc0dkaGtta0VhWlBRWllnWlBwMW9BbDUzSGR1SjlUWE9hVzM5Z2ZGZlVyUE9MZnhKWnBxa0EvNmVMZlpiM09mVE1UV0pBN2xaVDJOYUxlSXBOUXdOUDArN3VqbmlXZFRhUUQ2bHg1aEJIUXBHNDZWei93QVJvTlEwdlQ3RHhKY1hrTWErRnJ4ZFNtZ3RvZmsreWxXaHU5N3RsbkNXOHNzb0NDUEx3cHdlbEJTWFE3ZkhGVXZFdWd4K0tQRHQ5cHN3VXgzc0pqNTZLM1ZUK0RBSDhLdk11eHl2OTA0b3ppanlKUG1MVXZobjRKdC9FMmsrTHRmMDNTYlhXdkJzc2x4cDJzenFzTnpwbTVIaGxqV2JodkxramQwYUxKVnR3K1VzRkk5VWlrWmlHenVCd2VEd2ZwL092ekIvNExLK0tFL1kvd0Qyb05lMWpWdFR1clB3cjRndG8vRTFxSGxMUnE4ck10eEdpazh1YmlLVXFxNC8xaURwaXZvbi9naXQrM0MzN2VIN0MyaStLTlFrVmZFV2c2amVlSDlZaDQvZFBDNWt0dW5YTm5MYTVidTRrOUs3cFVZcWpHU2VyL3I4ekNFbXFqaTEvWC9ESDE5RWN0L2dPbFdFYko2WTIxWGhPUjkwaFY5YWxpZktyMDVQYnY4QTU0cmxOeWRXMit0U3FkK1BwVU1iQWtaYlByeDBxVlJuN3ZmOWFBSmxmUDhBUDZVNkxqLzY5Um8zNTlPdlNucWNBVUFTcDhwSFlBVklHd2Zidm52VUk0SGYzelRsNjlmeW9Bc0krQjhwNjlSL1N1VzFQNEkrRmRXMVdUVUYwZUxUTldtNWZVdEhsazB1K2I2ejJ6UnlINkZpRDZWMHFzUVF3L1AxcVFEY005T080b0dwTmJITHcrRmZHWGhvL3dERWw4Y1NYa1hHMjE4U2FiSHFFYUQwRTBMVzgvNHlTU0g2MWFnK0szaXJRY0RYUEFzMTFFb3dicnc1cWNWOEQ2czBNNHQ1VjlkcWVhUjA1NjEwU3ZuK1hJcHdPUi90VUNNM1JQMmhQQnVzNmhGWXRyMXZwV3BUWVdPdzFxS1RTYnVZK2lSWFN4dko5VUREM3J0bWphSURjckx1NTVIYXVXMWJTclhYZFBrdEw2MXRiNjFtRzJTRzVpRXNiajBLc0NEWEtXL3dHMFh3K2QzaHE0MXJ3WklweWk2RnFEMjlvamV2Mk50MW8zL0FvV285UXN2Ni9yOUQxUWZuL1dwRkpQOEE5ZXZNNFpmaUo0WHg5bjFidzE0d3QxNlI2cmF0cFY0M3ViaTNEd242QzFYNmlyVUh4M2ZSQnQ4U2VEL0ZtaCtXY1BkV3RxTlpzeWZWV3RDOCszL2FrZ2ovQUFxYkJxZWhxY0gvQU90VHdNblA4NjUzd0o4VWZEWHhQODVmRHZpRFI5Ym10MTNUdzJkMmtzOXRuL25yRUR2alBzNEJCNHJvQTFLd3ZKa2lPeWM1UDB6VWlYVGQvbXFGVG1uVWhPTnl3c2lQMStYM3B0OXBWdnJHbXpXbHhIRGRXZHl1eWFDWkJKRktwNmhsYklZZXhGUktNaitMNjA0Y054UU8ydDBmSW43U3YvQkFuOWt2OXFUenA5YytEUGhuUWRVa0RZMVB3bXJlSDdoV2JKTWhXMEtReVBubk1zYjVQWE5mQ1B4bS93Q0RNdndycU91ZWQ4T1BqeDRvOE82YXpmUFplSnZEOE90eUtNL3czRU10dDBIUUdNNTR5dzYxKzFxWEx4LzdROTZrRjZwKzh0RVZiVmFENXBkVDgvdjJzLzhBZ25kNGsrQVAvQkJIeG4rejM4RlcxRHhSNGxzL0RKc1k1ZklqaXZOZWFhK2p1TlRaSWdRb2ttaGU3V09FTWNCbzRneElCUDhBTGQ0MjhFNnA4THZGTng0ZThWYUxyWGhQWExCdkt1Tk0xcXhsc0xxMlljYlhpbFZXVWpIY1YvY3FxeHk5MXpYTS9GdjREK0RQajk0V09pK092Q1BoZnh0bzdmOEFManIybFFhbGJqNkpNaktEN2dWU25KUzV0eW91UEx5dm9meHBmc3QvdEZTZnN6Nno0Z3ZWOEMvRGJ4L2IrSWRIdU5NOG54WjRkdGRYWFRabmpkWWIyMGVWR2FDZUdSZzRLSGErM2E0T0ZLK1d3MkRXNktveXdVQUFrNXppdjZqZjJqLytEV0w5a3Y0NXZjWFdoZUdmRXZ3cDFhNGRwV3V2Q0d0eXh3c3g3RzJ1dlBnVkIvZGlXUDhBRHJYd3A4Y2YrRE9mNHBhSHFVWitHWHhvOEJlSnJBdWYzWGkzUzduUmJpRlNjOHkycVhRbFlmM2lFK2dIRmJSclIrMHJDNWROR2VvZjhHaG53YXQvaDk4RS9qQjhXdGFaYlhTOTl2cENUeTVWYlZZa2U4dm1QcXBnYlRHejIybjFyOGZQaXI4U2ZDdjdadnhyOGY4QXhLOGJ4YTlaNjU4US9GR3BhK3M5dTZTcmF3VHpNMFVPeGh5c2E0VVlZY0FEb0svb2U4Yi9BTERuaXovZ252OEE4RzkveEsrRS9ndEY4YWZFUnZCZXFMcVUya1drZy90SzZ2SS9LdWpieDh5TjVObVRGRng1amkyakpVT3hXdjVxL0RBMHViVExXMXM3Nnpta3Q0eEc4WmZiSXJMd1R0T0QxQjZpdEtQTFVydHUyMm45ZklqbGNhSzgyL3cvNGMvdEcyZk5uQXI1citQM3c0bThDK01ZOVEwOWZMdFpuOCtGaC9CeU55Zmh4Z2VoRmZUWGwrL0ZZZnhEOEZSK09mQzA5aXlyNW1OOERNUHV1T25QdjBQMXI4azhST0VZOFFaUlBEUlg3MlB2UWZXL2I1N2V0bjBPNkRzL0k1cjRIZUwxOFIrSHZLWnZuUWIxSG9EMUg1MXJhVjRLL3M3eGJmYW84bm1mYVFBaWtjcDY4MTQ5OE9kVnV2aHI0NEZwY0xKSEdzbTFrUFlkQ01mNTdWOURLVm1SWFVobFlBcVIzSHJYelhoZm1GUE5zdWhnOGVuN2ZCVDY3N05SZHZKTng4ckRsZU8zVXB0QVR5SytldjI1OVREdDRmMHdNQ3lsN2xsNDdrS1AvUVRYMGU2WUgvMXV0ZktQN1ZVeDhRZkd5NkROKzQwcTJTTUQrN2hBeFBQdXhyMnZGWEdmVjhpZFByVW5HUDNQbS84QWJUbXFYdFkrYi9HM2oyNThNL0VKSjFBa2hpakluaEJ3SFE0R1A4UHArZm9taXlIUlhzOVN0MWtYVDlRVHpVTEE5TS8wT1I5UlhpZmpHWC9oSVBGN0p0Wi90RnlzYUgvWlU1UDY0cjlFTDM5bjZ6OFQvQUhRTkg4cElkUjA3VEl2SmtLOGh5Z1psUHNXSi9HdjUxd2ZCZUx6NnBXbGw3dE9qVFVrdjVuZjRiK2FUdDVvTUwvQ2ZOM1BPUGgzckMzak5FdUcrMExsVG5xZlQ2MTdyOE52Rm45czZhdHRNLzhBcE51QU9lc2k5QWZyWHlwb2t0NTRMMTMrejd0WklaN2VYQTM1eUNLOVg4SytNL3N0M2IzYXZzRWg0d2VqZDFQMXJ3K0J1Tk1Sa0dkS3BPOXZobkRhOGI2Lzl2UWVxNzNzZFd2THl5UGVqSnRGUlRYV0RXUlkrSm85VjB4SjQvVEJHZnVtcXZpbnhmWitEL0RkL3JHcTNVT242WHBkckxlM2QzT2RzVnZCRWhlU1JqMlZWVmlUNkN2N2t3ZU9vNHloREU0YVhOQ2FUVFhWTTVkdHpWdTc1YmRDenR0VlFXTGVnRmVIK0s5Wms4WitOV1VaYU1zSEk5QjBVZmxYUTZ6OGJORThaL0RPMTF6dzlxMW5yR2s2eEVYdGJ1MWszeHlKa2c0UFVFRUZTcHdRUVFRQ0NLNG1YdzdxbXFmREh4S3VuM0UxanJtcTZWZVE2ZGNSbmJKYjNMd09zTWkrNnVWSVBxQlg1cnhsWG5tZVowTWh3NzB2elQ4dTEvbHI4ekNwNzB1WHRxZWxYdmpMUlBoVm9Xbi9BTnRhcnArai93QnAzY2VuMjV1NTFoKzBYTWdZeHdydUl5NVZXSVVjNFZqMEJ4ZnZ0WjJPM1AzZU9hL0FqeForMkI0bC9hWS80SlhTZURmaXhyMS9lVGVFMjhQZkUzUk5iczBMWG1wK0dKYnVUUU5YZzVPV25zTHU1dW85ek51Y1lPQXFacjlMditDYlg3VXV2ZkZqOW5HYnc3NDR2STd6NG1mQ1hWYnJ3SDR1bUVtLzdkZVdKQ1IzeXNlWkV1YmN3eWlYcEk3U2taQXI5TnBZZU9Ib3hwdzJqWkhUR0plLzRMRS90SGZFZjluajlrM1N2RlB3dnU0N1h4RkI0eDB1eGtXWWp5SjRybnpyZU9PWXNRUEpOM0phYitSbFFRVGdtdmczOXNmL0FJS2NhdDRTK09IN01mN1ZuaHVMVXJMdy93Q010QWwwYnhqNGJpVnpKRE5wZDNNbXEyRXFIQjNSeGFoZFBHWEErYXlobHhqRmZjZi9BQVVVK0hYL0FBMUwreE44VGZBY0lhYlVkYzBLWnRMVld3eDFDM0szVm1BZTJiaUNFRWpuQk5mbEQ0ejF1OCtPSHdrOFFYMWpwTGF0cC9qYXgwNzlvTFNyUkltOGhkV3RtL3NyeGhwck1vSkMzQmE0dUNnQUd5S01ZeVJucW95VWtUWS9jMC9FbXoxalNvTHl3dklMNnd2STF1TGE1aGNOSGNST0F5U0llNnNwQkI3ZzE4QWY4SEFYd3owZjRyL3M1ZUVmR09yUmlTeStIdXYrVHE4eVJlZExhNk5xaXJZM3NzYTg1bGpjMmNxWnlBMFFPRGl1Ni80SjU2TDR3K0ZYN0NPbDJ2anU0dDdQUi9oM1kzYXc2L2RYVVRRU2VIN2NzOW5kek1qR09IRnJzWHluWlhBaVVZeVFEOElmdG4vOEY5TkIrSjNnRHhCNFA4RC9BQTB1dFkwdnhCWXo2ZGMzL2k2N01JYUtSR1JpbG5iTnVWaG5jck5jWlVnSFp4UlRvejU3OWdsMlJ3ZXE2LzhBRUh4ejhkZmh2OFVOQTAyYld2ak5va01HaWF4YVdaYTR1Tlc4VWVHWjBzWm9HWlFUSWw3b3NzVE1GSDcyUldBSkNuUDZXL3RCZjhGRnZoTCt6ekMzL0NhZkVMUTlFMUpGM0hSTGVUKzFOYVE0QkVjbHJhK1lZbTdmdldSUWVNNHI4S1BpMyszZjhSUGlwSERvT3BlSjdxKzhLYVZiTkRwK21SeHcyRU1JOGtSK2F3aFZOOCt4ZHBsZmRJVloxejh4RmVPYVdNUkE4S3ZwakFQTmRjNkZOcjN0ZjYvcnNUelBaSDZDL3dEQlFIL2dyMTRBL2FnOFhlRTVmRGZ3N252ZitFSHZaNzIxMUR4aUlwclhVbzVJd3M5cE5wMFJJTUV2bHhFNXVDMllrR0JrMThrZkdmOEFicCtKSHg4dXRZdWRjOFJYVmxONGdTRzJ2N2JSUXVrNmZlV3NNUWpndDViYTNDUlNKR2cycVhESEhCSkFHUE01ckg3WktxS3lJWkNFRE93VlJuMUo0QUI2bjZtcWMyaVRhWmZYRnRxRE5wazl2RjVxeHp4TUdrSkFaRkFBL2lVZ2hqd1JnNXdSV2tiUlZvNkU4cDd4OEkvK0NaUDdSSHh3OEN3K0pQQi93TCtLdmlEdy9kUitkYmFoWmVHcnByVzdRL3hRdnNBbEI5VTNWNUo4VVBoSDRvK0VQaXErMFB4VjRkMXZ3dHIya3FyM2VtYXpaU2FmZXdBa0Fib1pnc25PUWVCbkdUMEJJL3FyL3dDRGYvWFBHbXVmOEVndmd2TjQ3ajFwZFlYVGJtS3pmVlE0dVo5TVc4bkdudmhodThyN0tJUkVUd1lsaUtrcVZKNTcvZzRlL1k0OEwvdFRmOEUwL0huaVBWTEd6WHhoOEo5Sm04UytIdFpaQUxtMFNIRFhWcnYrOFlKNEJJcGlKMm1UeW54bEJVUnU5VFNWbG9meXB3d3RGSEJjYjdlVHpwTnZsQmh2R0QzWHNEL25xSzlyL1loL2JSOGIvd0RCUG45cExSL2lkOFA3aXlYV3RIODIzZTF2b21tc2RVdFpWS1MyMXdpc3JORzR3ZmxaV1ZsVjFZTXFrZVRSNmZISGNGbGpVTi9zZzRIMDlQd3FkQUI5RzQ1cDNKUDBKLzRLZC84QUJldUgvZ3FKOEJOUDhIZUt2MmYvQUFUcHVxYVBNOXhwbmlCdGZ2cm01MFNhUlFrcjJxUitTQnZWVnlrelN4a29oWkdLS1IrZk1jVWJNendXdHZaeHNkMjJMZXlnZlZpellIMXBzRVdEMHorT1J6VnF6dG1rTzNKQ3NNZjczTkhNSEtSeFFzT1EzSFFFZHF2VzFvRlk4OVFUdTZIb01VUjI4aXhzdXh2WG9jai9BUFZpdlh2Mlp2Mkx2aXgrMkZxY2xqOEsvaDE0dThiT0poRFBjYWJwN3RZV3plazEyMjJDRWM5WkpFN2RjVlBOWkZxTGV4NVBER3djc3FyMXdPT3ZQWCtmNDFaUzBFeTc5eW8yT3FqcjA1YlArZnFLL1hMOWxQOEE0TktQaWQ0d1MzdnZpOTQrOE5mRDIwWmxkdE4wU0wrM2RWMjU1amFUTWR0Q3hHZm5SNXdEajVUWDZTZnN0LzhBQnY3K3kzK3kzOW51b3ZoN0g4UU5idDhFYW40NGxHc3NXL3ZDMVpWczFQb1JCdUdCOHhJelJxOWcwVzdQNXpQMld2MkNmakorMlRkN1BoZjhOdkZYaktQelBLa3Y3U3o4dlRvRDZTWGtwUzJqYm5vOGd4K2RmcE4reXAvd2FaZVBQRTZXOTk4WXZpSm92ZzJ6WWlSOUg4T3hmMnhxVzN1ajNEN0xlRnY5cFB0QSt0ZnV6WjJjV25hZmIybHZERmIybHFnaWdnaVFSeFFJT2lvb0dGQTlBQUtsNkNxNVgxWXVkZEVmSlA3TDMvQkRuOW1YOWxHUzF2TkwrSE5uNHUxNjBJWk5hOFpPdXRYVzRITzRSdW90WTJ6enVqZ1J2ZXZyWlRpR09NY1JRb0VqUWNMR280Q3FPZ0E3QWNDb3IyOGgwNndtdXJtYUczdGJaUzgwOHJpT09KUjFabVBDajNKcmtvL2pUcDJ1Si94VE5qcTNqRGQ5MjQwbUZmN1BZZjNoZXpOSGF5QWR4RkpJNDZiU2VLTklrODBwSFl0VUdxNnBhNkRwVTk5ZlhWdFkyTnF1K2U1dVpWaGhoWDFkMklWUjdraXZQL0RHdmVNUGliZTY3YTNWNXAvZ2h0QjFKdE51cmJURUdxWHBKaGh1SXBVdTdpTllGVjRiaUp0bjJSOXBMTDVoS211ZzAzNFA2QmFhcGI2amMyYjYzcWxxd2VDKzFpZDlSdUxWdldGcGl3dDg5U3NJUlNlMUhNK2lEbHR1VlkvakxhNitvLzRSblNkYThWaHVselp3QzMwOERzNHU3Z3h3eklUM3RqTXcvdStyam8zalB4UStMM1d0TjhNMjdFZnVOQ2dGN2VLZXcrMTNTZVdWUE9RTFFONk9NWktmdEE2djRtMGI0UmE1cUhoT09hNThRV1VjZHpIRkhFSnJpZUZKbzJ1RWhVcElEY05iaVlSWmpsSG1iTXh5RDVENXY0cy9aNjhmZUxmaVo0dW11ZkZqTDRiOFFhV0xPMXRKYis0dUUwYTZhM3MyaXY3WmQ0aGVXenZyRnBZMEZ2YmVZdW9PeG1CakVSTFBxeHJZMDlUK0lud3ArRitnYXA0MEY5QjRvdXZDdHhadzN1b3czTGVJTlcwNDNWMnRram96dThxUmVhMGdLd1lYRU02b2pNaFN1cytISHhmdXZpRDhTdkVXa3ZwdHZhNmZwZW1hZHF1bjZqRGZSM2tPdlc5OUxmQ0c2dDVFT0RDWXJSRDh3REI1SEEzSXFTUzVFbjdQL2hQUU5RdnIvd0FSM2kzK25YZDc5cXM3SFVuaGlzZFBjNm11cTdJZ0FHay8wOUVsVlpXY0tFUkVDcnZEOWRwRjk5aHNZN1BRZkR6dzJjUVBsaVNFYVhhUlpKWWdJVjgwWkpKeXNKVWtrNXFra3RrT1ZqbytwcmxQak5wTnY0aCtHK3FhUytwMnVrYWhxTVAvQUJLN21kd1BJdm95SmJXWlY2dTBkd2tVbTBBa2xPbGFaMFBVTlVVL2J0VWtoallZTUducDluR0QyTWhMU0VqKzhoano2RHBWclNQRGRqb0Vra2xwYXhRenlqRWsrTjA4MysvSTJYZjZzeE5CQnozdy93RGlsSjhWZkErazYvb3VoM2tGdnJWbEZlS05SWTJhMjdPZ0xRc3JBekI0MkpSZzBRRzVTTTFyL3dCZ1gyb25Pb2FyUHM2R0d3VTJjWkh1K1dtM2U2eUlEL2RyRCtHby93Q0VhOGFlTVBEZjNZcmU5SGlDeUdQK1hmVVhsa2tCUGR2dDBWKzJPeVNSZXZQYUFGamdESitsTWIzMEtla2FEWjZENW4yTzFndFduSU16b2dFazVIZDIrODU5MkpOWER3S3k1UEdGaDU4a050STJvWEVaMnZEWklaekczVGE3TDhzWi93Q3VqTDM5S1laZFkxUElXSzAwbUk5R21iN1ZjRWVoUlNxSWZmZklQYWtJMTl1UjlPVDdWa3Y0enNaSE1kbTAycXpLU3V5eFh6bEREcXJTWkVTTVBSM1drLzRSRzJ1ei93QVRCcmpWajFJdlhEdyt4OGxRSXNqczJ6STlhMVZUQ0t2OEtqQ2dEQUE5QUtCR1h2MWZVTzFucGNMY2ZObTV1TWYrT3BHMy9mMGZYcFZQWC9oZG92ampRTC9TZkVNRTJ2YWZxMXZKWjNjZDlKNWl5UlNLVWNDTUFSbzIwa2JrUlQzelhSWXFPNXVZN08xZWFhU09HR01aZVdSZ3FvUGNuZ2ZqUU83NkhQZkNUeEJmZUovQUZqSnEwNXVOYXNXbDB6VkpjQmZPdkxXUnJlZVFBZEZrZU5wRi93QmlSVDBOZExqRmVjNko0c2owTDQyYTNwMm4yMTdxTnY0dHM0OWZ0bmpUWmJ0YzI2eFdkMlZtZmFqUitWL1poQWozbmMweHdlY2RoOW0xYlVmOWRlUTZlcDZ4MlNlZElQOEF0ckl1MGcrZ2lCSFp1OU1iM05LOHZvZEt0V251cG9iVzNUNzBzMGdqalg2c1RnZmpXZW5pWDdZVkduMlY1ZkE4K2NVK3oyNDlQbmt3V0I5WTFjZnBVbGw0WHM3TzdXNit6K2RlUi9kdWJobXVKMDlsZHlXVmY5bFNCN1ZvS3U0NTYwaVRMRmpxZCtjM043SFp4OWZLc1k5ekQxRFN5QTdoN3FrYmU5VGFmNGNzOUp1L3RFTUgrbDQybTVsZHByZ2owOHh5WHg3WnhXaGdEdC9LcTJwNnhhYVJ0RjNjUTI3U2NSbzdEZktmUkY2c2ZaUVRRQkt1V1hQdjNvbXQ0YjYxa3Q3aU5KcmVaV2lsallaV1JHR0dVajBJT0t6VHJWNWRIL1F0Tm0yOWZOdkgreW9mWEM0YVhJOUdSUWY3M2VnYUhkWGh6ZmFsUElyZFk3SlRaeC9YSVl5NStrbVBhajFBcC9DaTVtWHdiSHAxM0kwdW9lSDVYMGk1Wjg3NURDZHNVcmY3VXNCaG0ra3dycEFjQ3VQMGpTN2Z3UDhBRkthM3RZSWJYVC9GRm45bzJ4cUVYN2RiYlVkaWY0cEpiZDQvVTdiRmp6ZzEyQTZkUDA2VUZTM1B5ai80TzVmMlMyK01YN0JQaG40cVdGdVpOVStEdXVEN1k0Ykd6UzlTTVZ2TXhIOFcyNmpzY2YzUThoNEdhK0VmK0RVLzlxNy9BSVZyKzF0NHMrRStvWFFUVGZpZHBIMjNUa0pQR3A2ZUhrQ2pzTjlvOTJTZTVnakhzUDZHUDJpdmdUcFA3VVB3QThiL0FBMjE1aEhvL2p6UXJ6UWJtVW9HTnNMaUZvMW1VTnh2aVlySXA3TWluZ2dHdjQ0L2hYNDU4Vy9zQmZ0amFWckV0ckpaZU12aEQ0cXplMlRNVkp1Yks1TWR4YXNSMFYvTGtpYjFWeU85WFNsYWRuc3laM2NMcm9mMkVXNTNqZ2JjOWVjMWFoYlBwMTZWemZnTHh4cFh4SzhHYVA0azBHNlcrMFB4Rll3YXJwdDBEL3g4MnM4U3l3ditLT3A2OFpyb0l6eHU5eGpnMVRUVHN3VHVyb3N3dnRHNytlTVZLZzR6N2Q2cnh0eCt0VHFNbi82OUlDUmNzcHgyNHdhZUdLcDlPY0dtUjg4YnYvcjA0TmdZeHg2SDBxZXR3SmxiWXZQSzlxVkdKSDVkS2pYanEzemQ2Y3AzZm5uNjBBVEE1Si92WjYrbFNJZW4xOWFoSDNzWlA0VkltVHoxOVNhb0NaT0FPbFAzSFA4QTlmcFVTbm5ydDlNOG1wRkovVE5BaVFIay93Q2NVNUc0UDlEVVN0ejk3ODZlbzNOK0hVaWdaSm5CL3dBYWVuRGRjRWRDT01WRm5KL1VtcEZIT090QkppK05QaGo0ZCtJNGgvdDdROUwxZVMxTzYzbHVMZFdtdFcvdlJTWTN4c096S3dJcDN3WTFHN3M3enhGNGJ2TDY3MVJmRGx4Q0xXN3VwVE5jTmJ6UjcwamxrUHpTT2hERGV4TEZHVGNTMldPMHZKWHB5ZXRjNyt6bEgvYW5oalhQRVRBNy9GbXUzZDZnUDhNRUxDeWd3ZTZ2RmFMS1ArdXhxZGl0MGVpSzJTS2NhamorWTA4VklDcU5weitkUFBOTXljZjFwdzRQM2FBSFVVWjVvb0FUQXA4VTd4bmhxYlJRQlpTK1kvZUFiNkdwUmR4Uy9leXYxcW1yY2Y4QTE2TTVOQlBVdW0yamxHVkk5UVIycnc3OXAvOEE0SmxmQVQ5c2tYRW54TitFbmdmeFpxRjBOc21xVDZhc0dxWTlyMkhaY0Q4Sks5a0JLdHdmcFUwZDdKSC9BQmJ2clJaUGNwU2EyTVVMdC84QXIwcFRJemo5S2xBMmppbXNtNDE1NTBIbS93QWIvaHQvYmxsL2E5akgvd0FUQzArYVFLT1prSDlSL0tybndhOFhMNGg4TnJiU0gvU0xNQUVaNUs5dnlydVpVMi9sWG1uaWJSZitGWStOcmJXTE5kdW5YMG5sM01hL2RqWTlmd1BVZS80VitWOFI1WThqemlIRk9FMHB5dERFUi91dHBlMFhuRjJjdkpYN21rWmMwZVIvSTlBenVmSHZpdmlINHllSVpOVzhVZUxOUTZxWjVRcFBwdUk0L1Q4cSswOWQxTmRPOFBYbDRyYmx0N2Q1bElPYzRVa1YrZjN4bjFYK3d2Q1UzVlpiNW1iZG5yL24rbGVGNHk0cFNoaGNPdHJ5bCtTVC9GbkJpSGFMT1YvWnQ4QS84TFYrUEdoNmJzYjdQOXA4K2NnSGhBZHo4LzdvTmZwbVdWYzRHMVY2REdNVitkMzdISDdRWGdMOW1YWFpQRUhqN1dvZkQ5cnFrUnQ3ZTl1Qi9vMWt2bjI4THp6di93QXM0UkxkVzBSa1B5cTF3bVNBU1IraFYxSzF1em93MnN2VWVocjFmQjdLNDBjc3E0OS9GV25iL3QyR2kvSG1ONDZVb3BmMS9TUEsvd0JvcjRUMmZpeEk3NjFlQ0hYQWp2RkJ2QWt2RWpBTGxWemxpZ0lKSTZBak9NZzE0NzROMUI1SkpOUHVHMkZ1QnUvaGNkRC9BQ3J5UC9ncTc4TDlYK0x2N2ZId0Y4UGFINHAxTHdYNGk4Y2VEdkYraytFOWV0YmhvUm92aUN3T25hdlpUTVFDQ2p0YW1PUldCRHhHUVl6Z2pqdjJHZjhBZ29IWWZ0NTZqNHkwKzYwT2J3ajhUdmgrMEVmaXJ3OUpGNVgyUzRJOHE3OG9aUDdxTzlqbmpBeVNxbUxjY25uNER4djhPcFNhNGp5cW5lY2Y0c1YxWDgyaStVdStuVTJwdm1WbWZaL3c0OGV2bzkyMWplTnQ1MmtlaDlhL09INDgvRXI0amZEMzl2OEEvYUswVjlZMTNYUGgxNHAxN1MvQi9pblFsaU03VzJrK0xORWhzOU0xYXp4ODMraGFoQ1lKQWdZc3R6c1Zja2tmZnVuL0FHZnhSb1FtWi9MdnJmNUN3SFVlL3dES3FNSGhDeDFIeHEydU5idzIvaXlQU20wVkw0ZksxemFOS2t3alkveEJYVGN1ZnVsbXg5NDU4RHcvOFFNWnd6bDlOWStEcVlPdGQwNXBwcUUxZThKZHJ2cDMxVzRwUXUzYnRZODgvWW0vWnR0LzJkUDJjUEIvZ0lRMmNkMW9XbnhYUGlXNXRKSGtodnRYYUpEZTNBWmpraVNaV0k2REdNS293bzlXMUx4NnRsZG8wTGVXc0pCakFQM2NjaitsZm5mL0FNRlAvd0Rnb0I0ZjhONlA0cStINytJN3o0WjZsOE5mRXVnYXRvK3RTcmN6RHhEcTFyZHRjUzJrOXRiUnU0dGpERUpJaElBc2hFVXJGVU1PL0wrQlgvQlZyeGgvd1VXL2FPMDM0Wi9zL2ZENnlqdkw2Tjd5NjEveGpkczFubzFqRVZFMTNOYVdqYmlxNzBWQjlvRFBKSkdtM0xISDczd2J3L2lhTktXYVkzK1BYZk0vN3FlcWl2djF0MU1xTWIzZlZuaFB4LzhBZ0RxbGpGOFV2aC9vbWk2cnEycmZCL3gxZVgyajZmcDlxOXhQcWZnYnhmQ1k3dTB0b2tCYVo3YWR4SXBBSWprOHdqREExdWZzd2Z0WitILzJNdkdtbCtOL2lKNDU4UGFETjRvOEFXWGhueHI0ZjN6WG10M092YUpLOWphWDBkckNqdHRrczQvTFo1ZktVdjVqYmlTTWVxZjhGbS8yR0l2Z1I4UC9BQWI0NjhlL0VmNGorSk5HMWpWUCtFVStJR3NhV0xUUlBzbGxkUXViSjQ0TFdBZ1dNVjJpbVNLNGE1WnZOVUJ5NUJINDAvdEgrSEkvQVh4S3RkQXRkU3VOVzB2VDdSUDdOMUs5MCtTd3VycTFiL1ZlYkMrV1RZb0NBWjI0WGRrQnNEOUdqVGc0MmwvWDlianRKZjE1SDZXL3RGLzhIR2tFSDJpSDRXK0FMaTRicEZxdmkyZnkxNmZlRmxhdVQ2SExYUDFYdFh3NWVmOEFCVDM0ditEdFRzYmp3ajQxdXZEbGxMTGRhamRhQmEya0V1aWk3dUNSY1NOYVRJOFVubUV0SUZrVjFqODBLbTNGZUdYRXBCYU9SVHZRa2RNYlQ3L2lUV1RxV2p0ZVdFdHhISkd6VytDMFdEdWRUMVpleHh4a1p6ZzVBd0dJMXBwUlZvcXdwSHNQeEsvYjQrSzN4djhBaExvZnc0MWp4dnJjbnc1OE1RSmE2YjRiaGxXR3dpampjeVJoMVVBM0hsc3hLTk9aQ21BRktnS0I1amNQaFdHNWwzREJZbnJudC9uaW9kRXM0cGROdGRRMCt6dS8rSmZtSFU1cDVGYUNScE4zbGhPQVFTb1liUmsvS1RuQU9HaCtNcWR4eDM3Zi9YcHlsZDNCYkdwNDgrRnNYaG53UDRmOFNSNnhiM0duZUlQa0Z1cVNmYUlaNDJkYmhEOHZsWmp4RytESUg4dTh0enQrWnR1WHBscGJ4MlYvNU0wazFzMDZMYXZKRDVieWdCdHh6bmpHVkJBSnlXWHNEaTNaNjdkMmxuSmF3enV0dmNNcnl3azdvcEdYTzFpaCtVa2Jtd1NNamNjRVpOUVN2SlBJWkpONzdqZzdqMTVwc1NJQWR6RW5yL1BQcFd2NEs4WDNIZzd4em9XdVEyV2o2bGRhRGZRWDBFR3FhZERmMnR5MFRLNnhUd3lLVm5oT3hWYU9US2xjcmpCck0ydDgzeWhRdjRZcVZMVmdlZHpFYy9oU3VQelA2WVAyUnY4QWc1dy9abitQSHcwczd6NGdlSUp2Zzk0dWhpQzZqcEdxNmZlWFZuNXFxTnpXbDFieFNMSkNUOTBTQ09RWUlLbkFadmpIL2d1di93QUhEWGd2OXB6NEJhdDhFL2dUSnFlcmFMNG9kSXZFL2l1N3M1TEdHNHRJM1dRV2RuRklGbUlrZEY4eVdWSThJaFJWY1NGMS9IVzIweHJwMis4cEh5dDN5UDhBUDRWNkQrejkreVo4UnYycC9GTGFMOE9QQkhpcnh4cVViQlpZdEcwMlc3VzJ6ME0waWp5NGwvMnBHVmV1VFJ6cElPUnRubTMyVGxjNCtZNHo3NXhpdmV0Wi93Q0NWdjdTUGhuNGVEeFpxSHdEK0xscjRkV0EzVDNiK0dMcjkzRU1IekpJd25tSW1PZHpLQmpKNlYrdUgvQkNiL2czejhmZnN0L3RJVy94ZytPdWcrRmJDNDBHd2R2REhoOWRTajFPNzAvVkdlTUxmVGVUdnR3WW9STjVlMlYyV1NSSHdyUnFSK3kwTUJpbEVtNWhJcDNCZ2NFSDErdEpYZXdTc3REK05EOW5EOWp2NG4vdGQrSVA3TitGL2dIeFI0N3VGY1J6blJyRnJpM3RTZWhtbjRoaFgvYWxkQVBXdjBtL1pVLzROSXZpNzhRbzRiNzR1ZU9QQ3Z3ejArWUJtMDdUVi90L1YxOVZiWXlXc2VSMFpaNWNkMTdWL1FSWVdrV21XRWRwYXd4V3RyR3pPa0VLQ09OR1ppekVLdUFDV0pKT09TU1R5YWt6UnlQcUhNdWlQaDc5bFA4QTROM3YyV2YyV2phM2tuZ2FYNGxhOWI0UDlwK05ya2FrdWVPbGtxcFpZeU1qZEF6RCs4YSsyOU4wMjEwVFNiYlQ3RzJ0N0hUN05CSGIydHRFc01GdWc2S2thZ0tvSG9BQlU0SEROamhRV1kvM1I2bXVQYjQyYUxxYnlSK0gxdnZHRndoSzdkQ2hGemJoZ2NNclhiTWxvakR1cnpxM29DZUtxMFk2azNsTFE2L0F4U1RTcmJXMGswakxIREFoa2xrYzdVaVVESlppZUFBT1NUMHJreEQ0MjhXc3k3OUg4SjJyZG9GT3E2aVY5UXpCTGVDUWVoUzVUM05jMzRqMG53RDRYOHU4OFZhaTNpcTh0UTkxNSt0VGYybjluRU1zQ1N6cmJxdjJhM01UWE1ETzBVVVpSVzNINVZKQnpON0w5QTVUb1I4YnRIMWRQK0tidDlVOGFNVGhXME9GSnJVK3YrbVN2SGFaSGRmTzNmN05DV3ZqanhRRDU5MW9uaEsxNTNKWUlkV3ZpdllpYVpJNEltOVZOdk92b3h4azhQNHAvYXV1OU4rSzJtYU12aCs2VFM1cDd1M3U3MjRqbW5tdFRhWDB0amRTdEhDckNPR0dSdE5rRE8rWll0VFJnSWtobGtIS2FoOE52aXA4VlBDME52ZFhjc1BpRFEwdXROajFxODFPYlRyZVNhNGdSdjdVdDdhQzJoUG0yZDFiUmVVa2lNa2tOM2NJSjJVc3hOZXIrNHEzVTdqeGZmOEF3MytIRnNtcitJcjF2RldwV3QrMm53M0dvem5WcGhxWUNZdElWWS9aclM4azh4QWtFYXdGeTRDcmpPUFhKUTNtdDVqYjJ6amRuT2NWNWZwLzdPUGhmd2RxZmpMV2RUMUc4a3R2R1Y3TmRhckZjM2YyV3diTjQxMWJOdEJBam50eXhWWjBaWkd5TjVZUjI2dzl3ZkZyYWgveURiRzgxRGZ6NXhUN05iZ25vZDhtQ3luKzlFc2cvU2lLUzJKZXV4Z2FnRjhKZkhleHVEOHRuNDAwMXRNa1A4UDIreTh5NHQxQS92U1dzbCtXYis3WlJqc0s2M1VOVnRkRnN2dEY1Y1c5bmI3Z3BsbmtFYVpQUVpZZ1pQcFhDZkd2dzU0aDFyNGUzV29RM0FpMUx3OUpIcm1uMldsUmI3aTRsdG04MXJZVFNBN3ZQaUVzSHl4STJKenoycnJmRGVqNks2VzJyNlg1Tjh0NUNzdHRxUmxhNW1uaGtVTXJMTTVaeWpLUVFOMk1FWUZVQUh4UkpxQjI2ZHB0NWVBOENlZGZzbHVQcXpqZXkvN1VjYmltL3dCaTZycWJmNmJxYTJzUjZ3YWRIc09EMVZwbnl6ZjcwYXhIK2RiUUdPNVAxby96eFFTWitrK0Y5UDBTNWE0dDdWRnVtRzFybDJhYTRjZWpTdVM3RDJMR3I2akZVTC94VllXRjQxcTF4NXQybkxXMXZHMXhPbnV5UmhtVWU3QUQzcUUzMnJYL0FQcWJPMzAxU09Idm5FMGluL3JsQzIwajM4MEgyb0dhd0JZNEFKSjdDczI2OFYyTnZjeVc2ekc2dTRqdGUzdFVOeExHZlJ3bWRuMWNxUGVvZitFVFMvOEFtMUM2dk5VQjZ4VE9JN2MrM2xSaFZkZlFTQnlQVTFwV2xwSFkya2R2REhIQmJ3cnRTS0pRa2NZOUFvNEE5aFFJODgrSWwxcSttZVBmQi9pS0cxdGRMdGZ0VCtIcjU3dC90RXl3MzdSTENURkd3VGQ5dGhzNDFQbXR0VzRsTzNrZzlqL3dpVU42di9Fd211dFcvd0JtNllDRWowOGxBc2JBZGl5bHZjMGVQdkJ5ZVA4QXdScTJodE8xbWRVdEpMYU82VWZOWnlrZnU1MTlIamsyU0tSeUdRRWNpby9oeDR6YngvNEEwdlc1b0ZzN3E4dGc5N2IvQVBQbGNxU2x6QVQ2eFRMSkdmZERRVnJZMklZRmdoV05WV09PTWJWUkJ0VlI2QWR2d3A0VUNzb2VNYlc4NDA5WjlYYk9QOUNVUEY3L0FMNWlzSUk3cVgzZXhORFI2dHFRK2FXMDB1Tmp5SVI5cHVDUFptQ3hvM3FDa2c5KzRDVFVsbFdHR1NSMlZJNDFMTzdIQ29CMUpQUUNzdGZGMEY0dWRQaHV0VzdoN1JBWVNQVVN1VmliNks1UHRTcDRRc21tamx1WTIxR2VNaDFsdm0rMEZHSDhTS2ZralA4QXVLdGFwQmt5V1ptUHVhQU1ueU5YMUFEemJpMDB0ZTZXcS9hWmZ3a2tVSVBvWWo5YWt0dkN0bEZkUjNEeEc2dW96dVNlNmRyaVNNOXloWW55OCtpYlI3Q3RMR2FnMURVYmJTYmJ6cnk0dDdTRE9QTW1rRWE1OU1ualB0UUJ5dnhvL3dDSkpwT2wrS0MyUCtFUTFGTlJ1V0orWDdFNnRiM2hmL1pqdDU1WjhkM3RvL1N1emVQeTJaU01NbVFSNkdzVy92NC9FRmpOWnBwTTJwV2QzRzBFNjNhL1piZVZHQlZrYmVQTUtzcEl5c2JLYzlhNW40THByR3EvRCszMDdXdFdrYlV2RGNrbWhYMzJWZkxrdVh0ajVhelNTTnVmZFBFSXJnRlBMSUZ3UGFncm9keHFHcTIyalFwSmVYRUZySEsyMk5wWEMrWWZSYzlUN0RKcW4vYmx4ZE50c2RPdUpCaklsdTgya1g1TURMbjAvZDRQcUttMDNRTFBTWjVKcmUzamp1SlYyU1RuNTU1QjZOSTJYYi9nUk5YUExVYy8xb0pNeit5cnkrNXZOUWtFYmRZYkpQczZrZTc1YVRQKzBqcG4wcXpwdWkydWxGMnRiZUtGNWY4QVdTS3Y3eVgvQUhuKzh4OTJKTlhBZVA4QTY5VTlUMTJ6MDJieVpyaFJjZGZJakRUVGtlb2pRRnlQY0NnQ3czUWJlT2Nabzh2STlUV2UybzZqcUlLMjlpdHFoLzVhM3NuUHNSRWhKUDBab3lQcnhURDRkYTk1MUMvdTdvSHJFamZacmNldUVRN21VLzNaSGNVQVlYeGs4UVd1aWVIUDdRVjJ1TlQ4SzNFZXRMYlc4YlhGd0k0d3duSGxvQ3dMMnNsd2dKQUdaQWMxMjY3VzVWbGtVOHE2L01yanNRZlNxMmwyZHZwTnRIQmF3dzIxdkNjcEZGR0k0MStpZ1k1K2xjNzhJay9zM3d6Tm9MSDUvQ2wyK2pyay93RExCRlNTMStwK3l5Mis0LzN0L3BRVjBPcWM1UDByK1l6L0FJT29QMlJSK3p2L0FNRk83cnhwcDlyOW4wRDR6NlhENGpReHB0alRVSThXMThnUGQya2pqdUc5N3o4Qi9UbnMvd0E1cjh6ZitEckg5a2dmdEFmOEV6bThjMk5xSjllK0Mrc3hhMnJySHZrT20zUlcwdlVIb0F6V2t6SHN0cWZyVXk3aEhYUWwvd0NEZUQ0eXQ4V2YrQ1hQZ20xbXZEZVhuZ3U4dnZEc203NzhFY2M1bnQ0anovRGJ6d2hlZnVLbk5mZFVad0Y0em50akdmOEFPSy9uUi80Tm9QMjNiejRJL3R1MjN3eDFDL2tpOEsvRmlHU3hFRWpqeVlkVmlpYVMwbUdlUTc3R3RzREc3N1FtYzdGeC9SUmJ5N2xYNXV2QitsZFZUVzBsMU1vZGk3RzJkdkF4emppcG8yL2xuclZkT1BtNituZXBrYjVobjY0OTZ6TEo4N3V3Nlo1OVA4bW5vTUx1OU8xUW8yNCsvWEJPUDg5S21Ydjh2MTRxV0E3UFA0KzlQSFEvVEZNQjlGK3VlYWNCei84QVh6UjVBU0w3Wi9NMUp0SVB5N2ZyVWNmM1I3ZTFQRFpmL0E5YW9DWE9WSFQ2MDZNYm01elVhakREOU1kcWtqNG9Ba0k1L3dBUlRoOHBwaW5hTzJmcFQ4a0wrSFNnQ1JmL0FLNHB3T1Q3aW8xR2Z1aW5CK2VjMEFjNzhZdkZrL2dqNFYrSU5VdFkxbXZyV3hrK3h4ZDVyaGhzaFFlcGFSbFVEMU5kbDREOEh3ZkR2d1RvM2grMWJ6TGZRckNEVG8zSTVkWVkxakRIM08zSit0Y0I4UlYvNFNQeHo0RDhQZ2JsdTlhR3JYUUE1U0d3VTNTc2ZiN1N0cWgvNjZDdlUxSUE2MU1nZTF2Ni9yUWRHTUQvQU90VGhrMDNwU3EyNG1wQVVIajYwNVQ4d3BvNmRhVlNSUUJMUlRSVHVwelFBVVVVVUFIU25KMDUvbFRjVXBmMG9BZHcxQkZJdWR0TzZVQVorMy9PS0NQVDhhY0dHTS9yU08yZnlyenphN0k1T2F6UEVlaHcrSXRIdUxPNC93QlhNdU1uK0U5UVI5RHpXay9YanJVTW1RdFk0akQwNjlLVkdzdWFNazAwOW1ubzE5dzVIblIxdVdENGE2NXBkMmNYZW13UGJuUDhTdDhvSS9QK1ZmRUg3UmNLMzNpZTIwdUxkdFhhQ3ZwM1BiL09hKzRQakZvS2xvN3lOL0xOd0RCS1A3eEhLbjhPbjVWOFo2ZDRZdVBpTCsweXVsK1RNMHh2MHRwRnh5dVhHY0RIOTNtdjVEOFJzZGpNSlhqazlYM3AwVXFkTjN1NXhrMjZiZm5aeGkrN2kzMUlxVVZWbkZkMmVLL0VINFIzM2dYL0FJS2hmczYrR2ZpSloyZXFmQlA0L2ZEcnhMNEFuaE9VQzMxMmp6elFNM2FTWHlOTDhwaGc3bTQ1anlmckgvZ2xiOFlmRUVud1c4VWZCdngzcUV1cGZFZjltL1cyOEM2cmVUWVdiV3RNUkJKbzJxbGNraGJxdzh2QllsbmEza1k4azE4TmZ0aC90c2VFWC80SjgyZmdmNGhmRXZ3MXAvN1Qzd1orTHMrcGVDTGVIZGRTYWplYWY0Z21ObktQSlYxaHRKTEtkb1ZlWmtYTUl5U1Z3Zm5uOXBuL0FJT1VyZTAvYlY4UmZFLzRHL0QrYlJMelh2Q1VYaFRXVThZVExOYTZqSmIzUm10YnhyVzFjZnZvRWVlRkdOd3dhT1k1WG9LL3E3SU1uL3MzSzZHQWl2NGNZeGZtMHRYODNkbGN5ZTIzNmJyODJ2bWZwaC93V3V0TlgwWDluVHd0OFhQRE52Y1huaVQ5bmJ4cHB2eEJTMnR3REpmNmZDelFhamE1N0kxdE8wam51c0JIZXZqTDRsYXg0Ui9aKy80THVXUHhlK0hQaXp3eHJ2Zy80cTZSRlllT2JIVE5UdHBKTkptdm1pdGtudTBWeTl1czF5Tk5ueklBV2xlVUVya1ovTXY5cUQvZ3JOKzBIKzFaZUIvRjN4UzhReVdJa1dRYVJwakpwbWxvVllNdWJhM1ZFbENzQmd6Q1J1T1NhOEQwVDR4Nm40TzhUK0pwTkZWTE8zOFdXVTJtWGxwanpJNW9KSGpsVmZVdkhQRkJNamRSTEJHM2JGZXg3Q000dFQxV3o5Q1U3UDhBcnRiL0FDUDZ4OUswUFZQQ21qUVgyb1Jxd2tab0xrSmdGU0NjYnNFZ01WeG5CeG5QU3ZtNy9nb2Ivd0FGSU5OLzRKeStPZmhGRDRwMGVTKzhOL0U2NjFCcnJWNExqTW1od1dndDBCV0VLUytXdVZZbkl3c1RZREUvTHhmeG4vNEtoNjkrd0grd1g4S3RhK00vaCtYeE44VHRic3JlSzc4TjI5LzlqYTl1eEdwdVo3cWN4TUlTaUZmTVZVYjkvSzBhZktHbFZmam44UFBBdi9CYlQ5Z1czdWZEVjNhdHFHdzZoNGVtdVNTMmo2Z29PNjFuMi9NRUpKUngzQnlPY1YvSE9PeXZLY0RtenhkYW5PZVNZaXBLQzE5eUZaMmk2cVNYOE52bVViL2FWMXBZNnQxZUc4ZnlJUDhBZ3B6L0FNRS8vRFAvQUFWYi9aMHRmRm53MTFiUXBQRzYyeVhPazZ0YnVqV2ZpQ0FmUDlubGtYTzBuakQ5VktnSDVTd1B6Si93YkVlS2wvWk4vd0NDa3ZpcjRWL0VMUjUvRGZqRHgzNGJsMGpUNHJ5TVJTeFhsck1MbDdac2tFaVdPQ1lxVnlIYUtQYmtPcHI1Qi9aWS9iSStKbi9CSXo5cGUrMG14anZOYThIL0FHMWsxdndwY1hQeldwVmlKRUk2UVhNWndQTTJoWlFxTnlyS1IrcjN4aCtFL3dBS2YrQzFmN090ajQwK0hldVI2TjhUUERDTGVhQnIxbEw5bjFUUXI5QXNxVzl5WTJEcmlSVU80RWxXQ3ZHMmNFL3BXVjQvTmVCYTBNQm1VbmlNcm0xN09zdFpVcjdScVd2ZU8xcGJkZklJY3JUbkhmcWo3VS80SzQvc1MzdjdlLzhBd1Q5K0lmd3owR2VPMDhSYXhiUVhPa1NTTnRqa3VyYTVpdVVpa3gvQklZdGhQTzNmdXdkdUQvSXBySGg3VlBEK3U2cm9ldmFMcU5oNGlzN3cyOXd0K2tsdGNhZlBISXlUeHp4c04yN2NyS3diREt5SHZrSDdiK01uL0JjTDl0VFNkSTFiNGErS2ZqVjRvMDJiUjVaTkkxRmJYVDlQc2RXVjRpVWRXMUNDM1M3M2NFRnhMdWJPU1RuTmZGYnpTWEV4YVI1RzNFc1N6SEpKNXo5Y25Qclg5QlFsR1VWS09xZXB4cGEzTFhpS1czbTFxNlcwbGFhMkRsSXBtQlZyaFJoZk1JUEs3c2I4SGtiaURrZ21xYXY1TExJcnNyS2NoZ2NGVDY1OXFjUG14bFQ4dlVFY1ZzZUF2aDFyL3dBVXZGdGw0ZThMNkRyWGliWDlRWS9adE8wcXlsdmJ1NElHVHNoaVZuYkF5VGdjQ3FLMzJNT1dSN21UZEl6U04weTUzRS81NG94c0kyNURkODE2TjhaZjJTdmlsK3poYjJqL0FCQytHM2o3d0hGZk41VnJONGg4UDNlbXgzTFlKMkkwMGFoMnhrNFU1d0Q2VlcrREg3T25qYjlvTHhrdmg3d0w0UDhBRS9qTFdtSVAyRFJOTG12cmhBZUF6TEdoS0x6eXpZVVo2NDVxZVpXdVZ5cytrLzhBZ2h4L3dTMXNmK0NvMzdWZW9hRjRsMVBVTkg4QitDOU1HdGVJSDA5bFc4dkZhVllvYk9GbUJFYlN1V1l5YlcycEMrQnVLbXY2SC9Ddi9CSUg5bGZ3YjRBWHd6Wi9zOS9DV2JTeEVZVEpxSGg2RFVOUVlFWUxOZlhBZTZMOWZuODNjTThFVjhOZjhHNTMvQkk3NCtmc0YvSEh4UjQrK0pPaCtIL0N2aC94WjRZZlJXMGlmV1V1TllXVVhWdmNRemVWYnJKQ3FnUlNLeXZNcmp6ZUY0SVA2OUxhS092elZVVW5xeVorN29qK2EvOEE0TEVmOEVNZGEvWnkvYlgwTHcvK3ovNFA4WStNdkMveEUwK1RWOU0wUFRiU2ZWYnJ3L0pITUlyaTJlVUJtK3pLWGlkSnAyQkN5bFhkakdYYnNQMldmK0RVSDQ2ZkZoTGU4K0pXdStGZmhKcGNtR2Uza2NhN3JCSEIvd0NQZTJrVzNYUFBEWElZZDFyK2laV01jUlJXS3hzY2xRZURTZCt0UGw4d1U3ZEQ0Qy9aVi80TnFmMlgvd0JtOFc5NXJuaDNVdml6cjBXMW51dkYxd0pMRXNQN3RoQ0V0MlRQTzJjVEVmM2pYM2I0UjhJNlQ4UHZDMXJvZmgvU2RMMERRN0ZRbHRwMm1Xa2RuWjJ5amdCSVkxVkZIYkFBclNqamFadHFLV1BvQlhKWFB4bTBHUzluczlMdUxqeE5xRnU1aWx0ZERoTitZWkFjR09XVlAzTURlMDhrZE8wWTZrOHprZFpRb1p3U0I5MFpKOUJYSWk2OGFlSjMvd0JIdGRIOEsycm5DbThZNnBxREE5akZFeVFRdjZFVFhDK29yRzFid3A0VGZYcmZUdkUyb2FsNDExYTRobHZFczlSVjlRaThxSDc4cHNiZU1Xc1lSaHRFalFxeGtLb0haMlZTYzNaQnk5elpuK05XaDNWdzhHaXRlZUxidU5palJhREI5dGpqY2RZNUxrRVcwTC83TTAwWm9XVHh0NG9iQ3g2TDRSdDJQRy9PcmFnNFBiYXBqZ2djZXU2NVU1NmV2bWZpUDl0dlRkUDhJYUxyR2gyT2x6YU5OWjNjMHR2ZDZ2Ykplck5BdHRKRHBrRU5zMDhmMjI1dDVwcElJV2tWbWExOHNxcGZkSE5lK0V2aVY4Vmo0bTA3VjVKdEwwK0RYN3A5RnVVdUV0WTlRMDZMVTJqazAyOXR3ckV3ejJzVWJ3M2FBemZ2SnNtTlF2MnVkWHUvdUs1YkhaK0t2MmJ2RG54SjhNNmhwUGkyWFZ2RmtPcTIwdHBOSnJGejU2UkNSQ2hraXRsQ1dzVXFnL0xKRkNqZ2djMXRmQ0h4WGVlTWZocHBGM3FubGpXWUltMC9WVWo0aml2N1dScmE3VkIvenpGeEZMdEk0SzdTT0RYUTN0MUhCRE5jeXlMRERHQ3p5eUVLaUR1V1BRRDYxNXY0VThYUTZIOFlQRXVrYWZhM21xV3ZpS0dMeEpZUGJ4aExkcEZDV2w4cVN1VmpaRUtXTXJiR1ppOTg1d1RrVmFpbHNUZHRXTjM0NWZDYXorTnZ3dTFqdzdkTGIrWmVXN215bHVJL09odHJvSTNrVFBGbmJLc2NoVnRqQXFkdlRvYXh0YS9aejhIeitPdFU4WGF0YXdOL2FEbVc0Z3VwUTFoRUpOT2JUcmlFcEorNyt6ejIva2lTUGFvZDdhRjJ5VVVEcmpaNjFxVC9BTDY5dGRMano5eXlUN1JML3dCL1psMllQcDVPZmVwckx3anA5dGN4M0hrRzZ1b3VVdUx1UnJtYU05OWpPU1V6Nkp0SHRUQzdSaitFVjB2d3RwRWRuNFgwbTl1cmNTU1RDNEJjcE04amJubWU2dUczVGwyNWFSV2xac0RPY0N0S0d3MWpVa1lYRjdCcGFkUEtzRTg2UmY4QXR0S3VDRDdRcVIvZTduYXdTMlQzOXV0TmNiWmgvdERGQk56UDA3d2hwK25YcTNhVy9uWHEvZHU3bDJ1YmhCNkxKSVdaVjVQeXFRdnRXbVBtUFhudnpWTFV2RWRqbzA0aHVMaFZ1R0FaYmVOVExjTXA2RVJJQzVIdUZxci9BR3RxV29mOGV1bnJaeG4vQUpiWDhnVW4wWllrM00zdUhhSTlQZWdEWVNWb1pGWlNReW5LbjBOZWQvQ0R4RnAvZ3pUOVU4R3lUcjlxOEY2akpwdHRad3EwMDRzSFJMbXkyd29ESjVjZHRQRkJ2MjQzVzc4OEd1c1BoMlcvT2RRdjd5OEhlS0ZqWjI2bjJDSGVRZjdzanVLNTI0MHEzOEEvR1BSYml6dDdlenNmRmRsSm9jOGR2RXNhbTV0aE5lMmh3QUFCNVIxUEo3c1l4UVVqb2pxV3E2Z2NXOWpIWVJ0d0pyNlFNdzlDSVl5ZHc5bWtqWWVsQjhNTmZqL2lZMzE3ZkE5WVEvMmEzOXhzandXVS93QjJSbnJXVkZBcHlxVzRVRW5zQUtDU3ZZMkVPbTJxMjl2RERhMjZIS3hRUmlPTmZvQUFCVXlvRnJNazhZV0xUTkRheU5xVnhHU3JSMlNtZll3T0Nyc3Z5Um4vQUs2TXROTStyNmw5Mk8xMHFKditleCsxWEdQUXFwRWFON2g1QjdHZ0RYQXowNTc4Vmt0NHdzNTJaTE15NnJJcDJsYkZQT1ZXL3V0SmtSSTNzN3FhUnZDRnJlai9BSW1EVGF1eDZpK1lQRWZUOXlvV0hJeHdkbWZjbm10VUpoVlgrRlJnRHNCN1VBWk9kWTFML24wMHFNK24rbFRrSC92bU9OaC8yMUIvbnlIZ1R3ZlplSHZpUjRvME85ODdVbzdxV1B4THA0dnBQTmlqRndXUzZXT0xBaVZ4ZHhTVHV5SUNEcUM5TWl2UnNBQ3VNK0xGMUg0UDFidzE0c2tranQ3ZlNiOGFYcU0wakJWV3h2MmpnT1NlRkMzYTJFak1mdXBESjJKeUlma2RrUnUrOHhiNjB1T0t6QjRtUzc0c0xXNzFEL3BwR25sd2V4OHg5cXN2dkh2UHRTZlpkVXYvQVBYWGtPbnAzanNrODJRSC9yckt1Q1BZUkFqMXAyRVg3NitnMHkwYTR1cG9iYTNYNzBzemlPTk05TXNlQlZGZkU3WGcvd0NKZlpYZDRDTWlWMSt6Mi9zZDc0TEtlelJxNHFTMDhPV2RuZExjTENzbHltY1hFN3RQT285QTdrc0I3QWdlMWFHM2IxL1drQmxpeDFMVUd6YzN5V2NiZjhzckdNRmg3R2FRRXNQZFVqSXFmVHZEbG5wZHg5b2l0MU4wUnROeEl6VFhCSG9aSEpjajJKd0t1ZEtnMUhXYlhSeEg5cXVJWUdtejVhdVJ2bHgyVmVySDJVRTBBV0FtUm5tdVJ0RS80UmI0MjNjUFMxOFk2ZXQ0b0hDcmUyV3lHVWs5Mmx0cGJVS1A3dGhJYTNYMW04dlArUExUNU52YVc5YjdNaEhzdUdsejdNaWozcmpQampvVjFENExqOFIzRjlkVFRlQzd0TmY4bXhVMnF0QkVycGVLdTBtVXUxbExkb3ErWnRMc25Bd01NcVBZN3ZVdGNzOUlrU080dUk0NXBPWTRCODAwMys1R3VYYjZLRFZYKzFyN1VmOEFqMDA0eEllazE2L2xBajFXTlFYUCs2L2xuM3EzcG1sMnVsSTBkbkhieFJ5OGxvRkdKZjhBYUpIM3M5Y25KTldnb0JGTFlreS83Q252UCtQMi91cHgvd0E4N2NtMGlIMDJuelBxR2tZZTFYTk4wbTIwaUR5YlcxdDdPSE80eHdSTEdoUHJoUUJWa0xrOGMrd0ZaMTM0cXNiUzVrdDFsYTV1b2poN2UyUXp5eG4vQUd3Z096NnZ0SHZSdUJvQWJmYjhxYWk1bHdBV1k4akE1ckxOM3ExK2YzTnRhNlpIL2V1ejU4dy83WnhzRUhzZk5QdXZha2J3akRmSi93QVRHYTUxYnI4bHl3OG5Ib1lVQ3hzUGQxWSs1b0FkSjR2c1JlTkRiU1BxRnd2eXRGWko1L2x0Nk95L0pHVHpqekdYTlljRjNlYU44WHJPNXVMT094c3ZGRmtkUENtNEVrdjJxMjgyNGlES28yS1dnYTd5VmQ4aUNNWkdCbnJJNGxoZ1dPTlZTT01iVlZmbFZSNkFEZ1ZpZkUzVExqVVBCZHhQcDhMVDZwcGJSNm5ZeHB3ODAwRENVUkE5dk5DdENUL2RtWWQ2Q285anBOM3YvS3NQNG4vREhSZmpYOE0vRW5nenhKYnRkZUhmR0dsM1dpYXBDRGd5V3R6QzhNb0I3SFk1d2V4eFdwcE9wV3V1NlhhMzluS0xpeXZvVXViYVVEaVdOMURJMzRxUWZ4cXdSL25GVTQ2V0p2YlZIOFZYam53WDR1L1laL2F5MWJRWnB2c1hqZjRSK0s1TFpMaU1GUXQ5cDkyZGtxZXFsNGtkVDNVam5uTmYxcS9zM2ZIVFMvMm1QZ040TytJV2k3VjB2eHRvdHJyVUVhc0cremVkRUdlRmlEamRHNWFOc0hoa1lWK0h2L0Iyeit5SWZnNyszMzRmK0ttbldtelIvakZvYVBkT3A0L3RiVHdsdGNER1BsM1d6V0w1emxtYVErdGZWWC9CckQrMVdQaWIreUY0bStGZC9kSytvZkREVmhkNmZGbjV2N04xQm5sQUFQWHk3dExrdGpnZmFJeDZWZEs3aHl2cC9UQ29rcFhXMytmOVdQMVZnY0FENXM4OUNPQi9uOEtsWGhmMHo2MVdqbFdUMCtucFU2TmdENjkvV2tCWVRwdVhvdlBKcVRHVHllOVFnY2Vod2R2RlNodDNQWDZpZ0NVT3BiOGhqSFNwQU1OMkgwNzFERzNIUHpmalQxSEp4MDY4OTZuUUNVYysyUGJyVDFQSTlQNVV3Zk1mNVVLUm4vNjlDQW5YSlBQVFAvNnFlRGtlb3o2MUNvd3g3ZCtsU0kyRjl6VkFTNXlNOGNucU8xUFU0SjZDbzFiUDBJeFRsYkpQdjFvQWxCS2pGT0xiaFVTOWZyd0JUdCswTWV3R1NjOXFBT2I4Q0gvaEpmMmdQRVYrVjNRK0Z0S3Q5SXQ1QVRqenJwL3ROMGg5MVNHeEk5QklmVVY2V3ArWCtsZWNmc3lSZmJ2aHZjZUlIQTh6eG5xbDFyMjhkSllKSDhxMGNleHM0YlVpdlJWTzBWTWc2a25lbFZoL2dhYU9LWDd0U0pPNUlwelMxR0gyb2YwcDViQm9HUGpQSGVsUFg4YVo5MzBweXZrL3JRQTZpa1hJSE5MUUFVQVpQM3FLTWMwQUtwd2Z2VTd2VFA4QUduWnljZjBvQW85YUFNVVlwcDZlK1BXdlBPZ1IxeXBxQnhoVFV4T1Q3ZldvWFB5VUFlUC9BTFRuaTl2RFZqSEl1eHZzY0RUNFk4TXhPQi9MK2RmbmIvd1c3OGQzbWtmOEUwZmlCNHk4SjJNOGw1NG50TGJRdFdsZ0hObmFYRXFRenp5ZTNsWmdKNS8xeW5vQ1I5bmZ0cmE3SnFTWEZyQXpaa2tXM0cwbkpDam45VFg1OC9GYi9ncHY0SCtDWDdmVTM3TlB4S3RkUGY0WCtJUEMxdHBHdlhWMGRzZGxxZDlINTJKMk9BTGQ3V2FGR09ma1pnK1FBY2Z4cHhaVXgrWThjZlhNQlFkZFlXWHRweFc4b1U1UmphUGVYdTNpdXIwNjJjNFhtbktjSHRvbDYvOEFCMlB3SzhSZUpyalVkSTBpem14dDBlS1NDREhIeU5JMG5QdnVkaG4wQ2p0V2g0SzhQNjU4UjlVMXU3czlPMVRWcGRPczVkWTFHUzBzNUxoYlNCR1VTVHo3QWZMaURPcW1Sc0tDNmc0em12UVAyMFAyVzUvMlNQMm4vSDN3eDFlNGtlYnducVRRV0Y2WTkzMnUzYmJKYnlOZzhMTGJ5UnZrWnczQUdNbXVPK0gzeE04VGZEVzBraTBmVlcweU9TMDFDeG0reW9pU1hOdmYyeTJ0M0RMSnREU1JQRW9YeTJabFU1WlFyTXpIKzBjTmlxZUpvUXhGRjNqTkpwOTAwbW45eEZyTXlXT1d4L0VCa0N2dlQvZ2pQK3lENGEweVhYZjJvdml3eTZaOE5maEtzbHpwNHVJd3k2cHFrV05zc2FINy9rbDR4R29JOHk2ZUZRVHNrV3ZDditDYy93RHdUODhTZjhGQy9qckg0YzAxcmpTL0RHbEZMcnhOcnhRZVhwZHFTY0twWWhXdUpkckNPTW5uYTduQ1J1eS9weCswTi93VEkrTi8vQlRQNFRlRi9BL3dFMFB3cjhPZjJaZkE4YUR3NWY4QWlUVkpyRmZHMHlCZ3QvQkhIRExQSmFEY3hobWtSUmNHV1M0M1A1cWhQZytLc2JYekt1dUc4dGsxS2FUcnpYL0xxazkwbjBxVlY3c0Z1bzgwK2l2cnl0TG0rNy9QK3VwK1dYN2FYN1pQaVQ5dFg0LytKdkhIaURiWVI2c1lMZlR0R3Q3cHBMZlM3SzM4d1c4SlA4Y2loMlptWENtU1dac0F1Vlgxai9na0wvd1Vhay9ZVCtPeHRkZG1rYjRmK0tuV0hWNGdUaXhseUFsMm9IOTBBaGdPcStwQUZlYi9BTGRQL0JPRDR1ZjhFNS9pRlorSGZpcDRaT2tQcXlQTG8rcVdjNHZOSzFwSXlxeUczblVZSlRjbStKZ3NxQ1JDeUFPcFBod3RzZ3J0TGJlby9wWDBlTzRieTNGNVc4bXEwbDdCeFVPWG9rbFpXOU5MQlRrNE84VDlqZjhBZzRCL1lEMDM0cWZEVzEvYUk4Qnd3M0YxYTI4UThTL1pCbGRRdERnUTNveDFaTWhXUC9QTTVKd25QNVgvQUFEL0FHa1BIWDdMUGo2SHhONEQ4U2FoNGQxaUhhR2t0bnpIT29KTzJSRDhzaTg5R0J4azR3YzE5NmY4RWlmK0N1ZG44TmZEemZCdjR5K2RySGdIV0lEcDJuYWhjRHoxMDVYVXI5bmxVam1FNXdDYzdjNFBHTWZEMS84QXMrYXo0NStQbXZlQy9oM29ldWVON20zMWU2dGRPc3RDc1pkU3ZMaTNXVmxqWllvUXpzQ2dVNXhqOWErVTRIeXZINWRoYXVRNXIrOHBVbmFuTjJmTlRlMFhmckhiWHBZcVM5NjhQNjhqa3ZpNThTOWMrT0h4TDFyeGY0aW5qdXRlOFJYTFh1b1RSd3JHczBwd0NRbzRHY2R2WDNyQVcwWnBCajV1Y0FmaC9uODYvVEg5bEQvZzF2OEEyanZqcjlsdmZHVnZvSHdmMFdURE5KcjkwTDNWQ2h3Y3BaV3hZaGgvY25rZ0l4WDZWL3NyZjhHdGY3TjN3TEZ0ZStOLytFaytNR3RRNFpqcTl3Mm02VnVIZGJPMllNVnovRE5QS3ZxSy9SS2NWR0toVGpvdEYyUzZHZktsdWZ6bmZDTDRHZUxmano0d2o4T2VDL0MzaVB4ZnJrNUd5dzBYVEo3KzQ1UFhaRXJNRjl5QUI2aXY2ZHYrQ0VYL0FBVGJnLzRKN2ZzVTZLMnRlSGwwbjRzK040anFYakM2dUkwKzJ3RnBHTnZwKzVjbFlvSVJIbU1NUVptbFk4a0Jmc0Q0WGZDWHdyOER2Q0VmaDd3VDRZOE8rRGRCaCs1cHVoYVpEcDFxUGZ5NFZWU2Zjakpyb052SFN0b3hkN3lKYzFheU1ENGdmRGJRZmkxNEUxWHd0NHEwZlRmRW5oclhZVGJhaHBlcFd5M0ZuZXg1QjJ5UnNDcllJQkI2Z2dFWUlCcC93NitIZmg3NFArRG9QRHZoSHcvb2ZoVHcvYS82clROR3NJckN6aTdaRVVTcW1lT3VNbXR4SXk3aFZVbGowQUhKcmw5VStNZmgzVDlVdU5QdDc1dGExVzJiWlBwK2pRUHFWMWJOMkV5UUJ2SXowM1RGRi8ycXAyV3JKVjNvanBxSTBhVTdWVm1ic0FLNDg2djQwOFNqRmpwV2xlRTdkdWZQMW1YKzByd2VxbTF0WkZpWE9lSCsxdGpITVo2REw4VitGdkRPbXpRMi9qanhGZCtJYmk4OHNSNmJxbDBvdDdwWkxpQzJYR25RS2tVMFludWJkTjBzVXBScG85ejVJTlQ3Uyt5RGxOeS8rTU9nMitwVFdObmRUYTlxbHUzbHkyV2pRTnFFc0VuOXlZeGd4MjVQck84YTl5UU9hd2RlK0lIaktYeFZvT25SNlBvL2hXeDhRU1Qyc1Y3cWN4MVM4UzRqaGFkWUd0YmQwaGpMd3hYTGlYN1ZJcW1BS1VKY0FkNVpXc0drYWRGWjJkdkRhMmxxb1NHM2hqRWNVUUhSVlZlRkgwRmN6OFo5SXZ0VytHOTlkYVpheVhldGFHOGV0YVpCR1AzbDFjMnJpZElGUGJ6Z2pRSDFXWmgzcCs5WU5DTFV2aE5wZDFwdHhQNGt1TmM4YUxERTBqVzJvRVhFRXdVYnRxMkZ1aVc4amNmTG1GcENjQUVrMTV6cm43WjlqcUduYTFwdmdQVGY3UXUvRC9oNjYxKzBFc0dZYjJ5dGwwMllQWjI2eVIrZWtzRjdNc1lNa09KN1h5MzJodzQ5dzB6V0xQWGRHdDlTc2JxTzYwMjhnUzh0cnBUKzdsZ2RRNlNBL3dCMHFRYys5Y3Q0WTA3d3I0WHZMaWZ3eG9WdGNYVjFkM2Q5SlBwVm9qSzA5M0lrdDIzMmhpSWxhV1NPTjVGRWdMTWlrcVNCUW9wYkZYL21QTi9FUGh2eGg4YnRWbTAzKzBOZmJ3UjR3MGdXdDdmUVMyMXBiMlZ2TnA5M2EzVVVTL0xjZmFGdWt0N21HZVBjcEZ3d0VubEtNM3ZoMSt5UC93QUlsUHArczY5NHMxQy8xalJkUm0xYTB1a2h0MkduaTZ0TEtPOHRmTnVJNUdraWU0dEdtRndSSGRIelczeXU3U1NTZXF2RnJtcXYrOG1zdEpqUFVRajdYY043NzNDeG8zc1VrSHZTeCtDN0VUSk5kUnlhcGNSdHZXVy9mN1FVYis4aXQ4a1ovd0N1YXJUNVE1cmJHVDRhL3NQUWJpNm04TzZmYzZqY1hzdjJtZTZ0eTAvbnNGS0FtN25iYXdWU1VWRmtPeFNWVlFNaXROcmJXOVZQNzY1czlKaFBCUzFIMm00OWlKWkZDTDdneFA3TjNyWlliMkpKYjhhYTN5bk9lYW9pNWx3ZUVMQ0c2am5taWJVTHFGdDhkeGVTRzRramIrOG03SWora1lVZTFZWHhnbS9zR1R3OTRwM2JmK0VlMU9OTHhpY1pzYnNpMnVDeDdSeE5KRGNzZlN6cnB0VjEyejBWNDF1cnFLS2FZZnVvYzdwcC93RGNqWEx1ZlpRVFdUNGp0MjhlZUhkUTBlYlNKSk5KMWkxbHNicHI2WDdNc3NFcU5ISUZRQnBNbFdZYlhXUDZqclFOYjZuUXVwU1JzakJCd1JWUFZQRWRubzB5dzNGeEhIY1NEY2tDZ3lUeUQxV05jdTMvQUFFR3VQOEFoQWRXOGFmRGZUWlBFV3NYVjVyRmw1dW1hb0xMTmhETGUya3IyMDhvMk1aZ0hraWR4bVhhVmRUam11MDBuUmJYUllHanM3VzJzNG5PWFdDSll3NTlXeDFQdWVUUUlwbldOUjFBZjZKcHYyZU51azkvSjVRSTdGWWwzT2Y5MS9LUDBwa3ZoeWJVRS80bUdwWGR4M01Oc1RaMitmYllmTng2aHBXQjlNY1ZzSkNxK241VXUzc295eDQ0RkFpdnBXbFd1a1doaHNiZUN6Z1k3eWtFWWpWai9lSUE1UHVlYXNBWXovT3N1WHhaWTJkMUphck45cXVvV3c5dmFJMXhMRm5wdlZBZGc5MzJqM29OM3Eyb2Y2dTF0OU5qYitLN2Z6NWg3ZVZFMjM4Zk40OURRQnJZejkwWmJzQU90Y0w4YWI1ZGI4Q2FwYmFMdTFQeEpwYlJhbnB0cGFJWm5lOXRaVXVZSVpDb0lpV1dTSVJNWEtqWkkvSUJOZEUzaFNPKy93Q1ArNHZOVTNEQmp1Sk50dVI2R0ZBcU9QOEFmVmo3MXFXdHV0aEJIRENxd3d3akVhUnFFU01lZ0E2ZmhRQmcrSC9GTjE0OThPNmZxK2tyYTJlazZ2YXhYMW5QZEg3Uk5MQktnZU1tT05naTVWbElJbGJyMHEyL2hHM3Z4L3hNSkxyVmdlcVhiZ3duMk1LQlltOWl5RSs5WW53aGpYdzZkZjhBQytGalh3N3FMdFpJUGxBc0xvbTV0dGkvd3h4RjVyVkIwQXN1T0JYWWtoSTJiUHlxQ3hKUEFIcVRRTmpZNEZqaVNOUnRqakFWRlViVlVEb0FPdzlxZUJpc3NlSzdlNjNmWVk3alZDTzlvZ2FJL3dEYlZpc1dSM0cvSTlLYmpWTlFQelRXdW14bmpFQSswekgzM3NBaUgyS1NEM29FYWtzcVc4VHlTTXNjY1l5N3NjS285U2UxWm84VlEzZi9BQjRSWEdwNTUzMjZEeWNlb2xZckczMFZtYjJwMEhoZXorMExOUEcxNWNSbmNrdDQvbnRHM3FpdDhzZi9BQUFMV2dSdis4UzMxNW9BelBKMWJVRCs4dWJYVG8rNldxZWZOLzM4a0FRWjdneEgyYnZWRHhMOEt0SDhhZUhOUzByVW81NW85V3RacktXNmxsTTF6QWtxRkdlRjN6NVRBTVNOZ0FCQU9LNlExQnFPcDIya1czblhsemIyY0pPM3pKNVZqVFBwbGlCUUJoL0NueFZlZU9maDdwbW9hb3NTNjFzZTAxZElodGpqMUMza2EzdTFVZjNSY1JTaGZWUUR6bXVqNkN2Ty9ESGlDYlEvaTc0aTBleTArNm10ZkVNRVhpT3lrdVZObkNKVkNXbDdHTjQzN0ZLV2N1NVkyeTk4NUo2R3V3L3MzVUw4QTNXb2VTdlV3MlVmbDVIOTFwVzNPZjhBZVFSbjJIU2dIb1hOVDFXMTBlQlpMeTRndFk1RHRReXlCTjU5RnllVDdEbXFwMSs0dlRpeDA2NGxYcDV0MlRaeFo3akRBeS9qNWUwOW1xYlROQXM5SW1lYTNnamp1Sk9KSnpsNTVoL3R5TVM3ZjhDSnEyRUFQdjYwQVppNlRlMzMvSDVxTWdWditXVmlodGx4N3ZscENSL2VSa0hzS3RhWG9scnBEU05hMjhNRFRZODExSDd5YkhkM1B6TWZkaWF0ZC8wcWpxUGlLeTBtNyt6elhLL2FpTnd0b3daYmhsOVJFbVhJOXd1QlFCZVVDbkEvTjkxWkIzVnZtVnZZanZuMHJJL3RYVXI4WXRiRmJPTnYrVzE5Sjh3OTFoanlXK2pQR2FRK0hKTlE1MUMrdkx3SHJDakczdHg2alloRE1wN3JJN2luNmdjejhJUEU5bjRhOE16ZUU1N3A1dFM4RTNUYUcwRVllNXVSYnhxa2xrN3FnWnlXc3BiVm1jakc5bkI1QnJxVHFHcVg0L2MyVU9uci9mdlpCTElQcEZFeEJIMWxVajBybmxzTGZ3RjhYN0g3UGJ3MmVtK0xyQnJFeHd4aUtJWDFwNWs4S3FxNEcrVzJrdkNUajd0a2d6MEZkc21BUHhwbFNNa2VHUmRqL2lZWFY1cUFickhJNGl0K2VvOHBNQmw5Qkp2STlUMXJTdExTT3h0NDRZWTQ0YmVNWWpqalVKR2c5QW80SDRWSVFkcmJWM04xeFdXUEdOblA4dG41dXB6RGdwWkw1eXEzZFdreUlsYjJaMU5JbmMxQmhmVDg2SGI5eXpOd3FnbGoyQTlUV1dUcTJvai9BSmRkTWo5czNVNUgvanFJdy83YUNoUENGcFBLSkx6enRUa1U3bGE5YnpsUS93QjVZOENORzkwUlRTQWFQR0Z2Y2ovaVh4M0dyTU85bW9hTDMvZk1WaXlPNDM3dlkwc1M2eGVsZDAxcnBVZWVsdjhBNlRPUFFoM0FSVDZneHVPdUQzclRrVm1mcmsrcG94NVpITk1EbWZoUmIvOEFDT2FmcVhobHBIWWVIYnBvN1V5RWJtc3B2MzF2Z0FBQlVEUGJqQUEvMFU0eFhXS01MLzhBWHJsZkVFaStHZmlQb2VwRWlPRFhGZlE3azUyaHBBR3VMUWtuKzZWdVl3QnlXdTE2OFk2c2NqdlZJYlBnTC9nNWEvWkliOXFYL2dsVjR1MUt5dC90R3Y4QXdsdW92RzlpcXFOejI4QWFLK1RQWlJaeXpUSEdjbTJRZWhINGIvOEFCQWI5cXhmMlh2OEFncFo0Smt2YnI3UG9manpkNE8xUXNma0l2R2pGczU3S0V1MHRpVDJYZjB5YS9xNzF2UWJEeFZvbDdwZXJXY09vNlRxbHZKWjMxcE1vYU82Z2xRcExHdzdxeU15a2VocitOVDlzejlsWHhCK3dwKzExNCsrSGQ5SHFrSjhCK0lKN0d4MUo0bWhOMWJMSnZ0THRXWGhmTmdNTW9JSkkzRDBwMFpjczlkdjZRNUxtaC9YeVA2Nm9YWkY2dHU3N2pnajYxWVJzQWRCNjE0bC93VDYvYWpoL2JNL1l6K0hQeEtXU0pyenhSbzZQcVFVajVOUmhMVzk0dUIwQXVJcFNCL2RLbnZtdmFvbTQ2YmM4OUtxY2VXVFJLZDFjc3h0KzgrWEdlbWY4YWtSOERwemtHb0ViSytucmsveStsU3dzQXZ1M0ZSSUNiK0g3MzB6elVpTmpuK3ZPYWpUanVDYzlha1hCL0dvQWVPU2ZwVXZlb1ZiQlA4cWtVZ0w3L1N0QUpFT0N0UEQ0SHBqb0tpWGowUElIMXFSY0w3bnZtZ0NRZk1lMzU5S2NqY0g1djBxTk1qNitsT1UvTitIZWdDYjd0Y2o4ZU5mdXRBK0VXdHRwekJkV3ZvbDAzVFFSd2J5NVpiZUFmakpJbGRVR3h4MjkrOWNsNHhqWHhQOEFGcndMb1REeklZN3VieERkUkh2RlpvUEtZLzd0NU5hTVBkYVQxMEtqbzducEhoencvYStFUEQybjZQcDYrWFlhVGF4V05zdjkyS0pCR2cvNzVVVmZYbkJ6K05Sb2NmaFRpM0ZHNUtYUWtIM1EzOWFjR05SZ1lOT3pnL2pVV0FkMVA0NHAyOGordFI3c04wNzlSVCs5QUQwT1JRZW5XbXEzNVlwdzVHUGVnQ1FPRFM0emltZFJTZzRYcjFGQUQ2S0EyUlJtZ0FvSEZGRkFGSGZrMGhiSjk2U2duRmVlZEExemdmalVjZ3d1ZlNwSEg4L1dvTHlVUTJ6eU45MUZMSDhxbXBOUWk1UHBxQjh3ZkdmVEU4WWZHT3gwMkZHZUZaekxOd1Q4d09UK1E0cjhGdjhBZzR5K0huOW8vdFkyWHhFanMydFkvR0ZoOWd1dGlrWm5zd2thYnZjMnpRSU9la0IraC9vWStGSGdxeitJL2p6eEpxR3JXLzJqVHA0SmJLVkF4WHpFbURJNmdqa2Z1eVJrY2l2NVBmMjBmZ3Q0citBLzdhUGo3NFdlSmRTMTd4RnJYaFBXN3JRYlNhOWxsdTdpOFJKTTJzaUJpek41OFpqWlZVY2lZWXptdngvd2h5bHY2N24xVGZFVkdvK1ZPR240eTVuOGtaMDlJcGQ5VGt2Mm9QMmdOVS9haCtOV29lTmRhdGJlenZkU3RiTzErendTTkpIRkhiV3NOc2dCYjV1VmhESFBkalhQK0FQRFdrZUpkU21HdGVKTEh3elpXc1htR1dheXVieVc0T2NlWEZIQ2hCZnYrOGVKY0EvTm5BUDZDZkJUL2cxWS9heStNSGdHSFhyN1MvQXZnSDdWRUpvTkw4VTY0OEdwTWhVTXUrSzNobkVMSFAzSm1SMU9ReXFRUlh5bjhmUCtDYnZ4dC9aai9hTWorRkhpejRiK0pUNDZ2SWx1Tk8wM1NiUnRXT3RRTmtMUGFOYkNRVHhrZ2pLWktzQ2poWFVxUDJTaFJwVWFNYUZIM1l4U1M4a3RGYTk3L081V3JscnVmYUg3TC83VVBncjQ4L0ZYNEcvc2UvQXZTYjd3ejhKL0ZYaVd5dC9IbmlEWEJIWmF2OFFJOXl5WDhVaVF2SjVNZHhIRkpIc0VyUElwaGh6SEVHUi82U1FGVUtrYVJ3eHFBcVJ4cUZTTlFNQlFCd0FBTUFEZ0N2NXRQMkgvQVBnMnAvYXU4ZjhBaTNRZkZsNURwdndML3NtNnQ5UnNOVjEzVU1hdmF5d3lMSkhORGFXM21UUnlvNmhnczVnUHlqcG12Nk52aGg0ZThRYUY4UE5Ic3ZGMnZhZjRxOFMyZHNzZXBhdlphVC9aTnZxTXdHRE10cjVzd2hMZFNxeUZkMlNvVUVLT0RLY293dUFoS0dGajhiY3BTYnU1U2U4cFNlcmIwWGtra3JKSkxTZnc2N254Ti93Y2QvQkJ2ajEvd1M5MXpTZE84TzZ0NG84WFdmaVRScm53dlk2Vll5WHQvSmZHNldHUVF4UnFYWW0wbHV0d0FQeWdudGtmazUreXIvd2E3L3RMZkhnMnQ5NHJzZkQvQU1JdEN1QUhhVHhMZStmcWV3OVNsbGJiM0RqKzVPOEI0NU9hL3Bjai9jNTJzVjRJT0RqSW93SzlmbGJNb3V4K2FQN0tuL0JySit6djhESTdlNjhkM1hpYjR2YXZIaG1YVUp6cEdsYmh5Q3R0YXNKZXZhUzRrQjZFWTRyOUIvaEQ4RlBCdjdQdmhCZkQvZ1B3bjRiOEZhSXVNMk9oYWJEcDhEa2QyV0pWM3QvdE5rbnVhNmRSdWJBQko3QUN1YThRZkZudzc0YTFXVFRadFMrMWF0RUFYMDNUNEpOUXY0d2VoYTN0MWVSRlA5NWxDK3BIV2hSaXRSOHplaDBlTUNuS3JNKzBjbjBBcmovK0VpOFllSXgveEx0QnNQRGNMZjhBTHpyMXdMcTRRKzFwYXVWWlQvdFhVYkR1dmFtdjhLRTExU2ZFbXRhMTRpRGZldFpKaFo2ZU05Vit6MjRSWlkvUmJnekVmM2oxcWxKdlJJbHg3bHp4QjhXdEI4UGExTnBiWHI2aHJNSEV1bWFaYnlhaGV3a2pJODJLRldhRlRrZlBLRVFaeVdBNXFvZGM4WStKVC94TDlHMHZ3emF0eDUrdVRDOXUxLzdkTFYvTDJuc1RkaGgzVHRWRDRRYU5aL0RieEw0bzhHYWJaMnVtNlRaeng2L3BkcGFSTEJiMjl2ZkdUelVWRkFVRVhzRjVJY0FBQzRqSGNaN3ZHUlJhVDNaT2lQTk5lMHp3ckhxTTFqNDA4WlNlSXIySklubjB1OTFDT0NDR0tXVklrTWxoYkJGZUZwWkVVTmNwTGpkOS9BTlVSOGNvN2ZYRzhHK0M5QXNiYWFQU3RUZlNQdHNjMWxwcHZyTzZ1TEpyWGJCQTZ4eHBkUndpUjNhTEtYZHY1SW1aeXE5ZHJ2d2MwZnhINGcxUzZ1SVUreGVJTkZ1TkYxdXhpVHkwMVdKM0RKSkk2RU1IaUQzU3F3TzdGMDV5Q3FtczNRL0NmZzNSM3N2c0dscjRwMVRTN3E0dTdlOWVMKzFieUc1bVlOUEo5c2x5c01qN0V6dWxUaU5GQUFWVkNVYkZLeldwNTVaZUx2aUo4VUx2UTlVME9IWGxqdHBUWlhNdTIxMDdUZlBqdWJPYzNSaU04cHVMU1cwbnVyWjlqeXRITmFIeWxqa3pJTi80Yy9za3dlR3JTL2gxYlZaTld0Ymp4Uy9qSzB0QmJSZVhvbW8vMmxKZWVkYVNGTjhZbFJsU2RUa096VHNwVHo1ZC9wUmwxdlZtei9vZWt4SHFYemQzSkg0Rlk0MkgxbEgxNlVId1BZM2kvd0RFeDg3V1d6bi9BSW1EaWFQUFlpSUFSS2ZkVUJxdVh1SFAySTE4YjZmZDUvczFialdwQngveEw0eE5Ia2RRWmlSQ3JlelNBMUpFZGJ2bkRickhSNDFJWmRtYnU0eDFCeVFzY2JEMHhLUGM5YTJPVDFPY0RBOWhTSGdWWkI1cjhGUEErbjZScHVxZUc3Nk45VWs4SDZwSlpXaHZtODFGczNWTHF6TWNQRVVZamduU0RjaUxsclYvUTE2VTN6dHljN2VPZTFjSjR4MWl6K0hmeG4wSFZMeTV0N096OFlXVW5oK1ZwWENtUzZ0aE5lMllYUFg5MGRUQkF5U3pSajBycFI0aHVkUUgvRXYwdTZrVTlKcjBteWl6M0dHQm16Nkh5dHA3R3BRNVhlcHF1dnJWVFZ0ZHM5Q0ViWHQxYjIzbkVyRXNqQU5PUjJSZnZNZlpRVFZJYU5mNmgveCs2bktxL3dEUERUMCt6SVIvdFNFdEtXLzJrZVA2VmMwclFMVFEzbGUwdFliZVM0d0pwVkg3MmZIVGU1K1ovcXhKcWlTcTJ2WGQvd0Q4ZU9sejdPdm5YeE5uR1I3S1EwdWZabzFCL3ZVSFJMdlVEL3AycFhEcDBhR3lVMmNiZW56QmpObi9BSFpBRDNGYW1GQjY5KzlPTkFGUFM5RHRkRlNSYk8zdDdVU25NaGlURFNuMWR1ckgzYkpxMEVHZU8xVXRUOFVhZnBWMTlubXVOMTBCdU50Q2pYRnhqMThxTU0rUGZiaW9QN1IxVytCK3oyRVdub2YrV3QvSUhjZTRoaVk3aC92U0l3OUtBTVRRVi80UnI0MTY5cDMvQUM3K0tiT0xYN1lZeVd1SUZpc3JzZXlpTWFhUU83U1NHdWd2L0ZWallYcldwbjgrOGp4dnRyZU5yaTRUUFRjaUFzbzU2c0FQZXVHK05IaGc2YnAyaStLTlF2YnU5SGhYVTQ3cThUZDludC9zRXdhMnZBVWp3V2lqaW1OeVVsYVRKdEV5VGl2UmJQVEl0SXRWdGJlR0cxZ2hKVllZVUVjY2ZyaFFNRDhLQ2pOKzM2dGZuOXpaMjJteC93Qis5a0Uwdi9mbUp0cFUrcG1COVZGTy93Q0VWUytYL2lZM0Y1cVhySEl3amdQc1lvd3F1dnRKdlB2V3FnVk9uNlU0REo2VUVrRnRhUmFkREZEQkhIYndSamFrY2FoSTArZ0hBL0NwK3RaVW5peXp1ZHlXVFNhcEtwSTIyUythb1lmd3RKeEdoSG83clNvK3E2bW9iRnBwc1REUHpmNlRQajZEYWlNUHJJUFkwQWFnSFhIVEdmcFdVdmkrenVzL1lmTjFWczQvMEpSSkhrZFFaU1JFRDdNNE5COEoydDNqN2NzbXFFRUgvVGlKVnlPaEVZQWlVajFWQWExR1hlUnVMSEhRRTlLQVBPdkZKMVhSL2kzNGMxYmRaNlRaK0lJWlBEdDhVLzBtWjNBZTZzbmNrTEhIc0tYa1FBRWdMM3dIT1FSMlMrRTdTWjFrdTFrMUtaVHVEM3IrY0F3Nk1zZkVhRWVxSXRVL2lsNFh1dkdIZ0RVckhUdkxHcktpWG1sRnpoRXY3ZVJiaTBadjlrWEVVUllkQ29JUEJxMzRiOGE2ZjRyOEZhZDRpdDVCYjZYcXRsRHFFVDNEQ1B5b3BVRHFISis2UURnZzlDQ0tDdWhwc200YzgwN0ZaUThVcmVyL0FNUysxdXRSQi81YUlvamd4MlBtU0ZRNm4xajNuMnBSYWFwcUp6TmVRMkVmWHk3S1B6SkI5WlpSZ2crMFNuMFlVRWw2K3ZvZE10R3VMcWFHMnQwT0dsbWNSeHJucGxqZ0NxSThTZmJWL3dCQXNydThCNlRNdjJlM0hvUzc0TEwvQUxVYXZVdGw0YXM3RzlXNVdIekxwUHUzTXpOTk9tZURoM0paUjdBZ2UxWGlQbXozOWFBTXY3QnFXb0gvQUVpK1d6VC9BSjVXTVlMZTRhV1FISVBxcUlSNjFQcC9odXowdTcrMFEyNi9haU5wdVpHYWE0SytubXVTNUhzVGlyM1FWVjFYVzdQUkZqKzJYTU51MDNFU3V3RHluMFJlckgyVUUwQWN0OFh5dmg1ZEM4Vloyand6cUtHOFBUZFlYUDhBbzF6dWJ0SEY1a1YwM3I5aVg2MTJiS1kzS2tiU3ZCQjdWZ2EyZitFMjBPKzB1VFI1TG5TOVV0cExTNS90QmphUnp3eUlVa1hZUVplVllqRFJxRDY0NXJDK0Q0MWZ4UDhBRCt5VHhEck54ZWF2cEx5NlBxZjJSVFpSM0YxYXlOQkpQd1RNUE5LZWNQM2dCU1ZQbHF1ZytoMkdxK0lMUFE1STQ3dTVqaG1tR1lvZVdtbS8zSTFCZC84QWdJTlZUckYvZmovUTlOYUZmK2V0Ky9rakhxc2E3bko5VmNSbjN6VnpTdEZ0TkVpa1N6dG9MVVNuZEo1U0JUS2ZWaU9XUHVTVFZvREZTSXlUNGZudi93RGovd0JRdTVsN3cyN0d6aHo2allmTlAwYVJsT2VuU3IybWFUYjZSYkdHenQ3ZTFoWTdpa01ZalVuMUlBNVB2VmdaSjlhb1hmaXF5dExwcmZ6amNYVVp3OEZ0Rzl4TEdUMDNxZ0pRSDFmQTk2ZW9GOEZjZEtFK1pzS0NTYXkydTlZMUEvdWJXMTAyUCs5ZVA5b2wrbmxSTnMvSHpqOUtRK0VvcjJQR29UM1dySzNWTHB4NUpIb1lrQ3h0N2JsWSs5SURtL2pWcXEzdmdtN2wwZUc0MW54QjRkbWoxZXdzOVBqTTAwMXhiTjVuMmNzdnl4bVpCSkFkNVViWm1yZTBuWEx6eGZwVnJmYWExbGE2YnFFS1hWdE83ZmFwWm9YVU1qQlVJalhLa0VFUElNRWNWdDJzUzJjVVN4QllsaEFFYXBoVmpBNkFBY0RIdFhJL0NCUjRmc3RZOEwvYy93Q0VXdjJ0N05TY1pzSmdMaTEyai9ubkdrald3UGMyYitocGxkRGFQaEczdkZ6cURUNnMyZVJkc0dqNDZmdWxDeFpIWTdOM3VhMUJHcUlxL3dBS2phbzdBZTFFa3l3UXRKSXl4eHhqY3pNMkZVZXBQWVZtbnhkQmVML3hMNGJyVk80ZTFVZVNSNmlaeXNiZW1GWm05cU5TVFZBNDk2anU3dUt3dFh1TGlTT0dDRVplV1JnaUlQVXNlQitKck9NT3E2aWYzbHhiNmNoNnJhTDU4dytrc2k3T2U0OG8remQ2a3RQQzluYlhVZHcwUnVMcU03a3VMaHpOTEdmOWxtSjJmUk1EMnBBUnllS0Z1OGYyZlozbW9IdEtxZVZialBRK1krQXkrOFljK3hwcldXcmFpdWJpK2gwK1ByNWRpZ2tjZXhsbFVoZ2ZhSlNQV3RZY24xUHZTSW5IemRjMHdPYThYZkRhMzF2dzFlUTJNY2E2ejVZbHNMMjVkcDVZTHFOaExic1pISmZhc3lSc1Z6Z2dFWTVyYzhLK0lZZkYzaG5UOVZ0NDVJb2RTdDQ3bFk1Qjg4VzVRZGplaktTVkk3RUVVdC9xOXJwRzM3VmNSVy9tSDkycnRocEQ2S09ySDJBSnJuZmh2ZkN5OFNlSk5GOHE0aHQ0cm4rMXJEem9URVhndTJaNWNCc044dDJ0MFNHVUZWa2lHTnUwbHhIME92YmdWOEovOEZqUDJhdEo4UVdPbmZFQVdOdTkweXJwK3BNWVViN1Fpall1L2NNSDVXVmZteU5zYmZTdnUzZjgySzhyL2JiK0ZWejhaZjJWdkd1aWFmRDlvMVpkUGUvMCtJQXMwMXhiL3ZsakE0K2FRSTBZN1prRmFVWjhsUlMvcnpJbEZ5aTRycWZKWC9CSmp3NW9Qd3YrR3ZpTHd2b01NT20yc21wLzIwdGpESUdnZ2VWRVNVeEtPSXd4aVJtVmZsM0ZtQXl6RS9Yc2JCc2Q4ZHY4L25YOCszZ1QvZ3JicC93Ty9ibitFTWVuYW1zdmhEUXRlMitLcm1LYk51MXZjeHlXYmpPZHJDR0s1a21KNUFlTk9jcTJQNkJvM01NbXhteTBiRlRqN3ZIcFhWalZIMmw0YmY4QURHZUg1bEcwaTVHNURFN2VlMmU5VElReTlQZkZWNG14MFBYdG1wSWp2WHVCMHovT3VNMkxVZlFmN1F6OHhwOFJHZS8rTlFxd0xEUFZ1L3BVb2JjYVFFcXQ4dUQyNHA2dGpwMjZacUpUZ1kvcFQxWUEwcmdTNTI3aHp5Y1k5YWZuNWM0SHpWRXE1RlBHQnoxSGIycWdKTVl3UGY4QU9ubzNIK2MwejhOdmJybk5LRDc0UFRQclFBOEhqajAvS3VaK0ZhLzhKTjhiZkdtc2NOYjZIQmFlRzdZazh4eTdmdGwxajJaWjdIOFl2YXVpa25XQlRJL3l4eGdzVDZBRG1zZjltSzBaL2czcG1yU2ovU1BGVXMvaUdSajk0cmR5dE5BRDdyYm1CUDhBZ0ZBZEQwSk9QeXAvVVV4ZXVmeW9EL1FDZ0NRSFAwcHdPZVA1VXdIbkovblFyZHNkZmVwOVFKRkdSNjA0SCtmcFRRZjhpaFJuMU5TQThkZTlPNjhVMEhuNlU1U1FLQUgvQUhSU2p0VWFjaW5nN1RRQThERk8rNktqVnVlYWNIelFBNEhORkZGQUdmUVRUZ25GTndRSzg4NkF4eldIOFFMMyt6ZkJ1cFRmZDJXN1krcDRyY0p3SzRmNDk2aDlpOEFTUS94M2t5UUwrSnovQUVyNS9pdkcvVk1teFdKL2xweXQ2MmFYNDJGTGF4RDhETkNHbGZEMkdUL2xwZk8wekhIdnRIOGorZGZrYi93Y0pmOEFCSkx4NzQzL0FHdTlFL2FZK0QrcjZUWWVLSTROUGt1ckdZdGJYTW1xNmNSOW11NHA4R1BjWVlyWk5zaFFBMitkNUJ3djdOYUZwYTZIb05uWnF1QmJXNlJmaUFNL3JtdlBmMnJmQVMvRUg0SjZ6YWhRMDlvZ3ZJZU9keWNuSC9BYzlLMjRaeTcrejhxdytDNndoRlAxdDczM3U0M2E5K3gyWHdqK0lIL0MzUGhUNFo4V2ZZTHJTRzhVYVRhNnMrbjNNWlNiVDNuaVdSb0hCNlBHekZEN3FhNkRlMFRmS3pMbFNwSVBZOVI5T0JYaC93Q3diOFlyZjRoL0NXVFFaSmxPcStEbWp0cG85MldOdkp1OG1USEJ3V2psWDAvZDE3ZTNYL0N2b3Flc1UyRldQTE5wYmRCaEZIOFB5alBzTzljNzhWdkUrb2VEL0J6MzJtcFllY3QzYVc4a3Q2cnZCYVJUWEVjTHp1aWxTNnhLNWtLNzB5cXQ4NjFSYjRYVDZ5emY4Sko0aTF6V2czM3JPQ1QreTdCRDNBanQ5c3NpSCs1Y1RUQ25LZG5aRUtKZThRZkZQUWZER3J5YWJjYWdzMnJxQXphWll4U1grb0tQN3h0b0ZlVUx5UG1LaFJua2lzOS9FdmkzeEw4dWxlSDdUdy9DM0gyenhCT0paay8ybHM3Wnp2VStqM01ERHVPTVYwR2hlR2JId3JveTZib2RocHVqMnE1OG0ydHJkYmUxUnowSlNNQUFaNjRHYStmL0FBZDhRUGlyOGY4QVRGdU5ROEozbmhmU0xtdzB1NW4wMjMxRTJzc2wxYnpJMnEyc1YvR3lTQlprdW8waEo4bytacGwxSEtZbGtaZ3ZlNmpTN0hwbmk3dzVwdWdhSmNhcDQ4OFhhcHFGbmF3VDNNdHNKanA5Z1VoaGVhWlV0YlhFbHlvaVIzTVV6WEJLcWVEWFArSVAybXZCUHdZMGpRYkd4MDlkSDBhKzFlWFNicEk5Ty9zNWZEenJick9acHJObGpkb3dzc0VqYkFNUVNOT1Q1Y2JzTXp3Wit4M0pMNCswVHhwcld1YW5GNGx0RnNtdkliVzQrMVI2bDltWFVMZFk3MTVWSXUyYXd2WTdaNXZMU1ltM0xMSUZsbFIrMCtIZmd6d2g4SkxXUFQ5RGp2TlYxR3h4QzB4bGsxTytSbGdodGdza3pFaUg5emJ3SnRabzF4R0NSdUxFbHRkRjk0OUMvd0RDTFgvRSt1UmVJaDRxc2JQVDc2dzFmN0pieFdlOTdWN2RiTzFjU3hTc3FtWkpKSGxjTUI4bS93QW81ZUpxN0JWTG5hQVQ5QldSNTJ0YWwvcW9MUFNZVDBhNUp1cDhlaGpqWlkxUG9SSzQ5VjdVaDhHMnQ4bi9BQk1wcnJXZXhXOWNOQ1I2R0JBc0p4NmxDM3VhMWpjemRqai9BSWsrTWJEUVBIM2cvWGJPU1RVbWh2SlBEbDh0aW5uaU9LL01heEIzSDd1TnpmUVdNWUVqTHhOSjcxMkFrMXJVejhzVmpwTUo1Qm1KdTdnajBLSVZqUWpya1BJUGFtK1B2QlMrUFBBR3ErSDFtRmovQUdoWnlXMXRjSXYvQUI0U2xmM015RHMwVWdTUmNkR1FIdFI4Ty9HSitJSGdYU2Rha2creVhHbzJ5eVhOdG5KczdnZkxOQWY5cU9VU1JuM1EwMWU0Ym9jZkJGbmRuT292YzYwZTR2M0VrSjlENUNoWWNqc3dqM0QxclhWZGthcXZ5cWloVkFHQW9IUUFkaFVPcGFuYmFOWm00dkxpM3RMY0VLWlo1QkdnSjZETFlHVDZWUS80U2FXL09OTzA2OHV0M1NhWmZzbHVQY3M0M2xmOXFPTnhUMFJPck5idFZiVTlYdGRFdFJOZVhOdlp3c2RvZWVWWTFZK2dMRVpQdFZJNmJxZW9mOGZXb0xheG4vbGpZUkFFZXF0TEp1TGY3eUxFUlUybCtHckhSN3RyaTN0a1M2WVlhNWRqTmN1UFJwWEpjajJMR21CQi93QUpKY1h3UDluNlplVC9BUFRXN0Jzb1I5ZDYrYitLeE1QZWsvc25VTlFPYnpVbmlqUC9BQ3dzSS9LNC91dEsyNTJ4L2VUeWo3Q3RieWhqMVB2VHM0b0QwT0grS253Kzh6NGQ2cE5vTmtyZUl0UDhyVmJDVEphNXU3cTBsUzVoaGVac3V5eXRFSVdKSk95VmgwT0s2elE5WnNmRkdoMk9xYWZNTHJUdFN0bzd5MG0vNTZ3eUlIamNmVldCL0dqVmZFbG40Zm5oUzZ1b29iaWI1b1ljN3A1c2YzSTF5NzQvMlFhNEg0TzZ2ZldGdHJuaGV6MDFvWXZDK3B5dzJzbCsvd0JtVWFmY2Y2VGFDS0lCcE5rVWNwdGdyaVAvQUk5Q004WUM2ajNSNlFHQkhXcWVxK0pMSFJiaFliaTVWYmx4bExaQVpMaVFlcXhJQzdEdndwNHFyL3dqOXhxSC9JUTFLOG5YdkRhRTJNUHNma1l6SHJ5REtWUDkycnVsNkxhNkxhbUd6dGJhemlZN21TQ01SaGozSngxSjdrOG1tU1VUcXVwYWoveDY2Y3RwRzNIbjM3aFNQUmxoVExOL3V1MFIrbEt2aDZhKytiVU5Rdkx2UFdLRmpaMjQraXhuZVFlNnlTT0sxbFhiVGd1NDR4K0ZBRmJUZE10OUl0UmIya0Z2WjI0T1JGYnhyRWdQcnRYQXF3RUE3Vm5YSGlteGd1bnQ0NUd1N3FOdHJ3V3FHZVNOdlI5dVJIOVhLajNxTTNXclg1L2R3V3VtUm5vYmsvYUp2eGpqSVFleDgxdmNkcUFMdXJhSlorSmRLdXRNMUMyanZOUDFHQ1MxdTdkeGxaNFpGS1NSc1BSbFlnK3hyalBnNzhReHFuZ0Mxczd1N24xelg5RGVYUmRVZTJUenBKcnUxZG9IbGtZZkpHWnRnbkFrWmZsbVd1bC80Uk9DOUgvRXdrdWRWM2RWdTNIa2tlaGhRTEUyUFZsTGU5WUdpd0R3bDhhZFMwMWNSMlBpblRrMWUyUlJoVnU3VHk3UzYvM1FZSDAwS280L2RTbjFvS1IwQmwxYS9QeXgybWx4NTZ5bjdWTVI2YlZLb2g5dzhnOXFVK0ZMZTVmTjYxeHFuZkYyNGVNbnNmSlVMRmtkaUV6NzFwaFFvMjBTT0lvbWRpRlNNRm1ZbkFVRHFTYUNSVlFKR3FnQUtnQVVBY0tCNlUySWJOdzdaeldjdml5M3ZWenA4ZHpxby92Mmlob1Qvd0J0V0t4SDZCeWZha01Pclh4RytlMTAyTThFVzQrMFRIMEllUlFpKzRNYmZXZ0RUbm5TMmdlV1IxampqR1hkenRWUjZrbmdWbWp4VERkcURZUTNHcHEzU1MzVWVRUjZpVmlzYkQvY1pqN0duUStGN05KbG1samE5dUVPNFRYYm1kbGIxUU44c2Y4QTJ6Q2oyclNZYm0zSGsrcG9BeXZzK3JhZ2YzbDFiNmFuOXkwWHo1ZnI1c2loT2ZUeWpqczFjbDhKL0M5bjRXOFNlSmRBZUh6NXRHMUQrMU5PbXVtYTRtVzB2eTg0S3M1UGxnWFl2b2xWTm9DUUp4M1BvV2E0ZjRqYWpiZUFQaUI0VzhUWFZ4QloyTjlKSjRadjVacFJGRW91TVMyc2pNVGhtVzRnRUNMNjZnNXBsTHNkc1J1UHpmTWZmdlR1aHJMWHhISmZqL1FkUHU3aFc2VFhBTnBBUHFYSG1FZWhTTmdmWHZUVHB1b2FpZjhBU3RRTnZHVHpEWXA1ZVFlelN0bHovdlIrV2FSSmUxUFZyWFJZVmt2THEzdEkzTzFHbWtDQno2TGs4bjJHVFZNNjljM3YvSGpwbDFMMzh5OHpaUi9RaGxNdWYrMldQZXB0TThPMmVrWER5Vzl1a2R4SXUxNXlUSlBJUFJwV3k3ZjhDSnE0QUIyb0F5LzdIdnI0ajdacVVpb2VzTmluMlpTUFF1UzB1UjZveVo3anRWclM5RHM5Rk1qV3R0REJKTi9yWkZYOTVON3U1eXpuM1lrMWM2RDY5S3A2cDRoc2RHdWhiM0Z3cTNMTHZTMlFOSmNPdnFzU2d1dzl3cEZBRnZxYTQ3Uy8rS1YrTnVxV1gzYmZ4aFlyckVHQjF1N1FSV3Qxazl0MEQ2ZHRIZnlaajJOYnAxUFViMDdiWFQxdFY3eTN6Z0gyWllvOXhiNk8wWnJqUGpiNGNlejhMMmZpalVMKzh1bThGM3FhMU1rUit6UXJaaFhodi9raitlUUN5bXVXRWNqdUM4Y2ZHUlZJZmtkMXFQaVN5MHk3YTNrdVBNdWxBSnRvRWFlNEFQY3hvR2NEL2FJd1BXcS85b2FwcUp4YjJVT25vZjhBbHJldUpKRjl4REcyR0I5NVVJOU8xYUZucFVHandmWmJlQzN0NEl5Y1JRSUVqQjc0QzhWS0YyaWtJeXYrRVlGNy93QWhHNnU5UkRkWW5meXJjanVwalRBZFQ2U0YvcldsWldFTmhhcERCREhCQkh3a1VhQkVUNktNQVZJcTcyNkZ2WVZsdjR5c3BYYU96YVRWSlZPMHJZcDV3VStqUHhHaDluZFRTMUExQWNyajd0T0xlWEd6WitWQmtra1lBSFVtc2tQcTJwamR0dE5MaFByL0FLVGNFZmhpTkdIMWxGSVBDTnBkTnV2dk8xU1JDRHV2V0VxNUhSaEhnUkl3OVVSVC9PbUFvOFlXdDNrV0l1TldicG15VVNSRTl4NXBJaUJIZFMrZmF1UDhTTHJHai9HRHcvcXpTV2VsV1BpS0YvRGw2SVI5b21NaWlTNnNwREk0Vkl3cEY1RUZLT0dlOVFBa2tDdlJNZ0RjZm9NOXF3L2lkNFR1UEczZ1BVdFBzcEk0dFNaVXVkT2trenNodllKRXVMVjIvd0JsYmlLSmlPNFVqdlR1aW9sdUh3blp0TWsxeEcrb1hDSGVzbDIzbm1OdlZBM3lSbi9ybXE5dlFWcGtaTzQ3aWZVOWF4L0RuanJUL0UvZ2JTdkVTeUxZNmJxMXBEZVIvYW1FWmdFcUs0amNrNERybmFSMURBanFLay80U05yMGY2QlpYRjF1NlN5cWJlSC9BTDZjYmlQZEVjVkpKcWJ1UDhhaDFEVkxmUjRGbHVyaTN0WTIrVU5OSUl3VDZEUFUrdzVxajlnMUMveDlvdmx0MFBXS3lUYWNlaGtZRW4vZVFSbjZWUHArZ1dtbFROTkRDcXpNTU5PeE1rN2owYVJpWFlmVnFBSWpyMDkzL3dBZU9uM0UzbzkxbTBpK256S1pNKzRqSTk2YTJsM2w2MytsNmpKSEgzaHMxOGhUOVhKYVRJOVVaTStsYWFBZGFWazNqNWZ2WjR4UUJTMDNSTFBSM1o3YTJqamtsd0pKZ1Aza3Z1N241blB1eEpyRzhmRWVIdGIwSHhDdnlyWTNQOW0zcHgveTZYYkpHVDdiYmhMU1F0L0NrY25ZbXBkYitLV2hhTHE5eHBadnZ0MnNXd3pOcG1uUXZmWDBPZVI1a01JWjR3ZjcwZ1ZmY1ZtZUlZL0VueEowQyswdGRIMC9RZE4xSzNrdEo1TlptKzEzVFJ1aFZzVzFySUV3UTNERzZWaDFLY1lMUlM4enVTUG02Y2pqNlVzVXJRU3JJdjNrSVpUNkVWVjB5Q2EyMCszanVMbDd5ZU9KVWx1SFJWYTRZQUF1UW9DZ3NSa2hRQU04QUNweTNYMStsV1NmeU9mOEZ3LzJNby8yRmY4QWdwejhTUENXbjZjdW4rRTljdWg0bzhNeEpIc2hHblgyWlZpaUFQM0lKdlB0diszYzErOVgvQkYvOXE3L0FJYkMvd0NDZFh3LzhSWEYwMXhydWgycDhMNjJTKytRWGxtcXhobkp5ZDh0dWJlWTU1L2YxOCsvOEhlSDdGeS9FLzhBWk84SC9IRFNiUHpOWStGZW9qU05ia2pRYm4wZStjTEc3dDF4RGVDSlZBLzUvcER4aXZrLy9nMUkvYXMvNFJiNDQrTi9oRHFOMXRzL0cxZ05iMGVFeUFZdjdKVDV5SU01ekphdTdrNHhpekh2VlVQaGRQOEFyVC9nQlUzVXY2L3E1KzhNYjU2L2hVNlBrK3ZwNjlLcHd0bEFWNVByai9QK1RWaEd6aFIxNzVxUUxTRVovd0IzdUttamZhY25IWVZYUnp6M3dldUtsVDd3UHYxelFCWlJ0eC96L09uS2NnZnpxRkdJYjYxSWpFTDBxTmdKbGY4QVR2bnJUczRHTjJmVEZScDMrbE9Sc2pyK1B2VGlCTG5QZm9lS2Z1OThidWFpWDVUMytsS0pPYW9EamYyaDdxNFB3bjFEVGJHVnJmVVBFa2tHZ1djcUhhOFUxN0tscXJnLzdCbDNld1VudFhyRnJaVyttMjBWclp3eDI5cGJvc01FU0RDeFJxTUtvSG9GQUg0VjVYcmNmL0NVZkh2d1JwUHkrWG84ZDc0bXVSL0N3aWpGcEVuKzk1dDZKQm4vQUo5ejZWNnhqQXFSdnQvWDliRHVncFZPRzlzMHhUdDQvQ25nOGY4QTFxRllROU9WNlU3UFAvMTZqN0dsVTVYbitWRmdKQmtBOThldE96elVXY0UwOEhKNzB1VUNRUDhBNDhVdTdJNlV3ZGY1MHFISHI2MGdKRlBOTHV6bitmcFRBZHBweURjS0FIYzd2YW5EaW1nL04zL0tnOUtBSk4rUVA4YWRtb1ZYQjlqVWgvTEpvQXI3T090TllaR0tmaWtjWi84QTFWNTV1bmNoY2JjMTUvOEFHRkJxL2l6d25wZk9KcjN6M0dPcXBqcit0ZWhPdlA2VndkemEvd0J1ZkhhTno4MGVpNmZ1QTlIY24ralovQ3ZrT05xYnI0R25nWS84dnF0S1B5NTFLWC9rc1pGUjMxT3luRzQvV3FWNGlUYmtrRzZPUWJYSHFwNFA2WnE2NHgrdFZib2ZNMzVWOWRJUitILy9BQVRyL2JVOFUvQ0QvZzVkK0lud3Y4YVIvd0JqNlQ0b1RVUGg1WVdJbFBrd0d5ZVMrMDI0eVFQTWFjTEtWYkF5ZFF3QUJqSDdsdjFyK2ZUL0FJT2hQaGhxMzdIZi9CUzM0Ty90SmVFWXZzMTVya2RwcUhtaGNxMnVhSlBDUXpub0E5cTFpdVA0dkprNjg0L2ZINGFmRXJTZmpQOEFEYnczNHkwR1h6dEI4WWFUYWE1cHNuL1BTMnVvVW5pUC9mRWkxMHdrVHE0cS9UVCt2WFV0K0pQRDFuNHY4UDZocE9vS3oyT3EyMHRsY3Fwd3pSU29VZkI3SGF4NXJKK0dHdjNuaW53SnA5eHFETEpyRVFlejFJb3UxVGVXOGpRWEJVZjNUTkc1SHFDRDBJcnBHNEpyZ2JEd3phVy94ZDhRV0Y1OW91TFBYSUlkZHRiYVdaL3NyU0tGdGJwUEpCQ09xK1hhU0hlRytlN1k4Y1ZVdTRMYXgwZDM0d3NJTG1TM2psZS91b3p0ZUN5amE0a2pic0gyQWlQUHJJVkh1QnpUWHZOYTFOdjNkdFo2WEgvZXZIKzB6ZlF4UnNFSHNSSzMrN1dyYldzZGxheHdReHh3d3hEYWtjYWhVUWVnQTRINFU0akFwTHlKTWQvQmx2ZkQvaVpYRjVyR2VDbDNJUElJOURDZ1dKc2R0NnNSNjFwUXdyYVc4Y01TeHhRd0tFampRYlVqVWRBQU9BQjZDblh0N0RwdG85eGN6UjI5dkh5OHNyaEVRZTdIQUZaWjhWQytYL2lXMmQ1cVhwS3FlVGJuMFlTeVlEcjd4ZVo5RFd1d3R6VjY5YWl2OVFnMHUwYTV1NTRiVzNUaHBacEJIR3YxWmlBS3p4WmF0cVkvMGkrZzArTS84c3JGQkxJcC93Q3UwcTRZSDJoUWoxNzFOWStHTEd4dTB1bHQvT3ZJK0Z1YmhtdUxoUjZDU1FzeWovWkJBOXFPWmlzaUFlS0RxSC9JTnNMeS9IL1BWayt6VzR6ME8rVEJkVC9laVdRZnBYSWVBdFAxVFR2SG5pencvZGFnbGhhL2FJL0VGamI2ZkdHS1EzcGs4OVBPa0IzL0FPbVEzY3JiWTBaZnRLY2dFQ3ZSY1pQUFAxcmp2aUwvQU1VNzQzOEkrSWx5c1NYYitINzQ5VkZ2Zm1OWWpqKzk5dWhzVUI1QVdhWDF5QnJxRWV4MFdtK0diTFNyejdWRmJxYnpCWDdWTTdUM09EMUhteUZuMisyY2UxWHR1U09wNTcxWDFQV3JUUklvM3ZMcTN0VmtPMlB6WkFoa1Bvb0p5eDloa21xYmVJYnU5NDAvUzdpUmYrZXQ4eHNZdnBobGFiUDFpeDcxV3d0VFd6VlBWdGVzOUNXUDdaZFEyN1RmNnBYYkR6SDBSZnZNZlpRVFZOZEZ2cjQvNmRxa3BUdkRZUi9aWXlQUXZ1YVVrZXFPbWY3dFd0SThQMmVpR1JyTzJodDVKdjhBV3lxdVpwL2Q1RDh6bjNZazBDS284UVhtb2ovUWRMbThzOUo3OWphSVI3Smhwc2owYU5BZjczZWc2RmVhai94L2FuY3N2ZUd4SDJPTS93REFnV216N2lVQS93QjJ0WUp0SHJRclVES3VrYUhhNkhISXRuYTI5bXN4RFMrU2dWcGo2dWVySDNPVFhNZUlGWHdyOGFkQjFKUnRnOFVXa3VnWFRaeVh1SUJMZVdXZjdxcW45cEtUM2FhTWVsZExxSGlTeTB5Nyt6eTNDdGRZeUxhSldtdUNQWHlrQmZIdmpBcmtmakRaYTk0dStIT29Mb3VteHc2dHA1aTFYUy90MGdMVFhscEtsekFubFJra3BMSkVzYkJuUnRzamNkaXRCeDNPOFhuL0FBclB1L0U5allYVFc1bjg2NlhHNjN0MGE0bVRQUXNrWUxLUGRnQjcxbTZCRGErT1BEOWpxcTZsZDZ0cDJyV3NWN2FrTjludDVZWlVEb2ZMVEJaV1ZnZHNyUHdhM0xLd2gwNjBXM3Q0WWJlQlB1eHd4aU5GK2lqZ2ZoVEVaN1gycVgzK3B0YmZUMS92M2ppYVFmOEFiS0p0cEI5Zk5COXFSdkN5M3lmOFRDNHU5VDNkWTVtQ1FlNE1TQlZaZmFRT1I2OTYxZ20wMHFqUHZRSWl0clNPMHRZNFkwU0dHSWJVaWpVSkdnOUFvNEFwNnJ0N1ZtdjR2czVYWkxNeTZwSXB3VnNWODVWYis2MG1SR2plenVwcHBmVnRSKzZMWFRJL2YvU3AyL0xha2JENnlnL3pBTlk4S3g3S01rOWdQV3ZOL2piNHlzOUs4T1dIaWl3KzBhb2ZCZW9KcTA3V1NDU0g3SHRlM3ZpMHBLeGZ1N1NlZVVLWEJMd3g4SEdEMlgvQ0pXdDBWYTlFbXB1cHlEZXNKbERmM2hGZ1JLM3VxQTFvWHRoYjZyYVNXdDVDbHphWEViUVRReURLU1JzTnJLUjZFRWpIb2FCbEdTRFY3dVJra2EwMHRNbFdFUSswejQ5UXpBUm8zc1ZrSHVhSS9DZG84aVNYTWJhaE5HMjlaTHgvTzJOL2VWVDhpSDNSVnJGK0NGOU0vd0FQTGZUTHlhUzQxTHd4TEpvRjdMSWN5M0QycmVVazcralR3aUc0eDJGd092QnJxcnU3aDArMGt1TGlXTzN0NGhsNVpXQ0luMVk4RDhhQWVqSHZ1WnR4Wm1iM05KSU1xUldXZkZhM1lYK3o3UzcxRlc2VElvanQ4ZG1Fc20xWFgzajMvU2xXejFYVU9acjZIVDQyL3dDV1ZsR0pKRitzMGd3d1B0RXBIWTk2QkYrOHY0Tk1zbXVMcWFHMnQxKzlMTklJNDErck1jRDg2b0w0bWErNDAreHZMM2ovQUZycjludHg2SGZJQVdVLzNvbGNmMWZwM2hpeDA2KyswTEI1dDJuM2JxNGRwN2hRZXl5T1N5cjErVUVBZWxhTzM1dDNlZ0RLK3dhbnFKLzBtK2pzNC84QW5sWXhnc1BacFpBZHc5MVJENzFsK09QaFZiK0svQityV0ZqNVZuckY5YkZMTFU1eTA4OXBjcVJKYnpHUmlaQ0k1MGlreG5IeUN1cUp4VlhWTmF0ZEVqUnJ5NWh0dk40akVqaFdsUG9vNnNmWlFUUU5GTHdMNHdpK0lQZ3ZTZGVodDVMTmRYdEk3dHJhUTVrdEhaUVhoYi9iamJjamVqS2ExeWVLODUrSFd2WFdrK05mRnZodXoweWZ5WTd4ZGYwOTcwbXppRnRmbVJwVjJsV2wzaStpdm5LbU1BTE5GeU1pdXdPaDNsLy9BTWYycDNESzNXS3lVMmFIMzNCbWx6N2lSUjdVeHN0YXBydGxvcnBIZFhFY01zby9kd241cFpmOXlNWlpqN0tDYXEvMnpmWDQvd0JEMDJTT051azE4L2tLd1BkWXdHay80QzZ4bjNGWE5MMFcxMFZYV3p0NGJiekRtUXhKdGFVK3JucXg5MkpKcTBLUkprblFMaS9KTjlxVjFObnJGYTVzNFQ3L0FDa3kvVUdRcWZRZEt1YVpwRnRvdHMwTnBidzJzTE52WklJMWpWbTlUZ2NuM1BOV2g4eHgxck92UEZOalkzYjIvbmZhTHVQNzF0YlJ0Y1RwL3ZJZ0xLUGRnQjcwOVdCb2hjQ216VzhkNUcwTTBNZHhES3BTU0oxM0xJcDRLa2R3UmtFZWxaZjIzVnRTL3dCVFoyK21wMmU4YjdSS01mOEFUS0p0blBZK2RrZDFQU2tQaE9PLy93Q1FoY1hXcER2Rk80RnVmWXdvRlJoNmJ3NTk2QU9VK0RIalcxc1BCemVHMnVMalV0WThGM01uaDY2aWdCdVo4UWJmc3J6TXZ5bzgxbTlyTVM3S016RUVnZzQ2ejdUcTJvTCs3aHRkTlE5N2cvYVp2Y0ZFSVJUNkVTT1Bhc0NPM2o4RS9HbUJJMVMzMHp4aHB2a0xHQUVpanY3TExxcWdjZVpOYVNTay93Q3hwZzlLN1hIRk5qZTVrdDRRdHIxZitKaEpjYXQ2cmV1R2lQMWhVTEZuMzJaOTYxRVJVUlYvaFFCVkhaUU9nQTZVU3lyQkMwa2pMSEhHTnpPeDJxZzlTZTFacStLb2J3ZjZCRmNhcDZTVzZqeUQ3aVppSTJBNzdHWWowenhScXhHcGlvN2k1aXNyV1NhYVNPR0dNWmVTUmdpSjlTZUIrTlo0ZzFXL1A3MjR0OU5qL3VXcStmTDlmTWtHM24wOG80L3Zla2xyNFpzN2U0U2RvemMzTWZLVDNMR2VXUDhBM1djblpuMFRhTTlxTkFJMDhVSmQ0YlQ3YTUxQU1PSlVVUndZN0VTUGdPdnZIdjhBNVVDejFTK1A3Kzhoc1kvK2VkbW05L29aWkJ5UHBHcDk2MHp5YzlUNm1nOGY1NjBnT0MrRm5odXo4RitQUEZHaUpEdWtodWY3ZXNMaVoybW0rejZnOHJ6SjVqa3RrWHNkNHhBSUNwTkNNY2pQZkQ1VFhudnhnOFdhYjRDOGQrRWRVbXVsYlZJWjVOT2sweTNScnJVcnl4dkRHcnREYXhCcHBSSGNRMmtyTWlOdGlobVBBeWEyRDRzOFJlSWwyNk40Yyt3eE53TDdYcHZzNHdlanBheEI1bngzam1Oc3g5UjFwNzZsUHVkWXB6L0xpc1B4SjhTdEQ4S2FwL1o5NXFFWjFUYjVnMDYxamt2TlFLZjN4YlFxOHhYL0FHZ21QZXFJK0hWN3JaM2VJUEVXcmFpcDVOcnA3TnBGa0QwNFdGL1BZSHVzdHhLcDlNY1Z1ZUcvQyttK0R0TCt3NlJwdW42VFk3aXh0N0syanQ0UzM5NG9nQXo3NHpSeWkwTVAvaEpQRkhpSGpUZEJ0OUZnYnBkYTdjQjVQWmx0YmRtM3FmU1NlQnhubGM1RkErR01tdERkNGgxclZkYzMvZXRGayt3NmVEM1VRUTdUSkdmN2x4SlA3azExblNzYjRpZkVidzc4SVBCMXg0aThYZUlOQjhKK0g3UC9BRitxYTFxTU9uV1VIKzlOTXlvdjRtcUVYdEQwR3g4TDZMRHB1bDJkcHB1bjJvSWh0TFNGWUlJYzhuYWlBS3ZQb0t0RGl2bkQ5bkQvQUlLd2ZCUDlzVDlvclV2aHA4S2ZFVjU0KzFiUXRLbTFqVnRWMDJ3a1RSdE9oU1dLRUEzTTJ6em5ra21RSjVDeUtRSFlzQXRlNGZFSHczSjhRUEJPcWFMRnJXdmVHMjFTM2UzWFZORXVVdDlSc0N3LzFzRWpvNnJJT29MSXc5UWVsSFM0RmY0dy9HM3dYK3p6NE5ieEY0LzhYZUdmQStncWR2OEFhR3ZhbkRwOXU3ZjNWZVZsRHNleXJsaWVBQ2EvTnY4QWE2LzRPMC8yYy9nWjlxc1BoeHAzaWo0emF4RXBDVFdVTGFMbzI0Y0ZXdWJsUE9PRDNTMmRXSFJzWUovRVgvZ3N2K3pUOFNmMlJ2Mjl2RmZnMzRuK05QRVh4STFTSkliL0FFcnhWcmQ3TmQzV3VhYk1wYUNZdE03c3JERHh1Z1lxc2tVZ1VsUUdQeWswak9mL0FLOVo4Mm1oVnJINnYvRUgvZzZrK0lIN1RYaUR4RjRUK0tYdys4SVNmQXZ4eG9kLzRhMXJ3em9FTExxa1VGMG0xTDZLOXVHY3RlV3h3NktWamhmQkJSSDJTeC9BZjdFWDdRVjcreW4rMDE0TCtJbGhoNzN3WnFzT3ArV0R6ZFJvY1RXNDVIK3VoTWtSN1ljOXVSNDJwTzZ0alFaaERkd3pNektOd1ZzSUd4MXh4a2ZUSDFxb3l0SlNKbHFyTS9zODhLK0o5UDhBR25oM1Q5WTBlNmp2dEgxaTFodjlPdUVQeTNOdk5HSklwQWZSa1pXejZFVnJJNUM1ejh2UVlQSGV2aGIvQUlONXYyaFpQanovQU1FNGREMHU3a21sdnZocmZ6K0YyZVhrTmJLcVhGb1FlQnRXQzRXSWNEaUFjRGl2dW1OQ0FEOTA0L1d0S254YUV4ZDBUb2VmbSs5K1ZUcjFHMzhpS2ppUUJjZHUzRldFVDV2dS93Q0ZTVUtqL0x6bXBVRzQ5VG5PS2JHZG85czA5RkFIME5TQTZQcitPYWVqZGUvZkZSb00relU0RGMvVWY0VklFd2JBcFM0QS9TbUV0Z2UvZkZWOVYxS0xSOU51THk0Wlk3ZXppZWFWbjRWVlFFa242QVZXeURmUXhmZ3hGL2IzeFMrSUd1a0R5N2U0cy9EdHQ2YmJhSDdSSXcvM3BMM2FmZUFlbGVuTDA0SHRYQmZzMTZQTm8vd084UHlYVWJRM21zUXlhNWRvNHcwVTE5Szk0OGJlNkdmWjlFQTdWM2dPUjF4UUQxWTRVcTRCQi9QaW1yelRqU0FlRGsvL0FGNlVjZHVuZW8xT0QxL1duNXlLYUFlejdSNjBZd1A2VXdISVBYcjFwZCtXbzh3SkZHQ1BwMHArY0gvNjFSam4xcDU0WCtLcEFjclpQcFRsNmNaOTZqVWMvWDlLZUdGQUQxT0RqK3RPUnVLajZpbkJzUi81NG9BZU9SU3J3ZU90TlU5UGNaby9pNzBBTjI4VWRhazI4MDF4eC84QVhyenpRZ2RjajYvenJrUEFzWDIzeFQ0bDFESCtzdTF0bE9PeUwvOEFYRmRkZlQvWmJXU1Z2dXhxV1A0YzF5dndodDJUd0xielNmNnkrbGt1Vy80RTJCK2dGZk41bCs5emZCMExmQ3FsVDdrb0wvMDQvdU5ZN05uUk9PUHhxcmRyZ01hdFNjQS9Xb0p3UUQ3MTlJSStFUDhBZzRiL0FHUElmMnZmK0NhUGlSWXh0MW40ZFgxdjR1c0pRb1psamgzUTNZSi91QzFubWtJN21CZllqVy80TjQvRVhpaS8vd0NDVi9nZlEvRlduNnRhM0hncTZ2TkQwdTl2clo0UnJHbHJMNTluY3hiaGhvaEhQNUFLbGwvMFlnTWNWOWhlSU5Bc3ZGR2c2aHBXcFdzTjlwdXFXMGxsZDJzNkI0cm1DVkNra2JxZUdWbFpsSVBCQklxVHcwRXNaQmJJcXh4K1dJa1JWMnFubGpBVlFPQUFvSUFIR01ZcWFjcGM2VjlDazBvTmR6WE5jaDhWcG8vRGt1aGVKcEpJNFl0QnYxaHZaR1lJQlozV0xlVGN4NFZFa2EzblluamJhbXV1SCtlYXArSmZEOXI0dThONmhwTjd1K3g2cmF5MlZ4c2JEQ09SQ2pZUFk0WTRQWTEyMnVZM3RxVXg0cmp2Qi94TDdXODFMMGtpUVJ3ZlVTU0ZWWmZVeGx6N0drTnJxK29OKyt2TGZUVS91V1NDZVhQL0FGMWxYYmoyOGtIM3FENGErSWJyeFg0RjArNjFJcTJxcWoybXBiZnVpOGdkb0xrTC9zK2RISmc5eGc5NjNBTVVrRXRIWXpyWHdwWTJsMUhjK1FKcnFQN2x4Y3UxeE1uKzZ6a2xSN0xnZTJLdnN2YzVQcm1vZFIxSzEwYTJOeGVYTnZad2JzR1NlVVJyazlzbkE1OUtvLzhBQ1NTWDVIMkRUcnk2WC9udE92MlNFSDNNZzh3anZ1U054NzlxdUtFOVRTSnovd0RxcUhWZFd0ZER0bG12THEzczRuYllyenlDTlhiMEJZOG4ySE5VbTB2VXRSNXU5Uyt6b2Y4QWxqcDZiTWorNjByN21iMlpCRWFuMHJ3NVk2SGNOTmEyeUpkU0xzZTVabWx1SkY5R2xjbDJIMVkwNzNFVi93RGhJYmk5NHNkTnVwdlNhN3paUWoxenVCbCtoRVJVK29ITlkzeEIrRzk5OFUvQTJyNkhlNjVMcG8xYTBrdDRuMDZMeWZzc2pEOTNMNWpGcEMwY2dSdzBaaU9VSEZkZHQyNCtuNVVwSEZPM2NWK3h5L3dvdmJUeEw0SjAzWG9OUGgwMisxZTFTUzlRRXlUd1Q0eE5CSkszenVZNVE2SGNjNVExMHdURmNMNFExeXo4QmZFRHhWNGJ1cmlPSHpybFBFV213ZFhraHZqSjV5SWd5N3VMMkM4bFlLRGhibUt1b09yMzE4ZjlEMDVvNDI2VFh6K1FyRDFXTUJwQ2Y5bHhHZmVrdXc1YjNOT3FlbytJYlBTTGhZYmk0alc1ZGQ2VzZneVR5TDZyR29MdC93QUJCcXN1Z1hGOTgxOXFWMU1EMWh0TTJjUHRqYVRMOVFaU3A5QU9LdTZicE50bzF1ME5uYncyc1R0dlpJWXhHSGIxT09wOXp6VkNLWDlyYWhxQy93Q2k2ZjhBWll5UDlicUQ3TTU2RllrM00zdUhNWm9QaCtXKy93Q1A2L3ZMb2Q0b0Q5a2dCOWdoOHdqL0FHWGtjZTFhcXJ0cGU5QVg3RmZUOUxnMG0yOG0xZ3Q3V0hPN3k0SXhHbWZYQzhaOTZtVWVXUVY0WmVSN1ZRdlBGTmphM1QyNG5OeGRSbkQyOXRHMXhLbnB1VkFTZ1BxMkI3MUViN1ZyNy9VMnRycHFZKy9kdDU4b1BwNWNUYmNIMTgzOEtCR0Y4SEYvc0llSVBDMjNiL3dqT3FTTGFBZngyTnovQUtYYmJWN0pINXNscXY4QTE1Tmowcm9adkZ0aWs4a01NajMxMUUyeDRiUkRPOGJlamxmbGpQOEF2bFI3MXhQaWJ3ckZvZnhtOFBhcGZ6WFdwV3ZpZTJsOE8zYVhEQVJOUEdzbDdaRm8wQ3htTkZYVVVHOVdZdmRSak5laVFXMGR2YlJ3eHFzY01TaFk0MEFWRUE2QUFjQWV3b0tmY3pUY2F0Zi9BT3JpdE5NaVBlYy9hWi9vVVFoRlBvUkk0OXUxQjhKMjkyUDlQZWZWUzNVWGpCb3ZiOXlvV0xqMTJidlVtdGJ0UVcycXpIN3FqTEhzbzk2Q1JxeEtrYXIvQUFxTnFqc285QUtjT0t5UjR2dGJ3ZjhBRXZXZlZ2UTJhaG9qNi92bUt3NUhwdno3VWhqMWZVU0EwMXJwY0o2aUJmdE54anRoM0FqUStvTWNnOUQzb0ExWjUxdHJlU2FSbGpoaVVzOGpzRlZBT3BKUEFIdWF5MThYUVhpLzhTK0M2MVVkbnRrQWhQdUpYS3h0anZzWmlQVHRUb2ZDRmo1OGM5eEcyb1hVTGIwbXZHKzBORTM5NUEzeXhuL3JtcWl0UWpjMjVpV2IxSnpRQjV2Wldtc2FQOGRMNkdTOHRkTDAvd0FhYWF0K2tka291SkV2ckx5NEptTXNxaGQwdHZOWmdMNVRjV0xuSTc5cmFlRTdHM3U0N2xvVGMzVWYzTGk2a2E0bWpQZmF6azdNK2liUjdWZ2ZIQmpvM2hLMzhTS0Q1bmd1OWoxeHlPb3RVVjQ3N0EvaWI3Rk5kYlY3dUU3Z1YxbXBYOXZvbHUwMTVjVzlyYnEyM3pacFZqanovdkVnVUZQVkV4WEw3ankzcVRTRTRyTC9BT0VsZTlIL0FCTDdDNnVoMEVzdyt5d0Evd0M4NDNzRDEzUm80cHAwM1V0VEgrazMvd0JsajYrVllSaFQ3aHBYM0Z2WW9zWkg4Z2t1NnRxMXJvVUtYRjVkVzluQzdlV3J6U0xHcnNlaWducWZZY21xbi9DUTNGLy9BTWcvVGJxWWRwcnJObkQrTzRHWDZFUkVIMXh6VStuK0c3SFNiaHByZTNWYnFSZGpYRHNaTGh4Nk5LeExzT25CWTlCVnhEdVhOQUdXZEoxQy93RCtQelVtamo3dzJLZloxSVBZeUV0TG4vYWphTSt3cTFwZWcyZWpQSTFyYnh3eVRjU1NnWm1sL3dCK1E1ZHZxeE5YRFZMVS9FTmpvMDZ3M0Z4SEhjU0RjbHVvTWs4ZzlWaVVGMi80Q3BvQTVyNGliZkRQalB3bDRqKzdCSGR0b0YrM1lRWDdScENjZDIrM1JXS0Evd0FLelNucG11d0grY1Z5dmp6Ujd2NHBlQ2RXMEtLMWZUYmZXTFNTMVcvdTM4dVMyWjFJUzRqaVhjKytOdHJnT1lpR1FWQjhOYjI4K0ozZ0xTOVkxcTRuWFVMeURicU9uMnpHMXRySzlqWXhYVnVBaDNzSXAwbGlJZVIxSlE5cVpYUTZYVWZFbGpwVjM5bWx1Rk40RkRmWm9sYWE0Mm52NVNBdmozeGlxNTFMVkwvaTFzWXJHUE9ETGZTQjNIdXNNWk81Zjk2U00rMVh0TzB1MzBleit6Mmx2RGF3YmkzbHdSaU5NbnFjS0FNbjE2bXJCb0pNaytHRGZEL2lZWHQzZi84QVRMZDVFQTlSc2p4dVUra3BrK3RhRm5ZdzJGb3NGdkZEYndKOTJLSkFrYS9SUmdDcGh5Y0FIOEJXWWZGbG5MSTBkbTBtcFRLeFVwWnI1b1ZoMVZuejVhTjdPeTBhZ2FkQjduc295VDJBckpNbXJhajkxYlhUWTI5ZjlJbng5UGxqUmg5WkI3SHBTLzhBQ0kybHpnMzNuYXBJcHp1dldFaWdqb1JIZ1JLZmRVQnBBY244YU5kWFVmQVV1cWFEYjN1dmF0NFh1STljc1k5TWpFMzJoN2NscGJkSkNSRnZudHpQYjQzN3NYQndNMTA5aGZYbmlld3Q3eXp2TEdEVHJ5Slo3ZWUwUDJwcDRuQVpKRmRnSTFES1FmdVNEQjRQZXRvT3l5Q1FOODY4cXhQSUlyaWZncUY4T2FicTNoTWdSLzhBQ0hhZzFsWnIwQjA2VlZ1TExZUCtlY2NNbjJZSHUxbkozQnFyak9pZzhKMmduam11Rmt2cmlJN2xsdTI4NWxiKzhvYjVZei8xelZSN1Zwa2M5ZWVtVFdaNHA4WmFQNEVzNDdqV3RVMC9TWWJodGtMWGM2dy9hSC91UmhqbVJ6MlZBV1BZR3NZZkVQVk5kQi80Ui93dnFWMUczM2J6V1MyaldwUGNiSkVhOHlPeCt6Qkc3UGptalZpc2RaakZaUGl2eDNvM2dVVzQxalVyUFQ1THpJdFlaWlA5SXZDTVpFTVF6Sk0zSStXTldQdFdTZkF1dmVJUCtRNTRvdW9vYzRObG9FUjB1Rmw2NGVmZkpkRmdmNDRwb1FRQjhnNXpzK0UvQVdpK0JqY05wT20yZGhOZVlOMVBFbitrWHBHY0dhVTVrbFBKK2FSbVBKNW81UU1mL2hPZGE4UVpYUWZETjRzZlVYbXZTblM0WEhxa0lXUzYzRFAzWllZUVJuNXh4a1g0ZTZ0cjRCOFErS05TdUl6OTZ5MFpXMGExSjdIZkc3M2VmVWZhZ2pkMHh4WFhBS0Jpb2RXMVcxMERScnJVdFF1clhUOU5zVU10emVYVXl3MjlzZzZzOGpFS2lqMVlnQ2l3RlB3dDRMMG53Ulp5MitqNlpZNlhEY052bVcxaFdMN1Evd0Rma0tnR1JqM1ppU2U1clRBeFh3cCsxZC93Y2Nmc3Fmc3J0ZFdjUGp1WDRuYTlia3IvQUdiNEl0aHFjWWJuR2IxbVN6eDY3Sm5ZZjNhL01mOEFhMS80Tzd2akY4U1Z1dFArRWZnL3dyOEs5TmZLeDZsZTQ4UWEwUFJsTXFwYUpudXJXOHBCeGgrNVkrVS9vVzhVK0p0TThEZUdielc5YzFMVDlEMFhUMDh5NjFIVWJwTFN6dFYvdlNTeUZVUWU3RVY4RS90Wi93REJ6Sit5Myt6TDlwczlGOFNhcjhYTmVoeWkybmc2MldheUQ0T04xOU0wZHV5RWpCZUF6NHo5MDlLL212OEEyaXYydXZpWisxcDRuWFdQaVo0KzhWK1BOUWpabmdmV3RUbHVvN1F0MUVNVEh5NFYvd0JtSlZYMnI3My9BT0RjWC9na040Ri80S1IrSi9IbmpQNHJEVTlTOEVmRDZXenNJTkNzN3g3TmRjdmJsWlpEOW9takltV0dHT0lIWkdVWjNtUTd3c2JLNHJ2WUxwRy8rMWovQU1IYTN4OCtMNzNOajhNZEU4Sy9CN1NIT0k3aUtKZGQxbkhmTnhjcDluR2Y5aTFWbDdQM3I4MmZqcCswdDQ5L2FYOFlueEI4UlBHZmlyeHhyV0NxM211Nm5OZlN3Zzg3WS9NWWlOZlJVQVVkZ0svcGYrT1AvQnRGK3gvOFlmQjB1bjZYOE83L0FPSGVwYmRzR3NlR2RjdkJjd0hzVEZkU3pRU0QxRFI3aU1nTXBPYS9uUy80S09mc0krSnYrQ2J2N1czaVQ0VStKN3kyMWVUU2ZLdTlOMWEyaGFHSFdiQ2RkOXZjcWpFbEdLNVYwM05za1NSUXpoUXpUcVBYb2Zabi9CclQrMjk0Si9aYi9iajhVNkQ0KzFqVHZEZW5mRkRRRTByVDlXdjUxZ3RZTlFodUZtaWlsbGJDeHJLaGxVTXhBOHdScWZ2QWoraWo0My90QytBZjJZL0JrSGlMNGtlTmZDdmdUUXJ4L0x0cjdYdFVoc1lieDloZlpDWkdIblBzQllKSHVZZ1pBTmZ4SytXVzQ5Zlh1S2ZiYVRKZG5FVUxPd3lTRlhKL0wvQ256TnF4SjlwLzhIQmYvQlJEd24vd1VsLzRLQVNlS3ZBWXVMandYNFQ4UDIzaFRTZFJuaGUzazFtT0dlNXVaTHJ5bkFlTkdtdTVWUU9BeGpSQ3lveEtMOE45RC84QVdyVU9qL1p4KytrV001MjdBZHprL1FaeGozeFhYZUFQZ0w0bStJMTlGYWFKb041ZVhOd1I1QWtHMXB4endrUStkMnoyWGQweGlvdWx1YWF2WTRXenNwTHk1Vkk0MmxadjRVQkxIOEJ6WFplSDlEMDNTZkQrc1hPbzNWbkxkVzhjYTJkc2x3MjZTVnBrK2Y1VVliVlZaTndrYU00T0Fja0EvYWY3UEgvQkJqNHJmRk9LMW04UjI4M2gzUzVtV1o0cjlqWmdqalA3aFZhWGQxKzhrZlFjaXYxWi93Q0NaUDhBd1M3K0VmN0ROOS9hbXFhQkg0djhRTWlLbDdkYWRCTGIyN0pKSEtzcXh5NzM4eEhpUmxjdVFwRzVWUW5qbit1VWVibDV0VFg2clV0ek5IcUgvQnY5K3hscWY3S3YvQk9QdzlENHQwcVRUZkUvamk4bDhVWGRsY3crVmM2YkRNa1VkdEM0d0dSekRFa3BRNFpHbktubGErMTI4Snc3aHNrbWpBSENNZDZqdjMrWS93RGZWVnRFK0kraTY4d0VlcFFpWnVkcytZV0ovd0NCWXp6Nlpyb294dVVOMlBJNTYxMWUwNW5lTE9ibGNkR1lUZUg3aUEvS0k1Vi8yV3czNUhBL1UxQk5HMXFmM3F2RDJ6SUNvL0FuZy9oWFVLbkdLY0Y1eCtkRjJCekFqWlQvQUNHT1RTaGNIN3A0NjhWdnZvZHJJZjhBVXFuZk1meVordU92NDFYbDhPRlIrNm1iam5FZ3orb3hnZmdhUUdWc3h4NjA1UnVYYjdkL3lxMUxwRnhEL3dBczl3OVVPNEQ4T0QrbFFiZjNwWG5mL2QvaVg2anJRQTNkeHo5YTRyOW9LRnRkK0h3OE9vekxKNHl2YmJ3OFNwK1pJYnFWWXJpUWU4ZHVacFArMmRkc1V3UDhlMWN1TFFlS3YyZ3ZEOXZuZkQ0VHNMaldwd1ArV1U4NnRaMm9iL2VqZStJOTRUNlU5ZXBVZTU2amtGMjJxcXFlaWdZQUhZVWpmZW9YNzFHTW1rVHRvT1E1TGUxT0hQMXBxSG1uQlFlT1B6b0FjYUFmVHQ3VW1lS1FHZ0NRSFAxcFJ6eFRGT0tjZVdYMjU2MHdKRVBQNmlsUEIvclRBZHdvQjRXbllDVU5rMG9iam9hakJ6NzgwNVRqTkt3RWcrWWZTbkRuOGFpQkRZRk9CK25ha0lrRFpxUUVZcUVQdS9LbktkcG9HUzBqRElwY1pQeTBkYTg4MEtXcnhlZllUUW5QNzVUSHdQNzNIOWFpc2JDUFRMS0cyaUcyT0JBaWdlZ3E2NkJtK2JuYWNpb1hHRFdQc1krMTlzMTcxclg2MjN0OS93Q1JjZHJFRGo1VC9uTlJUL2QvU3A1dW41OXFobFBGYkRLVWdyeDc5cVg0eFgzd1dtOE8zdHZIbXpiVUV1cmwxUHpPa0xvWGlBOUdVNEo3WkZleHlMdDNWOENmOEhJMzdNZi9BQTBQL3dBRXZQRk9zV2R1MG11L0N1OGg4WDJqeDhTaTJqM1EzeWdqb290WnBKVDJ6YnFld3FZL0VITmJVL1FnUEhLTjBUckpESUEwYnIwZFR5Q1BZam1rUEZmSGYvQkJIOXA5djJxLytDVkh3dDFTNnVSY2E1NFJ0SlBCdXJBdHVkSmRQYnlZTjU2bG5zemFTRTl6SWV2V3ZzTTgvd0Q2cTdJdTZKcVI1Wk5IRTZmZlhIaFQ0bjYvcE50WXpYU2ExSEhyMW94bFNLQkhJVzJ1VXlUdXdyUlFTdHNSanV2TWtET1R2ZjJmcWQvemMzeVdhSC9sall4L01QOEFaTXNnTzRlNnBHYXovaVAvQU1TWFV2RHV2TDAwL1VFc2JvOXphM2hXM0k5bFdjMnNySHNzQnJwTWNlL3ZRdHc2SW82ZDRac2RLdVB0RU51djJyRzAzTXJOTmNFZWhsY3M1SHNXd0t1bVBtb2RTMWUxMFdPTnJ5NWd0dk5iYkg1cmhmTVBvb1AzajdESnFsSnJsMWVuL1FkTm5rSC9BRDF2R05wRjlNRUdYUHBtTUEvM2hWa0dtNHdQeHFwcW10Mm1qK1g5cnVZYmRwZjlXanQrOG1Qb2kvZWMreWdrMVhPajNsODMrbWFsTHMvNTRXU2ZaVUk5M3laYys2T21mVHFLc2Fab2xyb3ZtRzF0NFlHay93Qlk2TCs4bDkzZjd6SDNZazAwSXEvMjNlWGVmc1dteTdPMHQ4NXRVUDBUYTB1ZlprVWU5SDlpWFY2UDlOMUs0a1gvQUo1MmFtempQNGhqS0Q5SkFQYXRRSnh4U2RENzFSUG9jTjR1MFcwOEErTlBDbmlDeXRiZTBoYTdmUWRUZU5BcGFHKzJMQzdrRGM3L0FHNkd5VExFNEU4aFBldTZIRmN6OFU3S3k4VmVFTlc4T3phZ3RucUdxV2J4MnhqUXpYTnJLUm1HNFNKQVhKamtDT0NCMVFWWDhBZkVMVXZpZjRGMGZXcmZTbzlKYlU3VkpyaEw2VExXYytNU3dpS01rc1lwQThiSzd4c0dRakhXZ3JvZGQxcWhmZUpySFQ3dHJacmdTWGE0SnRZRWFlNEFQY3hvQzRYL0FHaUFCM0lxQWVIWHZnRGYzMTVlZHpHakcyZ0I3NFNNaG1VLzNaSGNWb1dXblFhWmJMQmF3dzJ0dXB5SW9ZeEhHRC91cUFLQ1NoL2FHcDZnZjNGbERZeHQvd0F0THlRU1NENlF4a2dnKzhxa2R4MnBQK0VhRjhEL0FHaGRYV29LMmN4dS9sVzVIZFRHbUE2bjBrTC9BRk5hdU1DbFVGMndvTEgwQW9BaHM3R0hUN1JMZTNqamd0NC91UlJvRVJmb29HQlUyS3lwUEdOajU4a05ySkpxVnhHeFZvckpET1VZZFZkaDhrWi82Nk10TWFmV05TSDd1T3owbU51Y3lrM1Z4ajBLcVZqUnZjUElPbkJvQW8vRnp3NWZlSi9oMXFVT2xSZmFOYXN3bXBhVkh1Q2lTOXRwRnViZFNleXRMRWlOMjJzd1BCTlNlSHZpdm92amZ3OVlhdDRma3VkY3NkV3RvcnkwYXlpOHdORktna1RlNUlpamNxd0pXUjFJcTMvd2g5dGRrTmZOTnF6QTUvMDV4SkdjZFAzS2hZUVI2aE4zdWF3Zmc3R3ZoNXZFUGhjL0t2aDNWSkhza0l4L29GMy9BS1ZiN1Y3UlJ0SlBhcDdXUkhhZ3JTeHZFNnhxWFQ3SHBVZmZBTjFjTVA4QXgyT05oLzIxQi9EbFY4SDJkdzZ2ZkNYVkpGTzROZnQ1eXF3L2lXUEFpUnZkRVUxckFZRk11SjQ3TzNrbW1rU0dHRmQwa2pzRlNNZXBKNEE5elFTS1J1UHpaWSs5T3ppc24vaExvYnRSL1o5dmVhb3JkSkxkUXNHUFVTdVZSaDY3Q3g5alRSYjZ4cVIvZlhkcnBzZjl5eVg3UklEL0FOZFpWQzQ5dkp6NzBBYWQ1ZlE2ZGJQUGNUUTI4RWYzNVpYQ1JwOVdQQXJPSGlwYjREK3o3Tzd2bGJwTUU4bTJ3ZWplWStONm4xaUQxSlplRmJPMHUwdWZKOCs2ajVTNHVYYTRtajlkcnVTVUI5RndQYXRBcGxzOVQ2azVOQUdSTnBkOXJrVWtkOWNXOXZhektVa3RyV0lTYjFJd3lQTEtDR1Zoa0hFYUhucjNybHYyZXRCdGRGOEdKcGNxdGNhMTROdVpmRHM5M2RPMDk0MGNHUHN6dkxJUzJack43V2NnSEE4L0dCeUs5QklCcmhOUjFpMStIWHh3TFhsekRaMkhqYlRkMGZtdUkxYlVMRWdFS0Q5K1dhMW5YNVJ6czA0OGNVRFIzVzBENXYxTkdjaXNsdkVOMWZmTFk2YmNPcmRKcjBteml4M0cxZ1pzK243b0EvM2hRTkd2ZFIvNC90U20yZDRiRlRhb1I3dmxwY2oxVjB6NmRxQkZ6VmRkczlGWkZ1cmlHR1NZRXhSbHYzczNzaURMT2ZaUVRWTk5idnI1bUZqcGN5eHNkd212bit6S1FmN3FZYVhJL3V1aVo5ZTlYTkowR3owVHpQc3R0QmJtWTVrZEV3OHA5WGI3em4zWWsxWWNoWFUvaFFCbW5RTHErLzQvdFN1Smw3eDJlYkdQNjVWakxuMjgzSHRWelN0RHM5RWdhT3p0YmUwamtPNTFnaUVZYytyWSs4ZmM1TldnY2orbFo5NTRuc3JPN2UyODR6WGNadzl2Ym9aNWs5Tnlwa3FQZHNEM29BdmdjWXhYSGVDZitLWitLSGlqUWNNdHZxUmo4UjZldU1MKysvZFhjU2V1MjRpV2R6MmJVVjlSVzR0L3FtbzU4bTFnMDlNNDNYVENhWC92M0cyM0hvZk56NnIycml2aTU0YmkwWFV2RFBpblVMbTQxQ1BSOVJYVDc0VHNGaE5oZnNsdEtyUnFGajh0TGcyZHc3U0JpRXRXeTJLcUpVZXgzTng0cnNvNTNoaGthOXVJenRhRzBRenRHZlI5dVJIbjFjcVBlby90T3E2Z2ZrZ3R0Tmp4bmRPMzJpYjZGRUlSVDcrWS93Qkswb0xPTzBnV0ZJMWpqaUcxSXdOcW9QUURvUG9LZjJ4K0ZJa3kvd0RoRTRMdi9qL2t1TlU1enR1M0RSZTM3cFFzV1IyT3pkNzk2MDQ0bGlqVlJnS2dDcU1jS1BRQ3F1ditJTER3bm9rK3A2cmZXZWw2WmFqTTk1ZVRyYjI4T2VCdWtjaFYvRTF6SitMZjl2eC84VXZvT3RlSXZNNFM4YUwrenROeWVqRzR1TnJTeGY3ZHJIY1kvdW5wUnF3MU94M1pGVVBFL2l6Uy9CV2tmMmhyV3FhYm8xaHY4djdUZjNVZHREdTdEZklRdVQyR2NtdWZYdzU0dThTamRxdmlDMThQd3QveTZlSDdkWlpRT2hWcnU2UnQ2a2RESGJ3T096WjVyUThNL0MzUVBDT3FmMmhaNmNHMVhac09wWGs4dDlxSlgrNmJxZG5uSy83Ty9BN0FVRE00L0ZHODE1dG5oend4cldxQTQvMHpVVWJSckZmcTA2ZmFIVWprUERieW9mN3dyUGorRW11YTc0MG04UWF0NG51TkxtdXJDUFRwN0R3OUNMV0thR09XU1dOSmJtVVNUeU5HMDB3V1NEN0tjVFBsZVJqMEE4QS9yVHhFOHFzeXF6TEdOellIM1FPNTlxUFFSZytFZmh2b2ZnZTlsdTlOMDJHSFVicGRseHFFaGFmVUxzZjlOcnFVdFBOMi93Qlk3Y0FEb0FLM1FGVS8vcXI1QS9hMy93Q0M3djdMWDdHb3VyWHhCOFVOTjhVZUliVU1QN0I4R3FOZHZpNm5Calo0bUZ0QzRQRzJlZU0xK1pIN1czL0I0VDQwOFRtNjA3NEgvREhSdkNOcXhaSTliOFZ6ZjJ0cURyamlSTFdJcGJ3djN3NzNDMDdqc2Z2ckkvbHdTVHVka01LN3BKR08xSXg2azlBUGMwNlhkQzVWbFpXVTRJUEdEWDhaL3dDMVYvd1VSK04vN2JWNDcvRlQ0b2VMdkdWcThnbFhUcmk3K3o2VkN3NkdPeGhDVzBaOTBqQnJ0L2cvL3dBRm92MnJQZ1Q0ZjAvU2ZESHg0K0lFR2w2WENiV3pzNys4VFZJYmFJcnRDS3Qwa29DcU9FSDhHQnQyNG81ZzBQMjUvd0NEaUwvZ3RkNHcvd0NDYk0vZ253SDhKYnp3ekg0LzhWV2R6cXVyM09vMlF2NXRDc1FVanRYamlaaEVKSnBQdEdQTlJ4dGd6dCtZR3Z3QS9hYy9ibitMMzdaZXNmYnZpbDhTUEZ2amdySVpZYmJVOVFackcxWThIeWJSY1c4UFRwSEdvcmhQaWY4QUU3eEo4YVBpQnFuaXJ4aHIyc2VLUEUydVRHNHY5VTFXNmU2dTd5VEFVTThqa2s0VlZVRE9BcWdEQUFBd2RtRGpsdS9XcEQwRmU3YmNmOGFpa21KN25yMW9tRzExVXRqZDkwZXRTV21tM0YvTXNjRU1rMGp2NWFxaUZpV1BBWEhya1l4UUlnZCtuMDV5ZXY4QW4rbGZwZjhBOEd5Zi9CUy93WCt3YiswMTR3OE0vRXZXditFYjhGL0ZPd3RiZE5Yblp2c09tYWxheU9iZHJrRElqaWtqbm5qTXhCRWJGQ3hWQzdyK2R5K0JtdExqeWI2N3Q3VzVMYlJiTG1hNExZNVh5MHl5dDlRQWZYdlhWL0JyNFM2bjRuK0l1ajIxbjRQdXZGVWh1b1pXMGFZenJOcWNZWU0wUGxXdWJrQjFCWGZHUVZ6a0VIbXFqZE80Y3R6K3hMUi8yay9oejRpOEVYWGliVGZpQjRIMWJ3MVl4K2JjNnRwMnUydDlaVzZZenVhV0oyUlJqQjVQT1JYOHR2OEF3WEovYkxmOXZmOEE0S0krS1BGUTBmVmZER2srSDdhRHd0bzJsNnRhdGI2cXR2YWx5WHVJUHZReXlUU3pTZVcrQ2l5S2hKS2tuOVkvMlN0SitQMmxmczhSK0ZmaEIrei9BUEN2OWxQbnk3WFc5WHViblhOVXNrZm1TZTJXNGFXWko4c1NvdUVZRWtrbFRVWHdJLzROMWZoZjRlMXFUWHZpSnJYaWo0aitJYjZkN3UvbGx1WDArQyt1SkNXbGxsZFhhNm1kMlppelBQOEFNVGtna2tuT3BWaWpkVTdJL0JYd0Q4RWRmOGUrSUxmUzlJMEc4dXI2OXdzRVUwTWhtbEpHUVk0SWcwakVqR0NNam4wTmZibjdOLzhBd2J0ZkhQNDJSdzNHdmFlUEJlbXpiUzM5dHVOUHlDUmsvWm93ODVPT2drU1BQOTRZcjk5dmduK3k1NEwrQXVrZjJmNEw4SjZENFh0U01PdW0yU1c3Uy83N3FON24zZGlmZXZTOUw4S0tnWDVWSHBnZEt3bFdrOUVITEdPNStZZjdNUDhBd2JPL0NmNFhQQmQrTGRVMWp4bGV4a00wTnVuOWsyZTc2bzczSng3VHFNODdSWDNyOEhQMk9QQXZ3UzB0clh3bjRSMER3NUZJTVN0WVdLUlRUKzhrb0crUSs3c3hQclh0V20rSGxUR0ZGYTBHa29pYzFrNHVYeEQ5bzFzZVluNE8yWmIvQUZLL2wxcXZOOEpZWWgrN1RwNlY2dzFnbjkzODZoazB4V0hUcldib3hLVmFYVThkdWZoM0pEbkM1N2NyVWRqRHFYaHBzMmQ1ZFd2dEhJUXY0cjBQNGl2V3JuU2xZZmQ5K2xZdXMrRlZuaitWZVQweFdFcUxqckUxald2cEl4ZkR2eGV2OVB1RWoxU05icTNZZ05LaWJaVUhyZ2NOajB3RDllbGVsVzg2WGNFY3NUTEpISW9kR1U4TXA1QkgxSE5lVTMvaFdXTmZ1MDNUL0UrdGVGbzFqdDdodnM2L2Rpa1FPb0hwenlQd05hVWNaS0dsVzdRcWxCUzFnZXVCUVIvalR0dWUzNG12UGROK044a1cxZFEwN2NPNzI3NC84ZGIvQU9Lcm90SitLZWg2c1FvdkJheU4vRGNxWS8xUHkvclhiVHhWS2V6T2VWR2NkMGIrem50MHBKYmRabDJ2SEhJdWZ1c0FSVG9wVm5oOHlObGtSaDhyS2R5bjZHbllKUDByb01UUHUvRDhOd2pLcnpXN0grS05oOHYwREFxUHlxdjRUOEVhYjRLaHV4WXhTQ2JVSi90TjNjenpOUGNYY3UwS0dlUnlTY0tvVlZHRlJRRlZWQXhXMEZ4K2ZlbXN2UGJweFFBZ05HTWY0VTRyejdVcFhiMG9BYUZ3MVNkS1JSelNubWdCQ2NIdlM1L3o2VW5VZmp6U3FNMEFBTzNwejdVS0dQZHFjcWZOUW94LytxZ0FCNS9yUmpOQS9XZ3JsdjhBNjlVZ0hLZHYrMVRsTzQ5L3lwbWNtazZtaGdTZjU0cDRrd2V0UkkrMDk4ZXRPRGNmN3dxUUpGZm4vUE5PVnlhakQrbzZlbE9Wc0hnL2thQUx4NlV4K29wOU5rR1IrRmNMUm9SeWYxcXZLS3NTSHBVTWd5UHc2NHFTb2xlWGtmZ2U5UXVOdy9HcDNPU0tpUERHZ29xekRKK281ckg4WCtFOU0rSUhoWFZQRCt0MjYzbWk2L1l6NlpxTnUzM2JpMm5qYUtWQ09tR2pkaCtOYk53TUdxMHk0UDZWbkxjTjlEOGNmK0RaRFc5YS9aUC9BR3pmMmwvMlYvRWtzMGx6b055K3VXSmI1WTNsMCs2R24zTXFqL3A0aW5zcFJqcXNRTmZzOEQvbk5makgvd0FGT05Wai93Q0NZMy9Cd0Y4RS93Qm8zQzIzZy80cVc4V2orSjMzK1ZIaFVYUzc2UjhEa1JXc3VuM0l6d3p4SG9lYS9hQ2VGcmFlU052dlJzVk9QVVYyVTNkYUJPN2pHVDlQbXY4QWdXTTN4UjRidC9HZmhqVXRIdTJaTFhWclNXeW1aRDh5SkloUml2dUEyUjdnVnp2dzh2OEFWdkhuZ25UOVExZS9FTjY4YlFYOXZwOGZreHBkUk8wTnpIdllzNTJ6eHlxR1F4OERwWFlFWnJsUERDLzhJLzhBRVR4SnBmM1lOUU1XdTJpNDJxdm1EeWJoRkh0TkNKbVA5Njh6M3JUeklWOVVidW02RGFhUkxKSmEyOGNNMHcyeVRBRnBwUi90eU5sbS93Q0JFMWFLQVZWMVBYTFBSbWpXNnVJWVpKZVk0aWN5emV5SVBtYyt5Z21xMzl0M2w5L3g2YWJJaVp3SmIxL3M0WWVvUUJwTWowZFV6Njk2cGFNbm9hZVI2bXFlcDY5WjZST3NOeGNJazdydVNCY3lUeUQxV05jdTMvQVFhcm5Rcm0rUCttNmxkeUQvQUo1Mm02emorb0tNWmMvOXRNZTFXOU4wYTIwYUZvN08zZ3RZM081MWhqQ0J6NnRqcWZjODB4Rkp0VHY3NS84QVJOUDhsR1ArdnZwUEw0L3ZMR3U1ei91djVab0doVFh2TjlxRjFjWjVNVnVUYVFENkJENW1QVVBJd1BwMnJVSzdLQjA2WmIwcGl1VjlPMDIzMGUxOG0wdDRMV0V0dU1jRVlqVXQzSkF4ejcxeS93QVBBdmgzeHQ0dThQOEEzWWt1MDhRV2c3TERmbVJwUm51eHZZYjJRK2dtVDFGZEJmZUtiQ3l2R3QvTzg2N2orOWJXMGJYRThmdXlSZ3NvL3dCcGdCNzF4UHhDdjlXMHp4MzRSMTYzdExmVExWcnAvRDE3TGVzSm5TTytNWWhZd3hOZ2sza0ZwRXBNd0tpNGM3ZW9wYURqMlBSaDh4NDVKN0NzMjU4V1dNRjAxdkhNMTNkUm5hMEZyR2JpU00ramhNaVBQcTVVZTlSRHduSGZKL3hNcnE4MVRkMWltY0pia2YzVERHRlIxOXBBNTl6V2xhV2NkaGF4MjhNY2NNRVEycEZHb1JFSG9GSEFwaTBNejdYckdwLzZtMnM5TGovdlhiZmFwdmNHT0pnZytvbGIvZG9id2REZXB0MUthNzFqc1V2SFV3a2VoaGpDeE43RmtKSHJXeGpGQTVCOWhrKzFBaGtVQ3d3cEdxaFk0MUNvaWphcURzQUJ3QjlLZldUL0FNSm5aM0pLMkN6NnZJRGdpeFR6SXdlNm1Za1Fxdy91czRQVGprVWhHc2FuL0ZaNlZIbkh5QTNVN0QxeXdXT05oNkZaUWY1Z0dySklzY1R1ekJVUUZtWW5BVWVwUGF2T1BFM2pPMTBQNHllRzlVMDJPNTFXSHhKYnplSHJwN05BWUdrUlpMeTBjenVWaHdnUytqd0pOeGE2VVlKcnNrOEcyY2tpeVhpeTZwTWgzSzk4L3dCb0N0L2VTTS91NDI2Y3hvdlNxSHhnOE0zdml6NGM2bkJwcStkclZzSXRSMHRXYkFlOXRaVXViWldQOTFwb1kxYjFVa2Q2Q29sOHhhenFZK2VhMDB1TTlWdGwrMHoreEVrZ0NLZlVHSng2SHZUb1BDRmlsMUhQTkUxNWRSTnZqbnUzTnhKRXc3cHV5c2YwakNqMnFid3Y0bHMvR25oalROYTAxMmswM1diT0cvdEhZWUx3eXhySkdTUGRXQnF6ZjM5dnBObWJpNm1ndGJkVGhwWnBCSEd2MVp1S0JFckRuY2ZtYjFKcGQyQldTM2locndmOFMreHZMemppYVJmczF2N0hkSUF6S2V6Um80Tk1HbjZwcWVUYzZndG5HZWZKc0l4dUdmNFdta0JMRDNSSWo5S0JHaHFlc1d1aTJuMmk4dWJlemgzYlJKUElJMUo3QUU5U2ZUcWFwTjRrbnUrTERUYnE0SFR6YmtHemhCOUR2SG1INnJHeW4xNjRrMHp3M1k2UmRmYUliZjhBMG9ydE4xSXpUWExqME16bHBHQTlDMkJXZ0UyLy9Xb0F5UDdLMUxVdWJ6VVRER2YrV0ZnbmtnajBhUnQwaHgyWlBLUHQ2Y3I4WS9EOXI0UDhDUytKN0N5WCswUENNOGV2dktnTWwxY3dRQnZ0Y1pjNWVSM3NwTHVOUXhQelNnMTZDM0MvaFZQVVBFRmxvMTBrTnhOSDlvWUJsdFFwbG5sSHRFb0xzUFhBSXg3VUFXMTJnL0swY2kvd3VqWlZ4MklQY0gxcGQyYTgyK0F1bzZsYWVCRzhNd1dUUXQ0SnVwUEQzblg4bUgrendxajJUK1d1V2Rtc1piTjJEdEdkenNPMWRrZkQ4MThQK0pocUYxY0E5WW9XTnJDUGJhaDNrSHVydTRQcFFEMExPb2VKTExUTGcyOGx3R3VsRzQyOEtQTk9CNitXZ1o4ZStNVlhlOTFQVWdmczluRFlxUmdTM3JpUmg3aUtKaUNQcklwOXF2YWZwMXRwVnY1RnJiMjlyYmdraUtHTVJ4Zy83b0FGVERnZGZlZ0RMVHc2TDdEWDk1ZDMzckZ2OG0zQjdqeTB4dVgya0w5T3A2MW9XZG5EcHR0SGIyOFVkdmJ4Y0pIRWdXTmZvbzRINENrbXVJN08zbm1ta1NHM3QwTXNrc2pCWTRsSFVzeDRBSHFhNWhQakRwdXRSaHZEdHJxWGk5V09GbjBlRlhzbjdFaTlsYU8xYmIzQ1RNd1BHMG5pZ056clFlT1B5ckk4ZmFWcFBpSHdEcmxoNGdsaXQvRCtwV0U5bHFjMHNvaGpqdDVvMmprekkyRlQ1R2Jra1lySE9uZU52RTQvMGpVTko4STI3ZktZOU1qL0FMVHZ2WjF1TGhGZ2pQWW9iV1lER1E1enhOcGZ3WDhQMk9wd2FoZVdzMnZhdGF0NWtPb2ExTytvM0ZxL2RvREtXVzJ6M1czV0pUL2Q0b0djdDhKZmp2ZStOL2hybzgwZWphNzRuMTlJRGJhbGRXZG1MVFRyaTRoZG9KYnFLNnVUSERMYnl5UnRLaHQzbFl4eUl3VWdnbm8xMEx4bjRuei9BR2hyR20rRmJWditXR2hRaSt2QVIvMDkzY2ZsN1QzVVdZWWZ3eURHVDJUYm5rWm1KWm1PU3hPU2Z4b0F5Y0FjbnNCVEhjNW5RUGcvNGU4UDYxRHF5MkxYK3RXMmZLMVhVNTVOUXY0YzlmTG5uWjNpVTgvSkdVVG5BVURpdW16dWJPY3RuSlByWHpuKzFwL3dWcy9aei9ZamE2dGZpRjhWL0RGbnJscVdXVFFkTWxPcmF3cmorQjdXMkVqd2s5ak41YS83UXdhL01mOEFhdy80UERsUnJyVC9BSUYvQ1FuSEVldWVPcm50emtqVDdSK094RE5kSDNTa0kvY1B2WEdmdERmSFhSdjJadmdoNHArSUhpQzExeTkwUHdmcDBtcWFoRG8xZzEvZmVSR015T2tLa0ZncTVaaVNGUkZabUlWU1I1ei9BTUUzZmpmcm43U1g3QXZ3bCtJSGlUVzdmeEY0aDhaZUhZTlcxTzl0cmVLM2hOekt6dExDc2NLaEVFTDdvTUFaL2MvTVMyNG4yNnh0bzc2OGp0NUk0NTQ3aHhHOFVvREpLckhCVmdlQ3BCSUlQWTFYS0kvQzM5ckQvZzhYMWkvbXVkUCtCdnduc05MZzVFV3VlTjdrM2R3eWtmZVd4dFhXT05nZVFXdUpsOVZQU3Z5Ly9hei9BT0NuL3dBZi93QnVScFl2aWY4QUZUeFI0aTB1UmczOWpKT0xEUjFJT1JpeHR4SGI1SDk0b1c5elhtWHhrMGJSTkUrTS9pNjA4TnlyZGVHYlBYYjZIU0pBMjVack5MbVJZR0I3Z3hoVG11Y1cwTEg3djE5NmtvaFJkaWNMZ1k0R0IvS25LcFZXWnVGVVpZbnRWMkxUVzZzT0d6MTdHdTMvQUdmYmkzOEkvSGJ3UHJOOXBNMnZhZm8vaVBUcjI2MCtLRXpQZnd4WFVVandCUDRqSW9LaGU1WUR2VlJqZGlQMG0vWkkvd0NEU2o0b2ZHMzRQV0hpajRqL0FCRTByNFRhbnJOdXQzYWVIam9VbXI2aGJSc3VVRjUrL2dTM2tJSUppVXlzbWNQc2NNaS9KUDhBd1VzLzRJMmZGei9nbDVybW55ZU1vTk04UWVEZGVuYTIwcnhYb3J2SnA5ek1GTC9aNVZkVmt0N2pZQ3dqa0cxd3JtTjVCRzVYK3J6V3ZHTUpsdUo3ZU9hNmgzc3h1SlAzRU9PU1NYa3dQcU9vNTQ0cjg1ZitEaVQ0NmFqZmZzSHI0VjBhNjhGM21tZU10YnQ3UFdaTCt6bnVvTE9DQS9hMGxpdWNDR09RU3dJaExNcHhKOHJBNW9sWkRqRnlkaitiMnc4TjNPcHliTGVHU2FUT0FxcWNrOWdQWHQrZGFXbC9EZTYxZlhvZEx0NDVKOVN1cEZ0cmV5dG9udXJ1NG1ZaFZqV0tNRnl4SkFBeGtraXZ0djhBWjMvNEpPL0ZEOXBDMXRwdEM4TCtKTlMwYTZJWmIrL2gvc1BSR1Joa09IY29McVBvTjl2TGNrY2ZJZWcvUUg5a2YvZzN2dGZoUHIrbTY5NG84ZFRXT29hYk5GZFFXZmhDM1czYUNXTTdodXZaa3pNaFBZMnNiZ0QvQUZock4xSUkwOW1ldGZzbGZzN2FSL3dUbS9aVDAyMjhGeWZDL3dDQS9pYTVzMGcxUHhacjJsSjRzOFVhaGNsUnVhNm1qdTdXMHM1TjI3YmFKZFhkdkdObytadDViODQ3UC9nanI4ZmYyNy8ybi9GSGpieDVKcldvMnV2YXpjVGFoNG44UTI4R2hMcktnN0lwbHNZSFp6RzhTcGdRbG8xVUJRMk1WKzNIdzEvWmI4SS9EalU0OVMwN1JsbTF0VjJqV05Tbm0xUFZRdjhBZEYzY3ZKT3FjazdGY0lDVGdDdlJyVHc4aUhKWG1zcFZuZTZOT1JMUS9QRDltdjhBNE4vdmhYOExOSTh2eEV0eDRqa2xpS1QydHFEcDFtMjVkcnF6UmtUeUt3N1BJT3ByN0wrQ2Y3TEhndjhBWiswQWFWNEo4S2FCNFQwL0dIaDB1eVMzTXY4QTEwWlJ1a1B1NUo5NjlYdE5LU1BIR1BxS3V3Mmk4ZkwrbFp1VGU0dVpJNSt5OEtSeGo3di9BTmF0ZXowSllsKzc3L1N0T05WUTlLbWpsVmZUMCt0SWh5dVFXZW1oUmpiN1ZyMlZncVZUYlZsZ1U4REhXdkl2MjBmMnVMYjltYjltTHh2NHVTU05kUzB2VFhpMHdIQjMzMHhFRnNNZHdKcEVZais2cmVsVm9rRVl0dXlQZklZdkxXbm1RZlhINlYvTVg4WWYrQzkzN1QzdzcrTFY1YitHL2pKckgyUFR4QmF5cFBaMldvSk5ORGhaR2NUUU12elNLM0NuQlZoems4ZlJmN0svL0IzdDR3MGE5dHROK01ud3cwWHhSWmtwSExySGhXNWJUTDVBZURJMXJMNWtNemV5UEFQVEhTdDNoNVcwSmNiTS9lZ3VhUUxrZnBYeVIreXQvd0FGelAyWGYydWIyUFR2RC94VDBmdzdyMGpGQm8zaTMvaVEzVE51d0ZqZWNpQ1pqMldHVjJ4MnI2NkViSWlzeWtMSUE2RTlHSFlqMUh2V0VvdGJnTWEzM0NvWkxOV0ovd0FLdEt1Nm5MRm4vSEZTQmt6NlFyamtDczY5OEtSVGRVcnAyZzVwalcrNDlNMW5LbW1VcE5IQTZsOFBvNU03VnhXRHFYdytrUU50Vm1yMWVXeVZ2NGFnbDB0WkFlaDc4MXp5d3NXYlJ4RWtlTXJwT28rSDVqSlp6WFZxM3JFNVEvamordGF1bmZGcnhEb3dBbWFHK1FEQkU4V0dBLzNsd2Z6elhvbDM0ZWpuQjNMdTlheDlSOER3M0dma0g1Vm5HblVwL0F6VDJzSmZFaXJwWHg5c1pTRnY3RzZzMjd2R1JNbjlEK1FOZFRvM2puUjlmS2kwMUcxa1p2NEMyeVQvQUw1YkIvU3VDMVQ0YUIvdTUvS3VmMVA0ZnpvVytUY1BjVnBIR1ZvYVRWeWZZMHBmQzdIdWg0OXZyU1o1cndheTFUWC9BQXF3V3oxQzhoakI0akw3by84QXZsc2o5SzM5TStQdXJhZnRYVUxHMXZWN3RHVEMvd0Q3TVAwRmRFY3lwdlNkMFp5d2MxdHFldEFVWXlLNHpSdmp4b09wYlZ1SHVkTmticjUwZVV6L0FMeTUvWEZkWnBPczJldFErWlpYbHZlUjQ1TU1peVkrdUNjZmpYWlRyUW44RHVZU3B5anVpeW9Bb1BYcjdHbEIzZm5Tbm10Q0JDbTVmeG9JK2xLVGoyb0F4Ni9XZ0JPcTllS0JqSDU5NktBTnRBQXJjYyt0QTZZb3hUdWc2VUFOcGU5TDNvQjRvQUZPUUtrM1pOTkJJUEZLT0QvWDFvQTBhYkowL0QwcDFCNlZ4bWhDNDNEaW8zNkg5S202MUV3eCtYclVEVzVVYy9OVWJERFZZbFhscWhrNUE5S1JaWG1YNVRuclZXVmNtcmtveWZ3cXJNTUh2VXkyQmJuNTUvOEFCekoreW9QMmovOEFnbDlyMnQyc0prMXI0VTZsQjRvZ0tybVI3VG0xdlkvVUlJWnhPMk9UOWtYMHdmcHYvZ2xyKzFTdjdhbi9BQVQxK0ZIeEdrbWFmVk5WME9PeDFwbUNoanFkbVRhWGpFTHdBODhEeUwwK1NSRGptdldmRy9nalN2aVo0TTFqdzNyMEgyclEvRWxqY2FWcVVIL1BXMnVJbWlsWDhVZGgrTmZsdC93YTllTnRXK0JmaVQ5b3o5bG54WmNxM2lINFcrS0gxaTBqSUtHWk4vOEFaOTYwWVA4QXl5RWx0YVNESEgrbDd2NHEwb3lOSHM0L1A3dC93UDF0NmY4QTZxNDM0cVdLMmVzZUdkY2FXNGhqc2RRR21YalFTdEV6MnQ2VWhDN2xJWlI5cld4Y2xTQ0ZpYm5hV0I3SUhGWnZqTHd0RDQ1OEphbm90eE5KYnc2dGF5MmpUSVBuZzNxVkVpLzdTazdoNkZSWFVjL05aazJuYUxhNk1yTGFXOE52NW4rc0tJQTBwOVhicXg5eVNhc0tBSzVud2Y4QUUyMzEvd0FJYVZmYWpKRGE2dGUyK2J1d2gzU3pRM0tFeDNFYXhLR2RoSE1raUVnSDdsYUoxZlV0UStXMDA1YldNOUpyK1FLY2RtV0pOekgvQUhYTVJGQU5XZXBxN2NudCtWVU5TOFQyT2szZjJlYWRXdThCdnNzTWJUM0dEMFBsSUdmSHZ0eDcxQi93ak11b0EvMmpxRjFlYnVUREN4dGJjZlJVTzhxZTZ5U09EK2xYdE8wdTIwaXorejJkdmIydHZrc0lvSTFqakJQVTdWR01uMXJRa29IVXRVMUwvajEwK0d3WHA1dCs0WndleEVNUk81ZlpwSTJIcFNId3cxNmM2amZYbDluL0FKWkJ2czl1UFViSThGbFA5MlZwSzFzTFFGeTJGK1krZ29GY2hzZFBnMHl6VzJ0YmVHMXQwKzVGREdJNDEraXJ3S3l2aUw0T2I0Z2VBOVgwV0taYk82MUMyZU8wdWlQK1BLNUh6UVhBL3dCcUtaWTVGUFlvRFZpNThXMk1jN3dReVBmWE1iYkdnczBOdzZOL2RmYmxZL3JJVkhxUlVmMm5XTlJCOHFDMTBwZXh1RDlxbUhzWTQyQ0w5UksvMG9EWGNYNGZlTDErSW5nalNOY2p0MnRXMWEwanVYdGo5KzBrWlI1a0xmN1ViN2tZZG1RMHNuakd4a2thTzBhVFU1bzIydEhZcDUyeGgxVjMvd0JYR2Y4QXJveTF4bnczOElXMmxlTVBHSGhyVW51TlZodHIxZGRzbzd3aG9UYmFnWkpaTjBTS3NMTjl1ajFBL2MzS3JSalBUUG95UnJIR3FLQUZqQVZWQTRVRG9BS0J5dGZReWkrc2FtUGxXejB1SnY3K2JxNHdleEFLeHhzUFVOS1ByU2p3YlozUjNhZ1p0WWZybStjU1Jram9SQ0FJVkk5VlFIM0pyV3BrOXhIYTI4azBycEhER056dTdCVlFlcEo0RkFyaTdQcWNEQXllZ3AzU3NnK01ZYnRmK0piYjNXclo1RDJ5Z1FFZW9tY3JHdzlrWm05cVQ3TnJPb3QrK3VyWFM0dTYyYS9hSmg2WWxsVUlCNmp5VDdOM29FYVY3ZlE2Ylp5WEZ6TEZiMjBJM1NUU3VJNDR4NmxpUUIrTlp3OFhyZUVOcHRuZWFoNlRvbmsyNDlENXNtME92dkZ2K2g2VSt6OEpXTnRkeDNUUS9hYnlFN283bTVrTnhORWZWR2NrcDM0VGFPVHhXaVJscyt2Sko2MEFlYmZCcXkxWFQ1dkVuaGU1dkxmVFkvRHVxeXkyY0Zrbm1OOWh2Q2J1RGJKS3VQS1JwSjdaQUlrSUZtUURnQ3U0MDd3cllhYmVyY1IyL21YYUFxdHpPNzNGd28vdWlTUXM0SHNDQjdWenZpWS84SXI4YVBEZXFMOGx2NG10WnZEdDRjL2ZtaVdTOHNtYjBWVlhVVUhxOTBnNTRycXRVMXl6MFJFYTh1b0xmelNSR3NqNGFVK2lMMVkreWdtZ3A5eXdkcUgvQURtbE9GQnJLYlhidTkyL1lkTm1aZTB0Nnh0WXo2L0tRMHVSNk5Hb1A5N3ZRTkZ2TDFpYjdVcG1YUDhBcXJKVGFSa2Rzc0dhWFB1SkZCL3VpZ2t0YXBydG5vVHhwZFhFVU0wd0ppaUp6TE42N0VHV2Y2S0RWVTYxZlh4eFo2YkpHdjhBejJ2VzhsU1BWWTFEU1ovMlhXUDYxYTB2UnJYUlZrVzF0NGJmemp1bE1hYlRLUjNjOVdQdXhKcTB2QzRvQXlqb2R6ZmovVHRTbm1IZUsxelp4WjlSc0psL0F5a0gwcTNwMmsydWp3TkRhMjhGckd4M01zVVlRT2ZVZ2RUN25rMWFVR1EvS0R3Q1Q3ZXRjamNmR2pRN3VTUzMwVjdyeFplUnNVTU9oUS9iRVJ3Y0ZKTGpJdFlHSFBFODBmU2dDQzRmL2hFL2ozYnQ5Mnk4YWFVYlk4WVJiNnhMU1JqM2VhMW5uSlA5M1RsSFlWMm9qM0t4eDhxZ3N4L3VnY2tuMEZlYytMUENmaTc0cWYyV3p2cHZncVBTZFNnMU8xdUkyL3RUVkVaTnlzdjhGdEFaSVpKb1g1dWxNYzhnR0NRUnNuNEphSnFzaXk2OEx6eGRPcERodGRtRjNDckRveTJvQzJrYkQrOUhBamU5QURSOGJORjFjTXZoOWRROFl5S2NmOFNHSmJtMzNkMU40N3BacTQ3bzg2dDdVOFErTS9FMytzbTBmd25hdC9EYmc2cHFCVTlEdmRVZ2hjZENQTHVWNjRZOWE2NWwzWTNNZmxHMFpPY0QwK250UVBuWUtxN2kzVEhlZ0xuS1d2d2EwU1c4aXZOVmp1UEV1b1FzSkV1TmJtTjc1VWc2U1JRdGkzdDI2YzI4VVk5cTZ4c3UyNWl6SDFKeWE4YS9hbi80S0ZmQS93RFltaGIvQUlXcDhVUENYZys4UlBNR21UWFJ1ZFdrWHNWc1lCSmNzUGNSWTk2L003OXJML2c3OThHK0YwdXRQK0Nmd3gxYnhWZEx1U1BXL0YwNDAyeFU5bld6Z1o1NWs3NGVXM2IyRk1lcCt5MFViVE1GVlN6RTRBVVpOZURmdFpmOEZPL2dEK3hBdHhEOFR2aXA0VjhQYXRiajV0RmhtYlVOWnpqSUJzcllTVHJuKzg2S3Zxd0hOZnpVL3RkLzhGNFAyb1AyeHZ0ZG5yM3hPMVB3ejRkdThnNkY0UnpvZGo1WjZ4dVlUNTg2ZTA4MG45YStPdlBWR2Jhb1RkeWNEclNEUS9xMi9aTi80T0cvMlcvMnVOUzFTeHRQSGkvRHZVTlBuTWNOdDQvTnZvUDlweEFERThFeG1lM1pTU1I1YlNyTU1aTVlITmVTZjhGYWYrRGlqNE8vczNmQmJ4TjRSK0ZuaXpTL2laOFVQRVdrejJPbnorSGJxSyswZlFHbVV4ZmFybThSakU4a2FzN3BERVpHTG9vazhwVHVQODBabDNEbm42K2xPVThnZnBURFFrampXR0ZWWDVVVWRBT3RPVHJ4amRuMXFPUE80R3JObnA4Mm9UTEZESEpOSTNSSTEzTWZ3SE5JUjlnZjhFNmYrQzQzeDMvNEpyK0U1dkMvZzIrOFArSlBBOGx3OTFINGI4VFdVbDNaMlUwaEJrZTJlS1NLYUhjUnVLTEo1WllsaW00c3g5Zi9BR3AvK0RuajlwRDlwMzRZYXQ0UnNiYndMOE5OTDF5MmF5djdyd3pZM0kxS1dDUkNrc1MzRnhQTDVJZFNRV2lSSkFEdzRyNEIwUDRlM2wzcVRXcCtXNlFBbTJpamU0dUFPdVRIR0daZitCWUFyMmI0Uy9zbzNPc2VIMjF5OXM5TnNkRXlZLzdTMXkvU0cxVjFBM3JpTjFqRGpraEpycUU4ZE9PYXV1cHBDTGJQQ3RFOFAzR3Izc2RyYVdrMXpjUzhSd3dSbDJmMkFBOXUzcFcvRDhNYjYzMWROUHVkdHZmTU0vWlVWcmk1L3dDL1VZWngwUDNnUGZxVFgxeDhFUDJjOU4rTU54L1l2dy8wTHgzOGFicUZ0azlwNFQweDdMUW9XUFZMcTZJdDRJZlRmTE5lSWVNNUhGZlhud0gvQU9EZno0bGVPcm43VjR5MWZ3YjhIZEJuWU1kRTBHM2k4UWF1VXdOeVN6YllkUGprSEFXU0dHVEdCMXdEV2Nxa1VWN05wNm41ZitHdmdmZTNWbkxlTFlmWjdPMVlyTGVhcE1Jb1lTcCtZT3NaS1J0eG5Fc3lkRFgxRC93VGErQlB4RWsrUHZndjRnZkMvd0FIZU9QaUEvaExXSXRTdDd2UzBUUk5FM3hNY3hTMzB3UzI2N2dTSmJyY0NSc0pKcjlmUDJkLytDSy93RytBV3BXdXFId2pONDg4U1dvVUpyZmphNi90eThUYWNyc2prVVcwUkJIQmhoUWpBR2VLK3NyWHc2Q2tZMjU4dFFpRCs2b0dBQjdEcGlvbFhmUXZsc2ZLSStCMzdSSDdRTjRKL0h2eEc4UC9BQTMweVlnblMvQjlzZGMxWUx4d2RTMUdNVzhMQWNmdWJGZ09vY25ERDBQNFdmc0JmRFg0YmVLSWZFUytIcFBFbmk2RTcwOFIrS2I2ZnhCcTBUOTJpbnZIa052ei9EYmlKUFJSWHZsdG9pci9BQXIrVlhvTkxWQWVLeWxKdmNibGJZd1lkRDN0dWY1bVBPV0pKSnE5YjZLcUQ3dUsySTdFZjNmeHFkYlRIOE5TUzVtWkZwNFVkS3NKYWNkS3ZMYlU0d2JSenpRVHpNcHBCdEhiOGFjeTdmNTFZTVBQUFdvNVZ4L1dna2c4ejgvcFVUM094TW5paTZtV05md3JEMWpWY0JncmZsMnBTZGpTTWJrWGlYWG04cG80enR6M3J4bjQ2L3NiZUcvMjF2RHVsYUQ0dThRYTlwR202ZnJjT3BRdzZYZHdXNzMwMGFTRGJKNXNjbTVGU1ZpQW9IellZNTJnVjMrczZwczNiaXVLdmZCbWJVQzJxNnRGb3VnNnhEWVJBUVMyODBjTnhQSEt5czZlWTI1Q1JFcVpMc2l1VlZUc0NnaFVvODh0VGFYdXh1ajhvZjJ1ditEUDdXclNXNzFINEkvRmEyMVhPWEdpZU9ZVGIzQjc0Vy90a1pIWTlnOXZHTTlYSFVmbC93RHRYLzhBQk03NCsvc0hDUzcrSjN3eDhVK0dkTmhjS210eFJpKzBobUoycGk5dG1rZ0RFOUZaMWJweG12NitQRGVsMkZuWVc1MHFIN0Jab3JlWGJRZ0piNFlsc3FpL0lBU3hJS2RjamtqRmJFUE1NaTUrU1pURzRQM1hYb1FSM0I1NFBGZWp6TkhKZEg4Tk10ejV5TTMrc1Y4NVluTzZ2ZHYyU3Y4QWdxZiswQit3eVlZZmhsOFZQRkhoN1M0U1NORm1tWFVOSGJQWC9RcmxaTGNFL3dCNVVERHNRZWEvcFUvYTIvNE4vUDJVL3dCc1dhNnZkWCtHdHI0TDhRWFFPN1d2QkVvME80eWVTeGdSV3RKR0o1TFNRTXg5ZXVmekYvYW8vd0NET0w0aGVGNXJxKytEUHhTOE5lTUxFYnBJOUw4VVc3NlBxQ2puRWF6eGlXQ1Z1bnpQNUNubmdZNWlUdnVJNmo5a24vZzhpMUN3K3k2ZjhjdmhQYjZsR01MTHJuZ2k0K3ozR0IvRWJDNmN4dXgvMmJpSmZSUjIvVWo5ajMvZ3NsK3pYKzNHMXJaK0EvaXBvSytJTG9oVjhQNjZUbzJyTTU2SWtOeHRFN2RQOVEwZzk2L2xnL2F1L3dDQ2EveDYvWWRsa2I0cWZDdnhkNFJzVmRZeHFzdHFMclNaWFBSVnZvREpiTzNzc2hOZUpiOTQ1MnN2VVpHYzFMcHhZWGZVL3VzYUZvWmRzaXNyRHN3d2FUeXNHdjQvL3dCa1AvZ3RiKzAxK3hMQloyWGduNHJlSUovRDlteXJIb0d2bGRhMHBVSC9BQ3lTSzVEbUJmOEFyZzBaOTYvVVQ5a24vZzhqMGZVVGI2ZjhkUGhQYzZiTXgyeWEzNEduKzBRWkp4azJGMUlIUlJuSkszTWg5RlBTc25SZlFxNSszYlJBL3dCS2Exdm12RGYyUnY4QWdxRit6LzhBdHlRMjhmd3crS25oWHhCcWx3RHQwV2FjNmZySUk2LzZGY2lPZGdQN3lJeWVqRWMxNzFJbXlURFpWbE9DQ09RYXlhYTNBcHRCaW81TGNFZE9LdWJCbWhrei93RHJvc0JteWFlckE4VlZ1TkhWeDkxVHhXMTVBQnBqUVlxZVZEdXpscjN3cERQOTZOZnJXSnFYdzZoblZ0cS9wWG9MVzNOUXZhaGg5MVJXY3FNV1hHckpIa2VxZkRGazNiRitsWU56NEp1dE9sOHlNU1J5TDBkQ1ZZZlE4WXIzS1hUVllOeFZPNTBGSmVxcWZmdlhOTENMZEc4Y1U5bWVVNmI4UnZGSGh5VGF0OUpkUnIvQmRLSmgvd0I5SDV2L0FCNnVqMGo5bzR4NFhVOUpiM2t0Sk0vK09OLzhWVy9mK0NvYms4eDgvU3VmMVQ0WVJ5QnZMVUx4MnE0eXIwOXBmcU85S2U2T3MwWDR4ZUc5ZEtxdXB4MjBqZjhBTE82QmhiODIrWDhpYTZhT1Zab2xrUWlTTmhrT3B5cCtocnduVnZoaE5DcmJWTzM2Vml3NlZxM2hLWXZZWE41WXQxUGtTc2dQMUE0UDQ1cmFPT212amo5eFAxV012aGtmU0I0cFF1YThHMHo0K2VLdEErVzVGcnFjWTQvMGlMWkpqMlpNRDhTRFhVNkorMVRwRXJxbXFhZnFHbnVSeThlTGlQNjhZYjhsTmRNTVpTbDF0Nm1jc0pVWFM1NmdCbkZJUDhtc1h3NThSOUI4V0ZWMC9XTEc1a2JHSXZNOHVVLzhBYkRmcFc4RUtFOFk5SzZVMDlVYzBvdGFNWUR6U3F1VFRqbnQvT2sycm4vNjlBZzdDbHp5ZjUwQWRNK25ORzNEWkg1MEFhVkI2VU53OUZjWm9SdDk2b3lNVk02OEUxSElPOVRJQ3ZLTWZuVmQxK1g2ZnJWcVZNampGVjVSZ2ZuVW1oQzR5djYvV3E4cTQvSDlLdEVkcWhuVG42MG1CU2tISGV2eVAvYW9qLzRkNGY4QUJ6ZjhIZmlmSDVsbjRQOEEyazlNWHd6clRyOHNMM3NpcnB6cWM4QUxNdWozTEh1WGYzTmZybEtPYStSUCtDdlAvQk4vVGY4QWdveDhLUEF0cmM2MWQrR3RRK0h2aWVQeEJGcWRrbWIwV3ZsT3M5dkF4NFI1SkZ0V0RuSVF3QnNNVkNtSTZNMGkxekw4ZlRabjJZeUdOaXB6bFRnMDFodUZabmczeFVmRzNnN1M5WWNBUzZqYXBOTW8vZ2x4aVJmd2NNUHdyVGI1Ui84QVdyMEU3Nm5QS0xXaHlIZ2kzajhNZVA4QXhabzhjTWR2SGV6eGVJWVBMUUlycmNobzVnZjd6aTR0NXBXUC9UMG5jMTFZR0s1UDRsWGllRS9FbmhueEZJSlBKdDdwdEV2R2loZVpoRGZHTklzSWdMRW05anNseUI4b2tjbkF5YTJEZjZwZi93Q29zWXJCT2drdm5Fa24xRVVaSUsvV1ZHOXFxT2dwYTZtcDFKOWM4RDFyTnY4QXhaWTJkNDFxSnpjWGtadzl0YkkxeE5IL0FMNlJnbEIvdE5nZTlSLzhJejl0VC9pWTNsNXFBWWY2cG44bTNHZW84dVBBZFQ2U21UNjFmczdPSFQ3UklMZUdLM3Q0K0VpaVFSeHA5RlhnVlFqT04zcStvajl4YTIrbUtmOEFscGVNTGlVZjlzb20yOCt2blpIOTA5S0Q0VGp2RG5VTHE4MVRQV080Y0xBUjZHRkFzYmowOHdPZmMxclVBRno4b0orbEJKSGIyMGRwYnBERkdzY01Zd2lJQXFvUFFBY0NwT2xaSThhV04wV1d4ODdWblU0SXNWRXFBOXdaY2lKVDdNNE5ORGF4cVlQTm5wVVI2WXpkWEJIMStXT05oLzIxWDYwRE1QeDZ5K0dQaVA0VDhRNVZMYTRrbjhPWDdrN1VqanVnc3R2S3g5UmRXMFVLZy84QVA4L3JXNlBHbHJkcHUwK080MWpQUnJGUThKOVI1ekZZY2p1TitSNlZnZkZINE94L0VUNGY2dHA2c0wzV3BvUE4weTUxSi9PaXRiK0lpVzBuRWVQS1FwUEhFMlkwWDd2dWM5QjRMOFhXdnhEOEg2UjRnczQ1WWJYWExLRy9oaWxQN3lGSll3NFJ2UmwzYlNPeEJGQStnMVUxblV2OVpOYWFWSDAyd0Q3Vk45ZDdoVVUvN0pqa0grMVRvZkI5aWJwWjdpTnIrNGpPNUpyMWpjTkczcWdiS3huMTh0VkZhbUZ4VU9vNm5iYVJhK2ZlWEVGckJ1QytaUElJMHllZ3l4QXo3VUVrN0RMWk9XYjFQSnBEV1dmRWtsNGY5QTArN3VRM0FsbVUyc0krcGNieVBRcEc0Tk5PbTZscUsvNlZmL1pvejFoc1l3bVIvZGFWdHpIL0FIa0VSb0F2YXBxMXJvdHVzdDVjMjlyRzUycTAwaXhoejZEUFUrdzVxbko0Z3VMc2xiSFRicVh2NWwwVFp4RStuektaZnhFUkh2VTJtNkJaNlRPMDBGdXF6c01QT3hNa3pqMGFSaVhZZXhZMWFBVkQyQm9BNFA0MWVCZGM4YmZDL1ZFdDcyU1RXZFBFZXJhVGEyU2ZaMG12clNSYnEyaWR5V2sydk5FaU15TkdTanR3TTRIVGVDNU5IMWJ3L1o2MW9jY2JXT3VXc043QmM0UG0zVU1xQ1NObmMvTzVLc3B5eEpyWWkzQ1ZkbWQyY3J0NjVyeWY0Vy9FN1JQQWtuaUx3T3M4K3BhajRQMW1lMGdzTkx0cEw2NGp0Wnd0NWJJMGNLdDVFY1NYSXRRMHhSQWJVa3NBUlFVdGREMWNEQzBxSVpXQ3FyTTNvb3lhNUVhbjR6OFNiZnNPbGFYNFZ0Vy81YTZ6Si9hRjhwN2cydHRJSVFEMmI3V3g5WSt4SlBnelk2L0ZqeE5mYXI0dTNjTkJxY3lyWWxmN2pXY0t4MjBnQjZHYU9SeC9mTkJKSmRmR1RRUDdRbXNkUHVwZkVXbzJ6R09hMTBTRnRRZTJmUDNKM2p6RmJzZTNudkdEZzg4R29mdHZqYnhRMkxleDBmd2phbmtTWDcvMnRmc1A3cGdoZElJbTdoeGNYQzlQa05kWlk2ZkJwbW53MnR0REZiMnRxb1NHQ0pOa2NLam9xcU1CUjdBQVZJU3BHZlRpZ0RrZitGSzZWcktnK0k3alV2R0xkZG10eXJOWms5ajlqalNPejNESEQrUnZIOTdPU2VzRUN3UXhSb3FySENvU05GR0ZqVWRBQjBBOWhYblA3U1A3WW53cS9ZOTBMKzB2aWw4US9DZmdPQ1NNelF4YXJxQ1JYbDJnenpCYkRNOC8waWpZMSthLzdWdi9BQWQxL0NINGRpNjAvd0NFUGdYeFI4VE5RakpWTlQxZHY3QjBqMmRGWlpMcVVlcXZGQWY5b2RhQjZzL1c3dlhsdjdUbjdjM3dkL1l1MG8zSHhVK0pmaEh3Uko1Wmxqc2IrL1Z0U3VFOVlyS1BkY3k5djlYRzNVVi9OcCsxUi93Y1QvdFYvdFh6emFldmp4dmgzbzE4d2pqMGp3SmJ0cExNU2NCZnRRWjc1eWM0SytmdFA5MnZscjRxZnM2L0ZiNGE2TzNpdnh4OFB2aVI0ZnNOVWxFamExNGcwQyt0WWJ1UnprRTNFOGFoMmJya3NTMmU5QTdMcWZ2cDhRLytEdWY5blR3bjR4dWRPMFh3ZjhXdkZXbVc2TnMxVzNzTE96anVwQWVBa1U5d3N2bGtmeE9xTU9ubDk2L012L2dvNS93Y1pmSFQ5dG54YmQyZmc3WGRhK0RmdzZWUEp0OUM4UDZxOE45ZHJqRFBlMzBRamxtWitjeEpzaFZjTHNjN3BIL1B1UzRMamEzOTRuUGM1eC9uOGFqSTQvaDdjMEN2MkpybStrdXJpV2FSMmVXWnpKSzdITFNNZXJFOXllNU5XTFh3M3FtcWFQUHFWdHB1cFhXbTIzK3V2SWJaNUlJY2YzcEFOcS9pYSsxditEZTM5aGZ3ciszaC93QUZGTlAwUHgxWnc2dDRQOEc2SmRlTE5TMHVVbnk5WE1FdHZCRGJ5WUlQbG1lNWlkMS9qU0prUERHdjZuUEN1bTIzZzN3MWE2VG8xdGJhUnBGakVJYmF4c1lsdHJXMmpIQWpTSkFFUkFPQXFnQWVsTVIvRHlSdmp5R0JCSFhQRkVjUjNkSy9YUDhBNE9YZjJJUGhqNFkvYkswclhQaGIvd0FJem9lc2F0bzBsNzhRZEUwaU5taDBpNUR4dGJYczBNQ01sckpkd3l0a1A1YVA1Q3lIRFRiNVBnRFJQMllQN00wdGRTMWpicHVuN0JLdDFxa3kycUZldTVGOHhFbUJCWEhsM0ROejkwNUFKWXRVMnp4V3owdWErbldLS0tTYVNUb3FLV0ovTDYxMG5oSDRSNnA0cjFkYktHRmpjS044a1VNTDNVOFNqa3MwY1FaMFVkU1hDZ0RuT09hOWk4S2VIZkRONTRrdGZEWGgvUy9Fdmo3WHIwQVcrbTZGWXVzZDIyRnhzekVyekRIOEwya3VjbjV5RG12djMvZ25YL3dTUCtQR3VmR1B3MzRtOFlmRHJ3WDhOL2g5cDd5UGRhYnExd3phNWNxMFpDeVFvRm1hM21WeWpGU3RxcEFQeTVPYWpuaWkxUzdud3g4T2YrQ2ZXdmVKZEwrMmFib0dvYXlHajMyOHR5eW1PNXlQK1djY0wrVEl3NjdEZUJ4am1NOUQ5TWZzOC84QUJEN3g1OFFMaTJqMXhob09tM0RoWmxWVGhrYkh6TEJGNWU1Z0Q5eVFUY2o3Mk0xKzIvdzUvWk44TitCZ0d0N0dKcDhZYVVnbVIvOEFla0pMbm5uNzJQYmdWNmJwSGcyMzAySFpCQkhFdU9pS0Jtc3ZiUG9iUmpCSDRnL0FUL2czL3dEanA4U3J4b2ZFVjc0RStDL2hXTzRmeTRvWVY4UmF2Y0tyRUxLSUZLV3NlOEFFRldna0dSbEFSdHI3bi9aNy93Q0NCbndJK0U5L2E2dDRxMG5XUGpCNG1oQUxhbDQ1dmpxVVlZWXlFdE1MYjdlQmhaRWtJNmJzVjkzMitocWcrNk1kS3VRNllxMWs1TjdrOHk2SEtlSFBBZGo0YjBhMTA3VDdPMXNkUHMwOHUzdExXRlliZTNVZEZTTlFGVlI2QUFWdDIyaEtuTzM5SzJZckgvWnFlS3l5YUxFdVpsMitsS25SY2NlbFdvN0lBaml0Q095d2VuNTFOSFo0SCtGUGxJYnVVWTdMNWZ1KzFTcGFmblYwVzRQR0trU0RGVllSVEZtQWM4ZmxUaGJZUFNyWmgyNXBERms5UlJZQ3I1RkJ0OGpweFZwb3RvNkRwelRYUUVkQlNhQXB2R01WUnVwUkdudlY2N2t3bjFySTFHZmF0U1ZGWDBNbldMM0dhNUxXYjhyMy93RHIxMEdydWNOei9TdVI4UU1ZbzM3VmpKblhCSGdQL0JRVDlxV0g5bFg5bVh4SjR1YTJYVUx1THlyQ3dzamNOQTE3YzNFZ2lWQTYvTXBDbVNRbGVRc1RFZEsrSy8yVS93RGc0YytDZDR5K0gvaTM0YjhUZUU3N1I3MG5UZkVscUJyMXRBMGNwWkpDNFVYY2UxVlZSbExySDhPMEVpdUovd0NEalg5cEw3TjRnOEkrQWJPZjVkQXRKZkZHb29Ea2ZhcHQxcllEMktBWFRrSHFzcW5vQ2EvSGQ1aVc2N3ZyWFpoRmFQTVpZaXBhMFVmMXAvc2VmdGwrRnYyZ29acmY0Sy9FTHd6OFh0SDArQmJpOHNZTHhvZFd0WGR6c2FWN3JiTkd6dXNoTFRlWTdoVHRVRmN0OWQyOTFJMjFaTGVTRTVZRDVnd0lIUTVCNHo2WTRQRmZ4QitEZkdtcS9EenhGWjY1b1dxNmxvZXRhYko1bG5xR24zVWxyZFdzblRkSExHeXVoOTFJcjlEdjJMLytEb2o5cEQ5bUxUdFAwWHhaZWFUOFpmRGRuS3VWOFVGeHJDd1krYU5OUWpQbU14NEllNFdjcmpHQ01BZFR0STVYcWYwN0VuM3B4YmNPUDFyOHVmMlRmK0RyMzludjQ3ZUkwMG54NXBQaWI0TzNWeThVY041cVpYVk5MZDJHRHZ1SUZEUkJXNDN5UkttMzVpeThnZm94OFBmang0SCtMbmh2KzJmQ1hqRHdyNHMwZnprdG12OEFSTld0OVN0WTVYQUtSdkxDN29ydHVHRkpCT1JqT1JVOHJGWTZiVXJxT0hTN2hibUZyaTFtUXhYRVhsK2Fzc2JjTUdUb3k0UElJSXhuZzE4UC90ZC84RzhYN0tIN1orbjNlb1cvZ1d6K0hmaUs2UWlMVy9BakpwaXEvWm5zMUJzNUJ1NWI5MHJ0ejg0SnpYM0ttMXRyQm05dWF3L0Vlc1htbnY1MzlnM1dvS3JLak5hWENyY011ZUNtU29PRGpJZDBBRzQ1T01HYkRqMlA1M1AyMmY4QWcwaCtOM3dOdExuVnZnLzRnMG40MGFQR1djNmNJMTBiWG9VQ2xzaUdXUm9aOFkyL3U1dk1jN2RzWE9CK1lYeFcrRHZqRDRCK05aZkRmanJ3cDRtOEZlSW9ZMG1sMHZYdExuMDIralJ4bEhNTXlxNFZoeUNSZ2pwWDl0ZWphWmNRUmhrMVMvbVJtM0NLOGppWXhBNStYS3FyZlFsaitOY1IrMForenQ4TmYydS9EVXZnL3dDS253NTB2eHRva1VabWhPcmFXTG1PM0xaVXRiM0NmdllKY0U4eHNqNEo1eG1qVU5EK0s2Mm5aSkZZZmVqWU1yRHFwSFFqNmV2dFgydit5RC93WDMvYWkvWkFXMHM5SCtKdXBlTHZEMXFRRjBQeGluOXUyWVFLRkVhU1N0OXBoUUFEQ1F6b285T1RuOUsvMjMvK0RRandMOFFFdXRhL1ozOGNTZUNyL3dDWS93RENPZUtKcGRTMG1SK0NFaXZFRFhOdUIweElsd1R4eXZmOG1QMjIvd0Rna04rMEgvd1R0czIxTDRuZUFMeXg4TXRQOW5qOFNhWmNSNm5vMGhMbFUzWEVKYnlTK01xazRqYzVIeTU0cW90Yk1OZWgrdy83Si84QXdkNWZEcnhxTGV3K01udzcxN3dOZU1RajZ2NGJtL3RqVG05WkhnY1IzRUtqQk8xRGNON25rRDlMUDJaLzI2dmc3KzJYWkxMOEwvaVY0UjhhVGVWNXoyRmxmQmRTdDAvdlMyVW0yNWlIdThZRmZ4aFcxME91UWR3NEl3ZjgrdGFla2VKWnRHdjRicTJ1SmJXNnM1Qk5ielF5TkhMYnlBOE9qRGxXSFlpbktqVGx0b1VmM0JBNFBUOUtPMWZ5dC9zby93REJ4cisxSit5MGJXeVBqeGZpTm9Oc0FvMHp4dmIvQU5yY2NEQzNlNUx3WUE0SG43Qi9kNjErbVg3Si93RHdkMS9CNzRqdmI2ZjhYUEJmaWY0WTZnKzFKTlUwcy8yOW93UGQzQ3FsMUVPbUZXS2JBemxqakp3bGg1TGJVRDljZGc5QitWTjJaRmVlZnM1ZnRjL0Mvd0RhOThPdHFud3Y4ZjhBaFR4NWF4b0pKMTBmVUVudUxOVDA4K0RJbWhQdEtpbjJyMFJYcm5zMXVCR1ljK3YwcU13Yyt0V2M0b0toalFCVWEzNTZmcFVNbGlyZHF2R1A1cVR5OXg2VUFaVStrcktPZ3JOdmZDOGR5RHVqVnZ3cnBXaTVxSXdjZi9XcWVWTXBTYU9BMWI0YjIxMXV4SGo2Q3VVMXY0T3E0WW92NFY3TEpicTNYMXFDWFRGY2RCV2M4T251YlF4RWtmT21zZkNxNGg1MmwxOUdGTTBueE40czhEWVd3MVhVb1lZL3V3dEo1c0kvNEErVi9JVjlBWFhoOVhIS2c1OWF4OVM4RFcxME1OQ3Y1Vmo5WGFkNE94MFJ4aWF0TlhQUDlDL2F3MXpTMkNhdHBObnFDRGhuZ1pyZVRIcmo1bFAwQUZkdDRiL2FoOEo2enRTNm12TkhtWTQyM2NHVnovdnB1SDRuRllldGZDTzN1UTIxUXArbGNqcnZ3VGFNczBhL2hXdnRxOGZNZnM4TlBiUStoOUYxMng4UjJ4bTArOXROUWkvdjIweXpCZnFWSnF5ZW4rZUsrUTc3NGMzMmlYUW50L09obVEvTEpFNVNSVDdFWUkvQ3RmUlBqZDQ2OEhsVS90T1MrZ1hnUjM4UW4vOEFIOENUL3dBZnJXT09YMjAwWnl5OXYrSEpNK3VTdTRmL0FGNmFPbFNWR3cyVnBJNGdQTlJsZHAvK3ZVbE5kZDFTQkEzVS9qVmFWZm0rZ3E1SXY4cWhsVEkvSDBxWkZSS2JjTlVVcWZlL3ptcDJIeTRxT1Q3aHFTaW5PdnovQUkxVTFDMlc3dDVJVys3S3BRL2p4VjZaS3JTamQrUFdzNWFNcVBZNVg0Q3pOcDJuYTFvY24zdEp2VExFQ2VrVTJXQS9CMGx6OWE3dzhmOEE2NitPZmlCKzNCZWZBUDhBNEsrL0RmNE5hdjRZdFl2Qy93QVl2REZ4THBQaVFYekszOW94R2VSclZvaW0wODJ5S01Qbk4zSDEzQmEreHUzZXV5bTdvbW90YjkvMDBNZng3NFdQamp3YnFta3h6QzNudjdaNHJlZnZiVDR6RktQZEpBamozVVVlQy9GUytOdkIrbGF3c1AyYiswclNPNWVBbm0yZGxCZUkvd0MwamJrSTdGU0sxdTJPVFhEZUQzMUxUZkZmaWp3L2J0WTJzRm5mRFZiYVdZUFBJMEY5dm1iOTJOZ0grbExlZ052UENENUsyUm1sZFdPM0IzZE1uNlZremVMckl5dEhiTkpxVndoS0dLeVR6OXJEK0YzSDd1TS85ZEdVVTArRXJlOEovdENhNjFYSis1ZHNERDdEeVZDeEhIWXNoSTlhMUk0MWhpU05GVlk0eHRWQU1LbzlBTzFVUm9aWW0xalVoOHNkbnBjWjZlYWZ0VTVIY0ZWS3hvdzdFUElQYnRUVzhGMmQ4djhBeE1UUHJIdGZzSll6NytTQXNJUHVFQjk2MktqdXJxT3l0M21ta1NHR01aZDNZS3FEMUpQQW9FUEs1QzU1MmpBejJGS09LeVI0cmp1eC93QVMrM3V0U0I2U1FxRXR6N2lWeXFNUDl3c2ZZMG4yWFZ0Ui93QmRkUTZkR2VzZG12blNEL3RySXVNSDA4b0VlcDYwQWFOOWV3NmJhdGNYRTBWdkNodzBzcmlORitySGdWNTU4SnZGQTB6VmZGWGhteHNycTZYUjlXZS9zM1pmczhMV2QrVGRKSUhmRzZNWExYMEttSlh3dHIwNlo3ZXo4TVdWbGRMY2VUNTkybjNaN2h6UE9ucUZkeVdVZjdLa0RucFhNK0tNK0dmamo0WDFKZUlmRTFyYytIYnIxa21qUjc2MFpqNklrT29LUFZybGFDbzlqb1dzdFUxTC9qNHZJN0tOditXVmttVytobGtCM0QvZGpRNTcxTHAzaHl6MHk3RnpERHV1OXBYN1JLelMzRzMwODF5WHg3WnhWNG5QYXNIeEw4UzlEOEo2bC9aOTVxQ3RxdXpldW0yY1VsN3FMcWY0bHRZRmVjcjZzRUlIY2lnblUzTWNmV2xISjQ2bnBqdlhKZjhBQ1RlS3ZFM3k2VDRkaDBXM1k0RjdyMXdHa0E3T2xuYnN4a0hiWkxQYk9PNEdNRVB3c20xLzV2RWV2NjFyU3Q5NnppbE9tNmVNOVY4bUFxOGtaNkZMbVdkU09PYUJselhmaXBvSGg3V1gwMmJVQmRhdENBMG1tYWZCSnFGL0dwNk05dmJxOHFLZjd6S0Y5NnAvMjk0dzhTZkxwK2g2ZjRiaDdYR3VYQzNsd3A3WXRMV1FveW5qbHJ1TmgzU3VpMEh3NXAvaFBTSTlQMHV4c2RMMCtFa3BhV2R1bHZCR1QxeEdnQ2pQc0t1RndQOEE5VkFqa24rRWtldUxueEpyR3NlSkZJTzYxbm1GcnA1ejk1RGJXNFJKWS9SYm56eUIvRVRrbnBORzBhejhPNlBiNmRwOXJiV0duMlkyMjlwYlFyRGJ3RHJoSTFBVlI3QUN1YytOZng3OEQvczMrRlYxMzRpZU12QzNnWFIyeUk3dlh0VWgwK09jam5iSDVyS1pIOUZRTXg3QW12ZzM0MGY4SFRuN0szd3huMVMxME82OGZmRUM4c1lpYmQ5SDBIN05aWDB2T0kxbXZIaGRSbkdYTVJBQnl1L3BRVlpzL1I0c0FNRDE1elhEZnRBL3RQOEF3NC9aUzhMZjIxOFRQSFhoWHdIcGpvWGlrMXZVbzdTUzZBNmlHSmo1a3pmN01TczN0WDg4SDdmSC9CMFg4ZHYybmJuK3pmaGl6ZkFyd29JbWlsajBhK0Y3clY4eDZ1K290REc4SUdQbFcyU0lqYzI1NU9OdjV2ZU4vSG10ZkVmeFplYTU0ZzFmVmZFT3VhZzVrdXRTMUs4a3ZMdTZZOVdlYVJtZHlmY21nV2gvUTcrMWovd2R1ZkF6NFUvYWJINFUrRmZGWHhjMU5EaU8rblUrSDlHT2Y0Zzg2TmRQamo1VGJJRDJjZGEvTWo5ckgvZzVSL2FxL2FoUzRzYkR4alovQ25RYmdGRFllQjdkdE9tSzlpYjUza3ZOMk9ENWMwYW5yc0hRZkFnWWtaK3VlT2xDcjVod3JLeDlBY245S0FMMnZlSWI3eFRyOTFxbXAzdDVxV3FYMGhsdXIyN25hZTR1WGJxN3lNU3pzZlZpVFZSeXpQMVB6ZGZlbngyYk1QMXE1WTZXODg2eHJHenlTRUJGVWNzVDJGQWFzL29HL3dDRFZQOEFZRDhIK0J2MlM0dmo5cW1pMitvZkVUeGZxdDlhYU5xZDNiWmZROU50M050aTEzRDVKSlpWdURKTW5MSnNqQkFWdzM2eGE1cDFyNG0wUyswdlZMVzMxVFM5V3Q1TFMrc2J5SmJpMnZvSFVxOFVzYkFySWpLU3JLd0lJSkJCcjhrZitEY2ovZ3BMcVQvc3VhVDhFZkVYZ0hYcHYrRmNpNFN3OFFXRjFaZVdiT2FlVzVFZHhhelR4M1BtSkpNNmhvSTV0eWJDeW9RUzN1My9BQVZaL3dDQ21uakw0SGZBaTcvNFZwRFphSFBlYm9OUzhYWHJlYmJlR3Jac1JpVldSdDBkMDhqcWtlNkp6RzN6ZVc1MmlsZExjdjJjbnNmejJmdCtmQnp3MzhGLzI4L2pKNEo4RXhsdkN2aG54cHF1azZQRWptYnlZSXJ1UkZoREVrdDVlREhra2s3TW5KcmhORStGT29haWp5U2VWWXd3c3F5eVhCSUNNUm5heEdmTE9Ed1pOaS83UXIxUy93REdQZ2J3Z3MwbHJiNnQ0dW5tL2VUZVZHTEszbEorWnZObG1SNUxnRS9ONWhnallaenZ6elh1SDdPdjdBWDdXWDdXUnRMandQNEJYNGMrSDVnRWcxdTZoYlRWU0E0K2FPK3V5OTVMSDMvMFl1TWs0VURpbDdTSnA3RTloLzRJWWFaNEovWVorSm5pdjR3L0VINGlONEJ2TkwwbHRIMDJ4MU9XRFRZZGV0cm9GcHlWbGprTW9pYUczWlBzL21Lemxjc3UzYS82RitPZitEbDc5bjNSdENXSHdQZCtKUGlGcW1CSEdpYWRjV0szRTdkSTE4Nk16TzVKd1BLaUtmN1FBelh6cit6TC93QUd0WGhtejFOZGUrTlh4QzFyeHhyVTJIdUxUU1ZhQ0RkZ2dxOTNjYjVwZ2MvZVdPQndRTUVIbXYwYS9adC9ZUitGbjdLRmhIRDhQUEFmaHp3dk1zZmt2ZlcxcjVtb3pKL2RrdTVDMXc2OTlyU0VEc0JXVXF2WXBSVzdSK1V2eEovWjIvYkYvd0NDcVB4MTFYeHhaL0QvQUVQNEI2RHJqcTBlb2VJTjM5cGdDTVJiOTF6NTE5Q3pScXE0czRZSWNLUDRpenQ3MSt6Wi93QUd6M3d6OEkzRWVxL0ZUeFY0bStLbXRTT3N0eEg1cmFaWXl1RGtieXJ2ZFNZSkpCRThZT2ZtUThZL1VDMTBCWWg5M21yOEdtaEQwclBtYjNLNW9ubVh3Ty9aZzhFZnM1K0dUby9nUHdsNGY4SDZiSW9XV0hTYkpMWTNHT0FaWFViNVdHQjgwak0zdlhmMnVockd2M2ExNHJJQWZkcXdsbGlsWW5uWm5RYVlFN1ZaaHN2YXRDT3o0NlZNbHJqb0txMnBuekZHS3h4VThkbjdWZFMzL3dBNDZWSWtQUEg0MGNvcmxWYlRIYXBFdDhWYVdQQjlmYkZBVEE3L0FKVlZoRUt3NHFRUWYvcXFRSngvOWFsMkgvSW9BWjVmK2MwZ2o1cVF4NXBNWU5LMnR3R0ZNSDFwamMxS1JtbyszZWxiVzRFWitUTlFUdGlwWlRrMVR1WnNab2tCV3U1Y2YvV3JGMUNUZFdoZVNjWnlQeHJJdVpOeC93QThWSnRUM002OWc4MW02N3E1dnhMcGJUeDRYQTNIR1QwR2NjMTFoWGRUZE0wMWRRMW1KV1hNY0o4MXZ3NmZyaXVkNnlzamJtdHFmekVmOEZoOUUrSm11L0hQeFI0NzhYZkQzeC80VjBieFRyc3oybDNybWdYVmpieDJrQSt6V0VQbVNJRldUN09vWmx6a3M0T1BYNHFrSHo0L3lUWDl4NDBxSFV2RHMybjMxdkRlV045RTBkemEzTVN5dzNDTU1Nam93S3NwQklJSUlJNjE4SS90bC84QUJ0aCt5MysxcGFQY2FWNFJiNFFlSkdmZXVwZUNCSFkyNzhZMlNXREtiVXAzeEVrVDVIMzhaQjlLS3RGSTQ2a3VlVjJmeXVQTjVlMGZqUXMrZjByOWNQMnN2K0RRSDQxZkRTMXVkUytFdmpqd3I4V0xPRk40MDY5ai93Q0VkMWlRNSs0aXl2SmF2Z2Z4TmN4a25vdGZtWCswYit5WjhULzJRdkZvMFA0b2VBZkZuZ1BVcEdZUUpyT25TVzBkNEZPR2FDVWp5NWtCL2ppWmxQWTFSbWNQSGM3UHl4WFdmQmI0NitNdjJjdkh0djRvOEFlTFBFSGdueEphcVVpMVBSTCtXeHV0aHh1UXZHUVdSc2NvMlZib1FSWEVxZVBidFVnZGozSS9HcTVnUDFTL1piLzRPelAyaC9nNDBOcDhRTkY4Ry9GclNWUkkzZTZ0djdGMVE3ZUN3dWJZZVdXWWRTOERra0E4Yzd2MGMvWmsvd0NEcHI5bkQ0KzNHbldmaUtUV2ZoSHJqbzV1RThUV3JYT25aQ3FmTGl2N1VQaG1PU0RMQ2l0NVpCMnNVRGZ6SnJJYWVMaGxHYU9aZFN1YnVmMjMvRHY0cCtEL0FJeitDTFR4SjRYMXpSOWQ4UFhnM1d1cmFUZnhYTnBNdVJ5dHhBN0lBVGpLc3dPZUNPb3JxTlB1b3IyemptdHJpTzZ0NUYrV1ZIRHJKN2hsNHIrSm40SWZ0RGVPdjJhUEdhK0pQaDM0eThUZUJ0ZVFBRyswTFVwYkdXUmM1Mk9ZMkhtSVNCbEh5cDdnMStwSDdDMy9BQWRuL0VENFNXV242SDhiUEJ0bjhRdExXKzN6K0lOQU1PaTZ4REE3N25MV3NhTGFYVHIxQUloTGpJYVRKTDBXVDJEUS9vbUJ3ZWxOdUVGMWJUVzhzY2MxdmNSdEZOSEl1OUpVWVlLc3B5R1VqSUlQQnI1Ly9ZeS80S21mQVg5dm5TYmVUNFovRWJROVUxaWRONytIYjJRV0d2VzVDN21VMlV1Slgyak9YaUVrZkJ3NUhOZStXV29RYWpBc3R2UERjUnR5SGljT3A1STZqM0JINEdwSlBpWDl0VC9nM24vWmgvYlQ4Ni9tOEdOOE5QRThnNDFud01JdEtNcHh4NTFyNWJXc3ZPTW55bGtPUDlZRHpYNVVmdGcvOEdrM3gwK0RjVjFxZndsOFNlSFBqRHBNUHpwWU1Sb1d1QWQ4UXpPYmVUQS91M0Fkc2NSNUlGZjBiMFlvMjJLNWorSlg0NC9BTHg1K3pONDJidzM4UlBCM2lmd0w0Z1ViL3NPdWFkTFl6U0xuQWRCSW8zb2V6b1NwN0UxeHkzQmpiUDhBZHpqTmYyK2ZFdjRXK0YvalY0VWswSHhwNFk4T2VNZENsTzU5TjEzVElOU3MyUHFZcGxaTSsrTTErY243WC84QXdhbC9zM2Z0QnZkYWg0Qm04UmZCWFhyZ015alNIL3RQUmpJZWR6V053MjhEUDhNTThTZ2NBVStaZ2Z6WStHZkd1b2VFUEVGcHJHbFg5NXBPcmFmSUpiVy9zcDJ0N3EyY2RHamxRaDBQdXBCcjc2L1pJLzRPWmYycFAyWjF0N0hWUEZXbi9GYlFiZjVmc1hqVzNhOXVWWGo3dDlHMGQwV3dPRExKSW8vdW1zdjl0UDhBNE5xUDJvZjJSN2kvdjlIOEtwOFhQQ1ZyODY2dDROSnU3a0puanpOUE9MdFdBNWJ5MGtSZWZuSTVyNEwxVFNyend6cmR6cDJwV2wzcHVvV1VoaXVMVzZoYUdlM2NkVmRHd3lzUFFnR256WDBZYW45Slg3STMvQjJWOEJQak5IQlkvRkhSZkVYd2QxbDlxdGNNcmE3bzdFOFo4NjNqRTZjOVE5dnRVSGx5QVNQMGUrQjM3UTNnUDlwZndndXYvRHZ4bDRYOGNhS3dCTjNvZXBSWHFSZjdNZ2pZdEd3N3E0VmdlQ0FhL2lWaTFJcW5YUHRudFc5OE9QaTU0aytFbml1MzE3d240aTF6d3JyMW1jd2FsbytvVFdGNUQvdXpRc3JyMjZFVkVxTUh0b0YwZjIrbDl3NjlhQWRwL1N2NWpmMlMvd0RnNlUvYVgvWjdOdlorTGRRMFA0eGFERHRSb1BFc0FoMUlMMzJYMEFXUXNlbTZkWnUzRmZwMyt5WC9BTUhWdjdPUHgzaXRiUHg5RDRrK0RPdVRGVWNhckNkVjBqY2Y3dDViSnZDK3JTd1JLTzVyS1ZHUzIxS1AwNHpnNW8rN1hOL0N2NHQrRi9qaDRMdC9FM2dyeExvSGpIdzdkY1Jhbm9tb3c2aFp1ZTYrYkV6THVIZFNjanVCWFFlWmc0ckt6dllCempkK1ZSN1JqcCt0T0xaTkdhZXdFWmp5ZlNtdkJ1cWJQSDNhRGpIcFI2Z1VaYkZYN1ZWbjBWWDdWck11Nmd4Wm81YmpUc2N0ZmVGWTV0MjZOVDYxZzZyOE43YTdEZnU5djRWNkk4UDQvaFVVbGtyajd2NlZMcHA3bHhxeVIwMU1rR2FmVFhIeW42ZXRhR1kzb2FLQ01pak5SSUNPUmVmclVMcjFGV0pCa1o5S2prNjFMQXB5THRiMnFFcmppclV5OWYxcXUvUUdvTkN2TXZ5a2ZsVk9VRXRqMXE5SU9hcXpyODM2aXBrdW9SM1B6My80T0YvQUdwZUh2MmNmaDU4ZXZEZHVadkZmN04vamF3OFQyMjFkeGUwbHVJRWxqeDNEWEVOaGtmM1ZZOFYrZ25oWHhkcHZ4QThLNlQ0ZzBhWmJqUi9FRmpCcWRoS0NDSmJlZU5aWW16N282bjhhNDM5b0w0TFdIN1J2d0w4YWZEL1Z0cTZmNDIwTzgwT1dSeG55UHRFTHhyS1A5cEdaWEI3RkFlMWVEZjhBQkRqNG5hbDQ4LzRKdmVFZEIxOVdpOFVmQzY5di9BbXN3UDhBZXRwYkNkbGlqSVBJMjJzbHN1RDNVMXBoM3JZMG1yd2ZrNy9mby94dDk1OWNkVC85YXVVOFZIK3dQaWg0YjFJRUxEcThkeG9WeVA3emxUZFd6dDdJWUxpTmY5cTd4M3JxbCt0Y3Y4YU5Jdk5hK0dHc0RUZDUxYXdpR3A2Y0V3V2U3dFhXNGdYNWdSODBrU3FjZ2doaUNEbkZkeHpKNm5TTzRpaVoySVZJd1daaWNCUU9wSjdWbWp4WmJYYWJyR080MVFmM3JSUTBSK2tyRll6OUE1UHRVT2o2VG8vaUd3czlVaVp0V2d2STQ3dTF1YnAvTzNJNmgwa1JUOGtlVklQeUt0YkRITGJzN2oxeVRRVHNaWmkxYlVmOVpjV3VteCtscVB0RXY0UElvUWZReHQ5YVdEd3ZaUVhNYzhrWnZMbU03bG11WE04aUgxVGNTSS9vZ1VlMWFMTitYMXJIOFZmRUhSUEFza0VPcTZwWjJWMWRnbTF0WGszWFY1anFJWUZ6SktmYU5XTkFhOURZWnM5Y2s5Q1RRR3dDUDZWeVE4YjY5NGgvNUFmaGU0aXQyKzdmYS9NZE5qWmY3eTI0V1M2M0QrNU5GQm5IM2hrR2dmRHJWUEVMYnZFSGlqVkxxTThHeTBiT2pXZnNkMGJ0ZDU5UWJvbzM5d0RpZ2ZMM05QeFQ4UmREOEUzOE5ucW1wVzhHbzNTZVpCWUlyVDMxeXVjWml0b3cwMGcvM0VOY3A0OGo4UmZGclFvckxSOUVPaWVUZjJXb1E2bnJzZ2lNVDIxMUZjSTBkckNYbGtCTVcxNDVtdFdLc3d6eWE3UHduNEowZndKWXpXdWk2WHAra3czRCtiT2xuQWtIMmg4WTN5YlFONy83VFpZK3RhVzRLdnkwQ09UYjRZM212N2o0aThTYXhxY2I4L1k5UFp0SHNrUHNJRyswTXBIQlNhNGxRLzNhM1BEUGhUU2ZCZW1mWWRIMDNUOUpzdHhjMjluYkpieE14NnNWUUFGajNKR1QxelZQNGtmRXJ3MThIZkNVM2lEeGY0aTBId3BvTnZuek5SMXJVSWJDMFFqbkhteXNxNTlzNXI0Ry9hbS80T2MvMmIvZ0tMaXk4SHplSXZpOXJjT1ZDYUhhTlk2V3IrajNseXE3bFBIendSVHJ6UVBWbjZMazdQOEE5VlJYZDFIWlRXc2Mwa2NNbDRXRnVqc0ZhNEtydWJZRHkyRkJKeG5BQkpyK2N6OXFyL2c2SS9hRStOQzNOajRLL3dDRWIrRU9qekVxaDBXMUYvcXdUcGg3eTVETG4vYWdoaFlZNjlLK1dQMmFQK0NtdnhGL1p0L2JaOE4vSE84MWpVdmlCNHIwT2FTTzhQaUxVcHJ5WFY3S2FOb2JpMmU0a1pwRUR4eVBzYmtJNFI5cmJjRmN3MUUvcmJMWXpuOGEvTFgvQUlPWWYyK3ZpOSt4UDRLK0ZkdjhNUEg4M2d1MzhlTnE5dHFxMk5uYnRxRW4yVVdiUnlSWERvMHNLajdReXNZaWpaMm5kMUJ4Ny84QTRPN2ZnU2ZCSDJxRDRiL0Z5NDhSZVVXL3N0NDlPanRGbENrN1RlZmFTZG5iZUlDeC91WjRyOGFmK0NtUC9CU3Z4eC93VTYvYUNIamZ4aEZaNlBaNmJhLzJab09nMkxzMXBvbG1IWjlnWnVaWm5ZN3BabUFNallBVkkwampSM0Z5dE04ZytKWHhkOFFmRmZ4ZGNhNzRtMTNXdkVtdFhaTFQ2anExL0xlM1UyU1NkOHNyTTdmaVRqMnJrTHE4YVUvTnpqaWhtTXZ6ZC9VbW8vc3pQNmM4Q2dXckkyTFNOOTA5YWRGRzBocmM4UGZEelZ0YnY0YlNHeG04NjY0aFIwWVBJZVB1TDk1anowQVBCcjEvdzUreG5xbW42SERySGlhYTE4TTZQY1BzaXZ0WXZvOUxnbUlPR1ZmTXk1a1huNUdWY2tkVHppZVpGeHB0bjdFLzhHL2YvQkVYNE02dCt4cjRQK05YeE44SmFUOFNmRi94QWptMUd3czljZ0YzcE9nMlMzRXNNU0xhTm1LYVdSWS9NZVNaWDI3MVJGVGF6U2ZhZjdTZjdHMzdKUGlENGNhdlorTVBneDhLcjdUZFBzSmJpNFRRdkMxdmJhamJ3b2haakRQWXBIUEV3VlNRVWtVNUZmbE5iLzhBQmVuNFFmc2YvQURRL2hmOEZmRFBqSHhWNGQ4TndPTE8yMURVWm9iRzJNc2p6U3Q1czI2UWt5eU83Um1CNHNzUWpCYTkrK0hYN0xmN1UzN2JYZ0N4MWo0aGZFOC9BM1RkV2pXN3R2Q3ZnL1NDZFZ0WTJIeXRjWFR5Q1MybUlJSlNIYmdZRGJHREtzeXFxS05ZNGRQZG41VS9GMzlsL3dBQytFZmlMcmVxYVRxR3NlSGZoN2MzMGt2aDZQeHhjdzZicXNkc1d5c04xRkVYbGFaQWR1K0dOMGNBTmtaSUhIajR0L0Qzd1M3UWVIOUoxanhkZElOdUJFdW5XY3FEcUpHY1NUU1lKUHpLc0xZeHpYNm1OL3dhb1dIaTM0a3hhdHJIeGkxdSswMjVjemFnMTVvZ20xVzVjNDZUZmFTcExmTVM3aGlEajVXNXI3ZS9aYy80SWovczkvc3ZXdG8ybCtBYmJ4SnFWcmhsMUx4UXcxV1l1QW84d1FzcTJzYi9BQ3I4MGNLTndPYzgxbjdZZnM5ZEQ4WC9BTmlYUi8ycmYyaEx4cHZoTDhPVjAvUkxzckRMcU5qSGNhZlpPRlVxQk5xVTB3RXBRTVRocFdrRzQ3Um5pdjBHOEwvOEVNZmlkKzB2b1dqMmY3UTN4a2t1UERtbU10ekQ0VjhKd21TT0tiR043M3QyR0x1b3lvTFJTNER1RVpBemJ2MVF0ZkRhZ1I3c3NJMUNLRC9DQjBBOUFQVHBXaERvNm9PRi9DczVTY2l1YXlzZk5YN00zL0JMYjRJL3NwbTNuOEcvRG5RYlhWb1NHWFZyK002bHFXOForZFo1eTdSTWNuUGxiRjU0QUhGZlF0djRjVXlibnl6TWNsaWNrL2pXMUZwK0I5MnJFVmp6UVM2ak11RFNWWGphS3RRNmVvNXhXa3RsejkycGt0Y0hwVHNadVJRVFRzaXAwc0FCL25pcnNkdGovd0RYVWlRWS93RDEwN1dGY3FSMllIMHFZV3d6Vmp5YytsT0NBR3FFUXJBcTAveWdEMHFYYm50K3RDcnpnY1VBTUVaOXFYeWhUc1orbnJTN1A4NW9BWUV4VHFDQ08xRkFCUlJSUUFtTWYvcXBISEgvQU5hblp4VWI5ZjhBNjlBQ00yMFZFNStYRlNTZGFnbFA4cUFJcDMyaGo3VlF1Vy9QazFidUh4bjZaclB1NU9QY1ZtOXlvbWZmellCNXg3VmkzVnh0SitsYU9veTREZjNjZGF3TlF1TUJqOVRVeU5xY1IwdXBDTmMva1BXdW0rSGVqVFg5cDlxOGlYeTdsc3F3UTQyTHdUbjAzWkg1VjVMNDE4WTJmaGpScnpVTlN1bHM5TjArQ1M2dTdoejhsdkRHcGVTUnZaVlZpZllWL01UKzF4KzJaNHY4Yi9IL0FGRDRrNlBydXZlRmZGSGlIV0ovRVVWNXBtb1MyZDdwaVN1OGRyQXMwVEIxOHFCQ255dDBDL2lVWXR6S3FKY2wyZjJEZFB3NHBxbmNmd3dQeHIrYVg5aXovZzY3L2FCL1owczdYUi9pVFk2TDhidkQ5dUF2bjZySTJuNjhpREhBdm9sWkpPK1duaGxjbkh6akhQNnQvc2QvOEhMdjdLLzdWc1VObHEvaXk0K0VQaVNRZk5wL2pSRnRMVjJ4ejVkK2hhMTJqcG1aNFdQWk91TzQ0N2RqOUF0d1VmcldWNDg4Q2FEOFUvQjE1NGY4VWFIbzNpZncvcUs3YnJTOVhzSXI2eHVSNlNReWhrYjhRYXQrSHZFT24rTHZEMW5xK2szOWpxMms2bEdKclMvc2JsTG0xdTBQUjQ1VUpSMVBxcElxeU1EcDM5NkNUOHgvMjNmK0RWUDluZjhBYVVXNDFUNGN2cWZ3UDhUeUV0blNGT282SE94YkpMMkUwZ01mb0JielJJbzU4dGpYNHkvOEZDZitDQ3Y3UXY4QXdUajBlNjhRZUpOQXNmRi9nSzFQNzN4VDRWa2t2Ykd6VWtBRzZqWkVtdFJrcU4wcUNQY2RxdXh4bit0SUx1b2VKWGlaVzVXUUZYQjVEcVJncVIzQkdRUjZHZ1ovREFxaGh1VnNyNmc1elMvd1k5ZTlmMXRmdG4vOEVIdjJhZjI1NWJqVWZGUGd1VFFmRmx3WGR2RXZoZVNQU2RTbFpnQnVtQ1JtQzVZWUIzM0VVajl0K0NSWDQ4ZnQ5ZjhBQnFaOGFQMmNSY2E1OEl0UWkrTm5obnpRb3NiVzIreGVKTFJXenkxcVdNYzZyOG9Md3lGem5QbEtvSkFGajhyQWY1ZEtjR3gxNTVyYitJL3d4OFJmQi94dmZlR2ZGdWc2MTRYOFNhVXdTOTB2VjdHU3l2YlJpQXdFa01nVjF5cEJHUnlDRDBOWVRMZzhmaWZXbnFJczJlb1RhWGZRM052TkxiM1ZySUpZWm9uS1NRdU9RNnNPVllFQWdqa0VWK2lmL0JQZi9nNWgvYUEvWTR2MnNQRytwWHZ4eThHM0RxejJIaWpVNUcxYXpPRlV0YmFpd2VVWlZRUExtRXNmY0twTE1mempIQzR6VGxmNWVUOWFmTUIvVjkreE4vd2NNZnN4L3RyUjI5akQ0MFg0YWVLcE5xdG9mamRvdExhUnpnWWd1dDdXc3dMSENnU3JLM1V4cjByN2czN29ZNUYrYU9WUTZNUHV1cEdRUWU0STdqZzEvREVadDZiV3d5OU1IcFgwTCt4OS93QUZVUGovQVBzS0NHRDRaZkZEeEpvZWpSdHUvc0s1a1hVZEZiSnkzK2gzQWVGU2Vjc2lxL1AzZ2VhTkdQUS9zWForUHg1cGQrQUsvQm45bXY4QTRQSGZFZW5TV05uOFl2ZzdvMnIyKy9iZGF0NE8xR1N3dUVqL0FMNHNya3lwSS9xb3VJbEo2YmVCWDZqZnNpZjhGbFAyYWYyNExtT3g4Qi9GVFExMTlsVS8yRnJpdm91cWJqenRTSzVDQ2NqdjluYVVEMXBjckhZK29RMkR1R2E4ai9hcy9ZSytEUDdjT2svWmZpeDhOZkN2aloxaE1FVjllMm5sNm5hb1NEdGh2WWlsekVNZ0g1SkFLOVprVmxPMWdSM3dSUlNBL0duOXFQOEE0TTR2aDM0clM2dnZnNzhWUEUzZzI4WXZKSHBmaWkxVFdMRWs4ckdzOFFobWlRSGpjeXp0ajFOZm0zKzAvd0Q4RzR2N1hIN0xyWE55M3czaytJdWpXMlArSmw0RXVmN2FFbnVMVUtsNkFQVnJjQ3Y2dXNlMUN0dFArZUtCSDhOZXM2VmYrRmRkdXRMMVN6dk5OMU94a01OeFozY0xRWEZ1Nm5sSFJ3R1ZoNkVBMUhIZU1yZCtlbGYycmZ0Ri9zbS9DLzhBYTgwRCt5L2lqOFB2Q1BqMnpTTm80VzFyVFk3aTR0UTNYeVp5UE9oUCsxRTZuM3I4NGYycGYrRFJMNEIvRksybnV2aFo0bzhaZkNiVm01anQ1NWYrRWcwanVjR09abHVWendOMzJsc0FmZEpvdTBGaitmNzRKZnRJK092MmJ2RnlhNzhQL0dQaWp3UnJhOGZiZEQxS2F4bWNjZks1aVpkNm5BeXJaQjdnMStrUDdKUC9BQWRuL0g3NFBUVzFqOFR0SDhML0FCZzBXTWhYdWJpSmREMWdKZ2ppNHRvekN4NkVsN1ptT09XeWMxNHIrMkgvQU1HM243Vkg3Sk56ZDNWcDRKSHhVOE0yL3dBeTZ2NElkdFNiYnlmbnNpcTNpRUFaWWlGa0djQjI2bjRYdUxlZlROU210YmlLVzF1cmFSb3BvWmtLU1F1dkJWbE9DckFqQkJBSU5WemMyNDlUK3JmL0FJSjcvd0RCZjM0QmY4RkRQRjlqNFIwcTgxdndINC8xRTdMVHcvNG1namovQUxTbEM3bWp0TG1KM2lsWVlPRWN4U3ZqNVl6emo3YkxtdjRnL0RXcTNHajZoYjNWbmNUVzF4YlNyTkJMRTVqa2drVWhrZEhHQ3JLMkNHQkJCR1J5Sy9zSS93Q0NaMzdRdXEvdFZmOEFCUHo0US9FTFgza2sxN3hKNGJnZlZKcEUyTmRYa0phMm5teGdEOTVKQzBuQTJuZmtaR0RVVmFNVkhuUWMzdldQZGcrVGluVkgyNlUwai9acm51aWlVSG1sQnpVUTQ3VW9jNW8wQWtveGs5S2FKQlRnTnhwZ2JsTmM0Rk9xTm0zSDZVQUhTazZOU25tbTU5LzBxWDJHT1BJcU5sK2JwOU9LZXB6U1NjZm5VaUtzaTVYL0FIcXJ5cm4yNHExSXZhcTh3L3hvTGpzVjVPUitOVjU0OC9TclRERFZES01EL1BTczJNb3NPSytlL3dCbFQ0SStJUGdKKzI3OGZCRHBjeS9EcjRtUzZmNHowMjhFc2ZrMityTWhoMUdBcHYzaDVKRDUyZGdYYUFNa3JYMFJNUG03VlYzaTF2N2VSajhydDVUZmowL1hQNTBvNlNSU2VsdTZOUXRqL0NoSm1TUldYN3lrRVlOSS93Qjc4QlNZcjBVY3A1ejREOGRhSjhOUENrK2c2eHF1bjZiSjRkMU80MGExaG1uVlpKb2h0bnM0b1UrL0s0czdpMUd4QXpic2dBbXRnZU85WTF4OXVnK0Y3OW96eUx2VzVEbzl1ZlVDTmtlNzNEMGUzUlQyZXVrdHRDc2JMV2JuVW9iT3poMUM4aldLNHU0NFZXZWRGKzZyeUFibVVkZ1NRS3NoUW9wRk5wdTV5UThCNjFyN0sydStLcjVvL3dDSzAwT0k2UGJ0NlprVjVMdmNQVkxoRlBkTzFhL2hid05vL2dXT1pkSDAyeDAxcnM1dVpJSVFzdDIzOTZhVDc4cmR5MGhaaWVTVFZqeFY0bjB6d0o0YXU5YTF6VXRPMFBSYkJQTXV0UjFHNlMwdExaZldTV1FxaUQzWWl2anp4WC93WG0vWjl1ZmpqNGQrR0h3MzF5KytNbnhDOFdhcERvK20yUGhPMzh6VGx1SlRoV20xQ1hiYmlCZVdlU0F6bEVWbTJIYVJSb2dWM29qN1BZS0YvdTFsZU4vSG1oL0M3d2xkYS80bjF2UmZET2cyUzdyalU5WHY0YkN5dHg2dk5LeW92NHRVdXB3eWFwcDF4YitmTGFtZU14R2UxZmJKRmtZM0l4SEJIVUVqOEsvbmMvNE9RLzhBZ21wOFFmMlgvRmVrL0ZlNCtKbmo3NHNmRHZ4SmZ0cHNkeDR1MVI5UTFQd3BldXJTcGJGMndodDVWamtNYnhwR0ZNUlIxenNlUms2ZFQ5S1AycVArRG1uOW1YOW5wcml4OE42dnJYeGMxeUlGUkQ0WXR2TDA1WDdiNzY0MlJzcC92MjZ6ajJyODIvMnBQK0RxTDQrZkdWN2l5K0grbitHUGhIbzhnSlZyQ0lhdHEyMDhGV3U3cFBMOWZtaXRvbTQ0TmZsZXVyU014Qk80WXgvZEg2ZjU2MTdGL3dBRTlmZ2ZwUDdVdjdkSHdoK0hPdlhFOXJvUGpMeFpZYVhxTFJ5R0tSN1o1bDg2TkdIS3lPbTVGWWNobkZTMnpXS1Rka2UzL0NEOWlUOXJML2dyWnJNM2pYUzlGOGIvQUJNZ1YzZy80Uy94VHJYbDJiRU1RMFVGM2Z6S0pOcEJWa3R5M2xuQ2xWNEZlVmZ0c2ZzRS9HUDlnTHhOcHVtL0Zmd1RmZUdmN1lWbjB5OFdlRzkwL1VCSGplSXJtM1o0bWRRd0xSN2hJb1pTVkFaU2Y2NnZDL2hqUy9CSGhmVGRFMFRUYkhSZEQwVzFpc2RPMCt5aEVOdFlXMFNoWTRZa1hoVVJRQUZIQUFyNE0vNE9jNFBEVW4vQklQeGgvYnkydjlwTHIraXQ0YU11UE1HcGZiRkRHTC9iK3dtL3pqL2xuNW5hamxJbEozMFA1a0pyNThCV1BwMStucC9Xb1pMa3NmbXpnRGtEUHZYWWZEMzRGK0p2aXRyNmFkb1drM2wvZk1OL2tRUXZOY2JQNzRoalZwV1hxZHlvUU8rQlh2SGdYL2dsTjQvMWZRNU5jOFFRMnZoUHczYnNFdXRZMXk3aTB6VDRtNXdCUEt3aHljZmNubHRuSTZEcFU4eU5JeGs5ajVYNUM4OVNldmNWMW5nTDREZUtQaVRyMEduNlpwYzczZDBGYUtGMGI3VE9wejgwVnVvTTg0R0RueVkzUHRYM2wrelord3I4SjlWVlpkSzhXWDN4TXVvcGZzN3crQ1laRWhTVmM1Vjc1ekhKQzNzajNzVERCQUtrVjNIeE0rTGtQN0srbzNmZ0g0VCtEdExzZmlqcWtJU3o4T2FGWU5yV3FQTklmbGU4UGwvWjQzVDcrSWJlS2NneDhJcmlRRGR0V2J4dy9XVFBuVDRmZjhFaHRac3RCVHhKNDgxTFQvQy9oVkpERzJwNjVxVVBoL1RaSEIrNUhQY1pacE9SKzRuUzFrT2RvSVBOWWZqelVQMlovZ1ZmeHg2VHJtdGZGVFVMV0xMVzNodlM1ZEowK1dVRXFRYis1a2E1ak9PZDBRdW9qZzQ0TmU5L0NUL2czeC9hay9iYjhWUitLUGl4ckY1NGROMGlsOVU4YzZyTGZhdTBmR0ZTMVZwSmxZQW45M00wQUhRR3YwTy9aWS80Tm0vZ0Y4RVV0N3Z4ZERyUHhRMWlFaVFuVTVXc05PUndPcVcwRGh5TysyV2FWVG5wamdadW9oY3EyU3QrWitMdmdQNG9mR0Q0OStJMjhLL0JUNFlyb2N0OE56V3ZoZlFuMVRWWjQrVkUwMHJLKzFsd2N6eHh3OHJ5UmcxOVdmczlmOEd5bngwL2FLMXlIeEw4WWZGRnI0UGE4S1NYRW1yM2JhOXJjby8yb281U25vTVBkS3d6eXZhdjN4K0dYd1I4Ti9DTHd2RG9maFh3L29maG5SWVRsTERTYkNLeXRsUEhQbHhxcTU5OFpyckxYUWxqL2grbWFsMUd3MDY2bndGK3lmOEE4RzlIN1BIN05NbHJmWEhodTcrSU91V3BXUmIzeE5LczBDT0RrRmJTTUpBUm5rZWFzcEg5NnZ1YXg4SngyNS8xYWpKeVFCMUo2bXVraDB4VlBUbXJLV0lVOUtqMUpsVU1hMTBWWXdQbHE1RnAyQnhXa3RwakhHS21TMHl0UGxJNWpPajA3cHdlUGFwNDdIQTZZL0RwVjRRTFFJd1A4S3JsSnVWMHNzLzNxZWx0azhmeXF5SStPbjVpZ0w5UHpwK29pSllNVTlZc0QvNjFTQ0w5YWNJOW83VXdJd3YxL0tsQ1ovOEFyQ3BmSTVwd2o0N1VBUStYZ2REK1ZPRVczLzY5UzdPZXY2VXV6QTRvQWo4djMvU2sySFA5YWxDQTBGTUQyb0FpRWVSNzBnWEg5NnBId0Q3MUczeW50K1ZBQm1vMlhhYWtGSTUrWG1nQmxGQTZVVUFEZEtqNit0T2R1MzlLamM0SC93QmFnQnNoK2FxOGh3b3FaMnovQVBxcUNiZy95cGRMZ1ZMbDhBL1NzKzlmZy96cTdkbklKOXYvQU5WWjE0MmR3OWFndGVSazZrMmMvTlhPNnVTcUh0eFhTWGFlYXg5RFdScXRqdmhiQS9XczVTT2xhSHdQL3dBRndmajIzd2svWXMxWFE3VzUrejZ4OFI3dVB3emJFTmhvN2FRTkxleUgwVDdOSEpFVzdHNFQxcitjL3dDSWZpdHZGZmlhNnVWZVQ3Tzh6TmJ4ay82cE1LaWpIWStXa1lQKzdYN3hmOEZ1L3dEZ25wKzBKKzJUNHl0TlU4QitFWDFqd2o0UzhQdkJwcVJYc1huM2QxZFRBWDA2eEFsOEpDa0tnRWJpWW0ycVFjbjhSZjJodjJWUGlGK3pIcjBsbDQwOE02bHBTK2U4RU43NVRQWjNiS054OHVYRzAvTGhzSERBSEpBcnF3OU5xRGtZWWlXMFVlYk5KL1g4YXJ0SnVOT2tmYkUyTy9GUWgvWG10am1QWVAyVlAyOHZqSit4SHJNMTk4Si9pUjRxOER0ZFNDVzZ0ZFB2RDlndlhBd0RQYXZ1Z21JSFR6STJ4bXYxWS9ZMi93Q0R4WHhWNGJoc3RLK1BIdzFzZkZrRVpXT1R4RDRSbVhUdFEyZ2ZNOGxsTG0zbWtKN1J5VzZqKzdYNGtvN0hvZVBwVTBjbUIrSEZBN245aDM3RlAvQllqOW5UOXYyVzFzL2g1OFNOTC80U2E2QUE4TTYzL3dBU25XOTVHZGlRVEVDNFlBSEp0bWxVZXRmVGt3YUNieTNWbGJPQ0RnYmZxRC9ubXY0WFlaeWpLNnR0WkR1VWpncVIwSVByWDJ0K3dqL3dYNC9hUS9ZUTFLRzMwL3hwZGZFRHdpb0VjbmhueGxQTnFsbXFqZ2VSS3ppZTFJNXdJcEFtVGxrZnBUSG9mMWxsTTlQNTFGZDJjTjBtMmFLT1pWTzRCMERZUHFNOStlM05mbGYreDMvd2RxL0FmNDVYOXZwUHhSOE8rSXZneHFsdzIxYjZXVCszTkV6a0FCcDRZMG5qSnpuTFc1UlFDV2NBYy9wbDhQOEE0aGFUOFhQQmRqNG84RitKUEQvaS93QU02bmw3YlV0TnZJcjJ5blhrRVIzRUJLSEI0SU80NUJCd2VpQ3g1LzhBdFEvc0dmQ3o5czNUMnRmaVI0TDhOZU1MTnJQN0dQN1UweU9TNmhVTnVSNGIxTmw1Q3k3bUEyVEJSdmI1Y25OZm1IKzJKL3dhRStDUEU4VjdxbndWOGRhOTROdm04eWVQUnZFRVkxalN4MUlpU2VQWmRSRHNOMGR3ZU1FODVyOWhOT3ZieS90Si93QzNOTGgwbG9aWk5ra0Yvd0NkRzBRSHl5K1lGamFOaUNjcmo1U0NOekRCTjI2RjFZMnZtd2VkZUlDckxHcUl6c3ZvR1psQnlPaEp6em41dWxNRCtURDlxZjhBNElVZnRPZnNySFVyMisrRytwZU12RE9tTUZmWHZDQi90cTBDN1N4WjQ0djlJZzI0SWNUUkpzUFhncVQ4ZXRINUx0RzNEeGtoMVBCUWpzUjIvR3Y3ZWZEbnhEMC9WTHVTVHk3alRMb1lTU0s2czVMYTRWaG5CYmNBKzNiakJaVkdEd1RuanpQOXFuL2dteDhCZjIzcldSL2loOEsvQi9peStrWlhPck5iR3kxWTdmdS82ZGJHTzVLLzdKa0tudURRRFA0ME9oOUtOKzBkZnh6WDcxZnR2ZjhBQm9UNGQ4UjZoSnFQd0I4YmFoNFl1THBta0doK0xTYnpTSUNTUDNhWDBRTjFFb0dkb2tndU04YnBGNm44c2Yyd2YrQ01YN1MzN0MzaGVUWC9BSWlmQzNWTFB3ekM1V1hXdEt1cmZXTEMzQXo4MHNscThoZ1U0T0RNRXowNjhVaFdQbU1Ua2pyVWJsWkI4d0RkOEhtbTdzOUdCK2hvZkp4aWdSOWJmc1cvOEZ4UDJtZjJFYlRUOUw4Ry9FalVOVzhKNmFxeFJlR1BFcS8yeHBNVVNqQWhpU1UrWmJKN1cwa1g4OC9xWit5TC93QUhpbmczeGhxdW02VDhiUGhmZmVDMnVHU0c2OFFlR2J4dFNzSW1QV1ZyT1JSY1J4ampJU1NkOFp3R1BCL243SEJHUWV2UEZPQVhQOFFJNlV4M1A3VGYyWFAyN1BnMysydnB4dVBoUDhUUENQanFTT0lUeldXblh3WFVyYU05R2xzNU50ekVPMlhqVVp5SzlaSUtzUWM1VTRQMXIrR0d3djdqU3IyTzZ0WnByVzRpYk1jMExtT1JDUVJ3d3dSK0ZmZVA3SlgvQUFjbi90WGZzb2FaYmFWSjR5MC80bWVIN09JUXdhZjQ0c2pxVFFxQ01iYnVONHJ3NEEyZ1BPeWdIN3ZBb0hvZjFXMFYrUXY3SUgvQjN0OEl2aWEybmFiOFpQQnZpRDRZNmxOdlM1MWJTMWJXdEZqSUNsWEtJUHRTQmp2K1VSeTdjTDh6WkpYOU8vMmQvd0JxajRhZnRjK0ZwTmErRi9qendyNCswMjNWVGNTYUxxRWR6Slo3aGxSUEVENWtESCs3S3FuMnBXQkhleUlYNk1WUFhOZUdmdGVmOEUwZmdQOEF0M3d1M3hWK0dmaHp4TnFqUitXbXRwRTFqck1RQXdvRjdBVW5JWHFFZDJUL0FHVDByM1JEa1VtZHg5cVJSK0cvN1lmL0FBYUIzRmlMclZ2Z0Y4Uy90Uzd0MGZoM3hxZ2prUWR4SHFNQ2JXSS9oV1MzWC9ha1BXdjJpK0Rud3AwZjRFZkNMd3I0SDhQd3JhNkY0UDBpMTBXd2lCUHl3MjhTeExuSnlTUXVTVHlTU1R5YTZaK1Ivd0RXcHRaVmFqdHlFOHF2Y2R2NS9yU2I2U2lzU2gyLzMvbFM1M0NtVWREUUEvdlQxYlAxcU5UMDk2Y0cybXRFQjBCT0JVYkhwanQ3MDV6Z1V3ZGFVdGdGSFNpaWlvQUthNXgwL25UcVE4VUFRdndmd3FDVWNmclZoaDhsUlNVRlJLa3E0L0ErdFF1T2YvcjFha0dHcXV3K1Nwa1VVN2hjbjhhcGFsWk5mV1R4UmhtbWtYOTJCMUw5djF4V25PdTRmaDFxbStVYmNDY3FldFp5N2xSSS9DWGkvVGZIL2hiVDljMGU5dGRTMHZWWUZ1YmE2dHBCSkRPamZ4S3c0SXlDTWowcVhYOWVzZkNmaCs4MWJWYjZ4MHZTZFBqTXQzZlh0d2x2YTJxRHEwa3JrSWlqMVlnVitIUC9BQVdTL3dDQ3YzN1Ivd0R3U2gvYWo4UWZDWDRkMy9oSFNmQm1wMnN1dStITG05MEZMMi90WTlRdTVMMmFhTjVTWXlJN21XNnRZMWRHalZJRDh1NEJoK1BQN1RuN2J2eGUvYk4xMWRSK0tueEc4WWVPcFlaV210NGRWMUdTUzBzaTMzdnM5dGtRd0E0SEVTS1BhdStuSzhVekNWcjZIOU1QN1dIL0FBY29mc29mc3UvYUxPejhiM1h4UzE2M08zK3p2QTlxTlFoQnhrRTN6dEhabGZVeHl5TVA3dGZtYisxVC93QUhkZnhuK0o2WE5qOEovQjNoUDRVNmJKOHFYOTMvQU1WQnJLKzZ2S3FXaVpIVlRiT1IyZjEvSUdLYkgwL09yQ3lsL2VySlBWUDJodjJ1L2lWKzFuNG5YV3ZpWjQ4OFYrT3RTamRuaGZXZFJrdW83TW5xSUltUGx3ci9BTE1TcXZIQXJ1ditDV3Y3V09rL3NaLzhGQ3ZoUDhTdkVmbk40YzhNYTRQN1ZhT0pwWkxhenVJWmJXZVpVVUZtYU9PZDNDakpKVEFHVFh6cWp0ajhNMGlsaWUvSS9PcDVTbE4zdWYyNjZOOFFQRC9pTDRhUmVNdE4xL1JOUThHM0ZuOXZpOFFXOTlGSnBjbHRqZDU0dVEzbGVYamtzV3dNSE9LL0dmOEE0T1ovK0N2UHdsK0xQN0w4ZndKK0dYaW53LzhBRVRXZGUxYTAxTFhkVTBXNVMrMHpSN2EyYnpZNGt1b3lZcGJpV1haeEV6QkVTUU1RenFLL0VId2I0VThUZVByV1RTdEVzOWExUzEzaVNXMnRWa2xnUnV6dWk1VmUzek4rZGZVSDdMdi9BQVJrK01mN1NNVUY5RG9OMXAyaHNBOG1wUEdCWnBIeDgvMnAyUzFZWVAzUlB1SFBIQkZITjA2bHhvdVh3bytUSVVLbnBrVjJmd2o4TmVLTHJ4bnA5NTRXdGRWazFyUnJpSy90cGJDM2VhYXpsaWRYam1BVUVqYTZnZzR4a2VsZnNGOEYvd0RnakIrejc4SU5EU1B4SnJPcWVOUEVNaTdHaDBBRy9sU1Rna3Bjc3NWcUZPQ3BSeGNBakl5M0lKKzNycEhpYjlpVDlsMkR4UjhEZmhqNFA4STZicGVvUVdsOXEvaUMwVHhCcVdtUnpQNWNWeGJKY0t1bjJ1WldTTWlPMUozVEp0ZjFuYzJqaCtWM2IrNC9STDluL3dENEtMK0ovSFA3TGVqK012R21nK0ROTTFnMllrMW5WN1BXSGg4T3hTaFJ2ZHBMcU9IeUNXRGJvaTdyR1Jqelg2ajh3LzhBZ3BWKzNaOEl2Mmp2aVNMcjRsL0Z6V1BqTlkrSGJpV2JRZkNIZ1BUUEswalJXazJxVDlzWXcyOGpsUWlHWjMxQW41d0VqVStXUEFmaDMvd1RXL2JBL3dDQ25maXJUL0VuakszOGZlSkxGZ3N0cnJQamJVWmJQVGJhSnY4QW4yRnhqOTJPd3M0WFVZNFhwWDZDZnN6ZjhHd25oSHcxSFozZnhTOFpYbmlDYU5mbjBqdzVEOWlzd1J4ZzNNb01zaWtkZHNVTFpQQjduS1ZXMmkxTmxHQzFzZm03NGovNEsxL0VPS3dpOEgvQkg0ZCtEL2hQbytRTFh5ckdIV3RYdVpEd01iNGtzMGtZNEFOdlpSdUdKK1ltdWwrRzMvQkViOXIzL2dvaDRuWHhOOFJCNG10Zk9SZksxejRrNnRORktGSnp0amdrOHk3VlFPUUZoVk1Zd3c0RmYwQy9zNGZzT2ZDMzlsQ3dTSDRkK0F2RHZoV1JVMk5lMnRyNW1vU3JqR0pMdVF2Y09NY1lhUWdkZ0s5WXR0RFZlMVI3U1ZySXprNDN1OVQ4ci8yUmYrRFhYNFUvQm1hTFVmSG5panhONCsxYmJ0bHRyQ1J0RDB4MVBXTnhFN1hNZzY4aWVNSFBLQ3YwSStBbjdLZmdIOW1id3cyamZEM3dYNGI4RmFiSUFKb3RJc0k3WnJySFF6U0FiNW0vMnBHWnZldlZZZE1WVDAvU3JNVmx0UDhBaFUyNnN6ZFJkREZ0ZENXTmZ1OUt2UTZhb0ZhQzJ3VWYvV3FRUlpGWEZHZk95cEhaN08xU3JhLzV6Vm5ibi84QVZUZ25IcCtGVWtUZGtDd1lOU0xIZ1ZJSXMrdjhxY0lmOG5tbllDSUp0NkRyVC9MK3RTQ01jZjV6VGxqOXNmaFFCRXNYc1RUMWp5Ty81MUlFL0g4S2RpZ0NKWWMvL1hweXhZcCswLzVGT0VlUGVnQ014KzVwUXZwVWdYYWFXZ0NOWXNVcXBrL01LZlJRQTBSZ0dnSnRIRkt4K1UvU2szYzBBQkdlL3dDdE5wVEpTTWNkdnlvQWE1eXRNYnBUODRIZW8zUFhtZ0JwT1RUUzNILzE2Y2FhL3dCM3ZRQTJpaWcwQVJrNU5Na2JQOWFlT2FpYmdtaGdNZHNHcTh6Y2Y0Vk5NMjM4NnAzTGJSNlZNZ0t0M0pqUDQxbTNVdlBXclY1Tm44cXk3cTR3M3JVTTJpcnNHR2FyM3RzMXd5eEo5NXlFWDZrMEc3MnIxK3ZGV3ZDNC90TFdHa3h1VzJYUDFZOEFmek5aN3V4bzVXVnpyL0QxaXRwYnFxQTdZMUNLZllWUzhZL0RuUS9pQ0dPc2FYYTNzelJlUjU1QlM0V1BPZGdsVWh3dWVkb09NODR6V3hidytSQXEvd0Fxa3h5UHJpdlJqb3REaXZxZm0zKzBEL3dhMS9zeC9GdU80dU5DMFBXdkNtcFhwWnBibTAxcTQzS3pGbU1pQ1R6SWdRV3lWTVJEYlZHVjVKL0wvd0Q0S0RmOEd0ZnhYL1pqMHpVUEVudzExQi9pTjRadDUxQ2FkSkNJZFhnallnYnR5WmdrUk04dXhoWTR5SWhuRmYwek1PT240VUZtalliZHk0NkVWWE5mY1IvRDk4VVBnQjQ2K0NHcEd6OFplRGZFL2hhNFhaOG1xNmJOYTd0MjRMZ3VvQnp0YkdEeVZiME9PVUE0NEgwNXIrMmo0NS9zcmVBZjJrUEIrczZENHc4TzJlcWFiNGh0aGFhbEdNeC9ibzFZT2l6QmZsbDJNQVU4d05zT2R1TW5QNWYvQUxhbi9CcGI0QitLZXA2bHEvd2w4UXdlQ2JtNGlKdHRMdUlIK3kyOGlvcXFvWUZnNnNRUzJWUmd4SjNrSGFyNVU5bU0vbmRVOGUvZW5JMjcvd0RWWDJGKzFaL3dRaC9hWS9aUjEzN1BmL0RYeEY0bzA1MllSYWo0Y3NaZFRnZmFubVlKaFZzSGFEOVNwSDNzQS9KR3M2RmUrSE5UbXN0UXRMbXh2TFp6SExCY1JHT1NOaDFCVmdDS1VvdGJpS3lTWU5lZ2ZzOGZ0VS9FajlrdnhyL3drSHd5OGMrS1BBdXNQdDg2NDBYVUpMVVhTcWNoSmtVN0prei9BQVNLeW5KNHJ6NHJ6LzhBV3E3NGE4TTZoNDE4UzZkb3VsMjhsMXFtc1hVVmpad0tmbW1tbGNSeHFQY3N3SDQxTjdhc2F2ZlEvWmo5aXIvZzhBOGFlRHJTMjBuNDhmRCt4OGNRcThjWjhSZUdIVFN0U2pqNk84dG93TnZPL2NDTnJaZUNNY2dqOVh2Mk8vOEFnb3QremIvd1VFZ3RwdmhqNDgwai9oSVBPYy8yRE5jdm9ldW8rZHpFMlJaSG1EZFM4WWtRNXdXeUNCK0Z2N1pYN0Mzd2VzL0RzZmpMUTdlNHNmQVB3cThFNjU0ZjF5OTBhT0t4azFyeEZwVjFEcDlxWm5LdXBtdUxxNlFzK3dtUklTYzVKSStidEkvNEpxZVA1TkZ1dnNldWVDYnZ4L29XaEo0cnZQQXR2cU1vOFM2Zlk3Rm1FbmxtTVJHNFdOMGtOdWtwblVPdnliaUZQbTRYT2NMWGh6MzVmWCt2UnZ0ZGR6MEsyWDFxY3VWcS9wOHYrRytUUDY5NVlMeXlCWHpQdEhsbHN4VExoKytBRHhqMDVCcU93MVJyK1NSSkxlNnM1b1d3eXlKbFdCemhsY1pWZ2NaNE9SM0E0RmZ5N2ZzdmY4RnNQMnYvQVBnbmo0YThOUVhXdGE1clhnZStzNHJqUnRLK0lHbFQzdW4zdHE2aG9tdExxVHk3anl0bU5naG44c0QrSHRYNmNmc2Yvd0RCMlg4SHZpc3R2cHZ4ZzhLNjU4SzlXWWhIMVBUeTJ2YUkzQStkdkxRWFVJSjZLSVpRb3htUThtdlVVYnE4ZFRpY1dqOVhSa2U5T2pZcDh5L0szdFhEZkFQOXBmNGMvdFVlR1cxajRaK092Q2ZqelQ0MVZwcE5DMU9LOGUweU1nVFJveGVGc0g3c2lxdzdpdTRVMUpHcVBscjlwTC9naXQreTMrMWUrc1RlTHZnejRUaDFqV3BtdXJqV3RFamJSOVNlZGg4MDVsdGltOXllVDVpdXJOa3NyRW5QNWEvdG1mOEFCbmxybWc2VlBxMzdQL3hLaDhVR0ZtLzRwM3hlSTdPN2RSbkN4WDBROGw1T2dJbGpnWE9UdUgzYS9lL3JWUzcwYTN2ZnZDUmZuM255cG5pM25qN3dVamNPQmtOa0h1S0JuOFkzN1dIN0FYeG0vWWIxdHJINHJmRHJ4RjROVTNIMlNLK3VJVm4weTZtMmVZWTRiMkZudHBtQzhsWTVHSXdRUUNDQjVDVUliNzJhL3NyK0t2N05sNzRndEZoODIzOFlhREFaRW4wTHhmYnByVVZ5UzRJS0xjUnVHSGx0S2dpUm9oZ29DMkF3UHd4KzA1L3dSVS9aVC9hUGhrbTFENGZ2OEUvRkdxcGNMcDExNFl1UnBkdGRTeEg3cTI1RDJMNEJCSWlqUlF1NHROOHBLMXkzMks1TDdIODNtQitsT0p5Zy9wWDI3KzNKL3dBRUl2aXAreUw0eW10TkJ2dE4rSkdsdkJKZTJZc3dOUDFxNHRrTVlhUmRQbGNtNXcwcUtUWVNYYUtXVU15c1F0ZkdYaXp3aHEzZ1R4SmNhUHJ1bDZub21yMm0zejdMVUxXUzF1WU55aGwzUnlBTXVWWlNNamtFSG9hVm1pWEZvb0oxK25wV3Y0SjhhYXg4T2ZFdHJybmgzV05VOFA2NVlQNWxycU9tM2NscGVXemYza2xqS3VwSHFDS3gxNFphbWpHRi9IMDYwSWsvVEw5aWIvZzZYL2FJL1pwYTMwejRnU2FkOGJ2RFVSVlN1dk9iWFc0a0F3UkhxRVNrdVQxTFhNYzU5eFg2L2ZzV2Y4SEZYN01mN1pJdGJDVHhiSjhML0ZWd3dqR2plTkFsZ2tqOGY2cTlETmFPQ1RoUTBrY2pFZjZzVi9Lckd2RzcwUEEyOEVkLzZmblhYZkJ2NFg2eDhiZmlwNFo4RitIYmY3VHIzakRWYmJSTk9pd1NIdUxtVllZd2Y5bmM0eWV3eWF1TWJsY3kzWi9iQkJjeDNrS1N4U1J5eFNLSFIwYmNycWVRUVJ3UWZVVTZ1WitDdndnMGY5bno0T2VFL0FQaDFQTDBMd1RvMXBvVmdDTU0wTnRDc0tNM3F6Qk56SHVXSjcxMDFjTXZpZGh4MnV3b3pSUlVqRGRSVFdPM3R6VHFBQkQ4emZoVW5RMUhHZm1iOEtrcW83RE42WDd1YWJUbjZVeGpoYUpiaUZKd0thSHlmL3JVMG5QV2pOU0JKbi9PS2pZNWIrZEE2ZldqdFFBMTJBUDRWRzQ0L0ExSkllS2EzSzBBVjVVNS9XcTU0UDRWYWtXb0pSUWFGYVJmNTFXbFhCNmU5WEpPRG1xMHlZT2F6QS9HUC9nOEcvWlhYeFI4QnZoajhaTEszQnV2Q3VwdjRWMVdSVitaclc3RFQyeEo2aFk1bzV4Mkdia2Rjakg4K3NzZTAvMHIreG4vQUlLdWZzcFhmN2JmL0JQSDRxL0RYUzdlUzUxelhOS1c2MGFLTVIrWkxmMmx4RmVXOGFHUmtRTkpKQUlzczZMaVU1WURKcitjNzRKLzhFUnZHWHgxK05DZUViSHhCbzdhazFtMnB0WnZjMjlsZFEycUNNelR5L2FKVkN4b1h3WGhFNitoYXRxZGFNVnl5Q05DZFJ2a1I4THhqK2RkVDRGK0ZuaUw0akdUK3c5RnY5U2hoeDVzOGNSRUVBSndDOHB3aWpQR1dJcjlLNS8yS3YyTC93Qmc5SkcrS3Z4c3NQaUQ0a3N3enllSGZobFpEeFBlcXc3TnFFNmpUNGlPZHlOR2pna1lPQVRSZi84QUJValdOSThKVGFyK3kvOEFzbXhhTG90aEk4TWZqcnhUcGQzNHgxSzFLNHpORzJ3V2RtdzdwKzhqSEl3TWNhZTBiMk5QcThJL0cvdS9yOUR3bjltZi9naHg4WlBqL3BhNnUya1hGaG9TeG1hNHZ3aXBhMjBZL3dDV2ozVTdSVzJ3ZFcyU09RTzJlSzlBYjltYjlqdjlqaGtmNG1mRjIxK0luaUsxSDczUXZoMUVmRTBwYmpIK25TK1JwcVlJSVpXRXBBUEdTTW5pditGWmZ0aGY4RmdmRkgvRXd1UGloOFdWaGxIbVJGaW1pYWZOeU1CQjVWaGFrQmdlZGc3NXhuSDJqK3lqL3dBR2kvaXJXRnRkUStMdmpyUi9DdHVWRy9TZENqL3RYVUFPNk5NU2x2RTJNZ01oblVaNkhGUnpMcTJ6UldqOE1VdlhWbnliNGovNExCMmZnK3doMHY0RGZBN3daNEJ0N1BjMXZydmlranhWcTBUWndKcmVLZFZzYlp1Y2xFdDNHVHdjZGYwQy93Q0NER3BmRlg5c1RRZmlsNGkrTlY5NDU4YXkzVjVwMHVpYW5yTU16YVc4ZTI3V2FHeTNLdHZHcXQ1VE5IRUZIN3hTUml2dWI5bHIvZ2loK3psK3lZOXZkK0gvQUlkYWJydXVXcExMclBpYmJxMTRYM0Z2TUN1cTI4YmduQWFLRkNGQ2pPRkFIMVZIcFJaVlZ1UkdvUmNuN29IQUE5QUIycktYTkxSYUlGWGExYnVlTWVFUDJhdE0wRnkwZGxhMjZzTUZOdTVzY2NkbEhUL2FIRmQxWS9ETFRZdkxFbG5CY2VTNnVubklKTnJxUVZZQWpDc0NBUVFCZ2pJNXJ0SXROQ0ROU3JhS282VWNyWms2eGtSYVJ1Y3MyV1p1U1QxTlhJZE1WVnp0cStzUVVlbE9FZVByVnFKbTV0bGVPelZSNzFLc0h0VW9IdFM3T0tmS1FSaVBILzFxY3E0K3RQQ2JoMU5PQTIxVmdJOXBwd1RBK2FuZHFGTkFEVlVicWNxL056VHdNL3pwYUFERkNqZDlLRHpSdU5BRHdBQi85YWxJelROL0h2aWxENEZBRHFLYnZ5S1VOeHpRQTVUbHYvclVDVDIvU21iOG1uYnFBSEJ5YUErV3hVYk1CUnZHUC9yVUFTYitjZjBvTDQvL0FGVkdHQkdQNUNnT29ILzFxQUhGeWUvNFVBWXBoa1B0UnZiMm9BZjBGTlp0di82cVl4Sk5KdUFvQWNUbjZVeC91ODlmcFNtVHRVWkxmcFFBYnN2akg0MDBuZFRuYkgvNjZhT0tBQ21TSEgvNnFjeHhVYkhuUHZRQWpOdFBTbzNweDVOUlNOMzlLU0FpbGZnMVJ1NVA4T2F0M0RjVm5YVDRMVXBibGVabjM4dkg4ODFqYWhjL09mcFduZnlaei9Pc0hVbjJqcjM3MW5KblJUUmw2dnJmMldOdWNZSFBGZm5MKzFSL3djT3QreForMUI0aThPRHdxdmlId2g0WTFTTFM3dWExbUgyMjV1eGJocDBWWEtwdGhrM3huNXM3a0hUbmQ5bWZ0U2ZHK3gvWjQrQi9penh4cVNpV3o4SjZWY2FtWVNjZmFYalFtT0FIKzlKSnNqSHU0citXMzlwYng1ZmVMdkZFWDlvM3NsN3FraGwxTFZKblRhWjcrNmZ6cDVmZmRsT3VNRU54M09tSGhlZDNzaHprbEM3UDZXdjJXUDhBZzRyL0FHYy8ybU5XdGRQazhWYWY0VXZMaFkxTU9xU3pReWVmSklFamlWWGdRTXVNbDVBeFZDVnpsU1hYN3MwTFdMVHhIcGtkOXA5MWIzMWxJU0VudDVCSkd4REZXQVpjaklaV1Vqc1ZJNmcxL0RUUCs4QnpoaDdqclh0bjdKMy9BQVVqK05IN0R2aTIzMWI0YytPTlMwbHJhSkxZMnR5RnZMU1MzV1l6K1I1Y29PMk15TTdGWXl1UzcvM216MmU2emp1bWYyYVkvd0E0b0l6L0FQcXI4QWYyWC84QWc4UThYYVBIYTJQeForRzJoNnhobmVYVTlFdVpMUm55WlNpZVN3Zll2TVM3OHlrQkdPMWl3Mi9xQit4TC93QUZ3UDJldjI1ZE5zNGREOGNhVG9QaWE1OHFOdEIxYTUrejNabGt3QWtRa0NHWERIYmxWQUp4amdnazVld2NuWSt1d2FBYzFCcFdyMnV2YWZGZVdOMWJYMXBQbnlyaTJtV2FLVEJJTzExSlU0SUk0UFVHcDg4VkpBa2theXhOR3lxMGJydFpXR1ZZZHdSM0ZmTXY3VFAvQUFSMS9ady9heTFTNDFUeFo4TGZEYTY1Y1FmWnpxbGhiTGEzR0FEdEpDL0lTdWNqNWNuZ0VrQUFmVGZVVWpLeGtIUHlqcU1kYWFrMXNCK0FuN1pIL0JvNTR1OE4zR3FheDhJL0ZXbitJTFBMUFo2SWJab0xrQTlBV251Q0FvSjIvSzhqWVhjRk83YXY1bGVKZjJSdmo1K3lGNHJtOFQzbmdINGllRDlROENha3BmV1A3R3VZazBpNVJ2a2tNaFRDQW5CVm13R3lNRTEvWmdGK2JwN1ZUOFIrSE5QOFlhYTFscTFqYWFuWnNNR0c2aUVxWStqQTQvQ3FiakxTU0tUdHNmeGw2VisyVDR5dHYyZVArRlp6TnAybytHYmp4VXZpeTdlNFdWcnZVWi9sTFc4c20vRFFPNkxJUnQzYnhuZDJyNkk4ZWZ0dmZDbXcrUDhBOFJ2amo0SmJ4MGZpRjQ4MHU0czlLMERWTk5nanRQQzkxZFd5Mjg5MDk0czcvYVZSQTVpUllVQkxEY3FBWUg3VmZ0bi9BUEJ0Qit6eisxWGZYR3JhRGEzdnd0OFFUSVZFbWgyMEw2Y1NmNG10Y0lTMmU0bFVjbmptdnpSL2FrLzROUWZqMThHWXByLzRkNnA0YStLV2x3cm55TGVjNmZxakVjY1F5Z1JuZG5PQklkdlRMZFR4Vk1ydzAzZGFYdmUybDcydW42MlcycDFVOFpWanU3N1d2MHRlMXZTN1BudXgvYUQ4WC9zWC93REJQNzRZNk5wMm9MY2FuOFNkVXZmRmMybmExWnhheFlSYUpCbXp0YlpyTzZXU0x5cmlWWnB1RUJieTFJT1JXeisxaCt5SDRGK0Fud3Y4UDZQZWZEdnhkY2VMUDdLczlMbjhWZUhmRXRyYzI5MTRydUlIbU9uWG1udVhNS2hpb0JqOHBtUmNxamZlUHk5NDMrRlhqcjltZjRqMnRyNG04TTYxNFQ4UTZIZHBQRmJheHByUm1LV09UZXVZNWsydXUvQndRVllNTWdodWZTNzM5cS93ZjhadmpsNGM4VmZGajRXNkRxTW45cHlYWGl5LzhOWE41cGwvNGloa2pLaDJRWEhsQ2VPVStmdWpNWG10R3FFb0daampMQVZLZFJUcDdOeWxLMmpiK3l0MWRKYWJ2V3pzZEVjUkNVR3BkRWtyNnJ6ZXo2NjlOT3BzL0VUOWdiNG8vc3NhUDRpOGNhTDRxMEM5MVA0WDNObkI0cms4STZ6Y1E2dDRLdUxrcUxjVGxvNFh3N050V1MzTWlsbGZuQ3N3OXMvWlAvNE9XLzJvdjJhRXRiUFd2RTJuL0Z2dy9iNFEyWGpLMiswWGdYT1R0djRpbDBYSTZOTTh3SEh5OXE4aC9iai9BR2wvQW54cytFZmhyVDdmV05RK0pYeEcwM1Uya244ZWFub0g5ajZwTHBLeE9rTmpla1N0OXV1TjdLeHVXR1FzUXd4THlGdmx0bDNibUFiYXBBd1QxNzQvejcxMjVmVXJWS1BOaVBpdjJ0L1hsb25idnU4Y1ZHRUo4dFBiMXVmMGMvc2pmOEhXL3dBQS9qYTFycC94TTBmeEw4RzlZbU8xcm00VTYxb2VUd1A5SnQwRTZaUFh6TFpVWHUvZXYwZitFL3hmOEkvSHJ3WEY0ajhDK0tQRHZqTHcvTWNMcVdoNmpEcUZybnJ0TWtUTUZibmxUZ2p1Qlg4VXJKOU9CMXJwdmcvOGJQR1g3UG5qT1B4SjRCOFdlSlBCT3Z4REExSFJOU2xzTGhoL2RaNDJVc3A3cTJRZTROZExwcm9jdW5VL3RNMUs5K3diQTFyZFR3eUVoMmhqOHpaNlpVSGVjNS9oVTR3U2NWemVqUnRxbXEzMTE0YjhSYVhmMk1hdlpYMm52SEhjTEZkTHdDMDBaRXFNT0ZkSmZNeXFydEVaQkxmejYvc2xmOEhYbngrK0NxMnVuL0U3UnZESHhpMFdMQ3lYRndnMFhXd3Z0YzI2R0JzRGsrWmJNemQzcjlRdjJTZitEaW45bFg5cnZVTE9EVVBFOG53dDhXU29zUzJmamVCTEJEem5iSHFDTTlxVjNIZ1NTeHMzOXpxQkhLMEZqNlUrTzM3S2RwOGJmQzExSHBlczY1OFBkZVlZaXZ0TG0vY2gxSUtPMEN1RWRRM0kybU5qa2hqZ2tINXQrTm4vQUFUbThPK08vZ1ZkYVQ4Yk5LOEcvRWhOSXRsV1hXTHpTVWhrMG1JcWl1TGU5YVNHYUVBa3ljWEhtdXhPT0dWRisydFJ1TlMxN1N0TjFMd3pxbWh6V04wUE9FMDBUWGx2ZlFrZktZWllwVkFIT2R3M2dqSEhyNUQrMkw4TmZEUGovd0FJV3NYaWJ4bjRuK0U5NVB1c3JieExvT3B5MnNOcUpSdGtpa25aQkJGdndBc2tnamtCeDVicTJhY1pQWmx3YmJzejhaLzJ1UDhBZzI2MEs1aTFhKytIQytKdkJ0MWIybjIrMXRXTjk0bzB1U0FLR0wzRnVsa210NmMreFhieVRhWHU1OElKUVRnZkNYeHAvd0NDUTN4KytCUGhiL2hJcC9BZHo0dThIU2IydHZFbmcrNWoxL1RiaEZjS1dKdHkwc0pCSzVTZU9PUmM0WkZPUVA2UWYyUnYyRkw3OW0vNGRhWG9Hai9FKzQrTm53NjBWMmp0TExYNElkUTFQU3crVHRzOVJXNFJiWVJrb1ZUWndnWURERlNPMDhTL0JUNGYrTi9pYkRyTHphaG8vakhURk1VbCtMdTVqdnBraitRZmE1ZDdOY1JwakNOZG1SRkorVEFKQnJTK2duRmREK1AxTGZFenhsV1Y0M0tPckQ1a1lkUVFlaEhwMXI5TWYrRFdMOWs0ZkhYL0FJS1RwNDJ2clh6dEYrRHVqemE0V0s3bzIxQ2ZOcFpLZmNiNTUxUFpyVUh0WDZIL0FQQlZEOWhid2o0Ni9zdld2aUo4SmZEL0FJN3RiNjRnMHBQRjhQaUdYUzljRUx1cW9xWHNXODNGd21TeXBkV29nQytZQkp3RWYzYi9BSUliZnNLK0RmMk1QMlZ0VTFEd3JhK0s0WCtKbXJOck1wOFNYV24zbW9SMnNJTUZyQjU5Z3oyOHNReE5Na2lFRmhkRXNxSDVGbVVsR0RrUlVwNkpkLzYvNEI5cGY1TkZGQmF2UEdOYzRILzFxYUc2L3B4UVc5S1R2UUE1YzU5cWZUWXo4dE83MEFPakgvMTZkMU5Jb3dLY2g1cTBCdVA5Nm1PRFVqL2VxT1RxS21XNERDMkthcmJmNHMvalNQOEFlb3BBUERicVhyVWZRMC9yL3dEcW9BU1RrZDZiVW1NMDBwbWdDTmw0K2xWNWx4VnAxMmlvM2lCSGFncFNLYkRnaW9aWXlWcTNMRnkxUk11T0tYS1VVMnR2bXp6Nml2enovd0NDaUgvQnZUNEsvYS8rSUdxK09QQS9pQ1A0ZCtLOWJNaytxV00ybmZiTkYxYTRaaTdUR05XVjdhU1J5V2xaUE1WMll0NVlkbmR2MFdLZjV6UjVZcUhCUGNJemExaXo4bC8yRi84QWcyRzBINFIvRmY4QTRTTDQwM25ndng3cGVuMnkvd0JuYURwVWQwdG0xMkdVaWE0THJFWGpWUTJJT1VabUJmSVhhMzZvYUw0TXNmRDFsYTJ0bEN0cmFXTWF3MnR0YnFJSUxaRkFDb2tjZTFWVUFZQ2dZQTZBVnJtTFBwK1ZPRU9CN2RhcU5PTVNwVkpQY3EyZW53MkZqSGEyOE1kdmJRWjh1R0pBa2NlVGs3VkFBSFBQQXFWYlpSN1ZZRUlINDBvaTU2ZnpyVFF6MUt5d0RyMHFSWVQyL2xVM2w1SDlLVUppcUVRQ0huLzYxSGw0T01jMU41ZVRSdDVvSFloRWYvNnFjRjIvdzR6eFQyT0tSdjVITkJJM2FjaWwySC9JcGVjVW1lZi9BSzFLK29DRVkvaW9WY25tZzQvV2d0engxK2xGd0hDbTQzTWVQMG81eG5qcDZVQTgwcjZBU0JoaWdObW9sR1JTNFBOVUEvTzd2K1ZMdTRxUE5CWEFvQWZ2SHFLWFBGUmovUHZSME5BRDl3L3ZmclJ1eU92NjFGVHNab0FkdXlNMDdkeDk3OWFqN1VZb0Fmdkg5NzlhTjQ5UlRLVHZRQklXR0tRdnh4K1dLYlNHZ0IvbWUxQmtKcG9PYU0wQUJKTkZHZjhBT0tZN0UwQUxqZy93ME0rZW44NmFUbWlnQW9vb3pRQTEyeFViSGowcDc5Zi9BSzFNazRINDBwWDZBUjUvNERVVWg0L1UrMVBibjZkS3IzVWFUYmQ2aHZMYmN2c1JrWi9uUzJBanVHeldiY3ZubXJsMUlQOEFDcys2ZjBxVFRjb1hnM2J1L0hlc2pVN1RmR2VQY2NWdVBIdk5RWHNJU0EvVG1zYm1zV3RqOHRQK0RpTDQ1UStEdmdaNGErSFl1UEtieHBmdnF1cW9yQU1OTTA3Yk93SS8ycmcyN0RzZnM3aXY1Ky9GT3RUZUl0ZXZMNjQvMTE1Szh6Z0VrQXNTU0I3RE9CWDlrM3gzL1l0K0hYN1pId1B1dkF2eE04TlcvaURROVMvZnQrOGUydkxLUWtFU1c5eEdWbGhmQ3FEc1lCMUJSd3lNeW44aS93QnRQL2d6eTFLeWVUVlAyZmZpUkRxVUpMTWZEM2pjL1o3aFIyRVY5YngrWEllMjJXR0lESE1qWjQ3c091V0poV3FYc2o4UEJoWk10dTJxY25GVm1rNXowL2xYdi83WFgvQk1qNCsvc01DUnZpbDhMZkZIaG5UVklCMWRZVnZ0SGNrZ0tCZTI3U1crNDVBMm1RTnlNZ1Y4L09Bd0cwOFZvWWlGK1A2MCtHY282c0daWGpPNVdCNUI3RWR3YWhkdHRBT1JRQjlSL3NtZjhGZy8yaVAyTk5Uc204SWZFenhGTnBWbkw1aDBiVjd1VyswNmJKeVZhTjJ5Rko1d3JMeVNlcE9mMDcvWTUvNFBCR2p0Tk4wcjQ0ZkR1U2VYYkhIZGVJUERjNkRjd3lIbE5veWdET0Z3cXZnRXNjZ1lVZmhMSEpodjVWSXMvVHIvQUlWWE0rcFhPK3VwL1pYK3k1L3dVMStCbjdaVmpwc25nSDRrZUh0VXZOVXQ0NTAweVc1VzN2NFdjRWlHU0ppQ3N3MnVDbkorUnNaQXpYdkpiYi9PdjRaOU0xZTQwbS9odXJXYWUxdXJkaEpGUEE1amxpWUVFRldVZ2dnZ2NnOXErOVAyU3Y4QWc1SS9hZy9aZ3RORjB1OThZLzhBQ3hQREdqeVNPZFA4U1JKY1hWMEdEa0k5OFZOeVZWMkRZTEU0RzBFREdEM1hzR2pQNnBzMGpmNXpYNWpmc1QvOEhVdjdQdjdSMDJuNk44UkYxTDRQZUpyb3dRZWJxaUc1MFdhWjR4dkszVWVUREdKZHlocDFRYlNqTXd5d1g5R3ZodjhBRlB3ejhaUERLNjE0UjhSYUg0bzBrdjVadk5Ldm9yeUZXMmh0cGVOaUEyQ0RnODRJUFEwT0xRY3AwRkhlaWpHS2tMSEIvdEEvc3dmRHY5cXJ3bC9ZZnhHOEc2RDR3MDBjb21vVys2VzM5NHBsSWtqUHFVWVpIQnlPSy9NcjlyZi9BSU5LL2huOFE3Uzd2dmhINDIxcndOcXpGcFlySFdZeHFHbnV4M0hadlFKSkdtU29CMnV5Z1pPL2dWK3Q2NUlweEdhcU0ydGhYUDVRZjJuZitDRS83VW43S1ZpbDlybnd1MW54Qm82eEpKTHFIaFQvQUluME5zV0RuYkt0dUdrajJoRHVaazJBc2cza3NvUHlDaXJKRUhSa2ZuYWNNR3dmZkZmMitLK3dxeWxsSTVCSGF2blg5cjcvQUlKUC9zOS90MXpKZWZFYjRhYU5xR3VReE5EQnJlblN6YVRxY1FKTGN6Mnp4bVhERWtDYmVvSlBISnpvcXZkRHVmeUZ6akc3Qy9kd0NSMi96L1dnL013WHAyUFBXdjJtL2JLLzRORDlkc3I2YlV2Z0w4Uk5MMWF6a2xaditFZjhaaHJLNXRZejkxWXIyRkhTY2pwaVNLSGdaM0U4SDh1LzJxLzJBUGpGK3hENGdsc2ZpbjhQUEVuaE1LeUtsL05COW8wdWN1TnkrWGV4YjdkODRQeXJJV0JEQWdGU0JVWkp2UW84YkNNVzZISFhqbWlLQm1YSFVObmlwVWdia3NXNkVaQngzNEZTeEZXZ3h0QWI3dzc4SC9QdFdpUUhwMzdMMzdjdnhpL1lzMXBiejRXZkVqeFg0SjNTQ1dXenNid3RwdDIzL1RhemszVzB2ZjhBMWtiWXI5VlAyTC8rRHZMVlBEbW54NlQrMEI4UDIxeVNNYlI0ajhGK1hiWEVxNEEvZldFenJFekhrbDRwbzF3Y2VWM3I4WFZzaXpMam5HU2N0ai9QL3dCZW0zRnA1VHJ4eXd5dVQxN1p4VXlwcDdoNm45VjM3RVA3WWY3SGY3YW5qMWRWK0Qrc2VEOU0rSWwvWS9aNXRManN6NGM4UW1JNWRvbGh4R1p0cDNGbXRqSW9KSkxFTmsvVlYvNEl0WnA1SkpvVnZMZ3hpSE53MjA3Unh5UU01STRKSUp4eDByK0thTXRGTEhKRXhTU0dRU3hzcHcwVEtjcVZJNUJCd1FSN1Y5dS9zZmY4SEJIN1VYN0pFVnRaSjQ4YjRpZUhZUUYvc2p4dXI2dXFxTURFZHlXVzdqd01BS0p0Z0hPdzFEcHZveDdzL2ZUNDhmQUpmaWpxTU9nNmQ4U3ZpeDhIOWV2N2dQWVN4MmNOL1kzY28rWUo1enh2RmNSOEFmWmJtVW9RUDlUbmF3K205RzB1TFE5SXM3R0gvVTJVQ1FKaFF2Q0tGSEM4RHAwQUE5T0srSnYrQ1BIL0FBV1dpLzRLdHQ0czA2ZjRhNmo0SzFqd1BiMjkzZTNNT29wcU9sVExQSTZRb3NoV09XT1p2TGxZSVVaZHNibnpPaW43aXJreEYwK1ZoS1YzNkJUR2JqMFAxcDdIaW84NUpybkVGSGY4YUNhUDhhQUhnWXBWL3JRT0JUazZmalFBNGRLY3E4ZlEwMm5qZ2Y4QTFxMEEyV09XL0NteUhrVTV6ODFOa3FKYmdRbjd4b0J6VHBCelREd2FRQy80MDVhYlRsT1JRQTVRR1A4QW5tbmVYUkdPS2NUUUJHUVFhYXlmbjlhbXpUWEdCVHN3Szdwbi93RFhVYnAvbk5XR1hKL1Q2VTBpa1ZjcG1QaWhZUlZqWi9uRkJqM0h2K1ZCVnlGVTIrdE9FZU8yS2s4b21sS0hkL1dnbHk3RVpqL0dnUjgxSXlZWDhLWlRRcnNZQmlnVXJuQi9DbTlEVDV1d2dOTUp5YWU0NHBySEZMbUFUT0RTYnMwWXlhQjhncEFOVE9QV25BWS8vWFRWT1IvZ2FDZVAvcjFWZ0FoZDFKalAwb3hnVW9PUlJaQU42SC9QTktWeUtXaXFBUWMwdlNpaWdBNzBZb0pvb0FDY1VDa3hrVWluSEhXZ0FIM2V2NjBEanY4QXJTL25TRTRvQVhkbjAvT2t4bitMOWFYODZDY2V0QUJ1eDZmblJ1K241MGlnajFvd2QzZWdBem4vQVBYUWVuLzE2Ti92L0ttNVBOQURrNEgvQU5lZ25BLyt2VFZPRDNvL0hkUUFNMmFLT2xGQUJSUlJRQVVqTmdVdE5rT0ZvQVl4NjB3bm1udHdwK2xST2RwcUwzQVlXNzFXbWJhUHc1cVoycXBjdjhudjlhY2h4M0sxMUxrdDI3Vm5YTTI0bm5PYXMza21EL25tc205dU1ILzYxWnlMaXJzbTg4Yi9BTktJb3hxVjlEQVA0MitiMlhxZjByRnV0VUVJem5iV0w0RC9BR2hmQnAvYUFqK0hWejRoMHkxOGRhaHBTNnBwMmtUeWlPZS90MmxralpvUWNlWXdhRnlVWExCVlpzYlFUVTJ1elMxbG9lMFdLYlVadW00NEgwcWNuUDRDa1ZQS0czQkczakJweDVGZDYwVmpqSEl6SkRJbnplWElwV1JjL0s0UFVFZHg3R3ZpSDlzVC9nM2kvWlYvYkl1cnpVcjc0ZnA0QjhTM2tlMDZ4NEptWFIyM2JpMjlyVlZhemtZa25jelFiMkI1YklCSDI0eDNDak9Sai9JcGdmemNmdHRmOEdrWHh4K0NIMmpWdmcvcm1rL0dqUTFMUDloQVRSdGVnWDVqL3FKcERETmdBRDkxTjVqazhSRHBYNWJmRUw0YWVJdmhMNHp2dkR2aXpRZFo4TStJTkxrTVY1cG1yV1VsbmVXcmpxcnhTQlhVL1VWL2NsZ0FmL1dyeS84QWFrL1l3K0UvN2JQaE5kRStLL3cvOE0rT3JLR0pvYmFUVXJYL0FFM1QxYkc3N05kSnRudHljREpoa1FuQXptZ0QrS01KdG9KL0xyWDc0ZnR2L3dEQm5ocEd2WE0rci9zOC9FUCt3NUpaQVQ0YThhbDU3U01Gdm04bS9nUnBWQ2pHMk9XQ1FuSE1vcjhrZjIwUCtDWFh4Mi9ZQjFPNmorS0h3NTE3UmRKdDV4YnhlSUlJRGVhSGRzZnUrWGV4Z3haYmpDTXl2MktnZ2dBSHo3djJtaEpjZDZjMFdSL1hGUjVvQWs4L2JYcVg3TlA3YW54Vy9ZODhTUjZyOE1maUI0bjhGM1Vaa0pUVDd3aTFtM3FGYnpMZHN3eVoycjk5RzVSRDFVRWVVWTlxWE9QODlhQnAyUDNBL1kzL0FPRHczWDlQMVhUOUwrTzN3N3NOVTAwdjVkenIvaFA5eGVvaDZTUGFTTjVVakE5Ukc4UUlQQzVHRCt0SDdJUC9BQVZUK0FQN2N1aDZaY2ZENzRtZUdyelZkVUFWTkF2N3BkUDF1R1VrQXhOYVRGWkdZTXdBTVlkRzZxekRtdjQya2s0clIwUFc1dEJ2clcrMCs1bXNkV3NMbU81dEx1Q1pvWjdhUkR1VjQzVWdveXNGWU1Ea0VER09jMXpYM0hmdWYzTVo1cHBHOWUzV3Y1YXYyTC8rRG1qOXB6OWsxbnNQRVd2eC9HTFFmSktKWitNcEpMaTd0bndOc2lYeWtYQnhqN3NqdXBCSndHTzZ2MWMvWXcvNE9yUDJkZjJpWGowMzRoZjJ2OEdOZWtrV0tOdFhWcjdTYm5JNmk3Z1ErVnlEbnpvMFVaSHpubkNzSEwyUDA1VmRwcDI2c1h3RDhSUEQvd0FVOUJHcmVHZGUwZnhKcGJZQXU5TXZZN3VFWjVBTFJrZ1pIT0QycllMODB0aFc3ZzJHcUhVYlNIVnRKdXRQdW9ZYnpUNzZGN2U2dHJpTVN3WE1UamE2U0l3S3VyS1NDcEJCQklJcVRnOVBsL3BRRHRvR3o0Vy9hMS80TnpQMlhQMnBoZVh0bDRQbStGdmlPNkFLNmw0S21YVDRGY2RDMWd5dlprSCtMWkVqTVA0d2VSK1kzN1ZuL0JwdjhiUGhUdjFENFcrSlBEUHhhMDhGMmF6YlpvT3JJT3dFYzhqVzhtVjZrVHFjOEJPYS9vaUQ4VUdxVTJndWZ4cWZHYjltZjRoZnMxZUlJdEo4ZitDZkZ2Z25WSk0rUkJyZWx6V0xUYmNITVprVUNSUU82RmdQV3VFdTdJK1Vwenl1RHRIY1k1NDlqK1hIWHJYOXBmeEYrR25odjR3K0VwdEE4WGVIZEI4V2FEY0VOTHB1dGFmRmYya2hIUW1LVldYSTdIR1IycjRHL2FaLzROaXYyYmZqZk5xVi93Q0U0ZkVud20xaThqUGxyb04wdHhwTVV1MEJXTm5PR3dvd01wRExFRHpqQk9hM1ZkUGNwU1RQNW9CR3dkZDJGenhrL3dBUHIwN2NrVmR0bGNPT2gyOVJuMDljajJyOUp2MnV2K0RXL3dEYUErQmNkOXFuZ1diUmZqQm90c1EyelRSOWcxZGwvdkN6a2NoOGNBaU9Wbkp6aENCdVB4bjRML1l5K0lHdC90UitHUGcvclhodnhENFQ4WmVMTmV0TkNqc3RXMDZXMHViZDdpNFNEejlzaXFUR29jdnZHVjJvV3pqSkdzWkxvRGRsZG43L0FQOEF3YkwvQUxMbi9DZy8rQ2FXbmVLcnkyV0hXdmk3cVV2aUtVbGNTQ3lqSnRySlNlNEtSeXpqMnVxL1Eyc2o0ZmVBZEorRkhnRFFmQ3VnMjR0ZEI4TDZiYmFQcHNJLzVaVzF2RXNNUy9naUxXcXpaSGV2SXExT2Fia1RUVFVkUnJrSDYwMG5CcDJlS2pEbkE2bW9LSGtjNW9Ub00vU21BZStha1ZjbjZVQVNBWS9uVGxIQXBxL2VxUWNDcWlBRHRVbUtZZ3lhZlZBYkJPVFRIUE5QeHpUSCs5K2Zlc3dJaWN0UVJtbk9jZ2ZyVGVvb0FLZEczT0thQmlsVTRQdFFBL0pGT0F6OWFiVGxQeUQ4S0VBNmlpZzhpdEFJNUJodnJUV1VFMUpqaW03Y0dwYXVBd3J6U2YwcVRGSnQ1bzVRR2RUUlR1bi9BT3VtTHdLbllCVDBxTWo1cWtKd0toWTBBTlpnNXByOUtjZWxOKzcyeCtOQURRYzAxamluTzJSeFRjZ2ZUNjBBTlppUGxwQU0wcE9SL0ttOWFyMEFBZUtkbm1rcEIxL25ScUF2ZWxIU2s3VXRFUUNpZ0hJb0p4VkFGR2NIL3dDdFNCdnBRVG52UUF0RkpuUC9BT3VrenovOWVnQS96MG9DOC84QTFxTithQ2NmL3JvQU1jZi9BRnFDdWY4QTlWRy8vUE5OMmpyK1BXZ0J6SGFQL3JVMEtUMS9sUVFPdEFGQUFEdFA4dUtjV3dlbjZVMGNVQWJxQURqSEZGR2MwVUFGRkZGQUJSUlJRQVVVVVpvQURVWk80MDVteC84QXJxTThVbUFTZFJVTXB4OUtrSnkxUXlObXBRRVV6WTVxbGROeWZ5cTFQSldmY3Q4djRHa05GRzlmQkk5NnhkU2ZINlZyWFozRGJXWGQyKytNZ1pxWkdzSFk1WFhicDhiVjVaL2xVQ3Y1c1A4QWdyVCsxbEo4Y1AybC9IUGl6VGI2WVcyb2EyZEkwSzRna1pmSzA3VE5zVWNrVEE1WHpaVkUrUnlETS9yWDd1ZjhGUnZqcEwrelgreGQ0ODhSV2M3Vyt0WFZnZEcwVmxiYTQxQzh6YndPdisxRVhhYkg5MkZqMnIrWUQ0KzZwREo0MUdsMnZOcm9jQzJDbFR3ekxrdWNZNCtkbkhjSEFPY1lyVEQvQUJYTGxMbGg1cytyUDJTZitEaXY5cXo5a2RMT3loK0lUZkVUdzdaOGYyUDQyZy90aENvQUFWYm9zdDRpZ2RGU2NLUDd2YXYwMy9aSy93Q0R3UDRWL0VHKzAvU3ZqTjhQL0VIdzF2SjFDVDYzbzAzOXQ2VEcrM0prZUhhbDFGR1QwVkZ1R0dSMUdXSDg4VzNjZnI3MVhtbDN5ZGZhdW81T2J1ZjIxZnM2L3RYZkRIOXJud3IvQUczOEwvSDNoVHg1cDRqV2FWdEgxR080bXRGYnA1OEdmTmdiL1psUkdIY0N2UU85Znc0L0RqNGxlSXZoRjR5cy9FWGhQWHRiOEwrSU5QZmZhNm5wRjlMWTNsczJNWlNXSmxkVGowTmZwUit4Yi93ZGFmdEZmczhDMTB2NGlRNkg4YlBEc2NuN3h0WnpZYTVISHR3RWp2b1J0YjV2bUxYRU03SGtiaDFBR2oyUDZaaFFhK0FmMkwvK0RsTDltSDlyaGJEVDlXOFRUL0NQeFhlQUtkTThZQmJlemFUdUk5UlhOcVY5REswTE5rQUpuaXZ2cTB1NDcreGd1b0pZcmkxdW94TEJQRTRraW1ROGhrWUVobEk2RUVnMEE0dER6eWFoMVhUTFhYTkl2TlB2clcydnRQMUNGcmE2dGJtSlpvTHFKaGhvNUkyQlYwWUVncXdJSU9EVXU0R2d2OUtDVDg0LzJxLytEYTc5bkg0MlRYMnRlRWZCK21mRC9YTG96VFNXME50ZE5wa200YmdpVzl0UEVZTU9NaG90MjBNVkNGY0lQeUcvYXkvNE5tLzJtdmdUckZ6ZmVIL0J0ajQ0OExzaG1pdS9ET29TYWxKSDFQbHRiUERGZUtRT010Q1ZYK0tUdlg5U3dPZi9BSzFSR0lDNDNoUUpNZFIxNy80bXE1dTRIOFRYeDgvWmE4Y2ZzemFoWlErTDlDdXROaDFLTVNXbDRBWkxPNU9QbmpTWURZMGtaTzExQnlwSG9RVDU0UnU5L3dBYS90OStLUHdBOEQvR3UwdW9mR0hoUFFmRWtlb1JDQzhXL3MwbEY5Q09rTS9INzZFZjg4NU55ZjdQRmZKSDdTUC9BQWJrZnNrL3RIK0cvc2YvQUFyai9oQWRRaVhaYjZyNFB2RHB0MWJyeGhUR3drdDVSeDFsaWRnT0ZaUmdBZHVnSDhudTNiOWZyU2cvNXhYN0YvdGpmOEdlM3hRK0h5M09wL0JIeDFvWHhLc1VCZE5GMXNMb2VzZXlKSXpOYVNuL0FHbmtnN2ZMM3I4c3YyalAyVS9pVit5TDQyLzRSNzRuZUJmRkhnWFY4dDVVT3MyRWxzdDBxbkJlR1FqeTVrLzI0MlpUMkpxUU9GRS9IejhqMXowcFZHRzU3MVgyL05rL1dwTjUvcFFCMzN3Qy9hZytJMzdMZmlsTmIrRzNqcnhaNEgxUU1qUE5vdXB5MmduMkVsVmxWU0ZrVEpPVWNNcEJJSUlKcjlPUDJVLytEdkg0MmZET08zc2ZpeDRSOExmRlN5OHhSTHFGcXE2RHFxcG41djhBVW9iWnlCMEhrcG5BeXc1TmZrU3I0UFA4cW1qT2FkeXVabjlhSDdJSC9CZnI5bDM5c1hTNC9zUHhGc2ZBbXUrVkhKY2FMNDBkTkhuaFoyQ2JFbWtiN05NZHhBSGx5c1NHVTRHU0I5bnRFOGFxV1Znc2lobE9PR0I2RUh1UGV2NFpvdm1HMWdHSGNHdm9qOWkvL2dxRjhkUDJCOVJSdmhuOFE5WjBqU0RkUjNGMW9WeXd2ZEl2eW1CdGUya0RJTnlqWVdUWSswQUJodFhEdGNlalA3RCs5SDN2L3JHdnhRL1k3LzRPK3RMMVEyK2wvSGo0YXk2YktTVmJYL0JqK2RBY25neVdOdys5UUIxYU9aK1J4R000SDZ4L3MzZnRtZkNqOXI3UjRyNzRaL0VMd240eTh5MVM3a3RkTzFHT1MrdFVjQWp6N2JQblFzTTRLeUlwVThIQm9sQmo1V2VsNXcxS1RrKzlJZUc3KzlMMHFTUXhXWnFYaERSOWUxdlR0UXZOSjAyODFEUjNhYXh1cDdWSko3SjJCVXRFNUJaQ1FTQ1ZJeUNhMFd6NjBpZktySGpjZXZOWjFKV1FXN2p0M09QNlZHVzJpbk14eDYxR1R6WEpjb0MzNFVnT0JqOGFUZGsrMktVZGFldGdGUWMvU3BVR1NhWWg3Zm5Va2YzYW9CNkRQRlBwcWY1NXAxVkhZQUJ4L25wUm4vT0tLS29EY0p3S2p6azA1Z1RUQzJNKzFaZ0k3VTJndHpSUUFVR2lnbmlnQnluTk9INDFHRDh3L3dBS2tCb0FrWGdVRTRGUjVwZDI0ZFAwcTA3Z0tUdW8yZy93MEo5UDBveC9uRk1CbzRIZWlsWmNuLzYxSlFBMWhuMXB0RWpZL3dEMVVacVpBTmRzOFZISStCLzllZzhETk5JM0hOU0FnNlUxbU9QODgwamtqaWdERkFDRHB6U0QwcFdHUlFSazBBTjI1UFdrSTU2aW5ZNS8rdFRYQUhQOUtxd0FUeGpOSVJ6U25pa0l4Ukc0Q2c4MFVnNU5DMDBBdlFVbjUwb09hS1lEVlVnZFRUcVRrZjhBNnFUTzc4UGFnQnhwUHpwTWZON2ZTakgrY1VBQUdLVEdYNzB2K2VsR2VmOEE2MUFDQlF2V2pmOEFsUTQ0L3dEclVtT00wQUIvL1ZSUlJRQVVVVVVBRkZGRkFCUlJSUUFVVVVVQUZCNlVacHJ0ai84QVZRQTF6dTRwcnQ4djQwNDhDbU9lMzQxTWdHTTJQLzExQzU0NmdWSkkzSDRacXZLM3RSMHVCRGN0dDl1S3o3cDhyVnE2a3JQdUpjNS9wVWdpdko4N1kvcFViVytVNS9sVW04RS8vV291RzJ4azR6NkNzNUdoNXY4QXRRL0NUUy9pOSt6WDR3OE82dEhweGk4U1c0MHkxbHZJRm5XMXVXWWVUTWlOMWtqbDJPbUNEdmpHR1g3dy9ueC9heS80TnVQajU4QzlCZnhOcDkxNFo4VmFiZFhJVHlwNzZIU2RTalpnU0JMSEpJMXFwM0RhQWwxSnVMS0FTVGl2M1EvYksrT0h4cStBWHhXOEh0OE92ZzNlL0dmd3ZMWVhVMnQ2ZkJxeWFQSnBrMEpYWVlMakJFOHR4SE5JUHNzNm1OL3M4ZXc3bUpPeDhCUCtDcGZ3ditQT3ByNGYxRFRmR253cDhaYmxTWHc3OFJmRGx6b01tNTFMS3EzREk5cXhiQndubUNRN1d6R0NDQjZHSGg3dDJpS211aVA1T2Zqeit6WjQrL1pqOFV5YUo0OThKNjk0VjFSSVlKbnQ5U3NKclZrRXlGMEI4eFYrWTdYR081amZHUUNhOCtISEh0WDlsMzdTUDdIWGdyOXNqNEQ2dDRUMWEzajFUd3pyVVlhQ1NDMXNOU1czbGpJQ3oyajNDU3dtUldRZ2w5ellMajVjZ2o0SC9hci9BT0RUejRMZkVtenNiM3dQcTNpandGcmlJcTNLMmFKZmFkZmxjWi8wVnlqUXlTRElMck9rYU56NVp6Z2FPS2VzVExWT3pQNXlsTzAxYWlPZnovT3Z2TDlvVC9nMjkvYVErQzl0WnphSDRkWHg2dDFPMGNrZWx2SEZjMmlrSzBRYUdTUVNTU0VidDRnV1dOQ29DeXk3dVBqWDRxL0JYeFQ4Qi9IT3IrR2ZGMmkzbWg2M29OeXRwZjIwdTJRVzB6SjVpb1hRc2hMSjh3d3h5T1J4VXVMVzRYUmgycjdsQ3Q5MDhaTmZRWDdIbi9CU3Y0NmZzSmFwYXlmREg0bGVKZkQrbDI4aGtmUXBMazNtaDNHNGpkNWxqTnV0eVd4eTRRT096QTgxOC8yOFpBMi8wL0tyc01vTU96YXZ5c1dCeGh1UUFSbjA0SDA5c25OeDEzS2pKby9jZjlsSC9nOEc4K1cxMC80My9DZEVqWWdUYTU0SXV6KzdIcWJDNlk3dmZiZER2aE8xZnBKK3l4L3dXSy9abi9iSWUzdC9CZnhjOE1yclUrQXVpYTdLZEUxUXVjL0lrTjFzODV1UCtXSmtIdlg4aXU3SEc3ajJQYW83bVh6RUtzcXNwNXdSeC9uNlVwUlJWMTFSL2NUSWpST0F5c3ZHNFo3ZzBtNFovdlYvSVoreGIvd1dLL2FHL1lGbnNvUEFmeEUxV1R3MVpuSC9BQWpHdU1kVTBOMEp5Vlcza1A3alBYZGJ0RS8rMXljL3J2OEFzZWY4SGVId3ArSXNWcnB2eHM4RjY5OE5kV1pna21zYUlyYXpvaDQ1ZDR4aTdoSCt5cVhCL3dCcXA1YkM1YjdINit0MHBoWW4rOVhtMzdPSDdaWHduL2EvMHI3WjhMZmlQNE84ZHhvZ2tsaDBqVW81cnUzWHIrOXRpUlBGL3dCdEVVMTZYbkk1L2xVaXMxdU55Y2V2dldQNDg4QitIL2l2NFJ1ZkQvaXJRZEQ4VWVIN3ovajQweldMQ0xVTEdmOEEzNFpsWkcvRlRXejVXTzlKTENzeVk3SHVNZy9tS0NUOHFQMjN2K0RUUDRHZkgrN3V0WitFMnNhcDhGOWNtVXNMQ0tOdFcwR2FUT2MrVEpJSm9OM1Q5M0tVWElJaTQybjhpUDJ6L3dEZzN5L2FnL1lxa3ViM1V2QWplT1BDOXVjbnhCNE9rT3FXYUx6ODhzVzFibTNVWUdYbWlSQmtmTWEvckR1N0s2KzBSdGIzRVN4TC9ySTVJeWQzekRvd0kybkc3cURuanBnNWJxRjVmYWVZWkxlMWE5RFRJamlPWllwSWtZZ0dRYnNCZ3YzaU1na0E3ZHpBS3dNL2h1dXRPbTA2Ynk3aUdhQ1RHN2JKR1VPTTR6Z2pQYjlLRU9ldGYxeGY4Rkh2K0NSL3duL2IrOEg2bEo0bjhMNlkzaWFaZjNQaUd5czRMVFhiWTlzWGdBOHlOT3V5WVBuR000SkIvQ3o5c2ovZzNBK01uN050M3FGeDRSdTlQK0tXajJxUjNDTnBXMk85aXR5SkFaTGlMZVZSbWtRTEhIRTh4ZkxaS3NoVTF5OWg4dWwwZm50RngxNy9BS1ZhZzY5K3VPdGVnZVAvQU5rRDRvZkNUdzVlYTE0azhBZUxOSDBqVGJoYlM5dmJqVHBGdDdPWnNiWTVueGlKbURLUXI0SkRyeHlLNEdCRmxYY2gzRDFITlZ5dGJrcmNzUTdsYklOYkhoVHhIcW5nZlhyWFZ0SDFHLzBmVmJOdDl0ZldNNzI5eEFUeGxaRUtzdkJQUTlENkdzbUZmbXEwZ0piY1A0ZUI3MXBBMDIxUDBXL1k2LzRPWnYyamYyWkliTFRmRldvV0h4ZzhPVzZyRUxieE5sZFNWQi9jMUNNZWF6WTZHY1RIOEJpdjFxL1lxLzRPTXYyY3YydWJlMzAvWFBFQy9DSHhaSUFHMHp4ZGNSMjFuS2VPWWRRNHQyQkpJQ3lORkljY0pYOHdVVW0xT3Y4QTQ3VTZEN3ZzTWZqNy9uK2xPVUZJcTk5eisxM1JQRU5uNG8wS3kxVFNyeTExVFN0U2hXNXM3MjBuVzR0cnVKaGxaSTVFSlYwWUVFTXBJSVBXcllQYjhPdGZnbi93YVZlRC9HL2luOXBEeDVxOGZpVHhGYS9Ecndib3YrbDZNbW96UjZiZTZuZXlGTGRudGcvbHN5eFEzYjd5dVF5cDNQSDcxczJhNE1VdVdWaUZKTnV3cnRnMUd4NHhtamZrL3FhanpYS1hZZXBLajFwUWN0bi9BQ2FhVytYOEIycFVHUjcxYUIySlZIeVZNQnhVYWN0K05TVXlSNmpGTFRVT1ZwMWFJQW9vcHJOai93RFZRQnRNZHpVMWszVTZpc3dHQTdEN2ZXa0hTbk11UlRhQUViSkhGS09LS0tBQWNVNFBUYzBVQVNBNU5JUlRQei9PZ05qL0FQWFFCSUc0cFEzTk1WcVhPYXZtUUM5ZXROWTRvWTRIdlRTMmFYTUFFNXFOMkRDbk8rTzFSbmorS3BBYTN6bWtKMmlnSHJUUDErbEFDWTIwbzRGSVRta0pvOHdGSTNVZ2JqdGlnZGY2VUFFanZUc0FqSE9jZWhwQjhwNG9iNVQ5ZTlKbW11ekFVREZGRkZVQVlvb1BJb0J5S0FDaWdITkdPS0FHbm42L1dqL1BXbkhyM3BQem9BUitSMlA0MFovem1qQjNkNkMvSHJRQUE4Ly9BRjZHT1A4QTlkTkxaSW9KeWFBRE83ZzBZb29vQUtLS0tBQ2lpaWdBb29vb0FLS0tLQUNpaWlnQUp3YVkvWC82OUtXd0thVFFBRnNWR1Rtbk11ZS9mdFVibjVmU3BrQkN4d1B3elVFemMvOEExNm5rT0QrRlU3aHNEcjM5YUdCVXVaZWUxWnQzTjEveHEzZFBrVmxYMHVBMVNVdTRmYXdEeTNUbXB0T3VUUGZaV0thNCt5bzA1aWoyN3BOb3lGWGNRdVNjQVpJR1R5UUt3TlN2ekZHMkRqam5pdnpsL3dDQ2t2OEF3V2c4UWZzVmZ0RzNuaHJRYmV4MWp3dHBQaHdEeFRaank0NzJhNnZOM2t4Mjl3NlNDQ2FLQjRwVkxSeXhuelNIaWNLTUVZdVVySTBqRzU5eStEZkd2aUMzdjViSFR2aHpwL2pyd0JxZDlKZXFkSDFtS1BWTkxhNmtlYVJyclROU1dIeTlqeWRiZTdmaHppSUJSbjNQU2IvVDlhdGNLbW9ReVFxeXZGY2Vha3E1NGNIY2NQMHhsU3d4ME9LL0hYOWczL2d2MzhFSTduVGROOFNhOVorRDB1Sjh2SnJ2aDJTeG10Wm5EQlhXVzNOMUJMR1AzU2x2TzA1WWxEc3NUQWhVL1RUNFRmdE82YjhXVmkxTFIvRXVnNnZvTXorWGFhdFl5eGFwcE4rb1FNNWh1NFpDaU1Pbmx0TTc3Z3gybGNFZWp5MlZvbU1vdHU1UTBEL2ducjRYK0VIakx4TjRnK0ZkOXF2d3AxVHhkY1J6Nmt2aGlhSzEwMmFWZCs2NGsweWFLYXdsbWJjQXppQ0tSbFVBU29mbXIxZndYSDR3OE8rRzdlMzhUWEdqK0tkUWdqUG5haHBWcWRNKzF0bmpGcExKSXNmSEgvSHczU3I2K01vWjlHajFTMWprMVRSN3FBWE1GN3BuK25MTkdjWUtwSGw1TThrZVdIeUFlL0ZhOXZMOW9pVnVxc01nWUs4ZTRQSVBzZWFqbUoxU3N5akwvWnVzZVNsMUZINXJIRWNWMUhzY3NCbjVRM1VqbmxjL1d2Sy8ya1AyQnZoVisxaG9rT24rT3ZDT2s2NWIyNGpWQlBBdTVValpualR6T0pWUldaaUVSMUh6RWRDUWZaSlVXVk5zaUt5bnFHR1FhcXlhWEpDOGtscmRTUXN3NGpsek5DUFQ1Y2dqNkt5ajJvVW10aVQ4amYyb2YrRFNiNFgrTDdJTjhLZkUycWVDcHJmeldXRy9hVFVGdU1xZGlQSXpFWVY4QWJVUmlwTzkzYjU2L003OXE3L2czOC9hYS9aVmJVcnFUd0hkZU9QRDJuM0hrcHFmaG5GODA2bFFWZjdLcE0rQ1dJT3hIQ2xXQlBRbitxNklNVUc4THZ3TnhIVFBmRk11clNPNnRaSVpZNDVvWmthT1NPUlF5U0t3d1ZZSGdnaklJUEJGVkdwM0ZzZnhDNnZwRjFvbXBYRmpmVzkxWlgxbzVTZTJ1STJpbmdZZndzakFNcDlpQlZPYzUrWGc3aFg5bUg3Um43Q3Z3Wi9hNjBkN0g0bGZEUHdiNHdUWVk0N205MDVWdnJWU1NTSUx1UGJjUWNrbjkxSXZKUHFhL05mOXJuL2cwTytHdmoxTHJVUGdyOFFOZStIK29NR1pOSDhReG5XdEpkc2ZLaVRncGRRTG5xem01T08xUG1USHpQcWZ6M3VDamYwelZlVnVldjFyN0YvYk4vNElXZnROZnNSUVhtb2VKUGh6ZmVKUEM5a0dkL0VmaEluV2ROU01ESmxrRWFpZTNRZjNyaUtJWjc5SytQR3c2YmxJWmVtUnpVU0RjazBqVjd2dzdyRnZxV24zVnhZYWhZeUxOYjNWdEswTTl1Nm5LdWpyaGxZSGtFRVY5NmZzaWY4QUJ5OSsxWCt5eXRucCtwZUxyUDRzZUhiWWhUWWVONFd2N2pibm5iZm95WGU3R1F2bVN5S3ZIeUVjSDRCWWYvV3BPbzlha2FrMGYwZS9zci84SGRud0YrS2tkdFovRkh3dDR3K0V1cVNIYkxkeFIvMi9vNkRqNXpMQXFYSzkvbEZzMkFQdkd2MGYvWjIvYXY4QWhqKzExNGZiVnZoZDQvOEFDZmo2empBTTM5aTZsSGN6V3VlUUpvUWZOaE9PMGlLZmF2NG9nUDd4OXlhdStIL0VlbytFTmN0OVYwaSt2dEoxT3piZmIzZGxPOEZ4YnQ2ckloREtmY0VVRHZIcWorNUhHNzhhUXBocS9sby9ZeS80T1pQMm92MlU3bTN0TmU4VVIvR0h3ekdWV1RUL0FCb1h1N3hWSFh5OVFVaTZERWRESzhxakErUTgxK3JmN0lQL0FBZGRmczUvdEEzV242WjQvc2ZFbndaMTYrZnkzYlZBTlUwU05qOTMvVG9WVndEeDgwdHZHcTkyQXkxQWN0OWo5T1R1emo1V0h2MXJ4djR2L3NSZUhmaVY4UzlFOGRhRjRoOGFmRFh4OTRkODFMUFhQQzJvckNKNHBUdWt0cnF6blNXenVvSGJETWtrSmJjTnl1amZOWHAzdzUrSlhodjR4ZUU0ZkVIZy93QVJlSC9GdWczQUJpMVBSTlNoMUd6ay93QjJhRm1RL25Xem5qTkZ3dTBlZFhYd09QaW40WDIraStMcml6MW5WR3RmSTFEVU5EdFgwSmJwem5kSkZCNTBvZ1pzL3dEUFJpQ1RoZ0R4K2JuN1gzL0J0bDRCL2FuOFRhcDRpOEk2eHJuaHZYWm1sVzdoMU5aN2VZVGVVSTRWVXpCNDNnUm8xSmVNdXNpR1FSdU1xeS9yTytlbk5NUEl4K2xVcHRCMFA1UHYyMGYrQ0xmeHgvWXk4UVNMZStEOWM4UmFESEI1MG1yNlpaaWFHTEEvZWxsamQ1RmdRa0tKcFZqRFpCMmpJcjVoT2pTV0xSZWRGSkMxeEVrOFJsQlV2RTR5cnI2cXc1QjZFZEQzSDlyTjVZdzN0djVNME1NOEpJWXh5SUhRbnNkcDRyeGI0N2Y4RTVQZ3IrMFg0YXZOTDhVZkQvdzdkUVgwZ21lV0xUcmRaMWt4dE1pdTBiZnZDcHg1aEJjY0VFTXFrYXhxcGJvWi9JU2JkVmI1dnZidG96eHQrdkg4cWN0a2ZJTEt3WW4vQU1kT2Y4OTYvYmo5cnIvZzA4L3R2eFl1b2ZCenhucG1pNkd3SmZTZFZTNG5tVnkzeTdIa2tiNVFwRzkya3p3U3NlUUViNHM4U2Y4QUJ2eCswWDRCL2FIOEgrQmZFUGhHK204UGVMTmNzOUdieGg0ZFJ0VTB1d2dubVdPUzRsWUtza0FqWGMvK2tKR3AyNEJQZlZUaTloU2tsdWZzUC93YmRmc3dmOE01ZjhFdXZDdXIzZG90dHJueFV1NXZGOTR4SDd4cmVYRU5pcFA5MzdMRkhLQjJOdy9jdG43eVo4ZFBXcVBobndycGZnTHdycG1nNkpaeDZmb3VoMmNPbmFkYVI4SmEyMEtMRkZHdnNxS3FqNlZiSngzcng2cytlYmtPbkZwYWlON21nZXROSnkyZjYwSzJlT2xabW13OVRtbm9NOWFqVmNtcGdNbjlhMEZJa1FZT0trcHFyajYwK0ljLzU1cHhKSGppak9LS0QwcXdHczRGTWJsdW42MHIvTWFPbFMyQnVVVUVZTkZTQW1QcCtWTklDaW50L25tbytWNmZ6b0FLS0JSUUFoR0JRcG9QV2p0UU8xeGFNMDNlQWFPby93RHIwRDVSMUdmODRwakhCNHBON2Y3TkF1VmoyT0JUSGNqdmlndG4vd0RWVFMyUFNnRUROaGYvQUsxUjV5YWNUejcwM2RRTVJ3VlhqOGFaMHB4NU5OUFNnQnhHQlNZM1VmeFV1YXFKSW5RMG5iLzYxTkhKeit1YVhkVkFLZWFiME5ESGNhQU1VQUdLS0tDTTBBRkZGSFdnQXBEL0FKNG9QSC82NlRQK2MwQUdPZjhBNjFHUDg0b2JsZjhBNjlOVURtZ0IyZm14L1NtMEQ1V282Q2dBb29vb0FLS0tLQUNpaWlnQW9velJRQVVnNjB0RkFCUlJRVFFBWnBySEgvNnFNLzV6UVdGQURXT2UzTk5KeFNua1UwNFg2MEI1Q0Z2NStsUnRUOTJXTlJNMlIrbEFFVTU2L1NxVnkyVy9IMHEzTWMvaFdmZHR5ZnpxR0JUdVR4MXJOdW85NjU2K3RhVXcrOFB5cUlRK2NNOGduUFdva1VuYmM0SDRoYTNaK0VkQXY5VTFPNFd6MHZUYmVXOHZKMys3Ynd4cVhrYyt5cXBiNkN2NWQvOEFnb1o4ZjlUK01YanJWTmExRHpZZFE4Y2FyY2VJTG1Cam43UEN6RmJlRElQSWlqeWcvd0JsVStnL3FBL2FmL1p0dVAycWYyZi9BQng0QnN0WGswRzY4VGFOTlpRWHlxQ3NjalkycEpuL0FKWlNZTWNtTUh5M2t3UWNFZnlNL0hYeHRINDkrSm1xWGxzK2JHR1Q3SmFnRThSUmpZcFBvU0J1STlXTmRHSFdya3luSzBMSTRpOW55eC8yYTZQNE5mdEUrUFAyWnZHaTYvOEFEbnhwNG84QzY0cWhYdmRCMU9hd21sVU5uWTdSc3U5TWpsV3lwN2cxeThyWWZkL2QrWTFRa2t5NXozT2Eza2M5Mmo5Ti93RGdtbC93YzJlUGYySUk5YzBqeGg4UC9DL3hDMFB4WnI5ejRsMXUrc2NhSnJWMXFGeVU4KzVhU0pXdHBHS291UVlGTEZSbHdTVFg2NGZzWWY4QUJ4eCt6UDhBdGIzeVdkMTQ2aCtHV3RTc3FSYWQ0MVVhYUpXT003YmdGN1VMazRCYTVESC9BSjVKMHIrVk1IUHBRR0h0L2pSZHZWbGMzZEg5MU5wZXg2bllXMTNiVFEzVm5lUmlhM3VJV0VrTTZFWkRvNHlyS1J5Q0NRYW1DNFBvUFExL0YxK3lUL3dVTytObjdEV3NmYS9oVDhTdkZIZytObkx6V0VGd0o5TXVtUGVXem1EMjhoOTNqSkhZaXYxVy9Zay80UEJkYTBXNnQ5SitQbnc5ZzFpd2trQWZ4QjRSY3hYY0M0VVpleW5jcEx5Q3gyVFJnWitWY0FMU0RsWFJuNzRLYU1aUC93QmF2bXY5bFgvZ3J2OEFzNi90b2VMTkY4UC9BQTYrSm1rNjU0aDhRd3l5Mk9rdEROYlg4aGhBTXlQQklpeVJzZ0lPWFVJNHlZMmtDdVYra3lkcURiME5BT0xXNGhHRFNIbWhoeU9sS0R0b0pDT1I0WERJV1ZsNkZUZ2o4YStWL3dCdEwvZ2k1K3pkKzNvdDVlZU5maHhwMm0rSjczTE40bjhONDBmV1JJZXNra2thK1hjTnhqTnpIS1BRQTgxOVRZQUhhZzBYQS9ubC9iZS80Tkd2aWg4TFJjYXg4RGZGbW4vRkxTVlptR2g2djVXamE1Q3BQeXFrak45bHVNRHF4ZUJpY2JZenpqOHIvamgrejc0My9acDhlemVGdmlGNFQ4UmVDZkVWdmxuMC9XYkNTem5aZHhYZWdjQVNSa3FjT21VYkhCSXIrMlp0dWVvM0Rwbm11TCtPUHdLOEhmdEZlQ0pQRGZqend0NGQ4WWFETEp1T242MVlSWGx1R0l4dlZaQVFyZ0U0WVlZWnlEbXEwRFUvaWRKSi93QjBkcVA4OWEvb0UvYW4vd0NEU0Q0ZCtPYjNVTlMrRnZqYldQQWR4STVhMzByVUlQN1QwOU1LY0RlV0V3M1BnWkRFSXB5QXhHRy9JdjhBYnUvNEpUL0diL2duZmVXMG54RThQeExvMTdKSkhiNnpwcy8ydXdMSXlEYThpakViSHpFSURkY3NBU1VjS2N2WUQ1dXpSbkJ6NlZMQ0FreXliRm1VRUVxMmRyZW9PQ0QrUkZNQ2NER2ZUaXBBN0w0R2Z0QStPZjJaZkhFUGlYNGUrTVBFbmduWDRDQ3Q5b21vUzJVcmRmbGNvUUhVZ2tGWEJVZ2tFRUUxK20zN0hIL0IyeDhiL2hITERwL3hlOE82QjhZTkhBQ20raFdQUWRhaUc0YytaQkdiYVVCYy9LMENzeHhtUWM1L0psRndWK3RUeFJ0NisxVWlsSjdIOVhmN0czL0J3Sit6RCsyZDVkbFplTzErSC9pU1IxaVhSUEhBaDBlZWRteGp5Wi9NZTFseXgyaFZtOHdrZmNHUm43VWtpWk1ibElEZ01wN01EeUNQVUgxcitIcUFLQnp6dUdDTVpGZlNQN0dYL0JWMzlvRDloT2UxaCtIUHhJMXF4OFAyN2hqNGQxRnY3UzBPVmM1S2kwbTNMRnU2Rm9mTGZIUmh3YXJrdnNVckg5ZUpVT09uZWx6Z2MxK1JYN0UvL0IyWjhPdmlMYTJ1bGZIanduZWZEdldDTU5yM2grR2JWTkVuUGN0Yi9OZDIrZXlxTGdlckN2MUsrRDN4cjhHL3RDZUNMZnhONEQ4VmVIL0dmaCs2SHlhaG8xOUhlUUE5Q3JGQ2RqRGtGWHd3UEJBUEZUS0xXNCtWMnVkTVR6VFNjeTQvRThmNS93QWluWjQ1L3dEMVZHVDh6SDMvQUVyR3JLMFJCSTlNTDU1TklUelRTMmE0eHA2amkvR2FVZXZ2aW1aM0gvNjlPVVlhcXNNbVRnL2hVeW9lbFJ4Sit2dlU2amlxSkhxTjlQVmR0SXE3YWRXbXdCVFpEOHRPcHI5S0FHanJUSDRhbEo1cHA1Tlp2Y0RvbVRkVFN1My9BRDBwKzM2ZmxUWEhIOCtLQUVQSXBQenBhUnVCUUF6L0FCb28vcnpSUUFuVVVFMGZ3MDB0N2ZwUWFiQ0UvTWFCN2NVRTgwZHFBRVp2VTl2U2szKzlEOUQvQUlVMmdCeGZweit0TjM4K3RJT0RReHgvK3FnQnNqZGZXa0F5RFFQbWZQOEFTZ2dnVUVzUTlmNjBFNG9wQ005cUFzaDJPYVRGQXBhQ1JtTnYrTkkzQjZVOHJrVTNia1ZTWUNaK1hwMjYwVUFZcEFLRkx1QXRGQU9hTTFWd0NqUE5BT2FRWTlQMG9BUHpvL09rSTY5UHlvQTQvd0RyVUFLUmtVaCtUdFJqL09LYVQvbkZBQWVUUlFlQm1qR0tBQ2lpaWdBb29vb0FLS0tLQUFEbWlpaWdBb29velFBVVo5cWFldjhBOWFqL0FEMG9BYXhKUGNmMW9vSjVvUEpvQUNjVkR1eWY4YWtjY1ZHYW00RFhmQi8rdlVMdjh0U0Z1UHJVTXJZRGUzU2hzQ0dlWEErdWU5VUozelU5MUxtcys1bDRCOWV0U093eDVlZnJTck1xSnoycW5jVDgxeFB4cCtNZW4vQm40WStJdkZXcnVVMHp3M3B0eHFkMlZ4dk1jTWJTTUZ6Z2JqdDJxTThzUU85UkpsOHQ5RDE3d3BhN0xMemp3MHpiditBamdmcmsvalh5L3dEOEZEZitDSmZ3Ri80S1FXRjFlZUt2REVmaGp4MU1ReWVNZkRrU1dlcWx0eWsvYUFCNVYyQ0YyL3YxZGxCT3hrUE5mUzN3bjhmYVA4Vi9oajRlOFVlSDdrWG1nK0lkTmcxQ3dtQXdYZ2xqVjF5T3pBRUFxZVZZRUhrVjBoR0IvaUs3YWE1VWM4dDlUK1ovOXVqL0FJTlZmajUrejNmNnRxZnd2YXkrTUhnK0hNMXV0a3d0dGVqajR5a2xvM0VqQWtqTUx0dUM3dHFFN1IrWW5qN3dIclh3eDhYMzNoL3hKbytwZUg5ZDB1VHlielR0UXRYdHJtMmZBT0hqY0JsNElJeU9RUWVocis1V2FObkh5dHRPNEhPTTVBUFQ4YThzL2FpL1lmOEFoSCsycjRTdXRHK0tYdy84UGVMcmU4aVdGcmk0Z01OL0dxRWxCSGR4RkxpUGFTU0FzZ0F5ZU9TRHBkTW5WSDhVb0dmWG1qWXc5YS9vUC9iUS93Q0RQVHdQNHQwZHI3NERlUEw3d2pyRU1ZQzZWNHNrZSswNjZJWEdmdE1TR2FGbVBKUGx5TDZLQndQeXYvYSsvd0NDRnY3VG43RmwxZXkrSnZobnEydmFEWTIvMnFYWC9EQ1BxK2xySG5ERnBJMTNSbGU0a1JTQjgyTnZOTGw3QjdUdm9mSWFLUm1wRmJKejA5Nm1rc0hoZGtrUmtrVWxXVmdReW51Q1BYMnFNdzdmNTBpaVd6MUdiVDc2RzR0NXBZTGkza1dXS1dKeWtrVHFjcXlrY3FRUmtFY2l2dm45aGY4QTRPUC9BTm9qOWpiWGxYVnRXaStLL2gxNElyU2JUZkZOeE04NGpqWmlHanVrWU9Kc01VODJaWmlVQ3FRUkhHRi9QK1FZeDlhUUQ1dWhvS2pKclkvcDgvWXgvd0NEcHo5bXo5cFMzc05QOGRYR3JmQmZ4UmNCVWxoMTFEZDZPMHA3UjM4SzRDLzdWeEhBQjY5Ni9SZndWNDIwWDRrK0ZMTHhCNGIxclIvRW1nYWtnbHM5VDBxOWl2Yks3UThobzVvbVpIR0NEbFNhL2h0V1huMUJyMVg5bDc5dGY0dGZzWCtKL3dDMlBoWDhRdkZQZ2U2ZVFTeng2YmVsYlM4SXhqejdac3dUcndQbGxSaHdPS0EwWi9hY3lGaDEvTVpxTnc2RDVmMHI4RFAyTFA4QWc4RzhZZUZ6YTZUOGZQaC9ZK01MSmNJL2lEd2tFMDdWQU83eVdjamZacG1QcEcxc1BZMStybjdHMy9CWkQ5bkQ5dTJDMmg4Qy9FelI3ZnhEY2JSL3dqbXZzTkgxZ09mNEVnbUlFNTlUYnZLby92VUJ5UHBxZlJtcDZwSHArblRYRndwYU9GU3hJd01ZOXlRcTl1V0tnZFNRTWtjL2M2MWNlSnRBKzNhQk5LMGp2dEZyZEtJbGtLbjUxVXlLeWsrNmtvY2NIdlhWWFZwRmZ3dEhKOTJSU3BLdVZibnVHR0NwOXdjaXVPdGZoQkRvaVNMWWFucXUxM0xLTlFuZThrakJIS2k1M0xka2JzbjU1bkkzRURDaFZXbzI2Z3JXTXJ3NXFmaXF3dGtYWG9MV3cxS1IyZVI3SjViMnlZS3dIK3BjNzEzS2VrY20wWnlRY1lMZmlINEE4SS9IRHd6Y2FiNG4wZXoxaXpsQmptaWlVM0t0MFAzQUJKdTc0VlNSenp6ejBlblNheHBVNWp2TFdTNnQyYmg0SkV1RmpYdC9ESElEMHlDc25BKzltbDEzdzNwUGlUeS90VnZ0a3djR04yaWtBSVBRcmhzRFBUdDlhcm1TQitaK2MvN2NmL0J0djhIZjJxZFB2TlY4QTIraytCL0VmbHBIRlBwY0NXVnNHWGdMSkRDdmxLQXZYTUprYzR5Nm5MVitmUHh6L3dDRFVmNDBlQnJXNHVmQmZpN3duNHVTRUtJN1hVNDMwVzZ1V1BhTTdwb09QV1NXUFBvQ1FLL29XdFBDR3BhUThQa2FvMS9ER2hVL2JoL3BIQkpHSlVLOGM0MjdlY0E1NElPeEhkc0VLM0tQRzJCbmQzN2RSL2hUbFB2cVR5OWorTnY5b3o5aDc0dmZzalRFZkVyNGIrTVBCOXI1M2tSMzk5cDcvd0JtM0VuWGJEZUp1dDVmKzJjalY1aXNYSHBYOXIzaWY0YjZONDIwbWExdW9SNU4wcFdRUk9WRWdQQkRBZks0L3dCbHdWSTRJSU9LL09QOXJuL2cxOCtCbnhvdi93QzB2QmRycVB3MnV5OGtreWFIUG0zbjNDVmhpQ2JkR3VIa1U0VHl4c2pDQXI5NEVlVmdmemh4cm5Ic1JWcUpndkhPVGdZcjlFZjJ2ZjhBZzJjK1AzN090bWRROEd3MmZ4YzBtUGQ1eTZQQ2JQVXJjQnZsUDJhWno1dTVTQ2ZKZHlwM0RCMjdqK2YzaXJ3WHEzZ0R4TmVhUHIyazZyb3VzYWZJWWJ1dzFHMGt0THExa0g4TWtjZ1YwYjJJRld0Q3RDcEZOL2QrOFRuaXVyK0RueHU4WWZzLytNNC9FWGdYeFY0ajhGK0lJT0YxTFE5U20wKzQybkh5TThUS1dVNEdWYktub1FlbGNjRHRUUGZ0aXBveGtjS3A3OU9sVWlsb2Z0Zi9BTUVnUCtEalQ0eS9HbjQvZUEvZ3o4U3ZDK24vQUJNdVBHZXBXK2pXbmlMVHd1bDZyWUJqKzh1cnBFVm9MbU9LSU5JKzFJWEN4dXhaendmMjZMOGZqM3I4QWY4QWcwdS9aV2J4L3dEdFVlTi9pOXFGcnUwNzRiNk9OSjB5UjFPMyswOVIzS3pJZWhNZHBGT3JEcXYycU05eFg3OU1jOFY1K0t0ekpJVVpjMTJOTDhlOUFQRk5adDNvYU03U01INjF6RjJKRU9UVWtReVJVYURCcWFIci93RFdxa0xvVHhEQXgrR2FzSW5Tb29oOTJwa0dCVlIzRU9vMm5IK2VLRjVhbjdjaXJBWlNPY0xUOWd6L0FQcnFOdVVvQWpJeVAwcHA0UFNubjdwcU1yazgxbUIvLzlrPVwiIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0eWxlLWxvYWRlckAxLjIuMV93ZWJwYWNrQDQuNDMuMC9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jc3MtbG9hZGVyQDAuMjguMTEvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS0xIS4vc3R5bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCIvLyBzdGFydC4uXG5jb25zdCBhY3RpdmVTZXNzaW9uID0gJChgI21haW5Db250ZW50Q29udGFpbmVyYCkuZGF0YShgcmVjZWl2ZWQtc2Vzc2lvbmApXG5pbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCJcbmltcG9ydCBcIi4uL19jc3Mvc3R5bGUuY3NzXCJcblxuXG5pZiAoYWN0aXZlU2Vzc2lvbikge1xuXHQvLyBoaWRlIHdoZW4gc2lnbmVkIGluXG5cdCQoYCNuYXYtc2lnbnVwLWxpbmtgKS5oaWRlKClcblx0JChgI25hdi1sb2dpbi1saW5rYCkuaGlkZSgpXG5cblx0Ly8gc2hvdyB3aGVuIHNpZ25lZCBpblxuXHQkKGAjbmF2LWxvZ291dC1saW5rYCkuc2hvdygpXG5cdCQoYCNuYXYtZGFzaGJvYXJkLWxpbmtgKS5zaG93KClcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=
